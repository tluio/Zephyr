
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
  100000:	b0 ff                	mov    $0xff,%al
  100002:	e6 21                	out    %al,$0x21
  100004:	e6 a1                	out    %al,$0xa1
  100006:	eb 0c                	jmp    100014 <__start+0x14>
  100008:	02 b0 ad 1b 02 00    	add    0x21bad(%eax),%dh
  10000e:	00 00                	add    %al,(%eax)
  100010:	fc                   	cld    
  100011:	4f                   	dec    %edi
  100012:	52                   	push   %edx
  100013:	e4 0f                	in     $0xf,%al
  100015:	20 c0                	and    %al,%al
  100017:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
  10001c:	0f 22 c0             	mov    %eax,%cr0
  10001f:	fa                   	cli    
  100020:	0f 01 15 b0 00 10 00 	lgdtl  0x1000b0
  100027:	66 b8 10 00          	mov    $0x10,%ax
  10002b:	8e d8                	mov    %eax,%ds
  10002d:	8e c0                	mov    %eax,%es
  10002f:	8e d0                	mov    %eax,%ss
  100031:	66 31 c0             	xor    %ax,%ax
  100034:	8e e0                	mov    %eax,%fs
  100036:	8e e8                	mov    %eax,%gs
  100038:	ea 3f 00 10 00 08 00 	ljmp   $0x8,$0x10003f

0010003f <__csSet>:
  10003f:	0f 20 c0             	mov    %cr0,%eax
  100042:	83 c8 2e             	or     $0x2e,%eax
  100045:	0f 22 c0             	mov    %eax,%cr0
  100048:	bc 90 1b 14 00       	mov    $0x141b90,%esp
  10004d:	81 c4 00 08 00 00    	add    $0x800,%esp
  100053:	bf 00 60 12 00       	mov    $0x126000,%edi
  100058:	b9 bc 6b 00 00       	mov    $0x6bbc,%ecx
  10005d:	e8 13 00 00 00       	call   100075 <_x86_bss_zero>
  100062:	0f 01 1d a6 00 10 00 	lidtl  0x1000a6
  100069:	e8 92 73 00 00       	call   107400 <z_loapic_enable>
  10006e:	53                   	push   %ebx
  10006f:	50                   	push   %eax
  100070:	e8 6b 7c 00 00       	call   107ce0 <z_x86_prep_c>

00100075 <_x86_bss_zero>:
  100075:	31 c0                	xor    %eax,%eax
  100077:	fc                   	cld    
  100078:	f3 ab                	rep stos %eax,%es:(%edi)
  10007a:	c3                   	ret    

0010007b <z_x86_enable_paging>:
  10007b:	b8 00 50 13 00       	mov    $0x135000,%eax
  100080:	0f 22 d8             	mov    %eax,%cr3
  100083:	0f 20 e0             	mov    %cr4,%eax
  100086:	83 c8 20             	or     $0x20,%eax
  100089:	0f 22 e0             	mov    %eax,%cr4
  10008c:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
  100091:	0f 32                	rdmsr  
  100093:	0d 00 08 00 00       	or     $0x800,%eax
  100098:	0f 30                	wrmsr  
  10009a:	0f 20 c0             	mov    %cr0,%eax
  10009d:	0d 00 00 01 80       	or     $0x80010000,%eax
  1000a2:	0f 22 c0             	mov    %eax,%cr0
  1000a5:	c3                   	ret    

001000a6 <z_x86_idt>:
  1000a6:	ff 07 d0 49 12 00 8d 74 26 00                       ...I...t&.

001000b0 <_gdt>:
  1000b0:	17 00 b0 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ................
  1000c0:	ff ff 00 00 00 93 cf 00                             ........

001000c8 <_gdt_rom_end>:
  1000c8:	66 90                	xchg   %ax,%ax
  1000ca:	66 90                	xchg   %ax,%ax
  1000cc:	66 90                	xchg   %ax,%ax
  1000ce:	66 90                	xchg   %ax,%ax

001000d0 <__udivdi3>:
  1000d0:	55                   	push   %ebp
  1000d1:	57                   	push   %edi
  1000d2:	56                   	push   %esi
  1000d3:	53                   	push   %ebx
  1000d4:	83 ec 1c             	sub    $0x1c,%esp
  1000d7:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  1000db:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  1000df:	8b 74 24 34          	mov    0x34(%esp),%esi
  1000e3:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  1000e7:	85 d2                	test   %edx,%edx
  1000e9:	75 35                	jne    100120 <__udivdi3+0x50>
  1000eb:	39 f3                	cmp    %esi,%ebx
  1000ed:	0f 87 bd 00 00 00    	ja     1001b0 <__udivdi3+0xe0>
  1000f3:	85 db                	test   %ebx,%ebx
  1000f5:	89 d9                	mov    %ebx,%ecx
  1000f7:	75 0b                	jne    100104 <__udivdi3+0x34>
  1000f9:	b8 01 00 00 00       	mov    $0x1,%eax
  1000fe:	31 d2                	xor    %edx,%edx
  100100:	f7 f3                	div    %ebx
  100102:	89 c1                	mov    %eax,%ecx
  100104:	31 d2                	xor    %edx,%edx
  100106:	89 f0                	mov    %esi,%eax
  100108:	f7 f1                	div    %ecx
  10010a:	89 c6                	mov    %eax,%esi
  10010c:	89 e8                	mov    %ebp,%eax
  10010e:	89 f7                	mov    %esi,%edi
  100110:	f7 f1                	div    %ecx
  100112:	89 fa                	mov    %edi,%edx
  100114:	83 c4 1c             	add    $0x1c,%esp
  100117:	5b                   	pop    %ebx
  100118:	5e                   	pop    %esi
  100119:	5f                   	pop    %edi
  10011a:	5d                   	pop    %ebp
  10011b:	c3                   	ret    
  10011c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100120:	39 f2                	cmp    %esi,%edx
  100122:	77 7c                	ja     1001a0 <__udivdi3+0xd0>
  100124:	0f bd fa             	bsr    %edx,%edi
  100127:	83 f7 1f             	xor    $0x1f,%edi
  10012a:	0f 84 98 00 00 00    	je     1001c8 <__udivdi3+0xf8>
  100130:	89 f9                	mov    %edi,%ecx
  100132:	b8 20 00 00 00       	mov    $0x20,%eax
  100137:	29 f8                	sub    %edi,%eax
  100139:	d3 e2                	shl    %cl,%edx
  10013b:	89 54 24 08          	mov    %edx,0x8(%esp)
  10013f:	89 c1                	mov    %eax,%ecx
  100141:	89 da                	mov    %ebx,%edx
  100143:	d3 ea                	shr    %cl,%edx
  100145:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  100149:	09 d1                	or     %edx,%ecx
  10014b:	89 f2                	mov    %esi,%edx
  10014d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  100151:	89 f9                	mov    %edi,%ecx
  100153:	d3 e3                	shl    %cl,%ebx
  100155:	89 c1                	mov    %eax,%ecx
  100157:	d3 ea                	shr    %cl,%edx
  100159:	89 f9                	mov    %edi,%ecx
  10015b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10015f:	d3 e6                	shl    %cl,%esi
  100161:	89 eb                	mov    %ebp,%ebx
  100163:	89 c1                	mov    %eax,%ecx
  100165:	d3 eb                	shr    %cl,%ebx
  100167:	09 de                	or     %ebx,%esi
  100169:	89 f0                	mov    %esi,%eax
  10016b:	f7 74 24 08          	divl   0x8(%esp)
  10016f:	89 d6                	mov    %edx,%esi
  100171:	89 c3                	mov    %eax,%ebx
  100173:	f7 64 24 0c          	mull   0xc(%esp)
  100177:	39 d6                	cmp    %edx,%esi
  100179:	72 0c                	jb     100187 <__udivdi3+0xb7>
  10017b:	89 f9                	mov    %edi,%ecx
  10017d:	d3 e5                	shl    %cl,%ebp
  10017f:	39 c5                	cmp    %eax,%ebp
  100181:	73 5d                	jae    1001e0 <__udivdi3+0x110>
  100183:	39 d6                	cmp    %edx,%esi
  100185:	75 59                	jne    1001e0 <__udivdi3+0x110>
  100187:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10018a:	31 ff                	xor    %edi,%edi
  10018c:	89 fa                	mov    %edi,%edx
  10018e:	83 c4 1c             	add    $0x1c,%esp
  100191:	5b                   	pop    %ebx
  100192:	5e                   	pop    %esi
  100193:	5f                   	pop    %edi
  100194:	5d                   	pop    %ebp
  100195:	c3                   	ret    
  100196:	8d 76 00             	lea    0x0(%esi),%esi
  100199:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  1001a0:	31 ff                	xor    %edi,%edi
  1001a2:	31 c0                	xor    %eax,%eax
  1001a4:	89 fa                	mov    %edi,%edx
  1001a6:	83 c4 1c             	add    $0x1c,%esp
  1001a9:	5b                   	pop    %ebx
  1001aa:	5e                   	pop    %esi
  1001ab:	5f                   	pop    %edi
  1001ac:	5d                   	pop    %ebp
  1001ad:	c3                   	ret    
  1001ae:	66 90                	xchg   %ax,%ax
  1001b0:	31 ff                	xor    %edi,%edi
  1001b2:	89 e8                	mov    %ebp,%eax
  1001b4:	89 f2                	mov    %esi,%edx
  1001b6:	f7 f3                	div    %ebx
  1001b8:	89 fa                	mov    %edi,%edx
  1001ba:	83 c4 1c             	add    $0x1c,%esp
  1001bd:	5b                   	pop    %ebx
  1001be:	5e                   	pop    %esi
  1001bf:	5f                   	pop    %edi
  1001c0:	5d                   	pop    %ebp
  1001c1:	c3                   	ret    
  1001c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1001c8:	39 f2                	cmp    %esi,%edx
  1001ca:	72 06                	jb     1001d2 <__udivdi3+0x102>
  1001cc:	31 c0                	xor    %eax,%eax
  1001ce:	39 eb                	cmp    %ebp,%ebx
  1001d0:	77 d2                	ja     1001a4 <__udivdi3+0xd4>
  1001d2:	b8 01 00 00 00       	mov    $0x1,%eax
  1001d7:	eb cb                	jmp    1001a4 <__udivdi3+0xd4>
  1001d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  1001e0:	89 d8                	mov    %ebx,%eax
  1001e2:	31 ff                	xor    %edi,%edi
  1001e4:	eb be                	jmp    1001a4 <__udivdi3+0xd4>
  1001e6:	66 90                	xchg   %ax,%ax
  1001e8:	66 90                	xchg   %ax,%ax
  1001ea:	66 90                	xchg   %ax,%ax
  1001ec:	66 90                	xchg   %ax,%ax
  1001ee:	66 90                	xchg   %ax,%ax

001001f0 <main>:
#define LOG_LEVEL CONFIG_LOG_DEFAULT_LEVEL
#include <logging/log.h>
LOG_MODULE_REGISTER(app);

void main(void)
{
  1001f0:	55                   	push   %ebp
  1001f1:	89 e5                	mov    %esp,%ebp
  1001f3:	56                   	push   %esi
  1001f4:	83 e4 f8             	and    $0xfffffff8,%esp
  1001f7:	83 ec 58             	sub    $0x58,%esp
  1001fa:	31 c0                	xor    %eax,%eax
	u32_t count = 0U;
  1001fc:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
  100203:	00 
	char count_str[11] = {0};
  100204:	8d 4c 24 45          	lea    0x45(%esp),%ecx
  100208:	89 0c 24             	mov    %ecx,(%esp)
  10020b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100212:	00 
  100213:	c7 44 24 08 0b 00 00 	movl   $0xb,0x8(%esp)
  10021a:	00 
  10021b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10021f:	e8 4c a2 00 00       	call   10a470 <memset>
	struct device *display_dev;
	lv_obj_t *hello_world_label;
	lv_obj_t *count_label;

	display_dev = device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
  100224:	8d 05 c4 36 12 00    	lea    0x1236c4,%eax
  10022a:	89 04 24             	mov    %eax,(%esp)
  10022d:	e8 1e 02 00 00       	call   100450 <device_get_binding>
  100232:	89 44 24 40          	mov    %eax,0x40(%esp)

	if (display_dev == NULL) {
  100236:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
  10023b:	0f 85 ca 00 00 00    	jne    10030b <main+0x11b>
		LOG_ERR("device not found.  Aborting test.");
  100241:	e9 00 00 00 00       	jmp    100246 <main+0x56>
  100246:	e8 25 02 00 00       	call   100470 <_is_user_context>
  10024b:	24 01                	and    $0x1,%al
  10024d:	88 44 24 37          	mov    %al,0x37(%esp)
  100251:	f6 44 24 37 01       	testb  $0x1,0x37(%esp)
  100256:	0f 85 0f 00 00 00    	jne    10026b <main+0x7b>
  10025c:	b0 01                	mov    $0x1,%al
  10025e:	a8 01                	test   $0x1,%al
  100260:	0f 85 05 00 00 00    	jne    10026b <main+0x7b>
  100266:	e9 95 00 00 00       	jmp    100300 <main+0x110>
  10026b:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  100270:	66 83 e0 f8          	and    $0xfff8,%ax
  100274:	66 83 c8 01          	or     $0x1,%ax
  100278:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  10027d:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  100282:	66 83 e0 c7          	and    $0xffc7,%ax
  100286:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  10028b:	8b 0d 00 30 14 00    	mov    0x143000,%ecx
  100291:	89 0c 24             	mov    %ecx,(%esp)
  100294:	e8 e7 01 00 00       	call   100480 <log_const_source_id>
  100299:	66 8b 54 24 30       	mov    0x30(%esp),%dx
  10029e:	66 25 ff 03          	and    $0x3ff,%ax
  1002a2:	66 c1 e0 06          	shl    $0x6,%ax
  1002a6:	66 83 e2 3f          	and    $0x3f,%dx
  1002aa:	66 09 c2             	or     %ax,%dx
  1002ad:	66 89 54 24 30       	mov    %dx,0x30(%esp)
  1002b2:	f6 44 24 37 01       	testb  $0x1,0x37(%esp)
  1002b7:	0f 84 1f 00 00 00    	je     1002dc <main+0xec>
  1002bd:	8d 44 24 30          	lea    0x30(%esp),%eax
  1002c1:	66 8b 08             	mov    (%eax),%cx
  1002c4:	66 89 0c 24          	mov    %cx,(%esp)
  1002c8:	8d 05 cc 36 12 00    	lea    0x1236cc,%eax
  1002ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  1002d2:	e8 69 3d 00 00       	call   104040 <log_from_user>
  1002d7:	e9 1a 00 00 00       	jmp    1002f6 <main+0x106>
  1002dc:	8d 05 cc 36 12 00    	lea    0x1236cc,%eax
  1002e2:	89 04 24             	mov    %eax,(%esp)
  1002e5:	8d 44 24 30          	lea    0x30(%esp),%eax
  1002e9:	66 8b 08             	mov    (%eax),%cx
  1002ec:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  1002f1:	e8 aa 2e 00 00       	call   1031a0 <log_0>
  1002f6:	e9 00 00 00 00       	jmp    1002fb <main+0x10b>
  1002fb:	e9 00 00 00 00       	jmp    100300 <main+0x110>
  100300:	e9 00 00 00 00       	jmp    100305 <main+0x115>
		return;
  100305:	8d 65 fc             	lea    -0x4(%ebp),%esp
  100308:	5e                   	pop    %esi
  100309:	5d                   	pop    %ebp
  10030a:	c3                   	ret    
	}

	hello_world_label = lv_label_create(lv_scr_act(), NULL);
  10030b:	e8 90 01 00 00       	call   1004a0 <lv_scr_act>
  100310:	31 c9                	xor    %ecx,%ecx
  100312:	89 04 24             	mov    %eax,(%esp)
  100315:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10031c:	00 
  10031d:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  100321:	e8 6a 98 01 00       	call   119b90 <lv_label_create>
  100326:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	lv_label_set_text(hello_world_label, "Hello world!");
  10032a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10032e:	89 04 24             	mov    %eax,(%esp)
  100331:	8d 05 ee 36 12 00    	lea    0x1236ee,%eax
  100337:	89 44 24 04          	mov    %eax,0x4(%esp)
  10033b:	e8 a0 a8 01 00       	call   11abe0 <lv_label_set_text>
  100340:	31 c0                	xor    %eax,%eax
	lv_obj_align(hello_world_label, NULL, LV_ALIGN_CENTER, 0, 0);
  100342:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  100346:	89 0c 24             	mov    %ecx,(%esp)
  100349:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100350:	00 
  100351:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100358:	00 
  100359:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100360:	00 
  100361:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  100368:	00 
  100369:	89 44 24 24          	mov    %eax,0x24(%esp)
  10036d:	e8 de ee 00 00       	call   10f250 <lv_obj_align>

	count_label = lv_label_create(lv_scr_act(), NULL);
  100372:	e8 29 01 00 00       	call   1004a0 <lv_scr_act>
  100377:	31 c9                	xor    %ecx,%ecx
  100379:	89 04 24             	mov    %eax,(%esp)
  10037c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100383:	00 
  100384:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  100388:	e8 03 98 01 00       	call   119b90 <lv_label_create>
  10038d:	31 c9                	xor    %ecx,%ecx
  10038f:	89 44 24 38          	mov    %eax,0x38(%esp)
	lv_obj_align(count_label, NULL, LV_ALIGN_IN_BOTTOM_MID, 0, 0);
  100393:	8b 44 24 38          	mov    0x38(%esp),%eax
  100397:	89 04 24             	mov    %eax,(%esp)
  10039a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1003a1:	00 
  1003a2:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
  1003a9:	00 
  1003aa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1003b1:	00 
  1003b2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1003b9:	00 
  1003ba:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  1003be:	e8 8d ee 00 00       	call   10f250 <lv_obj_align>

	display_blanking_off(display_dev);
  1003c3:	8b 44 24 40          	mov    0x40(%esp),%eax
  1003c7:	89 04 24             	mov    %eax,(%esp)
  1003ca:	e8 f1 00 00 00       	call   1004c0 <display_blanking_off>

	while (1) {
		if ((count % 100) == 0U) {
  1003cf:	8b 44 24 50          	mov    0x50(%esp),%eax
  1003d3:	31 d2                	xor    %edx,%edx
  1003d5:	b9 64 00 00 00       	mov    $0x64,%ecx
  1003da:	f7 f1                	div    %ecx
  1003dc:	83 fa 00             	cmp    $0x0,%edx
  1003df:	0f 85 49 00 00 00    	jne    10042e <main+0x23e>
  1003e5:	8d 44 24 45          	lea    0x45(%esp),%eax
			sprintf(count_str, "%d", count/100U);
  1003e9:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  1003ed:	89 44 24 18          	mov    %eax,0x18(%esp)
  1003f1:	89 c8                	mov    %ecx,%eax
  1003f3:	31 d2                	xor    %edx,%edx
  1003f5:	b9 64 00 00 00       	mov    $0x64,%ecx
  1003fa:	f7 f1                	div    %ecx
  1003fc:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  100400:	89 0c 24             	mov    %ecx,(%esp)
  100403:	8d 35 9d 3a 12 00    	lea    0x123a9d,%esi
  100409:	89 74 24 04          	mov    %esi,0x4(%esp)
  10040d:	89 44 24 08          	mov    %eax,0x8(%esp)
  100411:	e8 5a c1 00 00       	call   10c570 <sprintf>
  100416:	8d 4c 24 45          	lea    0x45(%esp),%ecx
			lv_label_set_text(count_label, count_str);
  10041a:	8b 74 24 38          	mov    0x38(%esp),%esi
  10041e:	89 34 24             	mov    %esi,(%esp)
  100421:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100425:	89 44 24 14          	mov    %eax,0x14(%esp)
  100429:	e8 b2 a7 01 00       	call   11abe0 <lv_label_set_text>
		}
		lv_task_handler();
  10042e:	e8 5d 7b 01 00       	call   117f90 <lv_task_handler>
		k_sleep(K_MSEC(10));
  100433:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10043a:	e8 b1 00 00 00       	call   1004f0 <k_sleep>
		++count;
  10043f:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  100443:	83 c1 01             	add    $0x1,%ecx
  100446:	89 4c 24 50          	mov    %ecx,0x50(%esp)
	while (1) {
  10044a:	e9 80 ff ff ff       	jmp    1003cf <main+0x1df>
  10044f:	90                   	nop

00100450 <device_get_binding>:
extern "C" {
#endif

extern struct device * z_impl_device_get_binding(const char * name);
static inline struct device * device_get_binding(const char * name)
{
  100450:	55                   	push   %ebp
  100451:	89 e5                	mov    %esp,%ebp
  100453:	50                   	push   %eax
  100454:	8b 45 08             	mov    0x8(%ebp),%eax
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
  100457:	8b 45 08             	mov    0x8(%ebp),%eax
  10045a:	89 04 24             	mov    %eax,(%esp)
  10045d:	e8 ae c2 01 00       	call   11c710 <z_impl_device_get_binding>
  100462:	83 c4 04             	add    $0x4,%esp
  100465:	5d                   	pop    %ebp
  100466:	c3                   	ret    
  100467:	66 90                	xchg   %ax,%ax
  100469:	66 90                	xchg   %ax,%ax
  10046b:	66 90                	xchg   %ax,%ax
  10046d:	66 90                	xchg   %ax,%ax
  10046f:	90                   	nop

00100470 <_is_user_context>:
 * Indicate whether the CPU is currently in user mode
 *
 * @return true if the CPU is currently running with user permissions
 */
static inline bool _is_user_context(void)
{
  100470:	55                   	push   %ebp
  100471:	89 e5                	mov    %esp,%ebp
  100473:	31 c0                	xor    %eax,%eax
#ifdef CONFIG_USERSPACE
	return arch_is_user_context();
#else
	return false;
  100475:	24 01                	and    $0x1,%al
  100477:	0f b6 c0             	movzbl %al,%eax
  10047a:	5d                   	pop    %ebp
  10047b:	c3                   	ret    
  10047c:	66 90                	xchg   %ax,%ax
  10047e:	66 90                	xchg   %ax,%ax

00100480 <log_const_source_id>:
 *
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
  100480:	55                   	push   %ebp
  100481:	89 e5                	mov    %esp,%ebp
  100483:	50                   	push   %eax
  100484:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  100487:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10048a:	8d 15 84 30 12 00    	lea    0x123084,%edx
  100490:	29 d1                	sub    %edx,%ecx
  100492:	c1 e9 03             	shr    $0x3,%ecx
  100495:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100498:	89 c8                	mov    %ecx,%eax
  10049a:	83 c4 04             	add    $0x4,%esp
  10049d:	5d                   	pop    %ebp
  10049e:	c3                   	ret    
  10049f:	90                   	nop

001004a0 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
  1004a0:	55                   	push   %ebp
  1004a1:	89 e5                	mov    %esp,%ebp
  1004a3:	50                   	push   %eax
    return lv_disp_get_scr_act(lv_disp_get_default());
  1004a4:	e8 b7 73 01 00       	call   117860 <lv_disp_get_default>
  1004a9:	89 04 24             	mov    %eax,(%esp)
  1004ac:	e8 af d7 00 00       	call   10dc60 <lv_disp_get_scr_act>
  1004b1:	83 c4 04             	add    $0x4,%esp
  1004b4:	5d                   	pop    %ebp
  1004b5:	c3                   	ret    
  1004b6:	66 90                	xchg   %ax,%ax
  1004b8:	66 90                	xchg   %ax,%ax
  1004ba:	66 90                	xchg   %ax,%ax
  1004bc:	66 90                	xchg   %ax,%ax
  1004be:	66 90                	xchg   %ax,%ax

001004c0 <display_blanking_off>:
 * @param dev Pointer to device structure
 *
 * @retval 0 on success else negative errno code.
 */
static inline int display_blanking_off(const struct device *dev)
{
  1004c0:	55                   	push   %ebp
  1004c1:	89 e5                	mov    %esp,%ebp
  1004c3:	83 ec 0c             	sub    $0xc,%esp
  1004c6:	8b 45 08             	mov    0x8(%ebp),%eax
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;
  1004c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1004cc:	8b 49 04             	mov    0x4(%ecx),%ecx
	struct display_driver_api *api =
  1004cf:	89 4d fc             	mov    %ecx,-0x4(%ebp)

	return api->blanking_off(dev);
  1004d2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1004d5:	8b 49 04             	mov    0x4(%ecx),%ecx
  1004d8:	8b 55 08             	mov    0x8(%ebp),%edx
  1004db:	89 14 24             	mov    %edx,(%esp)
  1004de:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1004e1:	ff d1                	call   *%ecx
  1004e3:	83 c4 0c             	add    $0xc,%esp
  1004e6:	5d                   	pop    %ebp
  1004e7:	c3                   	ret    
  1004e8:	66 90                	xchg   %ax,%ax
  1004ea:	66 90                	xchg   %ax,%ax
  1004ec:	66 90                	xchg   %ax,%ax
  1004ee:	66 90                	xchg   %ax,%ax

001004f0 <k_sleep>:
}


extern s32_t z_impl_k_sleep(s32_t ms);
static inline s32_t k_sleep(s32_t ms)
{
  1004f0:	55                   	push   %ebp
  1004f1:	89 e5                	mov    %esp,%ebp
  1004f3:	50                   	push   %eax
  1004f4:	8b 45 08             	mov    0x8(%ebp),%eax
	if (z_syscall_trap()) {
		return (s32_t) arch_syscall_invoke1(*(uintptr_t *)&ms, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(ms);
  1004f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1004fa:	89 04 24             	mov    %eax,(%esp)
  1004fd:	e8 8e f1 01 00       	call   11f690 <z_impl_k_sleep>
  100502:	83 c4 04             	add    $0x4,%esp
  100505:	5d                   	pop    %ebp
  100506:	c3                   	ret    
  100507:	66 90                	xchg   %ax,%ax
  100509:	66 90                	xchg   %ax,%ax
  10050b:	66 90                	xchg   %ax,%ax
  10050d:	66 90                	xchg   %ax,%ax
  10050f:	90                   	nop

00100510 <z_sys_mem_pool_base_init>:

	return (*word >> (4*(bit / 4))) & 0xf;
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 24             	sub    $0x24,%esp
  100516:	8b 45 08             	mov    0x8(%ebp),%eax
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
  100519:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10051c:	0f b7 49 08          	movzwl 0x8(%ecx),%ecx
  100520:	8b 55 08             	mov    0x8(%ebp),%edx
  100523:	0f af 4a 04          	imul   0x4(%edx),%ecx
  100527:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10052a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10052d:	8b 49 04             	mov    0x4(%ecx),%ecx
  100530:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
  100533:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100536:	8b 09                	mov    (%ecx),%ecx
  100538:	03 4d f8             	add    -0x8(%ebp),%ecx
  10053b:	89 4d f0             	mov    %ecx,-0x10(%ebp)

	p->max_inline_level = -1;
  10053e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100541:	c6 41 0b ff          	movb   $0xff,0xb(%ecx)

	for (i = 0; i < p->n_levels; i++) {
  100545:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10054c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10054f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100552:	0f b6 49 0a          	movzbl 0xa(%ecx),%ecx
  100556:	39 c8                	cmp    %ecx,%eax
  100558:	0f 8d 7c 00 00 00    	jge    1005da <z_sys_mem_pool_base_init+0xca>
		int nblocks = buflen / sz;
  10055e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100561:	31 d2                	xor    %edx,%edx
  100563:	f7 75 f4             	divl   -0xc(%ebp)
  100566:	89 45 ec             	mov    %eax,-0x14(%ebp)

		sys_dlist_init(&p->levels[i].free_list);
  100569:	8b 45 08             	mov    0x8(%ebp),%eax
  10056c:	8b 40 0c             	mov    0xc(%eax),%eax
  10056f:	6b 4d fc 0c          	imul   $0xc,-0x4(%ebp),%ecx
  100573:	01 c8                	add    %ecx,%eax
  100575:	83 c0 04             	add    $0x4,%eax
  100578:	89 04 24             	mov    %eax,(%esp)
  10057b:	e8 c0 00 00 00       	call   100640 <sys_dlist_init>

		if (nblocks <= sizeof(p->levels[i].bits)*8) {
  100580:	83 7d ec 20          	cmpl   $0x20,-0x14(%ebp)
  100584:	0f 87 0e 00 00 00    	ja     100598 <z_sys_mem_pool_base_init+0x88>
			p->max_inline_level = i;
  10058a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10058d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100590:	88 41 0b             	mov    %al,0xb(%ecx)
		} else {
  100593:	e9 28 00 00 00       	jmp    1005c0 <z_sys_mem_pool_base_init+0xb0>
			p->levels[i].bits_p = bits;
  100598:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10059b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10059e:	8b 49 0c             	mov    0xc(%ecx),%ecx
  1005a1:	6b 55 fc 0c          	imul   $0xc,-0x4(%ebp),%edx
  1005a5:	01 d1                	add    %edx,%ecx
  1005a7:	89 01                	mov    %eax,(%ecx)
			bits += (nblocks + 31)/32;
  1005a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1005ac:	83 c0 1f             	add    $0x1f,%eax
  1005af:	99                   	cltd   
  1005b0:	b9 20 00 00 00       	mov    $0x20,%ecx
  1005b5:	f7 f9                	idiv   %ecx
  1005b7:	c1 e0 02             	shl    $0x2,%eax
  1005ba:	03 45 f0             	add    -0x10(%ebp),%eax
  1005bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		}

		sz = WB_DN(sz / 4);
  1005c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1005c3:	c1 e8 02             	shr    $0x2,%eax
  1005c6:	83 e0 fc             	and    $0xfffffffc,%eax
  1005c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for (i = 0; i < p->n_levels; i++) {
  1005cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1005cf:	83 c0 01             	add    $0x1,%eax
  1005d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1005d5:	e9 72 ff ff ff       	jmp    10054c <z_sys_mem_pool_base_init+0x3c>
	}

	for (i = 0; i < p->n_max; i++) {
  1005da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1005e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1005e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1005e7:	0f b7 49 08          	movzwl 0x8(%ecx),%ecx
  1005eb:	39 c8                	cmp    %ecx,%eax
  1005ed:	0f 8d 45 00 00 00    	jge    100638 <z_sys_mem_pool_base_init+0x128>
		void *block = block_ptr(p, p->max_sz, i);
  1005f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1005f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1005f9:	8b 49 04             	mov    0x4(%ecx),%ecx
  1005fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1005ff:	89 04 24             	mov    %eax,(%esp)
  100602:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100606:	89 54 24 08          	mov    %edx,0x8(%esp)
  10060a:	e8 51 00 00 00       	call   100660 <block_ptr>
  10060f:	89 45 e8             	mov    %eax,-0x18(%ebp)

		sys_dlist_append(&p->levels[0].free_list, block);
  100612:	8b 45 08             	mov    0x8(%ebp),%eax
  100615:	8b 40 0c             	mov    0xc(%eax),%eax
  100618:	83 c0 04             	add    $0x4,%eax
  10061b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10061e:	89 04 24             	mov    %eax,(%esp)
  100621:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100625:	e8 66 00 00 00       	call   100690 <sys_dlist_append>
	for (i = 0; i < p->n_max; i++) {
  10062a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10062d:	83 c0 01             	add    $0x1,%eax
  100630:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100633:	e9 a9 ff ff ff       	jmp    1005e1 <z_sys_mem_pool_base_init+0xd1>
	}
}
  100638:	83 c4 24             	add    $0x24,%esp
  10063b:	5d                   	pop    %ebp
  10063c:	c3                   	ret    
  10063d:	66 90                	xchg   %ax,%ax
  10063f:	90                   	nop

00100640 <sys_dlist_init>:
 *
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
  100640:	55                   	push   %ebp
  100641:	89 e5                	mov    %esp,%ebp
  100643:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
  100646:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100649:	8b 55 08             	mov    0x8(%ebp),%edx
  10064c:	89 0a                	mov    %ecx,(%edx)
	list->tail = (sys_dnode_t *)list;
  10064e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100651:	8b 55 08             	mov    0x8(%ebp),%edx
  100654:	89 4a 04             	mov    %ecx,0x4(%edx)
}
  100657:	5d                   	pop    %ebp
  100658:	c3                   	ret    
  100659:	66 90                	xchg   %ax,%ax
  10065b:	66 90                	xchg   %ax,%ax
  10065d:	66 90                	xchg   %ax,%ax
  10065f:	90                   	nop

00100660 <block_ptr>:
{
  100660:	55                   	push   %ebp
  100661:	89 e5                	mov    %esp,%ebp
  100663:	57                   	push   %edi
  100664:	56                   	push   %esi
  100665:	50                   	push   %eax
  100666:	8b 45 10             	mov    0x10(%ebp),%eax
  100669:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10066c:	8b 55 08             	mov    0x8(%ebp),%edx
	return (u8_t *)p->buf + lsz * block;
  10066f:	8b 75 08             	mov    0x8(%ebp),%esi
  100672:	8b 36                	mov    (%esi),%esi
  100674:	8b 7d 0c             	mov    0xc(%ebp),%edi
  100677:	0f af 7d 10          	imul   0x10(%ebp),%edi
  10067b:	01 fe                	add    %edi,%esi
  10067d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100680:	89 f0                	mov    %esi,%eax
  100682:	83 c4 04             	add    $0x4,%esp
  100685:	5e                   	pop    %esi
  100686:	5f                   	pop    %edi
  100687:	5d                   	pop    %ebp
  100688:	c3                   	ret    
  100689:	66 90                	xchg   %ax,%ax
  10068b:	66 90                	xchg   %ax,%ax
  10068d:	66 90                	xchg   %ax,%ax
  10068f:	90                   	nop

00100690 <sys_dlist_append>:
 *
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
  100690:	55                   	push   %ebp
  100691:	89 e5                	mov    %esp,%ebp
  100693:	56                   	push   %esi
  100694:	8b 45 0c             	mov    0xc(%ebp),%eax
  100697:	8b 4d 08             	mov    0x8(%ebp),%ecx
	node->next = list;
  10069a:	8b 55 08             	mov    0x8(%ebp),%edx
  10069d:	8b 75 0c             	mov    0xc(%ebp),%esi
  1006a0:	89 16                	mov    %edx,(%esi)
	node->prev = list->tail;
  1006a2:	8b 55 08             	mov    0x8(%ebp),%edx
  1006a5:	8b 52 04             	mov    0x4(%edx),%edx
  1006a8:	8b 75 0c             	mov    0xc(%ebp),%esi
  1006ab:	89 56 04             	mov    %edx,0x4(%esi)

	list->tail->next = node;
  1006ae:	8b 55 0c             	mov    0xc(%ebp),%edx
  1006b1:	8b 75 08             	mov    0x8(%ebp),%esi
  1006b4:	8b 76 04             	mov    0x4(%esi),%esi
  1006b7:	89 16                	mov    %edx,(%esi)
	list->tail = node;
  1006b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1006bc:	8b 75 08             	mov    0x8(%ebp),%esi
  1006bf:	89 56 04             	mov    %edx,0x4(%esi)
}
  1006c2:	5e                   	pop    %esi
  1006c3:	5d                   	pop    %ebp
  1006c4:	c3                   	ret    
  1006c5:	66 90                	xchg   %ax,%ax
  1006c7:	66 90                	xchg   %ax,%ax
  1006c9:	66 90                	xchg   %ax,%ax
  1006cb:	66 90                	xchg   %ax,%ax
  1006cd:	66 90                	xchg   %ax,%ax
  1006cf:	90                   	nop

001006d0 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
  1006d0:	55                   	push   %ebp
  1006d1:	89 e5                	mov    %esp,%ebp
  1006d3:	53                   	push   %ebx
  1006d4:	57                   	push   %edi
  1006d5:	56                   	push   %esi
  1006d6:	83 ec 34             	sub    $0x34,%esp
  1006d9:	8b 45 18             	mov    0x18(%ebp),%eax
  1006dc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1006df:	8b 55 10             	mov    0x10(%ebp),%edx
  1006e2:	8b 75 0c             	mov    0xc(%ebp),%esi
  1006e5:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i, from_l, alloc_l = -1;
  1006e8:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
	unsigned int key;
	void *data = NULL;
  1006ef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
  1006f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1006f9:	0f b6 5b 0a          	movzbl 0xa(%ebx),%ebx
  1006fd:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100700:	89 e0                	mov    %esp,%eax
  100702:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100705:	89 d8                	mov    %ebx,%eax
  100707:	c1 e0 02             	shl    $0x2,%eax
  10070a:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10070d:	89 e0                	mov    %esp,%eax
  10070f:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100712:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  100715:	29 c8                	sub    %ecx,%eax
  100717:	89 c4                	mov    %eax,%esp
  100719:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
  10071c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10071f:	8b 49 04             	mov    0x4(%ecx),%ecx
  100722:	89 08                	mov    %ecx,(%eax)
	for (i = 0; i < p->n_levels; i++) {
  100724:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10072b:	89 45 c0             	mov    %eax,-0x40(%ebp)
  10072e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100731:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100734:	0f b6 49 0a          	movzbl 0xa(%ecx),%ecx
  100738:	39 c8                	cmp    %ecx,%eax
  10073a:	0f 8d 4d 00 00 00    	jge    10078d <z_sys_mem_pool_block_alloc+0xbd>
		if (i > 0) {
  100740:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  100744:	0f 8e 18 00 00 00    	jle    100762 <z_sys_mem_pool_block_alloc+0x92>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
  10074a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10074d:	83 e8 01             	sub    $0x1,%eax
  100750:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  100753:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  100756:	c1 e8 02             	shr    $0x2,%eax
  100759:	83 e0 fc             	and    $0xfffffffc,%eax
  10075c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10075f:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		}

		if (lsizes[i] < size) {
  100762:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100765:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  100768:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10076b:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10076e:	0f 83 05 00 00 00    	jae    100779 <z_sys_mem_pool_block_alloc+0xa9>
			break;
  100774:	e9 14 00 00 00       	jmp    10078d <z_sys_mem_pool_block_alloc+0xbd>
		}

		alloc_l = i;
  100779:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10077c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (i = 0; i < p->n_levels; i++) {
  10077f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100782:	83 c0 01             	add    $0x1,%eax
  100785:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100788:	e9 a1 ff ff ff       	jmp    10072e <z_sys_mem_pool_block_alloc+0x5e>
	}

	if (alloc_l < 0) {
  10078d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  100791:	0f 8d 1c 00 00 00    	jge    1007b3 <z_sys_mem_pool_block_alloc+0xe3>
		*data_p = NULL;
  100797:	8b 45 18             	mov    0x18(%ebp),%eax
  10079a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -ENOMEM;
  1007a0:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,-0x10(%ebp)
  1007a7:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
  1007ae:	e9 60 01 00 00       	jmp    100913 <z_sys_mem_pool_block_alloc+0x243>
	 * its the three unused children needs to be performed
	 * atomically, otherwise we open up a situation where we can
	 * "steal" the top level block of the whole heap, causing a
	 * spurious -ENOMEM.
	 */
	key = pool_irq_lock(p);
  1007b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1007b6:	83 ec 04             	sub    $0x4,%esp
  1007b9:	89 04 24             	mov    %eax,(%esp)
  1007bc:	e8 6f 01 00 00       	call   100930 <pool_irq_lock>
  1007c1:	83 c4 04             	add    $0x4,%esp
  1007c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (i = alloc_l; i >= 0; i--) {
  1007c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1007ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1007cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1007d1:	0f 8c bf 00 00 00    	jl     100896 <z_sys_mem_pool_block_alloc+0x1c6>
		data = block_alloc(p, i, lsizes[i]);
  1007d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1007da:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1007dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1007e0:	8b 75 c0             	mov    -0x40(%ebp),%esi
  1007e3:	8b 14 96             	mov    (%esi,%edx,4),%edx
  1007e6:	83 ec 0c             	sub    $0xc,%esp
  1007e9:	89 04 24             	mov    %eax,(%esp)
  1007ec:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1007f0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1007f4:	e8 77 01 00 00       	call   100970 <block_alloc>
  1007f9:	83 c4 0c             	add    $0xc,%esp
  1007fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
		/* Found one.  Iteratively break it down to the size
		 * we need.  Note that we relax the lock to allow a
		 * pending interrupt to fire so we don't hurt latency
		 * by locking the full loop.
		 */
		if (data != NULL) {
  1007ff:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  100803:	0f 84 7a 00 00 00    	je     100883 <z_sys_mem_pool_block_alloc+0x1b3>
			for (from_l = i; from_l < alloc_l; from_l++) {
  100809:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10080c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10080f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100812:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  100815:	0f 8d 63 00 00 00    	jge    10087e <z_sys_mem_pool_block_alloc+0x1ae>
				data = block_break(p, data, from_l, lsizes);
  10081b:	8b 45 08             	mov    0x8(%ebp),%eax
  10081e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  100821:	8b 55 e8             	mov    -0x18(%ebp),%edx
  100824:	83 ec 10             	sub    $0x10,%esp
  100827:	89 04 24             	mov    %eax,(%esp)
  10082a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10082e:	89 54 24 08          	mov    %edx,0x8(%esp)
  100832:	8b 45 c0             	mov    -0x40(%ebp),%eax
  100835:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100839:	e8 c2 01 00 00       	call   100a00 <block_break>
  10083e:	83 c4 10             	add    $0x10,%esp
  100841:	89 45 dc             	mov    %eax,-0x24(%ebp)
				pool_irq_unlock(p, key);
  100844:	8b 45 08             	mov    0x8(%ebp),%eax
  100847:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10084a:	83 ec 08             	sub    $0x8,%esp
  10084d:	89 04 24             	mov    %eax,(%esp)
  100850:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100854:	e8 87 02 00 00       	call   100ae0 <pool_irq_unlock>
  100859:	83 c4 08             	add    $0x8,%esp
				key = pool_irq_lock(p);
  10085c:	8b 45 08             	mov    0x8(%ebp),%eax
  10085f:	83 ec 04             	sub    $0x4,%esp
  100862:	89 04 24             	mov    %eax,(%esp)
  100865:	e8 c6 00 00 00       	call   100930 <pool_irq_lock>
  10086a:	83 c4 04             	add    $0x4,%esp
  10086d:	89 45 e0             	mov    %eax,-0x20(%ebp)
			for (from_l = i; from_l < alloc_l; from_l++) {
  100870:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100873:	83 c0 01             	add    $0x1,%eax
  100876:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100879:	e9 91 ff ff ff       	jmp    10080f <z_sys_mem_pool_block_alloc+0x13f>
			}
			break;
  10087e:	e9 13 00 00 00       	jmp    100896 <z_sys_mem_pool_block_alloc+0x1c6>
		}
	}
  100883:	e9 00 00 00 00       	jmp    100888 <z_sys_mem_pool_block_alloc+0x1b8>
	for (i = alloc_l; i >= 0; i--) {
  100888:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10088b:	83 c0 ff             	add    $0xffffffff,%eax
  10088e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100891:	e9 37 ff ff ff       	jmp    1007cd <z_sys_mem_pool_block_alloc+0xfd>
	pool_irq_unlock(p, key);
  100896:	8b 45 08             	mov    0x8(%ebp),%eax
  100899:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10089c:	83 ec 08             	sub    $0x8,%esp
  10089f:	89 04 24             	mov    %eax,(%esp)
  1008a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1008a6:	e8 35 02 00 00       	call   100ae0 <pool_irq_unlock>
  1008ab:	83 c4 08             	add    $0x8,%esp

	*data_p = data;
  1008ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1008b1:	8b 4d 18             	mov    0x18(%ebp),%ecx
  1008b4:	89 01                	mov    %eax,(%ecx)

	if (data == NULL) {
  1008b6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1008ba:	0f 85 13 00 00 00    	jne    1008d3 <z_sys_mem_pool_block_alloc+0x203>
		return -ENOMEM;
  1008c0:	c7 45 f0 f4 ff ff ff 	movl   $0xfffffff4,-0x10(%ebp)
  1008c7:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
  1008ce:	e9 40 00 00 00       	jmp    100913 <z_sys_mem_pool_block_alloc+0x243>
	}

	*level_p = alloc_l;
  1008d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1008d6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1008d9:	89 01                	mov    %eax,(%ecx)
	*block_p = block_num(p, data, lsizes[alloc_l]);
  1008db:	8b 45 08             	mov    0x8(%ebp),%eax
  1008de:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1008e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1008e4:	8b 75 c0             	mov    -0x40(%ebp),%esi
  1008e7:	8b 14 96             	mov    (%esi,%edx,4),%edx
  1008ea:	83 ec 0c             	sub    $0xc,%esp
  1008ed:	89 04 24             	mov    %eax,(%esp)
  1008f0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1008f4:	89 54 24 08          	mov    %edx,0x8(%esp)
  1008f8:	e8 23 02 00 00       	call   100b20 <block_num>
  1008fd:	83 c4 0c             	add    $0xc,%esp
  100900:	8b 4d 14             	mov    0x14(%ebp),%ecx
  100903:	89 01                	mov    %eax,(%ecx)

	return 0;
  100905:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10090c:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
}
  100913:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100916:	89 c4                	mov    %eax,%esp
  100918:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10091b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10091e:	5e                   	pop    %esi
  10091f:	5f                   	pop    %edi
  100920:	5b                   	pop    %ebx
  100921:	5d                   	pop    %ebp
  100922:	c3                   	ret    
  100923:	66 90                	xchg   %ax,%ax
  100925:	66 90                	xchg   %ax,%ax
  100927:	66 90                	xchg   %ax,%ax
  100929:	66 90                	xchg   %ax,%ax
  10092b:	66 90                	xchg   %ax,%ax
  10092d:	66 90                	xchg   %ax,%ax
  10092f:	90                   	nop

00100930 <pool_irq_lock>:
{
  100930:	55                   	push   %ebp
  100931:	89 e5                	mov    %esp,%ebp
  100933:	83 ec 08             	sub    $0x8,%esp
  100936:	8b 45 08             	mov    0x8(%ebp),%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
  100939:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10093c:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  100940:	83 e1 01             	and    $0x1,%ecx
  100943:	83 f9 00             	cmp    $0x0,%ecx
  100946:	0f 84 10 00 00 00    	je     10095c <pool_irq_lock+0x2c>

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  10094c:	9c                   	pushf  
  10094d:	fa                   	cli    
  10094e:	8f 45 fc             	popl   -0x4(%ebp)

	return key;
  100951:	8b 45 fc             	mov    -0x4(%ebp),%eax
		return irq_lock();
  100954:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100957:	e9 07 00 00 00       	jmp    100963 <pool_irq_lock+0x33>
		return 0;
  10095c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  100963:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100966:	83 c4 08             	add    $0x8,%esp
  100969:	5d                   	pop    %ebp
  10096a:	c3                   	ret    
  10096b:	66 90                	xchg   %ax,%ax
  10096d:	66 90                	xchg   %ax,%ax
  10096f:	90                   	nop

00100970 <block_alloc>:
{
  100970:	55                   	push   %ebp
  100971:	89 e5                	mov    %esp,%ebp
  100973:	57                   	push   %edi
  100974:	56                   	push   %esi
  100975:	83 ec 24             	sub    $0x24,%esp
  100978:	8b 45 10             	mov    0x10(%ebp),%eax
  10097b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10097e:	8b 55 08             	mov    0x8(%ebp),%edx
	block = sys_dlist_get(&p->levels[l].free_list);
  100981:	8b 75 08             	mov    0x8(%ebp),%esi
  100984:	8b 76 0c             	mov    0xc(%esi),%esi
  100987:	6b 7d 0c 0c          	imul   $0xc,0xc(%ebp),%edi
  10098b:	01 fe                	add    %edi,%esi
  10098d:	83 c6 04             	add    $0x4,%esi
  100990:	89 34 24             	mov    %esi,(%esp)
  100993:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100996:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  100999:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10099c:	e8 df 02 00 00       	call   100c80 <sys_dlist_get>
  1009a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (block != NULL) {
  1009a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1009a8:	0f 84 3b 00 00 00    	je     1009e9 <block_alloc+0x79>
		set_alloc_bit(p, l, block_num(p, block, lsz));
  1009ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1009b1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1009b4:	8b 55 08             	mov    0x8(%ebp),%edx
  1009b7:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1009ba:	8b 7d 10             	mov    0x10(%ebp),%edi
  1009bd:	89 14 24             	mov    %edx,(%esp)
  1009c0:	89 74 24 04          	mov    %esi,0x4(%esp)
  1009c4:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1009c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1009cb:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1009ce:	e8 4d 01 00 00       	call   100b20 <block_num>
  1009d3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1009d6:	89 0c 24             	mov    %ecx,(%esp)
  1009d9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1009dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1009e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1009e4:	e8 e7 02 00 00       	call   100cd0 <set_alloc_bit>
	return block;
  1009e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1009ec:	83 c4 24             	add    $0x24,%esp
  1009ef:	5e                   	pop    %esi
  1009f0:	5f                   	pop    %edi
  1009f1:	5d                   	pop    %ebp
  1009f2:	c3                   	ret    
  1009f3:	66 90                	xchg   %ax,%ax
  1009f5:	66 90                	xchg   %ax,%ax
  1009f7:	66 90                	xchg   %ax,%ax
  1009f9:	66 90                	xchg   %ax,%ax
  1009fb:	66 90                	xchg   %ax,%ax
  1009fd:	66 90                	xchg   %ax,%ax
  1009ff:	90                   	nop

00100a00 <block_break>:
{
  100a00:	55                   	push   %ebp
  100a01:	89 e5                	mov    %esp,%ebp
  100a03:	53                   	push   %ebx
  100a04:	57                   	push   %edi
  100a05:	56                   	push   %esi
  100a06:	83 ec 34             	sub    $0x34,%esp
  100a09:	8b 45 14             	mov    0x14(%ebp),%eax
  100a0c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100a0f:	8b 55 0c             	mov    0xc(%ebp),%edx
  100a12:	8b 75 08             	mov    0x8(%ebp),%esi
	bn = block_num(p, block, lsizes[l]);
  100a15:	8b 7d 08             	mov    0x8(%ebp),%edi
  100a18:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100a1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100a1e:	8b 45 14             	mov    0x14(%ebp),%eax
  100a21:	89 45 dc             	mov    %eax,-0x24(%ebp)
  100a24:	8b 45 10             	mov    0x10(%ebp),%eax
  100a27:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100a2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100a2d:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  100a30:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  100a33:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  100a36:	89 3c 24             	mov    %edi,(%esp)
  100a39:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  100a3d:	89 44 24 08          	mov    %eax,0x8(%esp)
  100a41:	89 55 d0             	mov    %edx,-0x30(%ebp)
  100a44:	89 75 cc             	mov    %esi,-0x34(%ebp)
  100a47:	e8 d4 00 00 00       	call   100b20 <block_num>
  100a4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	set_alloc_bit(p, l + 1, 4*bn);
  100a4f:	8b 45 08             	mov    0x8(%ebp),%eax
  100a52:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100a55:	83 c1 01             	add    $0x1,%ecx
  100a58:	8b 55 ec             	mov    -0x14(%ebp),%edx
  100a5b:	c1 e2 02             	shl    $0x2,%edx
  100a5e:	89 04 24             	mov    %eax,(%esp)
  100a61:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100a65:	89 54 24 08          	mov    %edx,0x8(%esp)
  100a69:	e8 62 02 00 00       	call   100cd0 <set_alloc_bit>
	for (i = 1; i < 4; i++) {
  100a6e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
  100a75:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
  100a79:	0f 8d 4b 00 00 00    	jge    100aca <block_break+0xca>
		int lsz = lsizes[l + 1];
  100a7f:	8b 45 14             	mov    0x14(%ebp),%eax
  100a82:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100a85:	8b 44 88 04          	mov    0x4(%eax,%ecx,4),%eax
  100a89:	89 45 e8             	mov    %eax,-0x18(%ebp)
		void *block2 = (lsz * i) + (char *)block;
  100a8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100a8f:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  100a93:	03 45 0c             	add    0xc(%ebp),%eax
  100a96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
  100a99:	8b 45 08             	mov    0x8(%ebp),%eax
  100a9c:	8b 40 0c             	mov    0xc(%eax),%eax
  100a9f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100aa2:	83 c1 01             	add    $0x1,%ecx
  100aa5:	6b c9 0c             	imul   $0xc,%ecx,%ecx
  100aa8:	01 c8                	add    %ecx,%eax
  100aaa:	83 c0 04             	add    $0x4,%eax
  100aad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100ab0:	89 04 24             	mov    %eax,(%esp)
  100ab3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100ab7:	e8 d4 fb ff ff       	call   100690 <sys_dlist_append>
	for (i = 1; i < 4; i++) {
  100abc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100abf:	83 c0 01             	add    $0x1,%eax
  100ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100ac5:	e9 ab ff ff ff       	jmp    100a75 <block_break+0x75>
	return block;
  100aca:	8b 45 0c             	mov    0xc(%ebp),%eax
  100acd:	83 c4 34             	add    $0x34,%esp
  100ad0:	5e                   	pop    %esi
  100ad1:	5f                   	pop    %edi
  100ad2:	5b                   	pop    %ebx
  100ad3:	5d                   	pop    %ebp
  100ad4:	c3                   	ret    
  100ad5:	66 90                	xchg   %ax,%ax
  100ad7:	66 90                	xchg   %ax,%ax
  100ad9:	66 90                	xchg   %ax,%ax
  100adb:	66 90                	xchg   %ax,%ax
  100add:	66 90                	xchg   %ax,%ax
  100adf:	90                   	nop

00100ae0 <pool_irq_unlock>:
{
  100ae0:	55                   	push   %ebp
  100ae1:	89 e5                	mov    %esp,%ebp
  100ae3:	50                   	push   %eax
  100ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ae7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (p->flags & SYS_MEM_POOL_KERNEL) {
  100aea:	8b 55 08             	mov    0x8(%ebp),%edx
  100aed:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  100af1:	83 e2 01             	and    $0x1,%edx
  100af4:	83 fa 00             	cmp    $0x0,%edx
  100af7:	0f 84 1d 00 00 00    	je     100b1a <pool_irq_unlock+0x3a>
		irq_unlock(key);
  100afd:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b00:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include <arch/x86/mmustructs.h>
#include <arch/x86/thread_stack.h>

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  100b03:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b06:	25 00 02 00 00       	and    $0x200,%eax
  100b0b:	83 f8 00             	cmp    $0x0,%eax
  100b0e:	0f 84 01 00 00 00    	je     100b15 <pool_irq_unlock+0x35>
		__asm__ volatile ("sti" ::: "memory");
  100b14:	fb                   	sti    
	}
  100b15:	e9 00 00 00 00       	jmp    100b1a <pool_irq_unlock+0x3a>
}
  100b1a:	83 c4 04             	add    $0x4,%esp
  100b1d:	5d                   	pop    %ebp
  100b1e:	c3                   	ret    
  100b1f:	90                   	nop

00100b20 <block_num>:
{
  100b20:	55                   	push   %ebp
  100b21:	89 e5                	mov    %esp,%ebp
  100b23:	57                   	push   %edi
  100b24:	56                   	push   %esi
  100b25:	83 ec 08             	sub    $0x8,%esp
  100b28:	8b 45 10             	mov    0x10(%ebp),%eax
  100b2b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100b2e:	8b 55 08             	mov    0x8(%ebp),%edx
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
  100b31:	8b 75 0c             	mov    0xc(%ebp),%esi
  100b34:	8b 7d 08             	mov    0x8(%ebp),%edi
  100b37:	8b 3f                	mov    (%edi),%edi
  100b39:	29 fe                	sub    %edi,%esi
  100b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100b3e:	89 f0                	mov    %esi,%eax
  100b40:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100b43:	99                   	cltd   
  100b44:	f7 7d 10             	idivl  0x10(%ebp)
  100b47:	83 c4 08             	add    $0x8,%esp
  100b4a:	5e                   	pop    %esi
  100b4b:	5f                   	pop    %edi
  100b4c:	5d                   	pop    %ebp
  100b4d:	c3                   	ret    
  100b4e:	66 90                	xchg   %ax,%ax

00100b50 <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
  100b50:	55                   	push   %ebp
  100b51:	89 e5                	mov    %esp,%ebp
  100b53:	53                   	push   %ebx
  100b54:	57                   	push   %edi
  100b55:	56                   	push   %esi
  100b56:	83 ec 10             	sub    $0x10,%esp
  100b59:	8b 45 10             	mov    0x10(%ebp),%eax
  100b5c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100b5f:	8b 55 08             	mov    0x8(%ebp),%edx
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
  100b62:	8b 75 08             	mov    0x8(%ebp),%esi
  100b65:	0f b6 76 0a          	movzbl 0xa(%esi),%esi
  100b69:	89 e7                	mov    %esp,%edi
  100b6b:	89 7d f0             	mov    %edi,-0x10(%ebp)
  100b6e:	89 f7                	mov    %esi,%edi
  100b70:	c1 e7 02             	shl    $0x2,%edi
  100b73:	89 e3                	mov    %esp,%ebx
  100b75:	29 fb                	sub    %edi,%ebx
  100b77:	89 dc                	mov    %ebx,%esp
  100b79:	89 75 ec             	mov    %esi,-0x14(%ebp)
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
  100b7c:	8b 75 08             	mov    0x8(%ebp),%esi
  100b7f:	8b 76 04             	mov    0x4(%esi),%esi
  100b82:	89 33                	mov    %esi,(%ebx)
	for (i = 1; i <= level; i++) {
  100b84:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  100b8b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  100b8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b91:	3b 45 0c             	cmp    0xc(%ebp),%eax
  100b94:	0f 87 26 00 00 00    	ja     100bc0 <z_sys_mem_pool_block_free+0x70>
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
  100b9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b9d:	83 e8 01             	sub    $0x1,%eax
  100ba0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100ba3:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  100ba6:	c1 e8 02             	shr    $0x2,%eax
  100ba9:	83 e0 fc             	and    $0xfffffffc,%eax
  100bac:	8b 55 e8             	mov    -0x18(%ebp),%edx
  100baf:	89 04 91             	mov    %eax,(%ecx,%edx,4)
	for (i = 1; i <= level; i++) {
  100bb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100bb5:	83 c0 01             	add    $0x1,%eax
  100bb8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100bbb:	e9 ce ff ff ff       	jmp    100b8e <z_sys_mem_pool_block_free+0x3e>
	}

	block_free(p, level, lsizes, block);
  100bc0:	8b 45 08             	mov    0x8(%ebp),%eax
  100bc3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100bc6:	8b 55 10             	mov    0x10(%ebp),%edx
  100bc9:	83 ec 10             	sub    $0x10,%esp
  100bcc:	89 04 24             	mov    %eax,(%esp)
  100bcf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100bd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100bd6:	89 44 24 08          	mov    %eax,0x8(%esp)
  100bda:	89 54 24 0c          	mov    %edx,0xc(%esp)
  100bde:	e8 1d 00 00 00       	call   100c00 <block_free>
  100be3:	83 c4 10             	add    $0x10,%esp
}
  100be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100be9:	89 c4                	mov    %eax,%esp
  100beb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100bee:	5e                   	pop    %esi
  100bef:	5f                   	pop    %edi
  100bf0:	5b                   	pop    %ebx
  100bf1:	5d                   	pop    %ebp
  100bf2:	c3                   	ret    
  100bf3:	66 90                	xchg   %ax,%ax
  100bf5:	66 90                	xchg   %ax,%ax
  100bf7:	66 90                	xchg   %ax,%ax
  100bf9:	66 90                	xchg   %ax,%ax
  100bfb:	66 90                	xchg   %ax,%ax
  100bfd:	66 90                	xchg   %ax,%ax
  100bff:	90                   	nop

00100c00 <block_free>:
{
  100c00:	55                   	push   %ebp
  100c01:	89 e5                	mov    %esp,%ebp
  100c03:	57                   	push   %edi
  100c04:	56                   	push   %esi
  100c05:	83 ec 28             	sub    $0x28,%esp
  100c08:	8b 45 14             	mov    0x14(%ebp),%eax
  100c0b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100c0e:	8b 55 0c             	mov    0xc(%ebp),%edx
  100c11:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key = pool_irq_lock(p);
  100c14:	8b 7d 08             	mov    0x8(%ebp),%edi
  100c17:	89 3c 24             	mov    %edi,(%esp)
  100c1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100c1d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  100c20:	89 55 e8             	mov    %edx,-0x18(%ebp)
  100c23:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  100c26:	e8 05 fd ff ff       	call   100930 <pool_irq_lock>
  100c2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	key = bfree_recombine(p, level, lsizes, bn, key);
  100c2e:	8b 45 08             	mov    0x8(%ebp),%eax
  100c31:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100c34:	8b 55 10             	mov    0x10(%ebp),%edx
  100c37:	8b 75 14             	mov    0x14(%ebp),%esi
  100c3a:	8b 7d f4             	mov    -0xc(%ebp),%edi
  100c3d:	89 04 24             	mov    %eax,(%esp)
  100c40:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100c44:	89 54 24 08          	mov    %edx,0x8(%esp)
  100c48:	89 74 24 0c          	mov    %esi,0xc(%esp)
  100c4c:	89 7c 24 10          	mov    %edi,0x10(%esp)
  100c50:	e8 eb 01 00 00       	call   100e40 <bfree_recombine>
  100c55:	89 45 f4             	mov    %eax,-0xc(%ebp)
	pool_irq_unlock(p, key);
  100c58:	8b 45 08             	mov    0x8(%ebp),%eax
  100c5b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  100c5e:	89 04 24             	mov    %eax,(%esp)
  100c61:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100c65:	e8 76 fe ff ff       	call   100ae0 <pool_irq_unlock>
}
  100c6a:	83 c4 28             	add    $0x28,%esp
  100c6d:	5e                   	pop    %esi
  100c6e:	5f                   	pop    %edi
  100c6f:	5d                   	pop    %ebp
  100c70:	c3                   	ret    
  100c71:	66 90                	xchg   %ax,%ax
  100c73:	66 90                	xchg   %ax,%ax
  100c75:	66 90                	xchg   %ax,%ax
  100c77:	66 90                	xchg   %ax,%ax
  100c79:	66 90                	xchg   %ax,%ax
  100c7b:	66 90                	xchg   %ax,%ax
  100c7d:	66 90                	xchg   %ax,%ax
  100c7f:	90                   	nop

00100c80 <sys_dlist_get>:
 *
 * @return the first node in the list, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
  100c80:	55                   	push   %ebp
  100c81:	89 e5                	mov    %esp,%ebp
  100c83:	83 ec 0c             	sub    $0xc,%esp
  100c86:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dnode_t *node = NULL;
  100c89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

	if (!sys_dlist_is_empty(list)) {
  100c90:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100c93:	89 0c 24             	mov    %ecx,(%esp)
  100c96:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100c99:	e8 92 00 00 00       	call   100d30 <sys_dlist_is_empty>
  100c9e:	a8 01                	test   $0x1,%al
  100ca0:	0f 85 13 00 00 00    	jne    100cb9 <sys_dlist_get+0x39>
		node = list->head;
  100ca6:	8b 45 08             	mov    0x8(%ebp),%eax
  100ca9:	8b 00                	mov    (%eax),%eax
  100cab:	89 45 fc             	mov    %eax,-0x4(%ebp)
		sys_dlist_remove(node);
  100cae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100cb1:	89 04 24             	mov    %eax,(%esp)
  100cb4:	e8 a7 00 00 00       	call   100d60 <sys_dlist_remove>
	}

	return node;
  100cb9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100cbc:	83 c4 0c             	add    $0xc,%esp
  100cbf:	5d                   	pop    %ebp
  100cc0:	c3                   	ret    
  100cc1:	66 90                	xchg   %ax,%ax
  100cc3:	66 90                	xchg   %ax,%ax
  100cc5:	66 90                	xchg   %ax,%ax
  100cc7:	66 90                	xchg   %ax,%ax
  100cc9:	66 90                	xchg   %ax,%ax
  100ccb:	66 90                	xchg   %ax,%ax
  100ccd:	66 90                	xchg   %ax,%ax
  100ccf:	90                   	nop

00100cd0 <set_alloc_bit>:
{
  100cd0:	55                   	push   %ebp
  100cd1:	89 e5                	mov    %esp,%ebp
  100cd3:	53                   	push   %ebx
  100cd4:	57                   	push   %edi
  100cd5:	56                   	push   %esi
  100cd6:	83 ec 24             	sub    $0x24,%esp
  100cd9:	8b 45 10             	mov    0x10(%ebp),%eax
  100cdc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100cdf:	8b 55 08             	mov    0x8(%ebp),%edx
	int bit = get_bit_ptr(p, level, bn, &word);
  100ce2:	8b 75 08             	mov    0x8(%ebp),%esi
  100ce5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  100ce8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  100ceb:	89 34 24             	mov    %esi,(%esp)
  100cee:	89 7c 24 04          	mov    %edi,0x4(%esp)
  100cf2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  100cf6:	8d 75 f0             	lea    -0x10(%ebp),%esi
  100cf9:	89 74 24 0c          	mov    %esi,0xc(%esp)
  100cfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100d00:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100d03:	89 55 e0             	mov    %edx,-0x20(%ebp)
  100d06:	e8 b5 00 00 00       	call   100dc0 <get_bit_ptr>
  100d0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	*word |= (1<<bit);
  100d0e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100d11:	b8 01 00 00 00       	mov    $0x1,%eax
  100d16:	d3 e0                	shl    %cl,%eax
  100d18:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100d1b:	0b 02                	or     (%edx),%eax
  100d1d:	89 02                	mov    %eax,(%edx)
}
  100d1f:	83 c4 24             	add    $0x24,%esp
  100d22:	5e                   	pop    %esi
  100d23:	5f                   	pop    %edi
  100d24:	5b                   	pop    %ebx
  100d25:	5d                   	pop    %ebp
  100d26:	c3                   	ret    
  100d27:	66 90                	xchg   %ax,%ax
  100d29:	66 90                	xchg   %ax,%ax
  100d2b:	66 90                	xchg   %ax,%ax
  100d2d:	66 90                	xchg   %ax,%ax
  100d2f:	90                   	nop

00100d30 <sys_dlist_is_empty>:
{
  100d30:	55                   	push   %ebp
  100d31:	89 e5                	mov    %esp,%ebp
  100d33:	50                   	push   %eax
  100d34:	8b 45 08             	mov    0x8(%ebp),%eax
	return list->head == list;
  100d37:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100d3a:	8b 09                	mov    (%ecx),%ecx
  100d3c:	3b 4d 08             	cmp    0x8(%ebp),%ecx
  100d3f:	0f 94 c2             	sete   %dl
  100d42:	80 e2 01             	and    $0x1,%dl
  100d45:	0f b6 ca             	movzbl %dl,%ecx
  100d48:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100d4b:	89 c8                	mov    %ecx,%eax
  100d4d:	83 c4 04             	add    $0x4,%esp
  100d50:	5d                   	pop    %ebp
  100d51:	c3                   	ret    
  100d52:	66 90                	xchg   %ax,%ax
  100d54:	66 90                	xchg   %ax,%ax
  100d56:	66 90                	xchg   %ax,%ax
  100d58:	66 90                	xchg   %ax,%ax
  100d5a:	66 90                	xchg   %ax,%ax
  100d5c:	66 90                	xchg   %ax,%ax
  100d5e:	66 90                	xchg   %ax,%ax

00100d60 <sys_dlist_remove>:
{
  100d60:	55                   	push   %ebp
  100d61:	89 e5                	mov    %esp,%ebp
  100d63:	83 ec 08             	sub    $0x8,%esp
  100d66:	8b 45 08             	mov    0x8(%ebp),%eax
	node->prev->next = node->next;
  100d69:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100d6c:	8b 09                	mov    (%ecx),%ecx
  100d6e:	8b 55 08             	mov    0x8(%ebp),%edx
  100d71:	8b 52 04             	mov    0x4(%edx),%edx
  100d74:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  100d76:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100d79:	8b 49 04             	mov    0x4(%ecx),%ecx
  100d7c:	8b 55 08             	mov    0x8(%ebp),%edx
  100d7f:	8b 12                	mov    (%edx),%edx
  100d81:	89 4a 04             	mov    %ecx,0x4(%edx)
	sys_dnode_init(node);
  100d84:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100d87:	89 0c 24             	mov    %ecx,(%esp)
  100d8a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100d8d:	e8 0e 00 00 00       	call   100da0 <sys_dnode_init>
}
  100d92:	83 c4 08             	add    $0x8,%esp
  100d95:	5d                   	pop    %ebp
  100d96:	c3                   	ret    
  100d97:	66 90                	xchg   %ax,%ax
  100d99:	66 90                	xchg   %ax,%ax
  100d9b:	66 90                	xchg   %ax,%ax
  100d9d:	66 90                	xchg   %ax,%ax
  100d9f:	90                   	nop

00100da0 <sys_dnode_init>:
{
  100da0:	55                   	push   %ebp
  100da1:	89 e5                	mov    %esp,%ebp
  100da3:	8b 45 08             	mov    0x8(%ebp),%eax
	node->next = NULL;
  100da6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100da9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	node->prev = NULL;
  100daf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100db2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
}
  100db9:	5d                   	pop    %ebp
  100dba:	c3                   	ret    
  100dbb:	66 90                	xchg   %ax,%ax
  100dbd:	66 90                	xchg   %ax,%ax
  100dbf:	90                   	nop

00100dc0 <get_bit_ptr>:
{
  100dc0:	55                   	push   %ebp
  100dc1:	89 e5                	mov    %esp,%ebp
  100dc3:	53                   	push   %ebx
  100dc4:	57                   	push   %edi
  100dc5:	56                   	push   %esi
  100dc6:	83 ec 0c             	sub    $0xc,%esp
  100dc9:	8b 45 14             	mov    0x14(%ebp),%eax
  100dcc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100dcf:	8b 55 0c             	mov    0xc(%ebp),%edx
  100dd2:	8b 75 08             	mov    0x8(%ebp),%esi
	u32_t *bitarray = level <= p->max_inline_level ?
  100dd5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  100dd8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  100ddb:	0f be 5b 0b          	movsbl 0xb(%ebx),%ebx
  100ddf:	39 df                	cmp    %ebx,%edi
  100de1:	0f 8f 14 00 00 00    	jg     100dfb <get_bit_ptr+0x3b>
		p->levels[level].bits : p->levels[level].bits_p;
  100de7:	8b 45 08             	mov    0x8(%ebp),%eax
  100dea:	8b 40 0c             	mov    0xc(%eax),%eax
  100ded:	6b 4d 0c 0c          	imul   $0xc,0xc(%ebp),%ecx
  100df1:	01 c8                	add    %ecx,%eax
  100df3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u32_t *bitarray = level <= p->max_inline_level ?
  100df6:	e9 11 00 00 00       	jmp    100e0c <get_bit_ptr+0x4c>
		p->levels[level].bits : p->levels[level].bits_p;
  100dfb:	8b 45 08             	mov    0x8(%ebp),%eax
  100dfe:	8b 40 0c             	mov    0xc(%eax),%eax
  100e01:	6b 4d 0c 0c          	imul   $0xc,0xc(%ebp),%ecx
  100e05:	01 c8                	add    %ecx,%eax
  100e07:	8b 00                	mov    (%eax),%eax
  100e09:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100e0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
	u32_t *bitarray = level <= p->max_inline_level ?
  100e0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*word = &bitarray[bn / 32];
  100e12:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100e15:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100e18:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100e1b:	89 c8                	mov    %ecx,%eax
  100e1d:	99                   	cltd   
  100e1e:	b9 20 00 00 00       	mov    $0x20,%ecx
  100e23:	f7 f9                	idiv   %ecx
  100e25:	c1 e0 02             	shl    $0x2,%eax
  100e28:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  100e2b:	01 c1                	add    %eax,%ecx
  100e2d:	8b 45 14             	mov    0x14(%ebp),%eax
  100e30:	89 08                	mov    %ecx,(%eax)
	return bn & 0x1f;
  100e32:	8b 45 10             	mov    0x10(%ebp),%eax
  100e35:	83 e0 1f             	and    $0x1f,%eax
  100e38:	83 c4 0c             	add    $0xc,%esp
  100e3b:	5e                   	pop    %esi
  100e3c:	5f                   	pop    %edi
  100e3d:	5b                   	pop    %ebx
  100e3e:	5d                   	pop    %ebp
  100e3f:	c3                   	ret    

00100e40 <bfree_recombine>:
{
  100e40:	55                   	push   %ebp
  100e41:	89 e5                	mov    %esp,%ebp
  100e43:	57                   	push   %edi
  100e44:	56                   	push   %esi
  100e45:	83 ec 20             	sub    $0x20,%esp
  100e48:	8b 45 18             	mov    0x18(%ebp),%eax
  100e4b:	8b 4d 14             	mov    0x14(%ebp),%ecx
  100e4e:	8b 55 10             	mov    0x10(%ebp),%edx
  100e51:	8b 75 0c             	mov    0xc(%ebp),%esi
  100e54:	8b 7d 08             	mov    0x8(%ebp),%edi
	while (level >= 0) {
  100e57:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  100e5b:	0f 8c 1e 01 00 00    	jl     100f7f <bfree_recombine+0x13f>
		int i, lsz = lsizes[level];
  100e61:	8b 45 10             	mov    0x10(%ebp),%eax
  100e64:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100e67:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  100e6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void *block = block_ptr(p, lsz, bn);
  100e6d:	8b 45 08             	mov    0x8(%ebp),%eax
  100e70:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100e73:	8b 55 14             	mov    0x14(%ebp),%edx
  100e76:	89 04 24             	mov    %eax,(%esp)
  100e79:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100e7d:	89 54 24 08          	mov    %edx,0x8(%esp)
  100e81:	e8 da f7 ff ff       	call   100660 <block_ptr>
  100e86:	89 45 e8             	mov    %eax,-0x18(%ebp)
		clear_alloc_bit(p, level, bn);
  100e89:	8b 45 08             	mov    0x8(%ebp),%eax
  100e8c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100e8f:	8b 55 14             	mov    0x14(%ebp),%edx
  100e92:	89 04 24             	mov    %eax,(%esp)
  100e95:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100e99:	89 54 24 08          	mov    %edx,0x8(%esp)
  100e9d:	e8 ee 00 00 00       	call   100f90 <clear_alloc_bit>
		sys_dlist_append(&p->levels[level].free_list, block);
  100ea2:	8b 45 08             	mov    0x8(%ebp),%eax
  100ea5:	8b 40 0c             	mov    0xc(%eax),%eax
  100ea8:	6b 4d 0c 0c          	imul   $0xc,0xc(%ebp),%ecx
  100eac:	01 c8                	add    %ecx,%eax
  100eae:	83 c0 04             	add    $0x4,%eax
  100eb1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  100eb4:	89 04 24             	mov    %eax,(%esp)
  100eb7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100ebb:	e8 d0 f7 ff ff       	call   100690 <sys_dlist_append>
		pool_irq_unlock(p, key);
  100ec0:	8b 45 08             	mov    0x8(%ebp),%eax
  100ec3:	8b 4d 18             	mov    0x18(%ebp),%ecx
  100ec6:	89 04 24             	mov    %eax,(%esp)
  100ec9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100ecd:	e8 0e fc ff ff       	call   100ae0 <pool_irq_unlock>
		key = pool_irq_lock(p);
  100ed2:	8b 45 08             	mov    0x8(%ebp),%eax
  100ed5:	89 04 24             	mov    %eax,(%esp)
  100ed8:	e8 53 fa ff ff       	call   100930 <pool_irq_lock>
  100edd:	89 45 18             	mov    %eax,0x18(%ebp)
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
  100ee0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  100ee4:	0f 84 22 00 00 00    	je     100f0c <bfree_recombine+0xcc>
  100eea:	8b 45 08             	mov    0x8(%ebp),%eax
  100eed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100ef0:	8b 55 14             	mov    0x14(%ebp),%edx
  100ef3:	89 04 24             	mov    %eax,(%esp)
  100ef6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100efa:	89 54 24 08          	mov    %edx,0x8(%esp)
  100efe:	e8 ed 00 00 00       	call   100ff0 <partner_alloc_bits>
  100f03:	83 f8 00             	cmp    $0x0,%eax
  100f06:	0f 84 0b 00 00 00    	je     100f17 <bfree_recombine+0xd7>
			return key;
  100f0c:	8b 45 18             	mov    0x18(%ebp),%eax
  100f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100f12:	e9 6f 00 00 00       	jmp    100f86 <bfree_recombine+0x146>
		for (i = 0; i < 4; i++) {
  100f17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100f1e:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
  100f22:	0f 8d 3b 00 00 00    	jge    100f63 <bfree_recombine+0x123>
			int b = (bn & ~3) + i;
  100f28:	8b 45 14             	mov    0x14(%ebp),%eax
  100f2b:	83 e0 fc             	and    $0xfffffffc,%eax
  100f2e:	03 45 f0             	add    -0x10(%ebp),%eax
  100f31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			sys_dlist_remove(block_ptr(p, lsz, b));
  100f34:	8b 45 08             	mov    0x8(%ebp),%eax
  100f37:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100f3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100f3d:	89 04 24             	mov    %eax,(%esp)
  100f40:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f44:	89 54 24 08          	mov    %edx,0x8(%esp)
  100f48:	e8 13 f7 ff ff       	call   100660 <block_ptr>
  100f4d:	89 04 24             	mov    %eax,(%esp)
  100f50:	e8 0b fe ff ff       	call   100d60 <sys_dlist_remove>
		for (i = 0; i < 4; i++) {
  100f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100f58:	83 c0 01             	add    $0x1,%eax
  100f5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100f5e:	e9 bb ff ff ff       	jmp    100f1e <bfree_recombine+0xde>
		level = level - 1;
  100f63:	8b 45 0c             	mov    0xc(%ebp),%eax
  100f66:	83 e8 01             	sub    $0x1,%eax
  100f69:	89 45 0c             	mov    %eax,0xc(%ebp)
		bn = bn / 4;
  100f6c:	8b 45 14             	mov    0x14(%ebp),%eax
  100f6f:	99                   	cltd   
  100f70:	b9 04 00 00 00       	mov    $0x4,%ecx
  100f75:	f7 f9                	idiv   %ecx
  100f77:	89 45 14             	mov    %eax,0x14(%ebp)
	while (level >= 0) {
  100f7a:	e9 d8 fe ff ff       	jmp    100e57 <bfree_recombine+0x17>
	return -1;
  100f7f:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
}
  100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f89:	83 c4 20             	add    $0x20,%esp
  100f8c:	5e                   	pop    %esi
  100f8d:	5f                   	pop    %edi
  100f8e:	5d                   	pop    %ebp
  100f8f:	c3                   	ret    

00100f90 <clear_alloc_bit>:
{
  100f90:	55                   	push   %ebp
  100f91:	89 e5                	mov    %esp,%ebp
  100f93:	53                   	push   %ebx
  100f94:	57                   	push   %edi
  100f95:	56                   	push   %esi
  100f96:	83 ec 24             	sub    $0x24,%esp
  100f99:	8b 45 10             	mov    0x10(%ebp),%eax
  100f9c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100f9f:	8b 55 08             	mov    0x8(%ebp),%edx
	int bit = get_bit_ptr(p, level, bn, &word);
  100fa2:	8b 75 08             	mov    0x8(%ebp),%esi
  100fa5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  100fa8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  100fab:	89 34 24             	mov    %esi,(%esp)
  100fae:	89 7c 24 04          	mov    %edi,0x4(%esp)
  100fb2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  100fb6:	8d 75 f0             	lea    -0x10(%ebp),%esi
  100fb9:	89 74 24 0c          	mov    %esi,0xc(%esp)
  100fbd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100fc0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100fc3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  100fc6:	e8 f5 fd ff ff       	call   100dc0 <get_bit_ptr>
  100fcb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	*word &= ~(1<<bit);
  100fce:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100fd1:	b8 01 00 00 00       	mov    $0x1,%eax
  100fd6:	d3 e0                	shl    %cl,%eax
  100fd8:	83 f0 ff             	xor    $0xffffffff,%eax
  100fdb:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100fde:	23 02                	and    (%edx),%eax
  100fe0:	89 02                	mov    %eax,(%edx)
}
  100fe2:	83 c4 24             	add    $0x24,%esp
  100fe5:	5e                   	pop    %esi
  100fe6:	5f                   	pop    %edi
  100fe7:	5b                   	pop    %ebx
  100fe8:	5d                   	pop    %ebp
  100fe9:	c3                   	ret    
  100fea:	66 90                	xchg   %ax,%ax
  100fec:	66 90                	xchg   %ax,%ax
  100fee:	66 90                	xchg   %ax,%ax

00100ff0 <partner_alloc_bits>:
{
  100ff0:	55                   	push   %ebp
  100ff1:	89 e5                	mov    %esp,%ebp
  100ff3:	53                   	push   %ebx
  100ff4:	57                   	push   %edi
  100ff5:	56                   	push   %esi
  100ff6:	83 ec 28             	sub    $0x28,%esp
  100ff9:	8b 45 10             	mov    0x10(%ebp),%eax
  100ffc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  100fff:	8b 55 08             	mov    0x8(%ebp),%edx
	int bit = get_bit_ptr(p, level, bn, &word);
  101002:	8b 75 08             	mov    0x8(%ebp),%esi
  101005:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101008:	8b 5d 10             	mov    0x10(%ebp),%ebx
  10100b:	89 34 24             	mov    %esi,(%esp)
  10100e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  101012:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  101016:	8d 75 f0             	lea    -0x10(%ebp),%esi
  101019:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10101d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101020:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  101023:	89 55 e0             	mov    %edx,-0x20(%ebp)
  101026:	e8 95 fd ff ff       	call   100dc0 <get_bit_ptr>
  10102b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return (*word >> (4*(bit / 4))) & 0xf;
  10102e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101031:	8b 00                	mov    (%eax),%eax
  101033:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  101036:	89 45 dc             	mov    %eax,-0x24(%ebp)
  101039:	89 c8                	mov    %ecx,%eax
  10103b:	99                   	cltd   
  10103c:	b9 04 00 00 00       	mov    $0x4,%ecx
  101041:	f7 f9                	idiv   %ecx
  101043:	c1 e0 02             	shl    $0x2,%eax
  101046:	89 c1                	mov    %eax,%ecx
  101048:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10104b:	d3 e8                	shr    %cl,%eax
  10104d:	83 e0 0f             	and    $0xf,%eax
  101050:	83 c4 28             	add    $0x28,%esp
  101053:	5e                   	pop    %esi
  101054:	5f                   	pop    %edi
  101055:	5b                   	pop    %ebx
  101056:	5d                   	pop    %ebp
  101057:	c3                   	ret    
  101058:	66 90                	xchg   %ax,%ax
  10105a:	66 90                	xchg   %ax,%ax
  10105c:	66 90                	xchg   %ax,%ax
  10105e:	66 90                	xchg   %ax,%ax

00101060 <z_rb_get_minmax>:

	return sz;
}

struct rbnode *z_rb_get_minmax(struct rbtree *tree, int side)
{
  101060:	55                   	push   %ebp
  101061:	89 e5                	mov    %esp,%ebp
  101063:	83 ec 10             	sub    $0x10,%esp
  101066:	8b 45 0c             	mov    0xc(%ebp),%eax
  101069:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct rbnode *n;

	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
  10106c:	8b 55 08             	mov    0x8(%ebp),%edx
  10106f:	8b 12                	mov    (%edx),%edx
  101071:	89 55 fc             	mov    %edx,-0x4(%ebp)
  101074:	31 c0                	xor    %eax,%eax
  101076:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10107a:	88 45 fb             	mov    %al,-0x5(%ebp)
  10107d:	0f 84 1b 00 00 00    	je     10109e <z_rb_get_minmax+0x3e>
  101083:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101086:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101089:	89 04 24             	mov    %eax,(%esp)
  10108c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101090:	e8 4b 00 00 00       	call   1010e0 <get_child>
  101095:	83 f8 00             	cmp    $0x0,%eax
  101098:	0f 95 c2             	setne  %dl
  10109b:	88 55 fb             	mov    %dl,-0x5(%ebp)
  10109e:	8a 45 fb             	mov    -0x5(%ebp),%al
  1010a1:	a8 01                	test   $0x1,%al
  1010a3:	0f 85 05 00 00 00    	jne    1010ae <z_rb_get_minmax+0x4e>
  1010a9:	e9 1f 00 00 00       	jmp    1010cd <z_rb_get_minmax+0x6d>
			n = get_child(n, side)) {
		;
	}
  1010ae:	e9 00 00 00 00       	jmp    1010b3 <z_rb_get_minmax+0x53>
			n = get_child(n, side)) {
  1010b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1010b6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1010b9:	89 04 24             	mov    %eax,(%esp)
  1010bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010c0:	e8 1b 00 00 00       	call   1010e0 <get_child>
  1010c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
  1010c8:	e9 a7 ff ff ff       	jmp    101074 <z_rb_get_minmax+0x14>
	return n;
  1010cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1010d0:	83 c4 10             	add    $0x10,%esp
  1010d3:	5d                   	pop    %ebp
  1010d4:	c3                   	ret    
  1010d5:	66 90                	xchg   %ax,%ax
  1010d7:	66 90                	xchg   %ax,%ax
  1010d9:	66 90                	xchg   %ax,%ax
  1010db:	66 90                	xchg   %ax,%ax
  1010dd:	66 90                	xchg   %ax,%ax
  1010df:	90                   	nop

001010e0 <get_child>:
{
  1010e0:	55                   	push   %ebp
  1010e1:	89 e5                	mov    %esp,%ebp
  1010e3:	83 ec 08             	sub    $0x8,%esp
  1010e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1010e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (side != 0) {
  1010ec:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1010f0:	0f 84 0e 00 00 00    	je     101104 <get_child+0x24>
		return n->children[1];
  1010f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1010f9:	8b 40 04             	mov    0x4(%eax),%eax
  1010fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1010ff:	e9 17 00 00 00       	jmp    10111b <get_child+0x3b>
	uintptr_t l = (uintptr_t) n->children[0];
  101104:	8b 45 08             	mov    0x8(%ebp),%eax
  101107:	8b 00                	mov    (%eax),%eax
  101109:	89 45 f8             	mov    %eax,-0x8(%ebp)
	l &= ~1UL;
  10110c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10110f:	83 e0 fe             	and    $0xfffffffe,%eax
  101112:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return (struct rbnode *) l;
  101115:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101118:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10111b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10111e:	83 c4 08             	add    $0x8,%esp
  101121:	5d                   	pop    %ebp
  101122:	c3                   	ret    
  101123:	66 90                	xchg   %ax,%ax
  101125:	66 90                	xchg   %ax,%ax
  101127:	66 90                	xchg   %ax,%ax
  101129:	66 90                	xchg   %ax,%ax
  10112b:	66 90                	xchg   %ax,%ax
  10112d:	66 90                	xchg   %ax,%ax
  10112f:	90                   	nop

00101130 <rb_insert>:
	 */
	set_color(stack[0], BLACK);
}

void rb_insert(struct rbtree *tree, struct rbnode *node)
{
  101130:	55                   	push   %ebp
  101131:	89 e5                	mov    %esp,%ebp
  101133:	56                   	push   %esi
  101134:	83 ec 34             	sub    $0x34,%esp
  101137:	8b 45 0c             	mov    0xc(%ebp),%eax
  10113a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10113d:	31 d2                	xor    %edx,%edx
	set_child(node, 0, NULL);
  10113f:	8b 75 0c             	mov    0xc(%ebp),%esi
  101142:	83 ec 0c             	sub    $0xc,%esp
  101145:	89 34 24             	mov    %esi,(%esp)
  101148:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10114f:	00 
  101150:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101157:	00 
  101158:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10115b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10115e:	89 55 dc             	mov    %edx,-0x24(%ebp)
  101161:	e8 8a 01 00 00       	call   1012f0 <set_child>
  101166:	83 c4 0c             	add    $0xc,%esp
  101169:	31 c0                	xor    %eax,%eax
	set_child(node, 1, NULL);
  10116b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10116e:	83 ec 0c             	sub    $0xc,%esp
  101171:	89 0c 24             	mov    %ecx,(%esp)
  101174:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10117b:	00 
  10117c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101183:	00 
  101184:	89 45 d8             	mov    %eax,-0x28(%ebp)
  101187:	e8 64 01 00 00       	call   1012f0 <set_child>
  10118c:	83 c4 0c             	add    $0xc,%esp

	if (tree->root == NULL) {
  10118f:	8b 45 08             	mov    0x8(%ebp),%eax
  101192:	83 38 00             	cmpl   $0x0,(%eax)
  101195:	0f 85 30 00 00 00    	jne    1011cb <rb_insert+0x9b>
		tree->root = node;
  10119b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10119e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1011a1:	89 01                	mov    %eax,(%ecx)
		tree->max_depth = 1;
  1011a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1011a6:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
		set_color(node, BLACK);
  1011ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  1011b0:	83 ec 08             	sub    $0x8,%esp
  1011b3:	89 04 24             	mov    %eax,(%esp)
  1011b6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1011bd:	00 
  1011be:	e8 7d 01 00 00       	call   101340 <set_color>
  1011c3:	83 c4 08             	add    $0x8,%esp
		return;
  1011c6:	e9 18 01 00 00       	jmp    1012e3 <rb_insert+0x1b3>
	}

#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
  1011cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1011ce:	8b 40 08             	mov    0x8(%eax),%eax
  1011d1:	89 c1                	mov    %eax,%ecx
  1011d3:	41                   	inc    %ecx
  1011d4:	89 e2                	mov    %esp,%edx
  1011d6:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1011d9:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
  1011e0:	89 e2                	mov    %esp,%edx
  1011e2:	29 c2                	sub    %eax,%edx
  1011e4:	89 d4                	mov    %edx,%esp
  1011e6:	89 4d f4             	mov    %ecx,-0xc(%ebp)
#endif

	int stacksz = find_and_stack(tree, node, stack);
  1011e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1011ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1011ef:	83 ec 0c             	sub    $0xc,%esp
  1011f2:	89 04 24             	mov    %eax,(%esp)
  1011f5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011f9:	89 54 24 08          	mov    %edx,0x8(%esp)
  1011fd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  101200:	e8 6b 01 00 00       	call   101370 <find_and_stack>
  101205:	83 c4 0c             	add    $0xc,%esp
  101208:	89 45 f0             	mov    %eax,-0x10(%ebp)

	struct rbnode *parent = stack[stacksz - 1];
  10120b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10120e:	83 e8 01             	sub    $0x1,%eax
  101211:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  101214:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  101217:	89 45 ec             	mov    %eax,-0x14(%ebp)

	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
  10121a:	8b 45 08             	mov    0x8(%ebp),%eax
  10121d:	8b 40 04             	mov    0x4(%eax),%eax
  101220:	8b 55 0c             	mov    0xc(%ebp),%edx
  101223:	8b 75 ec             	mov    -0x14(%ebp),%esi
  101226:	83 ec 08             	sub    $0x8,%esp
  101229:	89 14 24             	mov    %edx,(%esp)
  10122c:	89 74 24 04          	mov    %esi,0x4(%esp)
  101230:	ff d0                	call   *%eax
  101232:	83 c4 08             	add    $0x8,%esp
  101235:	31 c9                	xor    %ecx,%ecx
  101237:	a8 01                	test   $0x1,%al
  101239:	ba 01 00 00 00       	mov    $0x1,%edx
  10123e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  101241:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  101244:	0f 85 06 00 00 00    	jne    101250 <rb_insert+0x120>
  10124a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10124d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  101250:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101253:	89 45 e8             	mov    %eax,-0x18(%ebp)

	set_child(parent, side, node);
  101256:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101259:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10125c:	8b 55 0c             	mov    0xc(%ebp),%edx
  10125f:	83 ec 0c             	sub    $0xc,%esp
  101262:	89 04 24             	mov    %eax,(%esp)
  101265:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101269:	89 54 24 08          	mov    %edx,0x8(%esp)
  10126d:	e8 7e 00 00 00       	call   1012f0 <set_child>
  101272:	83 c4 0c             	add    $0xc,%esp
  101275:	31 c0                	xor    %eax,%eax
	set_color(node, RED);
  101277:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10127a:	83 ec 08             	sub    $0x8,%esp
  10127d:	89 0c 24             	mov    %ecx,(%esp)
  101280:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101287:	00 
  101288:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10128b:	e8 b0 00 00 00       	call   101340 <set_color>
  101290:	83 c4 08             	add    $0x8,%esp

	stack[stacksz++] = node;
  101293:	8b 45 0c             	mov    0xc(%ebp),%eax
  101296:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101299:	89 ca                	mov    %ecx,%edx
  10129b:	83 c2 01             	add    $0x1,%edx
  10129e:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1012a1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  1012a4:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
	fix_extra_red(stack, stacksz);
  1012a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1012aa:	83 ec 08             	sub    $0x8,%esp
  1012ad:	89 14 24             	mov    %edx,(%esp)
  1012b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1012b4:	e8 97 01 00 00       	call   101450 <fix_extra_red>
  1012b9:	83 c4 08             	add    $0x8,%esp

	if (stacksz > tree->max_depth) {
  1012bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1012bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1012c2:	3b 41 08             	cmp    0x8(%ecx),%eax
  1012c5:	0f 8e 09 00 00 00    	jle    1012d4 <rb_insert+0x1a4>
		tree->max_depth = stacksz;
  1012cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1012ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1012d1:	89 41 08             	mov    %eax,0x8(%ecx)
  1012d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
  1012d7:	8b 08                	mov    (%eax),%ecx
  1012d9:	8b 55 08             	mov    0x8(%ebp),%edx
  1012dc:	89 0a                	mov    %ecx,(%edx)
	CHECK(is_black(tree->root));
}
  1012de:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1012e1:	89 cc                	mov    %ecx,%esp
  1012e3:	8d 65 fc             	lea    -0x4(%ebp),%esp
  1012e6:	5e                   	pop    %esi
  1012e7:	5d                   	pop    %ebp
  1012e8:	c3                   	ret    
  1012e9:	66 90                	xchg   %ax,%ax
  1012eb:	66 90                	xchg   %ax,%ax
  1012ed:	66 90                	xchg   %ax,%ax
  1012ef:	90                   	nop

001012f0 <set_child>:
{
  1012f0:	55                   	push   %ebp
  1012f1:	89 e5                	mov    %esp,%ebp
  1012f3:	83 ec 08             	sub    $0x8,%esp
  1012f6:	8b 45 10             	mov    0x10(%ebp),%eax
  1012f9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1012fc:	8b 55 08             	mov    0x8(%ebp),%edx
	if (side != 0) {
  1012ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101303:	0f 84 0e 00 00 00    	je     101317 <set_child+0x27>
		n->children[1] = val;
  101309:	8b 45 10             	mov    0x10(%ebp),%eax
  10130c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10130f:	89 41 04             	mov    %eax,0x4(%ecx)
	} else {
  101312:	e9 1e 00 00 00       	jmp    101335 <set_child+0x45>
		uintptr_t old = (uintptr_t) n->children[0];
  101317:	8b 45 08             	mov    0x8(%ebp),%eax
  10131a:	8b 00                	mov    (%eax),%eax
  10131c:	89 45 fc             	mov    %eax,-0x4(%ebp)
		uintptr_t new = (uintptr_t) val;
  10131f:	8b 45 10             	mov    0x10(%ebp),%eax
  101322:	89 45 f8             	mov    %eax,-0x8(%ebp)
		n->children[0] = (void *) (new | (old & 1UL));
  101325:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101328:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10132b:	83 e1 01             	and    $0x1,%ecx
  10132e:	09 c8                	or     %ecx,%eax
  101330:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101333:	89 01                	mov    %eax,(%ecx)
}
  101335:	83 c4 08             	add    $0x8,%esp
  101338:	5d                   	pop    %ebp
  101339:	c3                   	ret    
  10133a:	66 90                	xchg   %ax,%ax
  10133c:	66 90                	xchg   %ax,%ax
  10133e:	66 90                	xchg   %ax,%ax

00101340 <set_color>:
{
  101340:	55                   	push   %ebp
  101341:	89 e5                	mov    %esp,%ebp
  101343:	53                   	push   %ebx
  101344:	56                   	push   %esi
  101345:	50                   	push   %eax
  101346:	8b 45 0c             	mov    0xc(%ebp),%eax
  101349:	8b 4d 08             	mov    0x8(%ebp),%ecx
	uintptr_t *p = (void *) &n->children[0];
  10134c:	8b 55 08             	mov    0x8(%ebp),%edx
  10134f:	89 55 f4             	mov    %edx,-0xc(%ebp)
	*p = (*p & ~1UL) | (uint8_t)color;
  101352:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101355:	8b 12                	mov    (%edx),%edx
  101357:	83 e2 fe             	and    $0xfffffffe,%edx
  10135a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10135d:	0f b6 f3             	movzbl %bl,%esi
  101360:	09 f2                	or     %esi,%edx
  101362:	8b 75 f4             	mov    -0xc(%ebp),%esi
  101365:	89 16                	mov    %edx,(%esi)
}
  101367:	83 c4 04             	add    $0x4,%esp
  10136a:	5e                   	pop    %esi
  10136b:	5b                   	pop    %ebx
  10136c:	5d                   	pop    %ebp
  10136d:	c3                   	ret    
  10136e:	66 90                	xchg   %ax,%ax

00101370 <find_and_stack>:
{
  101370:	55                   	push   %ebp
  101371:	89 e5                	mov    %esp,%ebp
  101373:	53                   	push   %ebx
  101374:	57                   	push   %edi
  101375:	56                   	push   %esi
  101376:	83 ec 20             	sub    $0x20,%esp
  101379:	8b 45 10             	mov    0x10(%ebp),%eax
  10137c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10137f:	8b 55 08             	mov    0x8(%ebp),%edx
	int sz = 0;
  101382:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	stack[sz++] = tree->root;
  101389:	8b 75 08             	mov    0x8(%ebp),%esi
  10138c:	8b 36                	mov    (%esi),%esi
  10138e:	8b 7d 10             	mov    0x10(%ebp),%edi
  101391:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  101394:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  101397:	83 c3 01             	add    $0x1,%ebx
  10139a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  10139d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  1013a0:	89 34 9f             	mov    %esi,(%edi,%ebx,4)
	while (stack[sz - 1] != node) {
  1013a3:	8b 45 10             	mov    0x10(%ebp),%eax
  1013a6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1013a9:	83 e9 01             	sub    $0x1,%ecx
  1013ac:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1013af:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1013b2:	0f 84 8a 00 00 00    	je     101442 <find_and_stack+0xd2>
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
  1013b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013bb:	8b 40 04             	mov    0x4(%eax),%eax
  1013be:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1013c1:	8b 55 10             	mov    0x10(%ebp),%edx
  1013c4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1013c7:	83 ee 01             	sub    $0x1,%esi
  1013ca:	8b 14 b2             	mov    (%edx,%esi,4),%edx
  1013cd:	89 0c 24             	mov    %ecx,(%esp)
  1013d0:	89 54 24 04          	mov    %edx,0x4(%esp)
  1013d4:	ff d0                	call   *%eax
  1013d6:	31 c9                	xor    %ecx,%ecx
  1013d8:	a8 01                	test   $0x1,%al
  1013da:	ba 01 00 00 00       	mov    $0x1,%edx
  1013df:	89 55 e0             	mov    %edx,-0x20(%ebp)
  1013e2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1013e5:	0f 85 06 00 00 00    	jne    1013f1 <find_and_stack+0x81>
  1013eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1013ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1013f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1013f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct rbnode *ch = get_child(stack[sz - 1], side);
  1013f7:	8b 45 10             	mov    0x10(%ebp),%eax
  1013fa:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1013fd:	83 e9 01             	sub    $0x1,%ecx
  101400:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  101403:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  101406:	89 04 24             	mov    %eax,(%esp)
  101409:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10140d:	e8 ce fc ff ff       	call   1010e0 <get_child>
  101412:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (ch != NULL) {
  101415:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101419:	0f 84 19 00 00 00    	je     101438 <find_and_stack+0xc8>
			stack[sz++] = ch;
  10141f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101422:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101425:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101428:	89 d6                	mov    %edx,%esi
  10142a:	83 c6 01             	add    $0x1,%esi
  10142d:	89 75 f0             	mov    %esi,-0x10(%ebp)
  101430:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		} else {
  101433:	e9 05 00 00 00       	jmp    10143d <find_and_stack+0xcd>
			break;
  101438:	e9 05 00 00 00       	jmp    101442 <find_and_stack+0xd2>
	while (stack[sz - 1] != node) {
  10143d:	e9 61 ff ff ff       	jmp    1013a3 <find_and_stack+0x33>
	return sz;
  101442:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101445:	83 c4 20             	add    $0x20,%esp
  101448:	5e                   	pop    %esi
  101449:	5f                   	pop    %edi
  10144a:	5b                   	pop    %ebx
  10144b:	5d                   	pop    %ebp
  10144c:	c3                   	ret    
  10144d:	66 90                	xchg   %ax,%ax
  10144f:	90                   	nop

00101450 <fix_extra_red>:
{
  101450:	55                   	push   %ebp
  101451:	89 e5                	mov    %esp,%ebp
  101453:	83 ec 34             	sub    $0x34,%esp
  101456:	8b 45 0c             	mov    0xc(%ebp),%eax
  101459:	8b 4d 08             	mov    0x8(%ebp),%ecx
	while (stacksz > 1) {
  10145c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  101460:	0f 8e a0 01 00 00    	jle    101606 <fix_extra_red+0x1b6>
		struct rbnode *node = stack[stacksz - 1];
  101466:	8b 45 08             	mov    0x8(%ebp),%eax
  101469:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10146c:	83 e9 01             	sub    $0x1,%ecx
  10146f:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  101472:	89 45 fc             	mov    %eax,-0x4(%ebp)
		struct rbnode *parent = stack[stacksz - 2];
  101475:	8b 45 08             	mov    0x8(%ebp),%eax
  101478:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10147b:	83 e9 02             	sub    $0x2,%ecx
  10147e:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  101481:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if (is_black(parent)) {
  101484:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101487:	89 04 24             	mov    %eax,(%esp)
  10148a:	e8 41 08 00 00       	call   101cd0 <is_black>
  10148f:	a8 01                	test   $0x1,%al
  101491:	0f 85 05 00 00 00    	jne    10149c <fix_extra_red+0x4c>
  101497:	e9 05 00 00 00       	jmp    1014a1 <fix_extra_red+0x51>
			return;
  10149c:	e9 7a 01 00 00       	jmp    10161b <fix_extra_red+0x1cb>
		struct rbnode *grandparent = stack[stacksz - 3];
  1014a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1014a4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1014a7:	83 e9 03             	sub    $0x3,%ecx
  1014aa:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1014ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
		int side = get_side(grandparent, parent);
  1014b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1014b3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1014b6:	89 04 24             	mov    %eax,(%esp)
  1014b9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014bd:	e8 9e 07 00 00       	call   101c60 <get_side>
  1014c2:	31 c9                	xor    %ecx,%ecx
  1014c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct rbnode *aunt = get_child(grandparent,
  1014c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
				side == 0 ? 1 : 0);
  1014ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1014cd:	83 fa 00             	cmp    $0x0,%edx
  1014d0:	ba 01 00 00 00       	mov    $0x1,%edx
  1014d5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1014d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1014db:	89 55 dc             	mov    %edx,-0x24(%ebp)
  1014de:	0f 84 06 00 00 00    	je     1014ea <fix_extra_red+0x9a>
  1014e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1014e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1014ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1014ed:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		struct rbnode *aunt = get_child(grandparent,
  1014f0:	89 0c 24             	mov    %ecx,(%esp)
  1014f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1014f7:	e8 e4 fb ff ff       	call   1010e0 <get_child>
  1014fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if ((aunt != NULL) && is_red(aunt)) {
  1014ff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  101503:	0f 84 64 00 00 00    	je     10156d <fix_extra_red+0x11d>
  101509:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10150c:	89 04 24             	mov    %eax,(%esp)
  10150f:	e8 fc 0b 00 00       	call   102110 <is_red>
  101514:	a8 01                	test   $0x1,%al
  101516:	0f 85 05 00 00 00    	jne    101521 <fix_extra_red+0xd1>
  10151c:	e9 4c 00 00 00       	jmp    10156d <fix_extra_red+0x11d>
  101521:	31 c0                	xor    %eax,%eax
			set_color(grandparent, RED);
  101523:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  101526:	89 0c 24             	mov    %ecx,(%esp)
  101529:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101530:	00 
  101531:	89 45 d8             	mov    %eax,-0x28(%ebp)
  101534:	e8 07 fe ff ff       	call   101340 <set_color>
			set_color(parent, BLACK);
  101539:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10153c:	89 04 24             	mov    %eax,(%esp)
  10153f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101546:	00 
  101547:	e8 f4 fd ff ff       	call   101340 <set_color>
			set_color(aunt, BLACK);
  10154c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10154f:	89 04 24             	mov    %eax,(%esp)
  101552:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101559:	00 
  10155a:	e8 e1 fd ff ff       	call   101340 <set_color>
			stacksz -= 2;
  10155f:	8b 45 0c             	mov    0xc(%ebp),%eax
  101562:	83 e8 02             	sub    $0x2,%eax
  101565:	89 45 0c             	mov    %eax,0xc(%ebp)
			continue;
  101568:	e9 ef fe ff ff       	jmp    10145c <fix_extra_red+0xc>
		int parent_side = get_side(parent, node);
  10156d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101570:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101573:	89 04 24             	mov    %eax,(%esp)
  101576:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10157a:	e8 e1 06 00 00       	call   101c60 <get_side>
  10157f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (parent_side != side) {
  101582:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101585:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  101588:	0f 84 21 00 00 00    	je     1015af <fix_extra_red+0x15f>
			rotate(stack, stacksz);
  10158e:	8b 45 08             	mov    0x8(%ebp),%eax
  101591:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101594:	89 04 24             	mov    %eax,(%esp)
  101597:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10159b:	e8 c0 0d 00 00       	call   102360 <rotate>
			node = stack[stacksz - 1];
  1015a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1015a3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1015a6:	83 e9 01             	sub    $0x1,%ecx
  1015a9:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1015ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
		rotate(stack, stacksz - 1);
  1015af:	8b 45 08             	mov    0x8(%ebp),%eax
  1015b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1015b5:	83 e9 01             	sub    $0x1,%ecx
  1015b8:	89 04 24             	mov    %eax,(%esp)
  1015bb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015bf:	e8 9c 0d 00 00       	call   102360 <rotate>
		set_color(stack[stacksz - 3], BLACK);
  1015c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1015c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1015ca:	83 e9 03             	sub    $0x3,%ecx
  1015cd:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1015d0:	89 04 24             	mov    %eax,(%esp)
  1015d3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1015da:	00 
  1015db:	e8 60 fd ff ff       	call   101340 <set_color>
  1015e0:	31 c0                	xor    %eax,%eax
		set_color(stack[stacksz - 2], RED);
  1015e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1015e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1015e8:	83 ea 02             	sub    $0x2,%edx
  1015eb:	8b 0c 91             	mov    (%ecx,%edx,4),%ecx
  1015ee:	89 0c 24             	mov    %ecx,(%esp)
  1015f1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1015f8:	00 
  1015f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1015fc:	e8 3f fd ff ff       	call   101340 <set_color>
		return;
  101601:	e9 15 00 00 00       	jmp    10161b <fix_extra_red+0x1cb>
	set_color(stack[0], BLACK);
  101606:	8b 45 08             	mov    0x8(%ebp),%eax
  101609:	8b 00                	mov    (%eax),%eax
  10160b:	89 04 24             	mov    %eax,(%esp)
  10160e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101615:	00 
  101616:	e8 25 fd ff ff       	call   101340 <set_color>
}
  10161b:	83 c4 34             	add    $0x34,%esp
  10161e:	5d                   	pop    %ebp
  10161f:	c3                   	ret    

00101620 <rb_remove>:
		return;
	}
}

void rb_remove(struct rbtree *tree, struct rbnode *node)
{
  101620:	55                   	push   %ebp
  101621:	89 e5                	mov    %esp,%ebp
  101623:	57                   	push   %edi
  101624:	56                   	push   %esi
  101625:	81 ec 94 00 00 00    	sub    $0x94,%esp
  10162b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10162e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct rbnode *tmp;
#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
  101631:	8b 55 08             	mov    0x8(%ebp),%edx
  101634:	8b 52 08             	mov    0x8(%edx),%edx
  101637:	89 d6                	mov    %edx,%esi
  101639:	46                   	inc    %esi
  10163a:	89 e7                	mov    %esp,%edi
  10163c:	89 7d f0             	mov    %edi,-0x10(%ebp)
  10163f:	8d 14 95 04 00 00 00 	lea    0x4(,%edx,4),%edx
  101646:	89 e7                	mov    %esp,%edi
  101648:	29 d7                	sub    %edx,%edi
  10164a:	89 fc                	mov    %edi,%esp
  10164c:	89 75 ec             	mov    %esi,-0x14(%ebp)
#endif

	int stacksz = find_and_stack(tree, node, stack);
  10164f:	8b 55 08             	mov    0x8(%ebp),%edx
  101652:	8b 75 0c             	mov    0xc(%ebp),%esi
  101655:	83 ec 0c             	sub    $0xc,%esp
  101658:	89 14 24             	mov    %edx,(%esp)
  10165b:	89 74 24 04          	mov    %esi,0x4(%esp)
  10165f:	89 7c 24 08          	mov    %edi,0x8(%esp)
  101663:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  101666:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  101669:	89 7d bc             	mov    %edi,-0x44(%ebp)
  10166c:	e8 ff fc ff ff       	call   101370 <find_and_stack>
  101671:	83 c4 0c             	add    $0xc,%esp
  101674:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (node != stack[stacksz - 1]) {
  101677:	8b 45 0c             	mov    0xc(%ebp),%eax
  10167a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10167d:	83 e9 01             	sub    $0x1,%ecx
  101680:	8b 55 bc             	mov    -0x44(%ebp),%edx
  101683:	3b 04 8a             	cmp    (%edx,%ecx,4),%eax
  101686:	0f 84 0c 00 00 00    	je     101698 <rb_remove+0x78>
  10168c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
		return;
  101693:	e9 b7 05 00 00       	jmp    101c4f <rb_remove+0x62f>
  101698:	31 c0                	xor    %eax,%eax
	/* We can only remove a node with zero or one child, if we
	 * have two then pick the "biggest" child of side 0 (smallest
	 * of 1 would work too) and swap our spot in the tree with
	 * that one
	 */
	if (get_child(node, 0) != NULL && get_child(node, 1) != NULL) {
  10169a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10169d:	83 ec 08             	sub    $0x8,%esp
  1016a0:	89 0c 24             	mov    %ecx,(%esp)
  1016a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1016aa:	00 
  1016ab:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1016ae:	e8 2d fa ff ff       	call   1010e0 <get_child>
  1016b3:	83 c4 08             	add    $0x8,%esp
  1016b6:	83 f8 00             	cmp    $0x0,%eax
  1016b9:	0f 84 6e 03 00 00    	je     101a2d <rb_remove+0x40d>
  1016bf:	8b 45 0c             	mov    0xc(%ebp),%eax
  1016c2:	83 ec 08             	sub    $0x8,%esp
  1016c5:	89 04 24             	mov    %eax,(%esp)
  1016c8:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1016cf:	00 
  1016d0:	e8 0b fa ff ff       	call   1010e0 <get_child>
  1016d5:	83 c4 08             	add    $0x8,%esp
  1016d8:	83 f8 00             	cmp    $0x0,%eax
  1016db:	0f 84 4c 03 00 00    	je     101a2d <rb_remove+0x40d>
  1016e1:	31 c0                	xor    %eax,%eax
		int stacksz0 = stacksz;
  1016e3:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1016e6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		struct rbnode *hiparent, *loparent;
		struct rbnode *node2 = get_child(node, 0);
  1016e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1016ec:	83 ec 08             	sub    $0x8,%esp
  1016ef:	89 0c 24             	mov    %ecx,(%esp)
  1016f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1016f9:	00 
  1016fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  1016fd:	e8 de f9 ff ff       	call   1010e0 <get_child>
  101702:	83 c4 08             	add    $0x8,%esp
  101705:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		hiparent = stacksz > 1 ? stack[stacksz - 2] : NULL;
  101708:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
  10170c:	0f 8e 14 00 00 00    	jle    101726 <rb_remove+0x106>
  101712:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101715:	83 e8 02             	sub    $0x2,%eax
  101718:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  10171b:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10171e:	89 45 b0             	mov    %eax,-0x50(%ebp)
  101721:	e9 0a 00 00 00       	jmp    101730 <rb_remove+0x110>
  101726:	31 c0                	xor    %eax,%eax
  101728:	89 45 b0             	mov    %eax,-0x50(%ebp)
  10172b:	e9 00 00 00 00       	jmp    101730 <rb_remove+0x110>
  101730:	8b 45 b0             	mov    -0x50(%ebp),%eax
  101733:	89 45 dc             	mov    %eax,-0x24(%ebp)
		stack[stacksz++] = node2;
  101736:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101739:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10173c:	89 ca                	mov    %ecx,%edx
  10173e:	83 c2 01             	add    $0x1,%edx
  101741:	89 55 e8             	mov    %edx,-0x18(%ebp)
  101744:	8b 55 bc             	mov    -0x44(%ebp),%edx
  101747:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		while (get_child(node2, 1)) {
  10174a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10174d:	83 ec 08             	sub    $0x8,%esp
  101750:	89 04 24             	mov    %eax,(%esp)
  101753:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10175a:	00 
  10175b:	e8 80 f9 ff ff       	call   1010e0 <get_child>
  101760:	83 c4 08             	add    $0x8,%esp
  101763:	83 f8 00             	cmp    $0x0,%eax
  101766:	0f 84 35 00 00 00    	je     1017a1 <rb_remove+0x181>
			node2 = get_child(node2, 1);
  10176c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10176f:	83 ec 08             	sub    $0x8,%esp
  101772:	89 04 24             	mov    %eax,(%esp)
  101775:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10177c:	00 
  10177d:	e8 5e f9 ff ff       	call   1010e0 <get_child>
  101782:	83 c4 08             	add    $0x8,%esp
  101785:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			stack[stacksz++] = node2;
  101788:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10178b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10178e:	89 ca                	mov    %ecx,%edx
  101790:	83 c2 01             	add    $0x1,%edx
  101793:	89 55 e8             	mov    %edx,-0x18(%ebp)
  101796:	8b 55 bc             	mov    -0x44(%ebp),%edx
  101799:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		while (get_child(node2, 1)) {
  10179c:	e9 a9 ff ff ff       	jmp    10174a <rb_remove+0x12a>
		}

		loparent = stack[stacksz - 2];
  1017a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1017a4:	83 e8 02             	sub    $0x2,%eax
  1017a7:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  1017aa:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1017ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
		 * upper node.  Remember to swap the color bits of the
		 * two nodes also.  And of course we don't have parent
		 * pointers, so the stack tracking this structure
		 * needs to be swapped too!
		 */
		if (hiparent != NULL) {
  1017b0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1017b4:	0f 84 3f 00 00 00    	je     1017f9 <rb_remove+0x1d9>
			set_child(hiparent, get_side(hiparent, node), node2);
  1017ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1017bd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1017c0:	8b 55 0c             	mov    0xc(%ebp),%edx
  1017c3:	83 ec 08             	sub    $0x8,%esp
  1017c6:	89 0c 24             	mov    %ecx,(%esp)
  1017c9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1017cd:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1017d0:	e8 8b 04 00 00       	call   101c60 <get_side>
  1017d5:	83 c4 08             	add    $0x8,%esp
  1017d8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  1017db:	83 ec 0c             	sub    $0xc,%esp
  1017de:	8b 55 ac             	mov    -0x54(%ebp),%edx
  1017e1:	89 14 24             	mov    %edx,(%esp)
  1017e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1017e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1017ec:	e8 ff fa ff ff       	call   1012f0 <set_child>
  1017f1:	83 c4 0c             	add    $0xc,%esp
		} else {
  1017f4:	e9 08 00 00 00       	jmp    101801 <rb_remove+0x1e1>
			tree->root = node2;
  1017f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1017fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1017ff:	89 01                	mov    %eax,(%ecx)
		}

		if (loparent == node) {
  101801:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101804:	3b 45 0c             	cmp    0xc(%ebp),%eax
  101807:	0f 85 70 00 00 00    	jne    10187d <rb_remove+0x25d>
  10180d:	31 c0                	xor    %eax,%eax
			set_child(node, 0, get_child(node2, 0));
  10180f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101812:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  101815:	83 ec 08             	sub    $0x8,%esp
  101818:	89 14 24             	mov    %edx,(%esp)
  10181b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101822:	00 
  101823:	89 45 a8             	mov    %eax,-0x58(%ebp)
  101826:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  101829:	e8 b2 f8 ff ff       	call   1010e0 <get_child>
  10182e:	83 c4 08             	add    $0x8,%esp
  101831:	31 c9                	xor    %ecx,%ecx
  101833:	83 ec 0c             	sub    $0xc,%esp
  101836:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  101839:	89 14 24             	mov    %edx,(%esp)
  10183c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101843:	00 
  101844:	89 44 24 08          	mov    %eax,0x8(%esp)
  101848:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  10184b:	e8 a0 fa ff ff       	call   1012f0 <set_child>
  101850:	83 c4 0c             	add    $0xc,%esp
  101853:	31 c0                	xor    %eax,%eax
			set_child(node2, 0, node);
  101855:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  101858:	8b 55 0c             	mov    0xc(%ebp),%edx
  10185b:	83 ec 0c             	sub    $0xc,%esp
  10185e:	89 0c 24             	mov    %ecx,(%esp)
  101861:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101868:	00 
  101869:	89 54 24 08          	mov    %edx,0x8(%esp)
  10186d:	89 45 9c             	mov    %eax,-0x64(%ebp)
  101870:	e8 7b fa ff ff       	call   1012f0 <set_child>
  101875:	83 c4 0c             	add    $0xc,%esp
		} else {
  101878:	e9 c6 00 00 00       	jmp    101943 <rb_remove+0x323>
			set_child(loparent, get_side(loparent, node2), node);
  10187d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101880:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101883:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  101886:	83 ec 08             	sub    $0x8,%esp
  101889:	89 0c 24             	mov    %ecx,(%esp)
  10188c:	89 54 24 04          	mov    %edx,0x4(%esp)
  101890:	89 45 98             	mov    %eax,-0x68(%ebp)
  101893:	e8 c8 03 00 00       	call   101c60 <get_side>
  101898:	83 c4 08             	add    $0x8,%esp
  10189b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10189e:	83 ec 0c             	sub    $0xc,%esp
  1018a1:	8b 55 98             	mov    -0x68(%ebp),%edx
  1018a4:	89 14 24             	mov    %edx,(%esp)
  1018a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1018ab:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1018af:	e8 3c fa ff ff       	call   1012f0 <set_child>
  1018b4:	83 c4 0c             	add    $0xc,%esp
  1018b7:	31 c0                	xor    %eax,%eax
			tmp = get_child(node, 0);
  1018b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1018bc:	83 ec 08             	sub    $0x8,%esp
  1018bf:	89 0c 24             	mov    %ecx,(%esp)
  1018c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1018c9:	00 
  1018ca:	89 45 94             	mov    %eax,-0x6c(%ebp)
  1018cd:	e8 0e f8 ff ff       	call   1010e0 <get_child>
  1018d2:	83 c4 08             	add    $0x8,%esp
  1018d5:	31 c9                	xor    %ecx,%ecx
  1018d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			set_child(node, 0, get_child(node2, 0));
  1018da:	8b 45 0c             	mov    0xc(%ebp),%eax
  1018dd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  1018e0:	83 ec 08             	sub    $0x8,%esp
  1018e3:	89 14 24             	mov    %edx,(%esp)
  1018e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1018ed:	00 
  1018ee:	89 4d 90             	mov    %ecx,-0x70(%ebp)
  1018f1:	89 45 8c             	mov    %eax,-0x74(%ebp)
  1018f4:	e8 e7 f7 ff ff       	call   1010e0 <get_child>
  1018f9:	83 c4 08             	add    $0x8,%esp
  1018fc:	31 c9                	xor    %ecx,%ecx
  1018fe:	83 ec 0c             	sub    $0xc,%esp
  101901:	8b 55 8c             	mov    -0x74(%ebp),%edx
  101904:	89 14 24             	mov    %edx,(%esp)
  101907:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10190e:	00 
  10190f:	89 44 24 08          	mov    %eax,0x8(%esp)
  101913:	89 4d 88             	mov    %ecx,-0x78(%ebp)
  101916:	e8 d5 f9 ff ff       	call   1012f0 <set_child>
  10191b:	83 c4 0c             	add    $0xc,%esp
  10191e:	31 c0                	xor    %eax,%eax
			set_child(node2, 0, tmp);
  101920:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  101923:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101926:	83 ec 0c             	sub    $0xc,%esp
  101929:	89 0c 24             	mov    %ecx,(%esp)
  10192c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101933:	00 
  101934:	89 54 24 08          	mov    %edx,0x8(%esp)
  101938:	89 45 84             	mov    %eax,-0x7c(%ebp)
  10193b:	e8 b0 f9 ff ff       	call   1012f0 <set_child>
  101940:	83 c4 0c             	add    $0xc,%esp
		}

		set_child(node2, 1, get_child(node, 1));
  101943:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101946:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101949:	83 ec 08             	sub    $0x8,%esp
  10194c:	89 0c 24             	mov    %ecx,(%esp)
  10194f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101956:	00 
  101957:	89 45 80             	mov    %eax,-0x80(%ebp)
  10195a:	e8 81 f7 ff ff       	call   1010e0 <get_child>
  10195f:	83 ec 04             	sub    $0x4,%esp
  101962:	8b 4d 80             	mov    -0x80(%ebp),%ecx
  101965:	89 0c 24             	mov    %ecx,(%esp)
  101968:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10196f:	00 
  101970:	89 44 24 08          	mov    %eax,0x8(%esp)
  101974:	e8 77 f9 ff ff       	call   1012f0 <set_child>
  101979:	83 c4 0c             	add    $0xc,%esp
  10197c:	31 c0                	xor    %eax,%eax
		set_child(node, 1, NULL);
  10197e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101981:	83 ec 0c             	sub    $0xc,%esp
  101984:	89 0c 24             	mov    %ecx,(%esp)
  101987:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10198e:	00 
  10198f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101996:	00 
  101997:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  10199d:	e8 4e f9 ff ff       	call   1012f0 <set_child>
  1019a2:	83 c4 0c             	add    $0xc,%esp

		tmp = stack[stacksz0 - 1];
  1019a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1019a8:	83 e8 01             	sub    $0x1,%eax
  1019ab:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  1019ae:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1019b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stack[stacksz0 - 1] = stack[stacksz - 1];
  1019b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1019b7:	83 e8 01             	sub    $0x1,%eax
  1019ba:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1019bd:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1019c0:	83 ea 01             	sub    $0x1,%edx
  1019c3:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		stack[stacksz - 1] = tmp;
  1019c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1019c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1019cc:	83 ea 01             	sub    $0x1,%edx
  1019cf:	89 04 91             	mov    %eax,(%ecx,%edx,4)

		int ctmp = get_color(node);
  1019d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019d5:	83 ec 04             	sub    $0x4,%esp
  1019d8:	89 04 24             	mov    %eax,(%esp)
  1019db:	e8 d0 02 00 00       	call   101cb0 <get_color>
  1019e0:	83 c4 04             	add    $0x4,%esp
  1019e3:	89 45 d0             	mov    %eax,-0x30(%ebp)

		set_color(node, get_color(node2));
  1019e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1019e9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  1019ec:	83 ec 04             	sub    $0x4,%esp
  1019ef:	89 0c 24             	mov    %ecx,(%esp)
  1019f2:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  1019f8:	e8 b3 02 00 00       	call   101cb0 <get_color>
  1019fd:	83 ec 04             	sub    $0x4,%esp
  101a00:	8b 8d 78 ff ff ff    	mov    -0x88(%ebp),%ecx
  101a06:	89 0c 24             	mov    %ecx,(%esp)
  101a09:	89 44 24 04          	mov    %eax,0x4(%esp)
  101a0d:	e8 2e f9 ff ff       	call   101340 <set_color>
  101a12:	83 c4 08             	add    $0x8,%esp
		set_color(node2, ctmp);
  101a15:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101a18:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  101a1b:	83 ec 08             	sub    $0x8,%esp
  101a1e:	89 04 24             	mov    %eax,(%esp)
  101a21:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101a25:	e8 16 f9 ff ff       	call   101340 <set_color>
  101a2a:	83 c4 08             	add    $0x8,%esp
  101a2d:	31 c0                	xor    %eax,%eax
	}

	CHECK(!get_child(node, 0) || !get_child(node, 1));

	struct rbnode *child = get_child(node, 0);
  101a2f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101a32:	83 ec 08             	sub    $0x8,%esp
  101a35:	89 0c 24             	mov    %ecx,(%esp)
  101a38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101a3f:	00 
  101a40:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  101a46:	e8 95 f6 ff ff       	call   1010e0 <get_child>
  101a4b:	83 c4 08             	add    $0x8,%esp
  101a4e:	89 45 cc             	mov    %eax,-0x34(%ebp)

	if (child == NULL) {
  101a51:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  101a55:	0f 85 1c 00 00 00    	jne    101a77 <rb_remove+0x457>
		child = get_child(node, 1);
  101a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
  101a5e:	83 ec 08             	sub    $0x8,%esp
  101a61:	89 04 24             	mov    %eax,(%esp)
  101a64:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101a6b:	00 
  101a6c:	e8 6f f6 ff ff       	call   1010e0 <get_child>
  101a71:	83 c4 08             	add    $0x8,%esp
  101a74:	89 45 cc             	mov    %eax,-0x34(%ebp)
	}

	/* Removing the root */
	if (stacksz < 2) {
  101a77:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
  101a7b:	0f 8d 46 00 00 00    	jge    101ac7 <rb_remove+0x4a7>
		tree->root = child;
  101a81:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101a84:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101a87:	89 01                	mov    %eax,(%ecx)
		if (child != NULL) {
  101a89:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  101a8d:	0f 84 1e 00 00 00    	je     101ab1 <rb_remove+0x491>
			set_color(child, BLACK);
  101a93:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101a96:	83 ec 08             	sub    $0x8,%esp
  101a99:	89 04 24             	mov    %eax,(%esp)
  101a9c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101aa3:	00 
  101aa4:	e8 97 f8 ff ff       	call   101340 <set_color>
  101aa9:	83 c4 08             	add    $0x8,%esp
		} else {
  101aac:	e9 0a 00 00 00       	jmp    101abb <rb_remove+0x49b>
			tree->max_depth = 0;
  101ab1:	8b 45 08             	mov    0x8(%ebp),%eax
  101ab4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  101abb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
		}
		return;
  101ac2:	e9 88 01 00 00       	jmp    101c4f <rb_remove+0x62f>
	}

	struct rbnode *parent = stack[stacksz - 2];
  101ac7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101aca:	83 e8 02             	sub    $0x2,%eax
  101acd:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  101ad0:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  101ad3:	89 45 c8             	mov    %eax,-0x38(%ebp)
	/* Special case: if the node to be removed is childless, then
	 * we leave it in place while we do the missing black
	 * rotations, which will replace it with a proper NULL when
	 * they isolate it.
	 */
	if (child == NULL) {
  101ad6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  101ada:	0f 85 90 00 00 00    	jne    101b70 <rb_remove+0x550>
		if (is_black(node)) {
  101ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
  101ae3:	83 ec 04             	sub    $0x4,%esp
  101ae6:	89 04 24             	mov    %eax,(%esp)
  101ae9:	e8 e2 01 00 00       	call   101cd0 <is_black>
  101aee:	83 c4 04             	add    $0x4,%esp
  101af1:	a8 01                	test   $0x1,%al
  101af3:	0f 85 05 00 00 00    	jne    101afe <rb_remove+0x4de>
  101af9:	e9 24 00 00 00       	jmp    101b22 <rb_remove+0x502>
			fix_missing_black(stack, stacksz, node);
  101afe:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101b01:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101b04:	83 ec 0c             	sub    $0xc,%esp
  101b07:	8b 55 bc             	mov    -0x44(%ebp),%edx
  101b0a:	89 14 24             	mov    %edx,(%esp)
  101b0d:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b11:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101b15:	e8 e6 01 00 00       	call   101d00 <fix_missing_black>
  101b1a:	83 c4 0c             	add    $0xc,%esp
		} else {
  101b1d:	e9 49 00 00 00       	jmp    101b6b <rb_remove+0x54b>
			/* Red childless nodes can just be dropped */
			set_child(parent, get_side(parent, node), NULL);
  101b22:	8b 45 c8             	mov    -0x38(%ebp),%eax
  101b25:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  101b28:	8b 55 0c             	mov    0xc(%ebp),%edx
  101b2b:	83 ec 08             	sub    $0x8,%esp
  101b2e:	89 0c 24             	mov    %ecx,(%esp)
  101b31:	89 54 24 04          	mov    %edx,0x4(%esp)
  101b35:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  101b3b:	e8 20 01 00 00       	call   101c60 <get_side>
  101b40:	83 c4 08             	add    $0x8,%esp
  101b43:	31 c9                	xor    %ecx,%ecx
  101b45:	83 ec 0c             	sub    $0xc,%esp
  101b48:	8b 95 70 ff ff ff    	mov    -0x90(%ebp),%edx
  101b4e:	89 14 24             	mov    %edx,(%esp)
  101b51:	89 44 24 04          	mov    %eax,0x4(%esp)
  101b55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101b5c:	00 
  101b5d:	89 8d 6c ff ff ff    	mov    %ecx,-0x94(%ebp)
  101b63:	e8 88 f7 ff ff       	call   1012f0 <set_child>
  101b68:	83 c4 0c             	add    $0xc,%esp
		}
	} else {
  101b6b:	e9 ce 00 00 00       	jmp    101c3e <rb_remove+0x61e>
		set_child(parent, get_side(parent, node), child);
  101b70:	8b 45 c8             	mov    -0x38(%ebp),%eax
  101b73:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  101b76:	8b 55 0c             	mov    0xc(%ebp),%edx
  101b79:	83 ec 08             	sub    $0x8,%esp
  101b7c:	89 0c 24             	mov    %ecx,(%esp)
  101b7f:	89 54 24 04          	mov    %edx,0x4(%esp)
  101b83:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  101b89:	e8 d2 00 00 00       	call   101c60 <get_side>
  101b8e:	83 c4 08             	add    $0x8,%esp
  101b91:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  101b94:	83 ec 0c             	sub    $0xc,%esp
  101b97:	8b 95 68 ff ff ff    	mov    -0x98(%ebp),%edx
  101b9d:	89 14 24             	mov    %edx,(%esp)
  101ba0:	89 44 24 04          	mov    %eax,0x4(%esp)
  101ba4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  101ba8:	e8 43 f7 ff ff       	call   1012f0 <set_child>
  101bad:	83 c4 0c             	add    $0xc,%esp

		/* Check colors, if one was red (at least one must have been
		 * black in a valid tree), then we're done.  Otherwise we have
		 * a missing black we need to fix
		 */
		if (is_red(node) || is_red(child)) {
  101bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
  101bb3:	83 ec 04             	sub    $0x4,%esp
  101bb6:	89 04 24             	mov    %eax,(%esp)
  101bb9:	e8 52 05 00 00       	call   102110 <is_red>
  101bbe:	83 c4 04             	add    $0x4,%esp
  101bc1:	a8 01                	test   $0x1,%al
  101bc3:	0f 85 1e 00 00 00    	jne    101be7 <rb_remove+0x5c7>
  101bc9:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101bcc:	83 ec 04             	sub    $0x4,%esp
  101bcf:	89 04 24             	mov    %eax,(%esp)
  101bd2:	e8 39 05 00 00       	call   102110 <is_red>
  101bd7:	83 c4 04             	add    $0x4,%esp
  101bda:	a8 01                	test   $0x1,%al
  101bdc:	0f 85 05 00 00 00    	jne    101be7 <rb_remove+0x5c7>
  101be2:	e9 1e 00 00 00       	jmp    101c05 <rb_remove+0x5e5>
			set_color(child, BLACK);
  101be7:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101bea:	83 ec 08             	sub    $0x8,%esp
  101bed:	89 04 24             	mov    %eax,(%esp)
  101bf0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101bf7:	00 
  101bf8:	e8 43 f7 ff ff       	call   101340 <set_color>
  101bfd:	83 c4 08             	add    $0x8,%esp
		} else {
  101c00:	e9 34 00 00 00       	jmp    101c39 <rb_remove+0x619>
  101c05:	31 c0                	xor    %eax,%eax
			stack[stacksz - 1] = child;
  101c07:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  101c0a:	8b 55 e8             	mov    -0x18(%ebp),%edx
  101c0d:	83 ea 01             	sub    $0x1,%edx
  101c10:	8b 75 bc             	mov    -0x44(%ebp),%esi
  101c13:	89 0c 96             	mov    %ecx,(%esi,%edx,4)
			fix_missing_black(stack, stacksz, NULL);
  101c16:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  101c19:	83 ec 0c             	sub    $0xc,%esp
  101c1c:	89 34 24             	mov    %esi,(%esp)
  101c1f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c23:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101c2a:	00 
  101c2b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  101c31:	e8 ca 00 00 00       	call   101d00 <fix_missing_black>
  101c36:	83 c4 0c             	add    $0xc,%esp
  101c39:	e9 00 00 00 00       	jmp    101c3e <rb_remove+0x61e>
  101c3e:	8b 45 bc             	mov    -0x44(%ebp),%eax
		}
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
  101c41:	8b 08                	mov    (%eax),%ecx
  101c43:	8b 55 08             	mov    0x8(%ebp),%edx
  101c46:	89 0a                	mov    %ecx,(%edx)
}
  101c48:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  101c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101c52:	89 c4                	mov    %eax,%esp
  101c54:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101c57:	5e                   	pop    %esi
  101c58:	5f                   	pop    %edi
  101c59:	5d                   	pop    %ebp
  101c5a:	c3                   	ret    
  101c5b:	66 90                	xchg   %ax,%ax
  101c5d:	66 90                	xchg   %ax,%ax
  101c5f:	90                   	nop

00101c60 <get_side>:
{
  101c60:	55                   	push   %ebp
  101c61:	89 e5                	mov    %esp,%ebp
  101c63:	83 ec 18             	sub    $0x18,%esp
  101c66:	8b 45 0c             	mov    0xc(%ebp),%eax
  101c69:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  101c6c:	8b 55 08             	mov    0x8(%ebp),%edx
  101c6f:	89 14 24             	mov    %edx,(%esp)
  101c72:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101c79:	00 
  101c7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  101c7d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  101c80:	e8 5b f4 ff ff       	call   1010e0 <get_child>
  101c85:	31 c9                	xor    %ecx,%ecx
  101c87:	8b 55 0c             	mov    0xc(%ebp),%edx
  101c8a:	39 d0                	cmp    %edx,%eax
  101c8c:	b8 01 00 00 00       	mov    $0x1,%eax
  101c91:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  101c94:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101c97:	0f 84 06 00 00 00    	je     101ca3 <get_side+0x43>
  101c9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ca0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101ca3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101ca6:	83 c4 18             	add    $0x18,%esp
  101ca9:	5d                   	pop    %ebp
  101caa:	c3                   	ret    
  101cab:	66 90                	xchg   %ax,%ax
  101cad:	66 90                	xchg   %ax,%ax
  101caf:	90                   	nop

00101cb0 <get_color>:
{
  101cb0:	55                   	push   %ebp
  101cb1:	89 e5                	mov    %esp,%ebp
  101cb3:	50                   	push   %eax
  101cb4:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((uintptr_t)n->children[0]) & 1UL;
  101cb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101cba:	8b 09                	mov    (%ecx),%ecx
  101cbc:	83 e1 01             	and    $0x1,%ecx
  101cbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  101cc2:	89 c8                	mov    %ecx,%eax
  101cc4:	83 c4 04             	add    $0x4,%esp
  101cc7:	5d                   	pop    %ebp
  101cc8:	c3                   	ret    
  101cc9:	66 90                	xchg   %ax,%ax
  101ccb:	66 90                	xchg   %ax,%ax
  101ccd:	66 90                	xchg   %ax,%ax
  101ccf:	90                   	nop

00101cd0 <is_black>:
{
  101cd0:	55                   	push   %ebp
  101cd1:	89 e5                	mov    %esp,%ebp
  101cd3:	83 ec 08             	sub    $0x8,%esp
  101cd6:	8b 45 08             	mov    0x8(%ebp),%eax
	return get_color(n) == BLACK;
  101cd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101cdc:	89 0c 24             	mov    %ecx,(%esp)
  101cdf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  101ce2:	e8 c9 ff ff ff       	call   101cb0 <get_color>
  101ce7:	83 f8 01             	cmp    $0x1,%eax
  101cea:	0f 94 c2             	sete   %dl
  101ced:	80 e2 01             	and    $0x1,%dl
  101cf0:	0f b6 c2             	movzbl %dl,%eax
  101cf3:	83 c4 08             	add    $0x8,%esp
  101cf6:	5d                   	pop    %ebp
  101cf7:	c3                   	ret    
  101cf8:	66 90                	xchg   %ax,%ax
  101cfa:	66 90                	xchg   %ax,%ax
  101cfc:	66 90                	xchg   %ax,%ax
  101cfe:	66 90                	xchg   %ax,%ax

00101d00 <fix_missing_black>:
{
  101d00:	55                   	push   %ebp
  101d01:	89 e5                	mov    %esp,%ebp
  101d03:	57                   	push   %edi
  101d04:	56                   	push   %esi
  101d05:	83 ec 78             	sub    $0x78,%esp
  101d08:	8b 45 10             	mov    0x10(%ebp),%eax
  101d0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101d0e:	8b 55 08             	mov    0x8(%ebp),%edx
	while (stacksz > 1) {
  101d11:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  101d15:	0f 8e e3 03 00 00    	jle    1020fe <fix_missing_black+0x3fe>
		struct rbnode *n = stack[stacksz - 1];
  101d1b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d1e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101d21:	83 e9 01             	sub    $0x1,%ecx
  101d24:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  101d27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		struct rbnode *parent = stack[stacksz - 2];
  101d2a:	8b 45 08             	mov    0x8(%ebp),%eax
  101d2d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101d30:	83 e9 02             	sub    $0x2,%ecx
  101d33:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  101d36:	89 45 e0             	mov    %eax,-0x20(%ebp)
		int n_side = get_side(parent, n);
  101d39:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101d3c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101d3f:	89 04 24             	mov    %eax,(%esp)
  101d42:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d46:	e8 15 ff ff ff       	call   101c60 <get_side>
  101d4b:	31 c9                	xor    %ecx,%ecx
  101d4d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		struct rbnode *sib = get_child(parent, n_side == 0 ? 1 : 0);
  101d50:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101d53:	8b 55 dc             	mov    -0x24(%ebp),%edx
  101d56:	83 fa 00             	cmp    $0x0,%edx
  101d59:	ba 01 00 00 00       	mov    $0x1,%edx
  101d5e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  101d61:	89 45 d0             	mov    %eax,-0x30(%ebp)
  101d64:	89 55 cc             	mov    %edx,-0x34(%ebp)
  101d67:	0f 84 06 00 00 00    	je     101d73 <fix_missing_black+0x73>
  101d6d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101d70:	89 45 cc             	mov    %eax,-0x34(%ebp)
  101d73:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101d76:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  101d79:	89 0c 24             	mov    %ecx,(%esp)
  101d7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  101d80:	e8 5b f3 ff ff       	call   1010e0 <get_child>
  101d85:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (!is_black(sib)) {
  101d88:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101d8b:	89 04 24             	mov    %eax,(%esp)
  101d8e:	e8 3d ff ff ff       	call   101cd0 <is_black>
  101d93:	a8 01                	test   $0x1,%al
  101d95:	0f 85 a9 00 00 00    	jne    101e44 <fix_missing_black+0x144>
			stack[stacksz - 1] = sib;
  101d9b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101d9e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101da1:	8b 55 0c             	mov    0xc(%ebp),%edx
  101da4:	83 ea 01             	sub    $0x1,%edx
  101da7:	89 04 91             	mov    %eax,(%ecx,%edx,4)
			rotate(stack, stacksz);
  101daa:	8b 45 08             	mov    0x8(%ebp),%eax
  101dad:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101db0:	89 04 24             	mov    %eax,(%esp)
  101db3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101db7:	e8 a4 05 00 00       	call   102360 <rotate>
  101dbc:	31 c0                	xor    %eax,%eax
			set_color(parent, RED);
  101dbe:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  101dc1:	89 0c 24             	mov    %ecx,(%esp)
  101dc4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101dcb:	00 
  101dcc:	89 45 c8             	mov    %eax,-0x38(%ebp)
  101dcf:	e8 6c f5 ff ff       	call   101340 <set_color>
			set_color(sib, BLACK);
  101dd4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101dd7:	89 04 24             	mov    %eax,(%esp)
  101dda:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101de1:	00 
  101de2:	e8 59 f5 ff ff       	call   101340 <set_color>
  101de7:	31 c0                	xor    %eax,%eax
			stack[stacksz++] = n;
  101de9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101dec:	8b 55 08             	mov    0x8(%ebp),%edx
  101def:	8b 75 0c             	mov    0xc(%ebp),%esi
  101df2:	89 f7                	mov    %esi,%edi
  101df4:	83 c7 01             	add    $0x1,%edi
  101df7:	89 7d 0c             	mov    %edi,0xc(%ebp)
  101dfa:	89 0c b2             	mov    %ecx,(%edx,%esi,4)
			parent = stack[stacksz - 2];
  101dfd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101e00:	8b 55 0c             	mov    0xc(%ebp),%edx
  101e03:	83 ea 02             	sub    $0x2,%edx
  101e06:	8b 0c 91             	mov    (%ecx,%edx,4),%ecx
  101e09:	89 4d e0             	mov    %ecx,-0x20(%ebp)
			sib = get_child(parent, n_side == 0 ? 1 : 0);
  101e0c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  101e0f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  101e12:	83 fa 00             	cmp    $0x0,%edx
  101e15:	ba 01 00 00 00       	mov    $0x1,%edx
  101e1a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  101e1d:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  101e20:	89 55 bc             	mov    %edx,-0x44(%ebp)
  101e23:	0f 84 06 00 00 00    	je     101e2f <fix_missing_black+0x12f>
  101e29:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  101e2c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  101e2f:	8b 45 bc             	mov    -0x44(%ebp),%eax
  101e32:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  101e35:	89 0c 24             	mov    %ecx,(%esp)
  101e38:	89 44 24 04          	mov    %eax,0x4(%esp)
  101e3c:	e8 9f f2 ff ff       	call   1010e0 <get_child>
  101e41:	89 45 d8             	mov    %eax,-0x28(%ebp)
  101e44:	31 c0                	xor    %eax,%eax
		c0 = get_child(sib, 0);
  101e46:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101e49:	89 0c 24             	mov    %ecx,(%esp)
  101e4c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101e53:	00 
  101e54:	89 45 b8             	mov    %eax,-0x48(%ebp)
  101e57:	e8 84 f2 ff ff       	call   1010e0 <get_child>
  101e5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		c1 = get_child(sib, 1);
  101e5f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101e62:	89 04 24             	mov    %eax,(%esp)
  101e65:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101e6c:	00 
  101e6d:	e8 6e f2 ff ff       	call   1010e0 <get_child>
  101e72:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
  101e75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  101e79:	0f 84 18 00 00 00    	je     101e97 <fix_missing_black+0x197>
  101e7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e82:	89 04 24             	mov    %eax,(%esp)
  101e85:	e8 46 fe ff ff       	call   101cd0 <is_black>
  101e8a:	a8 01                	test   $0x1,%al
  101e8c:	0f 85 05 00 00 00    	jne    101e97 <fix_missing_black+0x197>
  101e92:	e9 a3 00 00 00       	jmp    101f3a <fix_missing_black+0x23a>
  101e97:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  101e9b:	0f 84 18 00 00 00    	je     101eb9 <fix_missing_black+0x1b9>
					is_black(c1))) {
  101ea1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101ea4:	89 04 24             	mov    %eax,(%esp)
  101ea7:	e8 24 fe ff ff       	call   101cd0 <is_black>
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
  101eac:	a8 01                	test   $0x1,%al
  101eae:	0f 85 05 00 00 00    	jne    101eb9 <fix_missing_black+0x1b9>
  101eb4:	e9 81 00 00 00       	jmp    101f3a <fix_missing_black+0x23a>
			if (n == null_node) {
  101eb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101ebc:	3b 45 10             	cmp    0x10(%ebp),%eax
  101ebf:	0f 85 1f 00 00 00    	jne    101ee4 <fix_missing_black+0x1e4>
  101ec5:	31 c0                	xor    %eax,%eax
				set_child(parent, n_side, NULL);
  101ec7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  101eca:	8b 55 dc             	mov    -0x24(%ebp),%edx
  101ecd:	89 0c 24             	mov    %ecx,(%esp)
  101ed0:	89 54 24 04          	mov    %edx,0x4(%esp)
  101ed4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101edb:	00 
  101edc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  101edf:	e8 0c f4 ff ff       	call   1012f0 <set_child>
  101ee4:	31 c0                	xor    %eax,%eax
			set_color(sib, RED);
  101ee6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101ee9:	89 0c 24             	mov    %ecx,(%esp)
  101eec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101ef3:	00 
  101ef4:	89 45 b0             	mov    %eax,-0x50(%ebp)
  101ef7:	e8 44 f4 ff ff       	call   101340 <set_color>
			if (is_black(parent)) {
  101efc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101eff:	89 04 24             	mov    %eax,(%esp)
  101f02:	e8 c9 fd ff ff       	call   101cd0 <is_black>
  101f07:	a8 01                	test   $0x1,%al
  101f09:	0f 85 05 00 00 00    	jne    101f14 <fix_missing_black+0x214>
  101f0f:	e9 0e 00 00 00       	jmp    101f22 <fix_missing_black+0x222>
				stacksz--;
  101f14:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f17:	83 c0 ff             	add    $0xffffffff,%eax
  101f1a:	89 45 0c             	mov    %eax,0xc(%ebp)
				continue;
  101f1d:	e9 ef fd ff ff       	jmp    101d11 <fix_missing_black+0x11>
				set_color(parent, BLACK);
  101f22:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101f25:	89 04 24             	mov    %eax,(%esp)
  101f28:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101f2f:	00 
  101f30:	e8 0b f4 ff ff       	call   101340 <set_color>
				return;
  101f35:	e9 c4 01 00 00       	jmp    1020fe <fix_missing_black+0x3fe>
  101f3a:	31 c0                	xor    %eax,%eax
		outer = get_child(sib, n_side == 0 ? 1 : 0);
  101f3c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101f3f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  101f42:	83 fa 00             	cmp    $0x0,%edx
  101f45:	ba 01 00 00 00       	mov    $0x1,%edx
  101f4a:	89 45 ac             	mov    %eax,-0x54(%ebp)
  101f4d:	89 4d a8             	mov    %ecx,-0x58(%ebp)
  101f50:	89 55 a4             	mov    %edx,-0x5c(%ebp)
  101f53:	0f 84 06 00 00 00    	je     101f5f <fix_missing_black+0x25f>
  101f59:	8b 45 ac             	mov    -0x54(%ebp),%eax
  101f5c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  101f5f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  101f62:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  101f65:	89 0c 24             	mov    %ecx,(%esp)
  101f68:	89 44 24 04          	mov    %eax,0x4(%esp)
  101f6c:	e8 6f f1 ff ff       	call   1010e0 <get_child>
  101f71:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (!(outer != NULL && is_red(outer))) {
  101f74:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101f78:	0f 84 13 00 00 00    	je     101f91 <fix_missing_black+0x291>
  101f7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101f81:	89 04 24             	mov    %eax,(%esp)
  101f84:	e8 87 01 00 00       	call   102110 <is_red>
  101f89:	a8 01                	test   $0x1,%al
  101f8b:	0f 85 d6 00 00 00    	jne    102067 <fix_missing_black+0x367>
			inner = get_child(sib, n_side);
  101f91:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101f94:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  101f97:	89 04 24             	mov    %eax,(%esp)
  101f9a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101f9e:	e8 3d f1 ff ff       	call   1010e0 <get_child>
  101fa3:	89 45 ec             	mov    %eax,-0x14(%ebp)
			stack[stacksz - 1] = sib;
  101fa6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  101fa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101fac:	8b 55 0c             	mov    0xc(%ebp),%edx
  101faf:	83 ea 01             	sub    $0x1,%edx
  101fb2:	89 04 91             	mov    %eax,(%ecx,%edx,4)
			stack[stacksz++] = inner;
  101fb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101fbb:	8b 55 0c             	mov    0xc(%ebp),%edx
  101fbe:	89 d6                	mov    %edx,%esi
  101fc0:	83 c6 01             	add    $0x1,%esi
  101fc3:	89 75 0c             	mov    %esi,0xc(%ebp)
  101fc6:	89 04 91             	mov    %eax,(%ecx,%edx,4)
			rotate(stack, stacksz);
  101fc9:	8b 45 08             	mov    0x8(%ebp),%eax
  101fcc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101fcf:	89 04 24             	mov    %eax,(%esp)
  101fd2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101fd6:	e8 85 03 00 00       	call   102360 <rotate>
  101fdb:	31 c0                	xor    %eax,%eax
			set_color(sib, RED);
  101fdd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101fe0:	89 0c 24             	mov    %ecx,(%esp)
  101fe3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101fea:	00 
  101feb:	89 45 a0             	mov    %eax,-0x60(%ebp)
  101fee:	e8 4d f3 ff ff       	call   101340 <set_color>
			set_color(inner, BLACK);
  101ff3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101ff6:	89 04 24             	mov    %eax,(%esp)
  101ff9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102000:	00 
  102001:	e8 3a f3 ff ff       	call   101340 <set_color>
  102006:	31 c0                	xor    %eax,%eax
			sib = stack[stacksz - 2];
  102008:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10200b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10200e:	83 ea 02             	sub    $0x2,%edx
  102011:	8b 0c 91             	mov    (%ecx,%edx,4),%ecx
  102014:	89 4d d8             	mov    %ecx,-0x28(%ebp)
			outer = get_child(sib, n_side == 0 ? 1 : 0);
  102017:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10201a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10201d:	83 fa 00             	cmp    $0x0,%edx
  102020:	ba 01 00 00 00       	mov    $0x1,%edx
  102025:	89 45 9c             	mov    %eax,-0x64(%ebp)
  102028:	89 4d 98             	mov    %ecx,-0x68(%ebp)
  10202b:	89 55 94             	mov    %edx,-0x6c(%ebp)
  10202e:	0f 84 06 00 00 00    	je     10203a <fix_missing_black+0x33a>
  102034:	8b 45 9c             	mov    -0x64(%ebp),%eax
  102037:	89 45 94             	mov    %eax,-0x6c(%ebp)
  10203a:	8b 45 94             	mov    -0x6c(%ebp),%eax
  10203d:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  102040:	89 0c 24             	mov    %ecx,(%esp)
  102043:	89 44 24 04          	mov    %eax,0x4(%esp)
  102047:	e8 94 f0 ff ff       	call   1010e0 <get_child>
  10204c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			stack[stacksz - 2] = n;
  10204f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102052:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102055:	8b 55 0c             	mov    0xc(%ebp),%edx
  102058:	83 ea 02             	sub    $0x2,%edx
  10205b:	89 04 91             	mov    %eax,(%ecx,%edx,4)
			stacksz--;
  10205e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102061:	83 c0 ff             	add    $0xffffffff,%eax
  102064:	89 45 0c             	mov    %eax,0xc(%ebp)
		set_color(sib, get_color(parent));
  102067:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10206a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10206d:	89 0c 24             	mov    %ecx,(%esp)
  102070:	89 45 90             	mov    %eax,-0x70(%ebp)
  102073:	e8 38 fc ff ff       	call   101cb0 <get_color>
  102078:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  10207b:	89 0c 24             	mov    %ecx,(%esp)
  10207e:	89 44 24 04          	mov    %eax,0x4(%esp)
  102082:	e8 b9 f2 ff ff       	call   101340 <set_color>
		set_color(parent, BLACK);
  102087:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10208a:	89 04 24             	mov    %eax,(%esp)
  10208d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102094:	00 
  102095:	e8 a6 f2 ff ff       	call   101340 <set_color>
		set_color(outer, BLACK);
  10209a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10209d:	89 04 24             	mov    %eax,(%esp)
  1020a0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1020a7:	00 
  1020a8:	e8 93 f2 ff ff       	call   101340 <set_color>
		stack[stacksz - 1] = sib;
  1020ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1020b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1020b3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1020b6:	83 ea 01             	sub    $0x1,%edx
  1020b9:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		rotate(stack, stacksz);
  1020bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1020bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1020c2:	89 04 24             	mov    %eax,(%esp)
  1020c5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1020c9:	e8 92 02 00 00       	call   102360 <rotate>
		if (n == null_node) {
  1020ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1020d1:	3b 45 10             	cmp    0x10(%ebp),%eax
  1020d4:	0f 85 1f 00 00 00    	jne    1020f9 <fix_missing_black+0x3f9>
  1020da:	31 c0                	xor    %eax,%eax
			set_child(parent, n_side, NULL);
  1020dc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1020df:	8b 55 dc             	mov    -0x24(%ebp),%edx
  1020e2:	89 0c 24             	mov    %ecx,(%esp)
  1020e5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1020e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1020f0:	00 
  1020f1:	89 45 8c             	mov    %eax,-0x74(%ebp)
  1020f4:	e8 f7 f1 ff ff       	call   1012f0 <set_child>
		return;
  1020f9:	e9 00 00 00 00       	jmp    1020fe <fix_missing_black+0x3fe>
}
  1020fe:	83 c4 78             	add    $0x78,%esp
  102101:	5e                   	pop    %esi
  102102:	5f                   	pop    %edi
  102103:	5d                   	pop    %ebp
  102104:	c3                   	ret    
  102105:	66 90                	xchg   %ax,%ax
  102107:	66 90                	xchg   %ax,%ax
  102109:	66 90                	xchg   %ax,%ax
  10210b:	66 90                	xchg   %ax,%ax
  10210d:	66 90                	xchg   %ax,%ax
  10210f:	90                   	nop

00102110 <is_red>:
{
  102110:	55                   	push   %ebp
  102111:	89 e5                	mov    %esp,%ebp
  102113:	83 ec 08             	sub    $0x8,%esp
  102116:	8b 45 08             	mov    0x8(%ebp),%eax
	return get_color(n) == RED;
  102119:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10211c:	89 0c 24             	mov    %ecx,(%esp)
  10211f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102122:	e8 89 fb ff ff       	call   101cb0 <get_color>
  102127:	83 f8 00             	cmp    $0x0,%eax
  10212a:	0f 94 c2             	sete   %dl
  10212d:	80 e2 01             	and    $0x1,%dl
  102130:	0f b6 c2             	movzbl %dl,%eax
  102133:	83 c4 08             	add    $0x8,%esp
  102136:	5d                   	pop    %ebp
  102137:	c3                   	ret    
  102138:	66 90                	xchg   %ax,%ax
  10213a:	66 90                	xchg   %ax,%ax
  10213c:	66 90                	xchg   %ax,%ax
  10213e:	66 90                	xchg   %ax,%ax

00102140 <z_rb_foreach_next>:
 * node/stack[top] is the left child of stack[top-1]).  The special
 * case of top == -1 indicates that the stack is uninitialized and we
 * need to push an initial stack starting at the root.
 */
struct rbnode *z_rb_foreach_next(struct rbtree *tree, struct _rb_foreach *f)
{
  102140:	55                   	push   %ebp
  102141:	89 e5                	mov    %esp,%ebp
  102143:	56                   	push   %esi
  102144:	83 ec 18             	sub    $0x18,%esp
  102147:	8b 45 0c             	mov    0xc(%ebp),%eax
  10214a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct rbnode *n;

	if (tree->root == NULL) {
  10214d:	8b 55 08             	mov    0x8(%ebp),%edx
  102150:	83 3a 00             	cmpl   $0x0,(%edx)
  102153:	0f 85 0c 00 00 00    	jne    102165 <z_rb_foreach_next+0x25>
		return NULL;
  102159:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  102160:	e9 36 01 00 00       	jmp    10229b <z_rb_foreach_next+0x15b>
	}

	/* Initialization condition, pick the leftmost child of the
	 * root as our first node, initializing the stack on the way.
	 */
	if (f->top == -1) {
  102165:	8b 45 0c             	mov    0xc(%ebp),%eax
  102168:	83 78 08 ff          	cmpl   $0xffffffff,0x8(%eax)
  10216c:	0f 85 1c 00 00 00    	jne    10218e <z_rb_foreach_next+0x4e>
		return stack_left_limb(tree->root, f);
  102172:	8b 45 08             	mov    0x8(%ebp),%eax
  102175:	8b 00                	mov    (%eax),%eax
  102177:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10217a:	89 04 24             	mov    %eax,(%esp)
  10217d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102181:	e8 2a 01 00 00       	call   1022b0 <stack_left_limb>
  102186:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102189:	e9 0d 01 00 00       	jmp    10229b <z_rb_foreach_next+0x15b>
	}

	/* The next child from a given node is the leftmost child of
	 * it's right subtree if it has a right child
	 */
	n = get_child(f->stack[f->top], 1);
  10218e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102191:	8b 00                	mov    (%eax),%eax
  102193:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102196:	8b 49 08             	mov    0x8(%ecx),%ecx
  102199:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  10219c:	89 04 24             	mov    %eax,(%esp)
  10219f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1021a6:	00 
  1021a7:	e8 34 ef ff ff       	call   1010e0 <get_child>
  1021ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (n != NULL) {
  1021af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1021b3:	0f 84 1a 00 00 00    	je     1021d3 <z_rb_foreach_next+0x93>
		return stack_left_limb(n, f);
  1021b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1021bf:	89 04 24             	mov    %eax,(%esp)
  1021c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1021c6:	e8 e5 00 00 00       	call   1022b0 <stack_left_limb>
  1021cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1021ce:	e9 c8 00 00 00       	jmp    10229b <z_rb_foreach_next+0x15b>
	/* Otherwise if the node is a left child of its parent, the
	 * next node is the parent (note that the root is stacked
	 * above with is_left set to 0, so this condition still works
	 * even if node has no parent).
	 */
	if (f->is_left[f->top] != 0) {
  1021d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1021d6:	8b 40 04             	mov    0x4(%eax),%eax
  1021d9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1021dc:	8b 49 08             	mov    0x8(%ecx),%ecx
  1021df:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1021e3:	83 f8 00             	cmp    $0x0,%eax
  1021e6:	0f 84 1f 00 00 00    	je     10220b <z_rb_foreach_next+0xcb>
		return f->stack[--f->top];
  1021ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  1021ef:	8b 00                	mov    (%eax),%eax
  1021f1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1021f4:	8b 51 08             	mov    0x8(%ecx),%edx
  1021f7:	89 d6                	mov    %edx,%esi
  1021f9:	83 c6 ff             	add    $0xffffffff,%esi
  1021fc:	89 71 08             	mov    %esi,0x8(%ecx)
  1021ff:	8b 44 90 fc          	mov    -0x4(%eax,%edx,4),%eax
  102203:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102206:	e9 90 00 00 00       	jmp    10229b <z_rb_foreach_next+0x15b>

	/* If we had no left tree and are a right child then our
	 * parent was already walked, so walk up the stack looking for
	 * a left child (whose parent is unwalked, and thus next).
	 */
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
  10220b:	e9 00 00 00 00       	jmp    102210 <z_rb_foreach_next+0xd0>
  102210:	31 c0                	xor    %eax,%eax
  102212:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102215:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  102219:	88 45 f3             	mov    %al,-0xd(%ebp)
  10221c:	0f 8e 19 00 00 00    	jle    10223b <z_rb_foreach_next+0xfb>
  102222:	8b 45 0c             	mov    0xc(%ebp),%eax
  102225:	8b 40 04             	mov    0x4(%eax),%eax
  102228:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10222b:	8b 49 08             	mov    0x8(%ecx),%ecx
  10222e:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  102232:	83 f8 00             	cmp    $0x0,%eax
  102235:	0f 94 c2             	sete   %dl
  102238:	88 55 f3             	mov    %dl,-0xd(%ebp)
  10223b:	8a 45 f3             	mov    -0xd(%ebp),%al
  10223e:	a8 01                	test   $0x1,%al
  102240:	0f 85 05 00 00 00    	jne    10224b <z_rb_foreach_next+0x10b>
  102246:	e9 11 00 00 00       	jmp    10225c <z_rb_foreach_next+0x11c>
		f->top--;
  10224b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10224e:	8b 48 08             	mov    0x8(%eax),%ecx
  102251:	83 c1 ff             	add    $0xffffffff,%ecx
  102254:	89 48 08             	mov    %ecx,0x8(%eax)
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
  102257:	e9 b4 ff ff ff       	jmp    102210 <z_rb_foreach_next+0xd0>
	}

	f->top--;
  10225c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10225f:	8b 48 08             	mov    0x8(%eax),%ecx
  102262:	83 c1 ff             	add    $0xffffffff,%ecx
  102265:	89 48 08             	mov    %ecx,0x8(%eax)
	return f->top >= 0 ? f->stack[f->top] : NULL;
  102268:	8b 45 0c             	mov    0xc(%ebp),%eax
  10226b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  10226f:	0f 8c 16 00 00 00    	jl     10228b <z_rb_foreach_next+0x14b>
  102275:	8b 45 0c             	mov    0xc(%ebp),%eax
  102278:	8b 00                	mov    (%eax),%eax
  10227a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10227d:	8b 49 08             	mov    0x8(%ecx),%ecx
  102280:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  102283:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102286:	e9 0a 00 00 00       	jmp    102295 <z_rb_foreach_next+0x155>
  10228b:	31 c0                	xor    %eax,%eax
  10228d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102290:	e9 00 00 00 00       	jmp    102295 <z_rb_foreach_next+0x155>
  102295:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102298:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  10229b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10229e:	83 c4 18             	add    $0x18,%esp
  1022a1:	5e                   	pop    %esi
  1022a2:	5d                   	pop    %ebp
  1022a3:	c3                   	ret    
  1022a4:	66 90                	xchg   %ax,%ax
  1022a6:	66 90                	xchg   %ax,%ax
  1022a8:	66 90                	xchg   %ax,%ax
  1022aa:	66 90                	xchg   %ax,%ax
  1022ac:	66 90                	xchg   %ax,%ax
  1022ae:	66 90                	xchg   %ax,%ax

001022b0 <stack_left_limb>:
{
  1022b0:	55                   	push   %ebp
  1022b1:	89 e5                	mov    %esp,%ebp
  1022b3:	57                   	push   %edi
  1022b4:	56                   	push   %esi
  1022b5:	83 ec 0c             	sub    $0xc,%esp
  1022b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1022bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	f->top++;
  1022be:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022c1:	8b 72 08             	mov    0x8(%edx),%esi
  1022c4:	83 c6 01             	add    $0x1,%esi
  1022c7:	89 72 08             	mov    %esi,0x8(%edx)
	f->stack[f->top] = n;
  1022ca:	8b 55 08             	mov    0x8(%ebp),%edx
  1022cd:	8b 75 0c             	mov    0xc(%ebp),%esi
  1022d0:	8b 36                	mov    (%esi),%esi
  1022d2:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1022d5:	8b 7f 08             	mov    0x8(%edi),%edi
  1022d8:	89 14 be             	mov    %edx,(%esi,%edi,4)
	f->is_left[f->top] = 0;
  1022db:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022de:	8b 52 04             	mov    0x4(%edx),%edx
  1022e1:	8b 75 0c             	mov    0xc(%ebp),%esi
  1022e4:	8b 76 08             	mov    0x8(%esi),%esi
  1022e7:	c6 04 32 00          	movb   $0x0,(%edx,%esi,1)
  1022eb:	31 c0                	xor    %eax,%eax
	while ((n = get_child(n, 0)) != NULL) {
  1022ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1022f0:	89 0c 24             	mov    %ecx,(%esp)
  1022f3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1022fa:	00 
  1022fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1022fe:	e8 dd ed ff ff       	call   1010e0 <get_child>
  102303:	89 45 08             	mov    %eax,0x8(%ebp)
  102306:	83 f8 00             	cmp    $0x0,%eax
  102309:	0f 84 32 00 00 00    	je     102341 <stack_left_limb+0x91>
		f->top++;
  10230f:	8b 45 0c             	mov    0xc(%ebp),%eax
  102312:	8b 48 08             	mov    0x8(%eax),%ecx
  102315:	83 c1 01             	add    $0x1,%ecx
  102318:	89 48 08             	mov    %ecx,0x8(%eax)
		f->stack[f->top] = n;
  10231b:	8b 45 08             	mov    0x8(%ebp),%eax
  10231e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102321:	8b 09                	mov    (%ecx),%ecx
  102323:	8b 55 0c             	mov    0xc(%ebp),%edx
  102326:	8b 52 08             	mov    0x8(%edx),%edx
  102329:	89 04 91             	mov    %eax,(%ecx,%edx,4)
		f->is_left[f->top] = 1;
  10232c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10232f:	8b 40 04             	mov    0x4(%eax),%eax
  102332:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102335:	8b 49 08             	mov    0x8(%ecx),%ecx
  102338:	c6 04 08 01          	movb   $0x1,(%eax,%ecx,1)
	while ((n = get_child(n, 0)) != NULL) {
  10233c:	e9 aa ff ff ff       	jmp    1022eb <stack_left_limb+0x3b>
	return f->stack[f->top];
  102341:	8b 45 0c             	mov    0xc(%ebp),%eax
  102344:	8b 00                	mov    (%eax),%eax
  102346:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102349:	8b 49 08             	mov    0x8(%ecx),%ecx
  10234c:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  10234f:	83 c4 0c             	add    $0xc,%esp
  102352:	5e                   	pop    %esi
  102353:	5f                   	pop    %edi
  102354:	5d                   	pop    %ebp
  102355:	c3                   	ret    
  102356:	66 90                	xchg   %ax,%ax
  102358:	66 90                	xchg   %ax,%ax
  10235a:	66 90                	xchg   %ax,%ax
  10235c:	66 90                	xchg   %ax,%ax
  10235e:	66 90                	xchg   %ax,%ax

00102360 <rotate>:
{
  102360:	55                   	push   %ebp
  102361:	89 e5                	mov    %esp,%ebp
  102363:	56                   	push   %esi
  102364:	83 ec 48             	sub    $0x48,%esp
  102367:	8b 45 0c             	mov    0xc(%ebp),%eax
  10236a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct rbnode *parent = stack[stacksz - 2];
  10236d:	8b 55 08             	mov    0x8(%ebp),%edx
  102370:	8b 75 0c             	mov    0xc(%ebp),%esi
  102373:	83 ee 02             	sub    $0x2,%esi
  102376:	8b 14 b2             	mov    (%edx,%esi,4),%edx
  102379:	89 55 f8             	mov    %edx,-0x8(%ebp)
	struct rbnode *child = stack[stacksz - 1];
  10237c:	8b 55 08             	mov    0x8(%ebp),%edx
  10237f:	8b 75 0c             	mov    0xc(%ebp),%esi
  102382:	83 ee 01             	sub    $0x1,%esi
  102385:	8b 14 b2             	mov    (%edx,%esi,4),%edx
  102388:	89 55 f4             	mov    %edx,-0xc(%ebp)
	int side = get_side(parent, child);
  10238b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10238e:	8b 75 f4             	mov    -0xc(%ebp),%esi
  102391:	89 14 24             	mov    %edx,(%esp)
  102394:	89 74 24 04          	mov    %esi,0x4(%esp)
  102398:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10239b:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10239e:	e8 bd f8 ff ff       	call   101c60 <get_side>
  1023a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct rbnode *a = get_child(child, side);
  1023a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1023a9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1023ac:	89 04 24             	mov    %eax,(%esp)
  1023af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1023b3:	e8 28 ed ff ff       	call   1010e0 <get_child>
  1023b8:	31 c9                	xor    %ecx,%ecx
  1023ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct rbnode *b = get_child(child, side == 0 ? 1 : 0);
  1023bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1023c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1023c3:	83 fa 00             	cmp    $0x0,%edx
  1023c6:	ba 01 00 00 00       	mov    $0x1,%edx
  1023cb:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  1023ce:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1023d1:	89 55 d0             	mov    %edx,-0x30(%ebp)
  1023d4:	0f 84 06 00 00 00    	je     1023e0 <rotate+0x80>
  1023da:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1023dd:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1023e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1023e3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  1023e6:	89 0c 24             	mov    %ecx,(%esp)
  1023e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1023ed:	e8 ee ec ff ff       	call   1010e0 <get_child>
  1023f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (stacksz >= 3) {
  1023f5:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  1023f9:	0f 8c 3d 00 00 00    	jl     10243c <rotate+0xdc>
		struct rbnode *grandparent = stack[stacksz - 3];
  1023ff:	8b 45 08             	mov    0x8(%ebp),%eax
  102402:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102405:	83 e9 03             	sub    $0x3,%ecx
  102408:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  10240b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_child(grandparent, get_side(grandparent, parent), child);
  10240e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102411:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  102414:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102417:	89 0c 24             	mov    %ecx,(%esp)
  10241a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10241e:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102421:	e8 3a f8 ff ff       	call   101c60 <get_side>
  102426:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102429:	8b 55 cc             	mov    -0x34(%ebp),%edx
  10242c:	89 14 24             	mov    %edx,(%esp)
  10242f:	89 44 24 04          	mov    %eax,0x4(%esp)
  102433:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  102437:	e8 b4 ee ff ff       	call   1012f0 <set_child>
	set_child(child, side, a);
  10243c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10243f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102442:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102445:	89 04 24             	mov    %eax,(%esp)
  102448:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10244c:	89 54 24 08          	mov    %edx,0x8(%esp)
  102450:	e8 9b ee ff ff       	call   1012f0 <set_child>
  102455:	31 c0                	xor    %eax,%eax
	set_child(child, side == 0 ? 1 : 0, parent);
  102457:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10245a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10245d:	83 fa 00             	cmp    $0x0,%edx
  102460:	ba 01 00 00 00       	mov    $0x1,%edx
  102465:	89 45 c8             	mov    %eax,-0x38(%ebp)
  102468:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  10246b:	89 55 c0             	mov    %edx,-0x40(%ebp)
  10246e:	0f 84 06 00 00 00    	je     10247a <rotate+0x11a>
  102474:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102477:	89 45 c0             	mov    %eax,-0x40(%ebp)
  10247a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10247d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102480:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  102483:	89 14 24             	mov    %edx,(%esp)
  102486:	89 44 24 04          	mov    %eax,0x4(%esp)
  10248a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10248e:	e8 5d ee ff ff       	call   1012f0 <set_child>
	set_child(parent, side, b);
  102493:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102496:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102499:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10249c:	89 04 24             	mov    %eax,(%esp)
  10249f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1024a3:	89 54 24 08          	mov    %edx,0x8(%esp)
  1024a7:	e8 44 ee ff ff       	call   1012f0 <set_child>
	stack[stacksz - 2] = child;
  1024ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024af:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1024b2:	8b 55 0c             	mov    0xc(%ebp),%edx
  1024b5:	83 ea 02             	sub    $0x2,%edx
  1024b8:	89 04 91             	mov    %eax,(%ecx,%edx,4)
	stack[stacksz - 1] = parent;
  1024bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1024be:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1024c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  1024c4:	83 ea 01             	sub    $0x1,%edx
  1024c7:	89 04 91             	mov    %eax,(%ecx,%edx,4)
}
  1024ca:	83 c4 48             	add    $0x48,%esp
  1024cd:	5e                   	pop    %esi
  1024ce:	5d                   	pop    %ebp
  1024cf:	c3                   	ret    

001024d0 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  1024d0:	55                   	push   %ebp
  1024d1:	89 e5                	mov    %esp,%ebp
  1024d3:	53                   	push   %ebx
  1024d4:	57                   	push   %edi
  1024d5:	56                   	push   %esi
  1024d6:	83 ec 20             	sub    $0x20,%esp
  1024d9:	8b 45 14             	mov    0x14(%ebp),%eax
  1024dc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1024df:	8b 55 0c             	mov    0xc(%ebp),%edx
  1024e2:	8b 75 08             	mov    0x8(%ebp),%esi
	entry(p1, p2, p3);
  1024e5:	8b 7d 08             	mov    0x8(%ebp),%edi
  1024e8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1024eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1024ee:	8b 45 10             	mov    0x10(%ebp),%eax
  1024f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1024f4:	8b 45 14             	mov    0x14(%ebp),%eax
  1024f7:	89 1c 24             	mov    %ebx,(%esp)
  1024fa:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  1024fd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  102501:	89 44 24 08          	mov    %eax,0x8(%esp)
  102505:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102508:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10250b:	89 75 e0             	mov    %esi,-0x20(%ebp)
  10250e:	ff d7                	call   *%edi

	k_thread_abort(k_current_get());
  102510:	e8 2b 00 00 00       	call   102540 <k_current_get>
  102515:	89 04 24             	mov    %eax,(%esp)
  102518:	e8 03 00 00 00       	call   102520 <k_thread_abort>
  10251d:	66 90                	xchg   %ax,%ax
  10251f:	90                   	nop

00102520 <k_thread_abort>:
}


extern void z_impl_k_thread_abort(k_tid_t thread);
static inline void k_thread_abort(k_tid_t thread)
{
  102520:	55                   	push   %ebp
  102521:	89 e5                	mov    %esp,%ebp
  102523:	50                   	push   %eax
  102524:	8b 45 08             	mov    0x8(%ebp),%eax
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
  102527:	8b 45 08             	mov    0x8(%ebp),%eax
  10252a:	89 04 24             	mov    %eax,(%esp)
  10252d:	e8 9e ea 01 00       	call   120fd0 <z_impl_k_thread_abort>
}
  102532:	83 c4 04             	add    $0x4,%esp
  102535:	5d                   	pop    %ebp
  102536:	c3                   	ret    
  102537:	66 90                	xchg   %ax,%ax
  102539:	66 90                	xchg   %ax,%ax
  10253b:	66 90                	xchg   %ax,%ax
  10253d:	66 90                	xchg   %ax,%ax
  10253f:	90                   	nop

00102540 <k_current_get>:
{
  102540:	55                   	push   %ebp
  102541:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  102543:	e9 00 00 00 00       	jmp    102548 <k_current_get+0x8>
	return z_impl_k_current_get();
  102548:	e8 a3 d6 01 00       	call   11fbf0 <z_impl_k_current_get>
  10254d:	5d                   	pop    %ebp
  10254e:	c3                   	ret    
  10254f:	90                   	nop

00102550 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
  102550:	55                   	push   %ebp
  102551:	89 e5                	mov    %esp,%ebp
  102553:	50                   	push   %eax
  102554:	8b 45 08             	mov    0x8(%ebp),%eax
  102557:	31 c9                	xor    %ecx,%ecx
  102559:	89 45 fc             	mov    %eax,-0x4(%ebp)
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
  10255c:	89 c8                	mov    %ecx,%eax
  10255e:	83 c4 04             	add    $0x4,%esp
  102561:	5d                   	pop    %ebp
  102562:	c3                   	ret    
  102563:	66 90                	xchg   %ax,%ax
  102565:	66 90                	xchg   %ax,%ax
  102567:	66 90                	xchg   %ax,%ax
  102569:	66 90                	xchg   %ax,%ax
  10256b:	66 90                	xchg   %ax,%ax
  10256d:	66 90                	xchg   %ax,%ax
  10256f:	90                   	nop

00102570 <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
  102570:	55                   	push   %ebp
  102571:	89 e5                	mov    %esp,%ebp
  102573:	8b 45 08             	mov    0x8(%ebp),%eax
	_char_out = fn;
  102576:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102579:	89 0d 04 30 14 00    	mov    %ecx,0x143004
}
  10257f:	5d                   	pop    %ebp
  102580:	c3                   	ret    
  102581:	66 90                	xchg   %ax,%ax
  102583:	66 90                	xchg   %ax,%ax
  102585:	66 90                	xchg   %ax,%ax
  102587:	66 90                	xchg   %ax,%ax
  102589:	66 90                	xchg   %ax,%ax
  10258b:	66 90                	xchg   %ax,%ax
  10258d:	66 90                	xchg   %ax,%ax
  10258f:	90                   	nop

00102590 <z_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void z_vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  102590:	55                   	push   %ebp
  102591:	89 e5                	mov    %esp,%ebp
  102593:	53                   	push   %ebx
  102594:	57                   	push   %edi
  102595:	56                   	push   %esi
  102596:	83 e4 f8             	and    $0xfffffff8,%esp
  102599:	83 ec 78             	sub    $0x78,%esp
  10259c:	8b 45 14             	mov    0x14(%ebp),%eax
  10259f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1025a2:	8b 55 0c             	mov    0xc(%ebp),%edx
  1025a5:	8b 75 08             	mov    0x8(%ebp),%esi
	int might_format = 0; /* 1 if encountered a '%' */
  1025a8:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%esp)
  1025af:	00 
	enum pad_type padding = PAD_NONE;
  1025b0:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  1025b7:	00 
	int min_width = -1;
  1025b8:	c7 44 24 68 ff ff ff 	movl   $0xffffffff,0x68(%esp)
  1025bf:	ff 
	char length_mod = 0;
  1025c0:	c6 44 24 67 00       	movb   $0x0,0x67(%esp)

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  1025c5:	8b 45 10             	mov    0x10(%ebp),%eax
  1025c8:	80 38 00             	cmpb   $0x0,(%eax)
  1025cb:	0f 84 23 06 00 00    	je     102bf4 <z_vprintk+0x664>
		if (!might_format) {
  1025d1:	83 7c 24 70 00       	cmpl   $0x0,0x70(%esp)
  1025d6:	0f 85 4b 00 00 00    	jne    102627 <z_vprintk+0x97>
			if (*fmt != '%') {
  1025dc:	8b 45 10             	mov    0x10(%ebp),%eax
  1025df:	0f be 00             	movsbl (%eax),%eax
  1025e2:	83 f8 25             	cmp    $0x25,%eax
  1025e5:	0f 84 1a 00 00 00    	je     102605 <z_vprintk+0x75>
				out((int)*fmt, ctx);
  1025eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1025ee:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1025f1:	0f be 09             	movsbl (%ecx),%ecx
  1025f4:	8b 55 0c             	mov    0xc(%ebp),%edx
  1025f7:	89 0c 24             	mov    %ecx,(%esp)
  1025fa:	89 54 24 04          	mov    %edx,0x4(%esp)
  1025fe:	ff d0                	call   *%eax
			} else {
  102600:	e9 1d 00 00 00       	jmp    102622 <z_vprintk+0x92>
				might_format = 1;
  102605:	c7 44 24 70 01 00 00 	movl   $0x1,0x70(%esp)
  10260c:	00 
				min_width = -1;
  10260d:	c7 44 24 68 ff ff ff 	movl   $0xffffffff,0x68(%esp)
  102614:	ff 
				padding = PAD_NONE;
  102615:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  10261c:	00 
				length_mod = 0;
  10261d:	c6 44 24 67 00       	movb   $0x0,0x67(%esp)
			}
		} else {
  102622:	e9 ba 05 00 00       	jmp    102be1 <z_vprintk+0x651>
			switch (*fmt) {
  102627:	8b 45 10             	mov    0x10(%ebp),%eax
  10262a:	0f be 00             	movsbl (%eax),%eax
  10262d:	83 c0 db             	add    $0xffffffdb,%eax
  102630:	89 c1                	mov    %eax,%ecx
  102632:	83 e9 55             	sub    $0x55,%ecx
  102635:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  102639:	0f 87 6e 05 00 00    	ja     102bad <z_vprintk+0x61d>
  10263f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  102643:	8b 0c 85 b4 30 12 00 	mov    0x1230b4(,%eax,4),%ecx
  10264a:	ff e1                	jmp    *%ecx
			case '-':
				padding = PAD_SPACE_AFTER;
  10264c:	c7 44 24 6c 03 00 00 	movl   $0x3,0x6c(%esp)
  102653:	00 
				goto still_might_format;
  102654:	e9 8d 05 00 00       	jmp    102be6 <z_vprintk+0x656>
			case '0':
				if (min_width < 0 && padding == PAD_NONE) {
  102659:	83 7c 24 68 00       	cmpl   $0x0,0x68(%esp)
  10265e:	0f 8d 18 00 00 00    	jge    10267c <z_vprintk+0xec>
  102664:	83 7c 24 6c 00       	cmpl   $0x0,0x6c(%esp)
  102669:	0f 85 0d 00 00 00    	jne    10267c <z_vprintk+0xec>
					padding = PAD_ZERO_BEFORE;
  10266f:	c7 44 24 6c 01 00 00 	movl   $0x1,0x6c(%esp)
  102676:	00 
					goto still_might_format;
  102677:	e9 6a 05 00 00       	jmp    102be6 <z_vprintk+0x656>
				if (min_width < 0 && padding == PAD_NONE) {
  10267c:	e9 00 00 00 00       	jmp    102681 <z_vprintk+0xf1>
			case '6':
			case '7':
			case '8':
				/* Fall through */
			case '9':
				if (min_width < 0) {
  102681:	83 7c 24 68 00       	cmpl   $0x0,0x68(%esp)
  102686:	0f 8d 12 00 00 00    	jge    10269e <z_vprintk+0x10e>
					min_width = *fmt - '0';
  10268c:	8b 45 10             	mov    0x10(%ebp),%eax
  10268f:	0f be 00             	movsbl (%eax),%eax
  102692:	83 e8 30             	sub    $0x30,%eax
  102695:	89 44 24 68          	mov    %eax,0x68(%esp)
				} else {
  102699:	e9 14 00 00 00       	jmp    1026b2 <z_vprintk+0x122>
					min_width = 10 * min_width + *fmt - '0';
  10269e:	6b 44 24 68 0a       	imul   $0xa,0x68(%esp),%eax
  1026a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1026a6:	0f be 09             	movsbl (%ecx),%ecx
  1026a9:	01 c8                	add    %ecx,%eax
  1026ab:	83 e8 30             	sub    $0x30,%eax
  1026ae:	89 44 24 68          	mov    %eax,0x68(%esp)
				}

				if (padding == PAD_NONE) {
  1026b2:	83 7c 24 6c 00       	cmpl   $0x0,0x6c(%esp)
  1026b7:	0f 85 08 00 00 00    	jne    1026c5 <z_vprintk+0x135>
					padding = PAD_SPACE_BEFORE;
  1026bd:	c7 44 24 6c 02 00 00 	movl   $0x2,0x6c(%esp)
  1026c4:	00 
				}
				goto still_might_format;
  1026c5:	e9 1c 05 00 00       	jmp    102be6 <z_vprintk+0x656>
			case 'h':
			case 'l':
			case 'z':
				if (*fmt == 'h' && length_mod == 'h') {
  1026ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1026cd:	0f be 00             	movsbl (%eax),%eax
  1026d0:	83 f8 68             	cmp    $0x68,%eax
  1026d3:	0f 85 18 00 00 00    	jne    1026f1 <z_vprintk+0x161>
  1026d9:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  1026de:	83 f8 68             	cmp    $0x68,%eax
  1026e1:	0f 85 0a 00 00 00    	jne    1026f1 <z_vprintk+0x161>
					length_mod = 'H';
  1026e7:	c6 44 24 67 48       	movb   $0x48,0x67(%esp)
				} else if (*fmt == 'l' && length_mod == 'l') {
  1026ec:	e9 7e 00 00 00       	jmp    10276f <z_vprintk+0x1df>
  1026f1:	8b 45 10             	mov    0x10(%ebp),%eax
  1026f4:	0f be 00             	movsbl (%eax),%eax
  1026f7:	83 f8 6c             	cmp    $0x6c,%eax
  1026fa:	0f 85 18 00 00 00    	jne    102718 <z_vprintk+0x188>
  102700:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  102705:	83 f8 6c             	cmp    $0x6c,%eax
  102708:	0f 85 0a 00 00 00    	jne    102718 <z_vprintk+0x188>
					length_mod = 'L';
  10270e:	c6 44 24 67 4c       	movb   $0x4c,0x67(%esp)
				} else if (length_mod == 0) {
  102713:	e9 52 00 00 00       	jmp    10276a <z_vprintk+0x1da>
  102718:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  10271d:	83 f8 00             	cmp    $0x0,%eax
  102720:	0f 85 0e 00 00 00    	jne    102734 <z_vprintk+0x1a4>
					length_mod = *fmt;
  102726:	8b 45 10             	mov    0x10(%ebp),%eax
  102729:	8a 08                	mov    (%eax),%cl
  10272b:	88 4c 24 67          	mov    %cl,0x67(%esp)
				} else {
  10272f:	e9 31 00 00 00       	jmp    102765 <z_vprintk+0x1d5>
					out((int)'%', ctx);
  102734:	8b 45 08             	mov    0x8(%ebp),%eax
  102737:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10273a:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  102741:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102745:	ff d0                	call   *%eax
					out((int)*fmt, ctx);
  102747:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10274a:	8b 55 10             	mov    0x10(%ebp),%edx
  10274d:	0f be 12             	movsbl (%edx),%edx
  102750:	8b 75 0c             	mov    0xc(%ebp),%esi
  102753:	89 14 24             	mov    %edx,(%esp)
  102756:	89 74 24 04          	mov    %esi,0x4(%esp)
  10275a:	89 44 24 28          	mov    %eax,0x28(%esp)
  10275e:	ff d1                	call   *%ecx
					break;
  102760:	e9 74 04 00 00       	jmp    102bd9 <z_vprintk+0x649>
  102765:	e9 00 00 00 00       	jmp    10276a <z_vprintk+0x1da>
  10276a:	e9 00 00 00 00       	jmp    10276f <z_vprintk+0x1df>
				}
				goto still_might_format;
  10276f:	e9 72 04 00 00       	jmp    102be6 <z_vprintk+0x656>
			case 'd':
			case 'i': {
				long d;

				if (length_mod == 'z') {
  102774:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  102779:	83 f8 7a             	cmp    $0x7a,%eax
  10277c:	0f 85 16 00 00 00    	jne    102798 <z_vprintk+0x208>
					d = va_arg(ap, ssize_t);
  102782:	8b 45 14             	mov    0x14(%ebp),%eax
  102785:	89 c1                	mov    %eax,%ecx
  102787:	83 c1 04             	add    $0x4,%ecx
  10278a:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10278d:	8b 00                	mov    (%eax),%eax
  10278f:	89 44 24 60          	mov    %eax,0x60(%esp)
				} else if (length_mod == 'l') {
  102793:	e9 c8 00 00 00       	jmp    102860 <z_vprintk+0x2d0>
  102798:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  10279d:	83 f8 6c             	cmp    $0x6c,%eax
  1027a0:	0f 85 16 00 00 00    	jne    1027bc <z_vprintk+0x22c>
					d = va_arg(ap, long);
  1027a6:	8b 45 14             	mov    0x14(%ebp),%eax
  1027a9:	89 c1                	mov    %eax,%ecx
  1027ab:	83 c1 04             	add    $0x4,%ecx
  1027ae:	89 4d 14             	mov    %ecx,0x14(%ebp)
  1027b1:	8b 00                	mov    (%eax),%eax
  1027b3:	89 44 24 60          	mov    %eax,0x60(%esp)
				} else if (length_mod == 'L') {
  1027b7:	e9 9f 00 00 00       	jmp    10285b <z_vprintk+0x2cb>
  1027bc:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  1027c1:	83 f8 4c             	cmp    $0x4c,%eax
  1027c4:	0f 85 7b 00 00 00    	jne    102845 <z_vprintk+0x2b5>
					long long lld = va_arg(ap, long long);
  1027ca:	8b 45 14             	mov    0x14(%ebp),%eax
  1027cd:	89 c1                	mov    %eax,%ecx
  1027cf:	83 c1 08             	add    $0x8,%ecx
  1027d2:	89 4d 14             	mov    %ecx,0x14(%ebp)
  1027d5:	8b 08                	mov    (%eax),%ecx
  1027d7:	8b 40 04             	mov    0x4(%eax),%eax
  1027da:	89 44 24 5c          	mov    %eax,0x5c(%esp)
  1027de:	89 4c 24 58          	mov    %ecx,0x58(%esp)
					if (lld > __LONG_MAX__ ||
  1027e2:	8b 44 24 58          	mov    0x58(%esp),%eax
  1027e6:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  1027ea:	31 d2                	xor    %edx,%edx
  1027ec:	be ff ff ff 7f       	mov    $0x7fffffff,%esi
  1027f1:	29 c6                	sub    %eax,%esi
  1027f3:	19 ca                	sbb    %ecx,%edx
  1027f5:	0f 8c 26 00 00 00    	jl     102821 <z_vprintk+0x291>
  1027fb:	e9 00 00 00 00       	jmp    102800 <z_vprintk+0x270>
					    lld < ~__LONG_MAX__) {
  102800:	8b 44 24 58          	mov    0x58(%esp),%eax
  102804:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  102808:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
  10280d:	29 c2                	sub    %eax,%edx
  10280f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  102814:	19 c8                	sbb    %ecx,%eax
					if (lld > __LONG_MAX__ ||
  102816:	0f 8c 1c 00 00 00    	jl     102838 <z_vprintk+0x2a8>
  10281c:	e9 00 00 00 00       	jmp    102821 <z_vprintk+0x291>
						print_err(out, ctx);
  102821:	8b 45 08             	mov    0x8(%ebp),%eax
  102824:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102827:	89 04 24             	mov    %eax,(%esp)
  10282a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10282e:	e8 cd 03 00 00       	call   102c00 <print_err>
						break;
  102833:	e9 a1 03 00 00       	jmp    102bd9 <z_vprintk+0x649>
					}
					d = lld;
  102838:	8b 44 24 58          	mov    0x58(%esp),%eax
  10283c:	89 44 24 60          	mov    %eax,0x60(%esp)
				} else {
  102840:	e9 11 00 00 00       	jmp    102856 <z_vprintk+0x2c6>
					d = va_arg(ap, int);
  102845:	8b 45 14             	mov    0x14(%ebp),%eax
  102848:	89 c1                	mov    %eax,%ecx
  10284a:	83 c1 04             	add    $0x4,%ecx
  10284d:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102850:	8b 00                	mov    (%eax),%eax
  102852:	89 44 24 60          	mov    %eax,0x60(%esp)
  102856:	e9 00 00 00 00       	jmp    10285b <z_vprintk+0x2cb>
  10285b:	e9 00 00 00 00       	jmp    102860 <z_vprintk+0x2d0>
				}

				if (d < 0) {
  102860:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
  102865:	0f 8d 28 00 00 00    	jge    102893 <z_vprintk+0x303>
					out((int)'-', ctx);
  10286b:	8b 45 08             	mov    0x8(%ebp),%eax
  10286e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102871:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  102878:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10287c:	ff d0                	call   *%eax
  10287e:	31 c9                	xor    %ecx,%ecx
					d = -d;
  102880:	2b 4c 24 60          	sub    0x60(%esp),%ecx
  102884:	89 4c 24 60          	mov    %ecx,0x60(%esp)
					min_width--;
  102888:	8b 4c 24 68          	mov    0x68(%esp),%ecx
  10288c:	83 c1 ff             	add    $0xffffffff,%ecx
  10288f:	89 4c 24 68          	mov    %ecx,0x68(%esp)
				}
				_printk_dec_ulong(out, ctx, d, padding,
  102893:	8b 45 08             	mov    0x8(%ebp),%eax
  102896:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102899:	8b 54 24 60          	mov    0x60(%esp),%edx
  10289d:	8b 74 24 6c          	mov    0x6c(%esp),%esi
						  min_width);
  1028a1:	8b 7c 24 68          	mov    0x68(%esp),%edi
				_printk_dec_ulong(out, ctx, d, padding,
  1028a5:	89 04 24             	mov    %eax,(%esp)
  1028a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1028ac:	89 54 24 08          	mov    %edx,0x8(%esp)
  1028b0:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1028b4:	89 7c 24 10          	mov    %edi,0x10(%esp)
  1028b8:	e8 a3 03 00 00       	call   102c60 <_printk_dec_ulong>
				break;
  1028bd:	e9 17 03 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			case 'u': {
				unsigned long u;

				if (length_mod == 'z') {
  1028c2:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  1028c7:	83 f8 7a             	cmp    $0x7a,%eax
  1028ca:	0f 85 16 00 00 00    	jne    1028e6 <z_vprintk+0x356>
					u = va_arg(ap, size_t);
  1028d0:	8b 45 14             	mov    0x14(%ebp),%eax
  1028d3:	89 c1                	mov    %eax,%ecx
  1028d5:	83 c1 04             	add    $0x4,%ecx
  1028d8:	89 4d 14             	mov    %ecx,0x14(%ebp)
  1028db:	8b 00                	mov    (%eax),%eax
  1028dd:	89 44 24 54          	mov    %eax,0x54(%esp)
				} else if (length_mod == 'l') {
  1028e1:	e9 9a 00 00 00       	jmp    102980 <z_vprintk+0x3f0>
  1028e6:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  1028eb:	83 f8 6c             	cmp    $0x6c,%eax
  1028ee:	0f 85 16 00 00 00    	jne    10290a <z_vprintk+0x37a>
					u = va_arg(ap, unsigned long);
  1028f4:	8b 45 14             	mov    0x14(%ebp),%eax
  1028f7:	89 c1                	mov    %eax,%ecx
  1028f9:	83 c1 04             	add    $0x4,%ecx
  1028fc:	89 4d 14             	mov    %ecx,0x14(%ebp)
  1028ff:	8b 00                	mov    (%eax),%eax
  102901:	89 44 24 54          	mov    %eax,0x54(%esp)
				} else if (length_mod == 'L') {
  102905:	e9 71 00 00 00       	jmp    10297b <z_vprintk+0x3eb>
  10290a:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  10290f:	83 f8 4c             	cmp    $0x4c,%eax
  102912:	0f 85 4d 00 00 00    	jne    102965 <z_vprintk+0x3d5>
					unsigned long long llu =
						va_arg(ap, unsigned long long);
  102918:	8b 45 14             	mov    0x14(%ebp),%eax
  10291b:	89 c1                	mov    %eax,%ecx
  10291d:	83 c1 08             	add    $0x8,%ecx
  102920:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102923:	8b 08                	mov    (%eax),%ecx
  102925:	8b 40 04             	mov    0x4(%eax),%eax
					unsigned long long llu =
  102928:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  10292c:	89 4c 24 48          	mov    %ecx,0x48(%esp)
					if (llu > ~0UL) {
  102930:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  102934:	85 c0                	test   %eax,%eax
  102936:	0f 84 1c 00 00 00    	je     102958 <z_vprintk+0x3c8>
  10293c:	e9 00 00 00 00       	jmp    102941 <z_vprintk+0x3b1>
						print_err(out, ctx);
  102941:	8b 45 08             	mov    0x8(%ebp),%eax
  102944:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102947:	89 04 24             	mov    %eax,(%esp)
  10294a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10294e:	e8 ad 02 00 00       	call   102c00 <print_err>
						break;
  102953:	e9 81 02 00 00       	jmp    102bd9 <z_vprintk+0x649>
					}
					u = llu;
  102958:	8b 44 24 48          	mov    0x48(%esp),%eax
  10295c:	89 44 24 54          	mov    %eax,0x54(%esp)
				} else {
  102960:	e9 11 00 00 00       	jmp    102976 <z_vprintk+0x3e6>
					u = va_arg(ap, unsigned int);
  102965:	8b 45 14             	mov    0x14(%ebp),%eax
  102968:	89 c1                	mov    %eax,%ecx
  10296a:	83 c1 04             	add    $0x4,%ecx
  10296d:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102970:	8b 00                	mov    (%eax),%eax
  102972:	89 44 24 54          	mov    %eax,0x54(%esp)
  102976:	e9 00 00 00 00       	jmp    10297b <z_vprintk+0x3eb>
  10297b:	e9 00 00 00 00       	jmp    102980 <z_vprintk+0x3f0>
				}

				_printk_dec_ulong(out, ctx, u, padding,
  102980:	8b 45 08             	mov    0x8(%ebp),%eax
  102983:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102986:	8b 54 24 54          	mov    0x54(%esp),%edx
  10298a:	8b 74 24 6c          	mov    0x6c(%esp),%esi
						  min_width);
  10298e:	8b 7c 24 68          	mov    0x68(%esp),%edi
				_printk_dec_ulong(out, ctx, u, padding,
  102992:	89 04 24             	mov    %eax,(%esp)
  102995:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102999:	89 54 24 08          	mov    %edx,0x8(%esp)
  10299d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1029a1:	89 7c 24 10          	mov    %edi,0x10(%esp)
  1029a5:	e8 b6 02 00 00       	call   102c60 <_printk_dec_ulong>
				break;
  1029aa:	e9 2a 02 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			case 'p':
				out('0', ctx);
  1029af:	8b 45 08             	mov    0x8(%ebp),%eax
  1029b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1029b5:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  1029bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1029c0:	ff d0                	call   *%eax
				out('x', ctx);
  1029c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1029c5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1029c8:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  1029cf:	89 54 24 04          	mov    %edx,0x4(%esp)
  1029d3:	89 44 24 24          	mov    %eax,0x24(%esp)
  1029d7:	ff d1                	call   *%ecx
				/* left-pad pointers with zeros */
				padding = PAD_ZERO_BEFORE;
  1029d9:	c7 44 24 6c 01 00 00 	movl   $0x1,0x6c(%esp)
  1029e0:	00 
				if (IS_ENABLED(CONFIG_64BIT)) {
					min_width = 16;
				} else {
					min_width = 8;
  1029e1:	c7 44 24 68 08 00 00 	movl   $0x8,0x68(%esp)
  1029e8:	00 
				/* Fall through */
			case 'x':
			case 'X': {
				unsigned long long x;

				if (*fmt == 'p') {
  1029e9:	8b 45 10             	mov    0x10(%ebp),%eax
  1029ec:	0f be 00             	movsbl (%eax),%eax
  1029ef:	83 f8 70             	cmp    $0x70,%eax
  1029f2:	0f 85 1e 00 00 00    	jne    102a16 <z_vprintk+0x486>
					x = (uintptr_t)va_arg(ap, void *);
  1029f8:	8b 45 14             	mov    0x14(%ebp),%eax
  1029fb:	89 c1                	mov    %eax,%ecx
  1029fd:	83 c1 04             	add    $0x4,%ecx
  102a00:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102a03:	8b 00                	mov    (%eax),%eax
  102a05:	89 44 24 40          	mov    %eax,0x40(%esp)
  102a09:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
  102a10:	00 
				} else if (length_mod == 'l') {
  102a11:	e9 7a 00 00 00       	jmp    102a90 <z_vprintk+0x500>
  102a16:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  102a1b:	83 f8 6c             	cmp    $0x6c,%eax
  102a1e:	0f 85 1e 00 00 00    	jne    102a42 <z_vprintk+0x4b2>
					x = va_arg(ap, unsigned long);
  102a24:	8b 45 14             	mov    0x14(%ebp),%eax
  102a27:	89 c1                	mov    %eax,%ecx
  102a29:	83 c1 04             	add    $0x4,%ecx
  102a2c:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102a2f:	8b 00                	mov    (%eax),%eax
  102a31:	89 44 24 40          	mov    %eax,0x40(%esp)
  102a35:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
  102a3c:	00 
				} else if (length_mod == 'L') {
  102a3d:	e9 49 00 00 00       	jmp    102a8b <z_vprintk+0x4fb>
  102a42:	0f be 44 24 67       	movsbl 0x67(%esp),%eax
  102a47:	83 f8 4c             	cmp    $0x4c,%eax
  102a4a:	0f 85 1d 00 00 00    	jne    102a6d <z_vprintk+0x4dd>
					x = va_arg(ap, unsigned long long);
  102a50:	8b 45 14             	mov    0x14(%ebp),%eax
  102a53:	89 c1                	mov    %eax,%ecx
  102a55:	83 c1 08             	add    $0x8,%ecx
  102a58:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102a5b:	8b 08                	mov    (%eax),%ecx
  102a5d:	8b 40 04             	mov    0x4(%eax),%eax
  102a60:	89 44 24 44          	mov    %eax,0x44(%esp)
  102a64:	89 4c 24 40          	mov    %ecx,0x40(%esp)
				} else {
  102a68:	e9 19 00 00 00       	jmp    102a86 <z_vprintk+0x4f6>
					x = va_arg(ap, unsigned int);
  102a6d:	8b 45 14             	mov    0x14(%ebp),%eax
  102a70:	89 c1                	mov    %eax,%ecx
  102a72:	83 c1 04             	add    $0x4,%ecx
  102a75:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102a78:	8b 00                	mov    (%eax),%eax
  102a7a:	89 44 24 40          	mov    %eax,0x40(%esp)
  102a7e:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
  102a85:	00 
  102a86:	e9 00 00 00 00       	jmp    102a8b <z_vprintk+0x4fb>
  102a8b:	e9 00 00 00 00       	jmp    102a90 <z_vprintk+0x500>
				}

				_printk_hex_ulong(out, ctx, x, padding,
  102a90:	8b 45 08             	mov    0x8(%ebp),%eax
  102a93:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102a96:	8b 54 24 40          	mov    0x40(%esp),%edx
  102a9a:	8b 74 24 44          	mov    0x44(%esp),%esi
  102a9e:	8b 7c 24 6c          	mov    0x6c(%esp),%edi
						  min_width);
  102aa2:	8b 5c 24 68          	mov    0x68(%esp),%ebx
  102aa6:	89 44 24 20          	mov    %eax,0x20(%esp)
				_printk_hex_ulong(out, ctx, x, padding,
  102aaa:	89 e0                	mov    %esp,%eax
  102aac:	89 58 14             	mov    %ebx,0x14(%eax)
  102aaf:	89 78 10             	mov    %edi,0x10(%eax)
  102ab2:	89 70 0c             	mov    %esi,0xc(%eax)
  102ab5:	89 50 08             	mov    %edx,0x8(%eax)
  102ab8:	89 48 04             	mov    %ecx,0x4(%eax)
  102abb:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  102abf:	89 08                	mov    %ecx,(%eax)
  102ac1:	e8 3a 03 00 00       	call   102e00 <_printk_hex_ulong>
				break;
  102ac6:	e9 0e 01 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  102acb:	8b 45 14             	mov    0x14(%ebp),%eax
  102ace:	89 c1                	mov    %eax,%ecx
  102ad0:	83 c1 04             	add    $0x4,%ecx
  102ad3:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102ad6:	8b 00                	mov    (%eax),%eax
  102ad8:	89 44 24 3c          	mov    %eax,0x3c(%esp)
				char *start = s;
  102adc:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  102ae0:	89 44 24 38          	mov    %eax,0x38(%esp)

				while (*s) {
  102ae4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  102ae8:	80 38 00             	cmpb   $0x0,(%eax)
  102aeb:	0f 84 24 00 00 00    	je     102b15 <z_vprintk+0x585>
					out((int)(*s++), ctx);
  102af1:	8b 45 08             	mov    0x8(%ebp),%eax
  102af4:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  102af8:	89 ca                	mov    %ecx,%edx
  102afa:	83 c2 01             	add    $0x1,%edx
  102afd:	89 54 24 3c          	mov    %edx,0x3c(%esp)
  102b01:	0f be 09             	movsbl (%ecx),%ecx
  102b04:	8b 55 0c             	mov    0xc(%ebp),%edx
  102b07:	89 0c 24             	mov    %ecx,(%esp)
  102b0a:	89 54 24 04          	mov    %edx,0x4(%esp)
  102b0e:	ff d0                	call   *%eax
				while (*s) {
  102b10:	e9 cf ff ff ff       	jmp    102ae4 <z_vprintk+0x554>
				}

				if (padding == PAD_SPACE_AFTER) {
  102b15:	83 7c 24 6c 03       	cmpl   $0x3,0x6c(%esp)
  102b1a:	0f 85 47 00 00 00    	jne    102b67 <z_vprintk+0x5d7>
					int remaining = min_width - (s - start);
  102b20:	8b 44 24 68          	mov    0x68(%esp),%eax
  102b24:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  102b28:	8b 54 24 38          	mov    0x38(%esp),%edx
  102b2c:	29 d1                	sub    %edx,%ecx
  102b2e:	29 c8                	sub    %ecx,%eax
  102b30:	89 44 24 34          	mov    %eax,0x34(%esp)
					while (remaining-- > 0) {
  102b34:	8b 44 24 34          	mov    0x34(%esp),%eax
  102b38:	89 c1                	mov    %eax,%ecx
  102b3a:	83 c1 ff             	add    $0xffffffff,%ecx
  102b3d:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  102b41:	83 f8 00             	cmp    $0x0,%eax
  102b44:	0f 8e 18 00 00 00    	jle    102b62 <z_vprintk+0x5d2>
						out(' ', ctx);
  102b4a:	8b 45 08             	mov    0x8(%ebp),%eax
  102b4d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102b50:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  102b57:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102b5b:	ff d0                	call   *%eax
					while (remaining-- > 0) {
  102b5d:	e9 d2 ff ff ff       	jmp    102b34 <z_vprintk+0x5a4>
					}
				}
  102b62:	e9 00 00 00 00       	jmp    102b67 <z_vprintk+0x5d7>
				break;
  102b67:	e9 6d 00 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			case 'c': {
				int c = va_arg(ap, int);
  102b6c:	8b 45 14             	mov    0x14(%ebp),%eax
  102b6f:	89 c1                	mov    %eax,%ecx
  102b71:	83 c1 04             	add    $0x4,%ecx
  102b74:	89 4d 14             	mov    %ecx,0x14(%ebp)
  102b77:	8b 00                	mov    (%eax),%eax
  102b79:	89 44 24 30          	mov    %eax,0x30(%esp)

				out(c, ctx);
  102b7d:	8b 45 08             	mov    0x8(%ebp),%eax
  102b80:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  102b84:	8b 55 0c             	mov    0xc(%ebp),%edx
  102b87:	89 0c 24             	mov    %ecx,(%esp)
  102b8a:	89 54 24 04          	mov    %edx,0x4(%esp)
  102b8e:	ff d0                	call   *%eax
				break;
  102b90:	e9 44 00 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			case '%': {
				out((int)'%', ctx);
  102b95:	8b 45 08             	mov    0x8(%ebp),%eax
  102b98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102b9b:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  102ba2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102ba6:	ff d0                	call   *%eax
				break;
  102ba8:	e9 2c 00 00 00       	jmp    102bd9 <z_vprintk+0x649>
			}
			default:
				out((int)'%', ctx);
  102bad:	8b 45 08             	mov    0x8(%ebp),%eax
  102bb0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102bb3:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  102bba:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102bbe:	ff d0                	call   *%eax
				out((int)*fmt, ctx);
  102bc0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102bc3:	8b 55 10             	mov    0x10(%ebp),%edx
  102bc6:	0f be 12             	movsbl (%edx),%edx
  102bc9:	8b 75 0c             	mov    0xc(%ebp),%esi
  102bcc:	89 14 24             	mov    %edx,(%esp)
  102bcf:	89 74 24 04          	mov    %esi,0x4(%esp)
  102bd3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  102bd7:	ff d1                	call   *%ecx
				break;
			}
			might_format = 0;
  102bd9:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%esp)
  102be0:	00 
		if (!might_format) {
  102be1:	e9 00 00 00 00       	jmp    102be6 <z_vprintk+0x656>
		}
still_might_format:
		++fmt;
  102be6:	8b 45 10             	mov    0x10(%ebp),%eax
  102be9:	83 c0 01             	add    $0x1,%eax
  102bec:	89 45 10             	mov    %eax,0x10(%ebp)
	while (*fmt) {
  102bef:	e9 d1 f9 ff ff       	jmp    1025c5 <z_vprintk+0x35>
	}
}
  102bf4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102bf7:	5e                   	pop    %esi
  102bf8:	5f                   	pop    %edi
  102bf9:	5b                   	pop    %ebx
  102bfa:	5d                   	pop    %ebp
  102bfb:	c3                   	ret    
  102bfc:	66 90                	xchg   %ax,%ax
  102bfe:	66 90                	xchg   %ax,%ax

00102c00 <print_err>:
{
  102c00:	55                   	push   %ebp
  102c01:	89 e5                	mov    %esp,%ebp
  102c03:	56                   	push   %esi
  102c04:	83 ec 18             	sub    $0x18,%esp
  102c07:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	out('E', ctx);
  102c0d:	8b 55 08             	mov    0x8(%ebp),%edx
  102c10:	8b 75 0c             	mov    0xc(%ebp),%esi
  102c13:	c7 04 24 45 00 00 00 	movl   $0x45,(%esp)
  102c1a:	89 74 24 04          	mov    %esi,0x4(%esp)
  102c1e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102c21:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102c24:	ff d2                	call   *%edx
	out('R', ctx);
  102c26:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102c29:	8b 55 0c             	mov    0xc(%ebp),%edx
  102c2c:	c7 04 24 52 00 00 00 	movl   $0x52,(%esp)
  102c33:	89 54 24 04          	mov    %edx,0x4(%esp)
  102c37:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102c3a:	ff d1                	call   *%ecx
	out('R', ctx);
  102c3c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102c3f:	8b 55 0c             	mov    0xc(%ebp),%edx
  102c42:	c7 04 24 52 00 00 00 	movl   $0x52,(%esp)
  102c49:	89 54 24 04          	mov    %edx,0x4(%esp)
  102c4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102c50:	ff d1                	call   *%ecx
}
  102c52:	83 c4 18             	add    $0x18,%esp
  102c55:	5e                   	pop    %esi
  102c56:	5d                   	pop    %ebp
  102c57:	c3                   	ret    
  102c58:	66 90                	xchg   %ax,%ax
  102c5a:	66 90                	xchg   %ax,%ax
  102c5c:	66 90                	xchg   %ax,%ax
  102c5e:	66 90                	xchg   %ax,%ax

00102c60 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
  102c60:	55                   	push   %ebp
  102c61:	89 e5                	mov    %esp,%ebp
  102c63:	53                   	push   %ebx
  102c64:	57                   	push   %edi
  102c65:	56                   	push   %esi
  102c66:	83 ec 30             	sub    $0x30,%esp
  102c69:	8b 45 18             	mov    0x18(%ebp),%eax
  102c6c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  102c6f:	8b 55 10             	mov    0x10(%ebp),%edx
  102c72:	8b 75 0c             	mov    0xc(%ebp),%esi
  102c75:	8b 7d 08             	mov    0x8(%ebp),%edi
	unsigned long pos = 1000000000;
  102c78:	c7 45 f0 00 ca 9a 3b 	movl   $0x3b9aca00,-0x10(%ebp)
	unsigned long remainder = num;
  102c7f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  102c82:	89 5d ec             	mov    %ebx,-0x14(%ebp)
	int found_largest_digit = 0;
  102c85:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int remaining = sizeof(long) * 5 / 2;
  102c8c:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
	int digits = 1;
  102c93:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (sizeof(long) == 8) {
		pos *= 10000000000;
	}

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  102c9a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  102c9e:	0f 8f 07 00 00 00    	jg     102cab <_printk_dec_ulong+0x4b>
		min_width = 1;
  102ca4:	c7 45 18 01 00 00 00 	movl   $0x1,0x18(%ebp)
	}

	while (pos >= 10) {
  102cab:	e9 00 00 00 00       	jmp    102cb0 <_printk_dec_ulong+0x50>
  102cb0:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
  102cb4:	0f 82 df 00 00 00    	jb     102d99 <_printk_dec_ulong+0x139>
		if (found_largest_digit != 0 || remainder >= pos) {
  102cba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  102cbe:	0f 85 0c 00 00 00    	jne    102cd0 <_printk_dec_ulong+0x70>
  102cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102cc7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  102cca:	0f 82 37 00 00 00    	jb     102d07 <_printk_dec_ulong+0xa7>
			found_largest_digit = 1;
  102cd0:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
			out((int)(remainder / pos + 48), ctx);
  102cd7:	8b 45 08             	mov    0x8(%ebp),%eax
  102cda:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102cdd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102ce0:	89 c8                	mov    %ecx,%eax
  102ce2:	31 d2                	xor    %edx,%edx
  102ce4:	f7 75 f0             	divl   -0x10(%ebp)
  102ce7:	83 c0 30             	add    $0x30,%eax
  102cea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102ced:	89 04 24             	mov    %eax,(%esp)
  102cf0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102cf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102cf7:	ff d0                	call   *%eax
			digits++;
  102cf9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  102cfc:	83 c1 01             	add    $0x1,%ecx
  102cff:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		} else if (remaining <= min_width
  102d02:	e9 5e 00 00 00       	jmp    102d65 <_printk_dec_ulong+0x105>
  102d07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102d0a:	3b 45 18             	cmp    0x18(%ebp),%eax
				&& padding < PAD_SPACE_AFTER) {
  102d0d:	0f 8f 4d 00 00 00    	jg     102d60 <_printk_dec_ulong+0x100>
  102d13:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
		} else if (remaining <= min_width
  102d17:	0f 83 43 00 00 00    	jae    102d60 <_printk_dec_ulong+0x100>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
  102d1d:	8b 45 08             	mov    0x8(%ebp),%eax
  102d20:	8b 4d 14             	mov    0x14(%ebp),%ecx
  102d23:	83 f9 01             	cmp    $0x1,%ecx
  102d26:	b9 20 00 00 00       	mov    $0x20,%ecx
  102d2b:	ba 30 00 00 00       	mov    $0x30,%edx
  102d30:	89 45 d8             	mov    %eax,-0x28(%ebp)
  102d33:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  102d36:	89 55 d0             	mov    %edx,-0x30(%ebp)
  102d39:	0f 84 06 00 00 00    	je     102d45 <_printk_dec_ulong+0xe5>
  102d3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102d42:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102d45:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102d48:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102d4b:	89 04 24             	mov    %eax,(%esp)
  102d4e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102d52:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102d55:	ff d0                	call   *%eax
			digits++;
  102d57:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  102d5a:	83 c1 01             	add    $0x1,%ecx
  102d5d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  102d60:	e9 00 00 00 00       	jmp    102d65 <_printk_dec_ulong+0x105>
		}
		remaining--;
  102d65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102d68:	83 c0 ff             	add    $0xffffffff,%eax
  102d6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		remainder %= pos;
  102d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d71:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102d74:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102d77:	89 c8                	mov    %ecx,%eax
  102d79:	31 d2                	xor    %edx,%edx
  102d7b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  102d7e:	f7 f1                	div    %ecx
  102d80:	89 55 ec             	mov    %edx,-0x14(%ebp)
		pos /= 10;
  102d83:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102d86:	89 d0                	mov    %edx,%eax
  102d88:	31 d2                	xor    %edx,%edx
  102d8a:	be 0a 00 00 00       	mov    $0xa,%esi
  102d8f:	f7 f6                	div    %esi
  102d91:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (pos >= 10) {
  102d94:	e9 17 ff ff ff       	jmp    102cb0 <_printk_dec_ulong+0x50>
	}
	out((int)(remainder + 48), ctx);
  102d99:	8b 45 08             	mov    0x8(%ebp),%eax
  102d9c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102d9f:	83 c1 30             	add    $0x30,%ecx
  102da2:	8b 55 0c             	mov    0xc(%ebp),%edx
  102da5:	89 0c 24             	mov    %ecx,(%esp)
  102da8:	89 54 24 04          	mov    %edx,0x4(%esp)
  102dac:	ff d0                	call   *%eax

	if (padding == PAD_SPACE_AFTER) {
  102dae:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
  102db2:	0f 85 3a 00 00 00    	jne    102df2 <_printk_dec_ulong+0x192>
		remaining = min_width - digits;
  102db8:	8b 45 18             	mov    0x18(%ebp),%eax
  102dbb:	2b 45 e0             	sub    -0x20(%ebp),%eax
  102dbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		while (remaining-- > 0) {
  102dc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102dc4:	89 c1                	mov    %eax,%ecx
  102dc6:	83 c1 ff             	add    $0xffffffff,%ecx
  102dc9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  102dcc:	83 f8 00             	cmp    $0x0,%eax
  102dcf:	0f 8e 18 00 00 00    	jle    102ded <_printk_dec_ulong+0x18d>
			out(' ', ctx);
  102dd5:	8b 45 08             	mov    0x8(%ebp),%eax
  102dd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102ddb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  102de2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102de6:	ff d0                	call   *%eax
		while (remaining-- > 0) {
  102de8:	e9 d4 ff ff ff       	jmp    102dc1 <_printk_dec_ulong+0x161>
		}
	}
  102ded:	e9 00 00 00 00       	jmp    102df2 <_printk_dec_ulong+0x192>
}
  102df2:	83 c4 30             	add    $0x30,%esp
  102df5:	5e                   	pop    %esi
  102df6:	5f                   	pop    %edi
  102df7:	5b                   	pop    %ebx
  102df8:	5d                   	pop    %ebp
  102df9:	c3                   	ret    
  102dfa:	66 90                	xchg   %ax,%ax
  102dfc:	66 90                	xchg   %ax,%ax
  102dfe:	66 90                	xchg   %ax,%ax

00102e00 <_printk_hex_ulong>:
{
  102e00:	55                   	push   %ebp
  102e01:	89 e5                	mov    %esp,%ebp
  102e03:	53                   	push   %ebx
  102e04:	57                   	push   %edi
  102e05:	56                   	push   %esi
  102e06:	83 e4 f8             	and    $0xfffffff8,%esp
  102e09:	83 ec 40             	sub    $0x40,%esp
  102e0c:	8b 45 10             	mov    0x10(%ebp),%eax
  102e0f:	8b 4d 14             	mov    0x14(%ebp),%ecx
  102e12:	8b 55 1c             	mov    0x1c(%ebp),%edx
  102e15:	8b 75 18             	mov    0x18(%ebp),%esi
  102e18:	8b 7d 0c             	mov    0xc(%ebp),%edi
  102e1b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  102e1e:	89 44 24 30          	mov    %eax,0x30(%esp)
  102e22:	89 4c 24 34          	mov    %ecx,0x34(%esp)
	int shift = sizeof(num) * 8;
  102e26:	c7 44 24 2c 40 00 00 	movl   $0x40,0x2c(%esp)
  102e2d:	00 
	int found_largest_digit = 0;
  102e2e:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  102e35:	00 
	int remaining = 16; /* 16 digits max */
  102e36:	c7 44 24 24 10 00 00 	movl   $0x10,0x24(%esp)
  102e3d:	00 
	int digits = 0;
  102e3e:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
  102e45:	00 
	while (shift >= 4) {
  102e46:	83 7c 24 2c 04       	cmpl   $0x4,0x2c(%esp)
  102e4b:	0f 8c 3a 01 00 00    	jl     102f8b <_printk_hex_ulong+0x18b>
		shift -= 4;
  102e51:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  102e55:	83 c0 fc             	add    $0xfffffffc,%eax
  102e58:	89 44 24 2c          	mov    %eax,0x2c(%esp)
		nibble = (num >> shift) & 0xf;
  102e5c:	8b 44 24 30          	mov    0x30(%esp),%eax
  102e60:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  102e64:	8a 54 24 2c          	mov    0x2c(%esp),%dl
  102e68:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  102e6c:	88 d1                	mov    %dl,%cl
  102e6e:	8b 74 24 18          	mov    0x18(%esp),%esi
  102e72:	d3 ee                	shr    %cl,%esi
  102e74:	88 d1                	mov    %dl,%cl
  102e76:	8b 7c 24 18          	mov    0x18(%esp),%edi
  102e7a:	0f ad f8             	shrd   %cl,%edi,%eax
  102e7d:	f6 c2 20             	test   $0x20,%dl
  102e80:	89 44 24 14          	mov    %eax,0x14(%esp)
  102e84:	89 74 24 10          	mov    %esi,0x10(%esp)
  102e88:	0f 85 08 00 00 00    	jne    102e96 <_printk_hex_ulong+0x96>
  102e8e:	8b 44 24 14          	mov    0x14(%esp),%eax
  102e92:	89 44 24 10          	mov    %eax,0x10(%esp)
  102e96:	8b 44 24 10          	mov    0x10(%esp),%eax
  102e9a:	24 0f                	and    $0xf,%al
  102e9c:	88 44 24 1f          	mov    %al,0x1f(%esp)
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
  102ea0:	0f be 4c 24 1f       	movsbl 0x1f(%esp),%ecx
  102ea5:	83 f9 00             	cmp    $0x0,%ecx
  102ea8:	0f 85 16 00 00 00    	jne    102ec4 <_printk_hex_ulong+0xc4>
  102eae:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  102eb3:	0f 85 0b 00 00 00    	jne    102ec4 <_printk_hex_ulong+0xc4>
  102eb9:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
  102ebe:	0f 85 63 00 00 00    	jne    102f27 <_printk_hex_ulong+0x127>
			found_largest_digit = 1;
  102ec4:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
  102ecb:	00 
			nibble += nibble > 9 ? 87 : 48;
  102ecc:	0f be 44 24 1f       	movsbl 0x1f(%esp),%eax
  102ed1:	83 f8 09             	cmp    $0x9,%eax
  102ed4:	b8 30 00 00 00       	mov    $0x30,%eax
  102ed9:	b9 57 00 00 00       	mov    $0x57,%ecx
  102ede:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102ee2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  102ee6:	0f 8f 08 00 00 00    	jg     102ef4 <_printk_hex_ulong+0xf4>
  102eec:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102ef0:	89 44 24 08          	mov    %eax,0x8(%esp)
  102ef4:	8b 44 24 08          	mov    0x8(%esp),%eax
  102ef8:	0f be 4c 24 1f       	movsbl 0x1f(%esp),%ecx
  102efd:	01 c1                	add    %eax,%ecx
  102eff:	88 4c 24 1f          	mov    %cl,0x1f(%esp)
			out((int)nibble, ctx);
  102f03:	8b 45 08             	mov    0x8(%ebp),%eax
  102f06:	0f be 54 24 1f       	movsbl 0x1f(%esp),%edx
  102f0b:	8b 75 0c             	mov    0xc(%ebp),%esi
  102f0e:	89 14 24             	mov    %edx,(%esp)
  102f11:	89 74 24 04          	mov    %esi,0x4(%esp)
  102f15:	ff d0                	call   *%eax
			digits++;
  102f17:	8b 54 24 20          	mov    0x20(%esp),%edx
  102f1b:	83 c2 01             	add    $0x1,%edx
  102f1e:	89 54 24 20          	mov    %edx,0x20(%esp)
			continue;
  102f22:	e9 1f ff ff ff       	jmp    102e46 <_printk_hex_ulong+0x46>
		if (remaining-- <= min_width) {
  102f27:	8b 44 24 24          	mov    0x24(%esp),%eax
  102f2b:	89 c1                	mov    %eax,%ecx
  102f2d:	83 c1 ff             	add    $0xffffffff,%ecx
  102f30:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  102f34:	3b 45 1c             	cmp    0x1c(%ebp),%eax
  102f37:	0f 8f 49 00 00 00    	jg     102f86 <_printk_hex_ulong+0x186>
			if (padding == PAD_ZERO_BEFORE) {
  102f3d:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
  102f41:	0f 85 18 00 00 00    	jne    102f5f <_printk_hex_ulong+0x15f>
				out('0', ctx);
  102f47:	8b 45 08             	mov    0x8(%ebp),%eax
  102f4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102f4d:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  102f54:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102f58:	ff d0                	call   *%eax
			} else if (padding == PAD_SPACE_BEFORE) {
  102f5a:	e9 22 00 00 00       	jmp    102f81 <_printk_hex_ulong+0x181>
  102f5f:	83 7d 18 02          	cmpl   $0x2,0x18(%ebp)
  102f63:	0f 85 13 00 00 00    	jne    102f7c <_printk_hex_ulong+0x17c>
				out(' ', ctx);
  102f69:	8b 45 08             	mov    0x8(%ebp),%eax
  102f6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102f6f:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  102f76:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102f7a:	ff d0                	call   *%eax
  102f7c:	e9 00 00 00 00       	jmp    102f81 <_printk_hex_ulong+0x181>
		}
  102f81:	e9 00 00 00 00       	jmp    102f86 <_printk_hex_ulong+0x186>
	while (shift >= 4) {
  102f86:	e9 bb fe ff ff       	jmp    102e46 <_printk_hex_ulong+0x46>
	if (padding == PAD_SPACE_AFTER) {
  102f8b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  102f8f:	0f 85 41 00 00 00    	jne    102fd6 <_printk_hex_ulong+0x1d6>
		remaining = min_width * 2 - digits;
  102f95:	8b 45 1c             	mov    0x1c(%ebp),%eax
  102f98:	c1 e0 01             	shl    $0x1,%eax
  102f9b:	2b 44 24 20          	sub    0x20(%esp),%eax
  102f9f:	89 44 24 24          	mov    %eax,0x24(%esp)
		while (remaining-- > 0) {
  102fa3:	8b 44 24 24          	mov    0x24(%esp),%eax
  102fa7:	89 c1                	mov    %eax,%ecx
  102fa9:	83 c1 ff             	add    $0xffffffff,%ecx
  102fac:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  102fb0:	83 f8 00             	cmp    $0x0,%eax
  102fb3:	0f 8e 18 00 00 00    	jle    102fd1 <_printk_hex_ulong+0x1d1>
			out(' ', ctx);
  102fb9:	8b 45 08             	mov    0x8(%ebp),%eax
  102fbc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102fbf:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  102fc6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102fca:	ff d0                	call   *%eax
		while (remaining-- > 0) {
  102fcc:	e9 d2 ff ff ff       	jmp    102fa3 <_printk_hex_ulong+0x1a3>
	}
  102fd1:	e9 00 00 00 00       	jmp    102fd6 <_printk_hex_ulong+0x1d6>
}
  102fd6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102fd9:	5e                   	pop    %esi
  102fda:	5f                   	pop    %edi
  102fdb:	5b                   	pop    %ebx
  102fdc:	5d                   	pop    %ebp
  102fdd:	c3                   	ret    
  102fde:	66 90                	xchg   %ax,%ax

00102fe0 <vprintk>:
{
  102fe0:	55                   	push   %ebp
  102fe1:	89 e5                	mov    %esp,%ebp
  102fe3:	57                   	push   %edi
  102fe4:	56                   	push   %esi
  102fe5:	83 e4 f8             	and    $0xfffffff8,%esp
  102fe8:	83 ec 28             	sub    $0x28,%esp
  102feb:	8b 45 0c             	mov    0xc(%ebp),%eax
  102fee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102ff1:	31 d2                	xor    %edx,%edx
	struct out_context ctx = { 0 };
  102ff3:	8d 74 24 20          	lea    0x20(%esp),%esi
  102ff7:	89 f7                	mov    %esi,%edi
  102ff9:	89 3c 24             	mov    %edi,(%esp)
  102ffc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103003:	00 
  103004:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10300b:	00 
  10300c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  103010:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  103014:	89 54 24 14          	mov    %edx,0x14(%esp)
  103018:	89 74 24 10          	mov    %esi,0x10(%esp)
  10301c:	e8 4f 74 00 00       	call   10a470 <memset>
  103021:	8b 44 24 10          	mov    0x10(%esp),%eax
	z_vprintk(char_out, &ctx, fmt, ap);
  103025:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103028:	8b 55 0c             	mov    0xc(%ebp),%edx
  10302b:	8d 35 50 30 10 00    	lea    0x103050,%esi
  103031:	89 34 24             	mov    %esi,(%esp)
  103034:	89 44 24 04          	mov    %eax,0x4(%esp)
  103038:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10303c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  103040:	e8 4b f5 ff ff       	call   102590 <z_vprintk>
}
  103045:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103048:	5e                   	pop    %esi
  103049:	5f                   	pop    %edi
  10304a:	5d                   	pop    %ebp
  10304b:	c3                   	ret    
  10304c:	66 90                	xchg   %ax,%ax
  10304e:	66 90                	xchg   %ax,%ax

00103050 <char_out>:
{
  103050:	55                   	push   %ebp
  103051:	89 e5                	mov    %esp,%ebp
  103053:	56                   	push   %esi
  103054:	83 ec 10             	sub    $0x10,%esp
  103057:	8b 45 0c             	mov    0xc(%ebp),%eax
  10305a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct out_context *ctx = ctx_p;
  10305d:	8b 55 0c             	mov    0xc(%ebp),%edx
  103060:	89 55 f8             	mov    %edx,-0x8(%ebp)
	ctx->count++;
  103063:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103066:	8b 32                	mov    (%edx),%esi
  103068:	83 c6 01             	add    $0x1,%esi
  10306b:	89 32                	mov    %esi,(%edx)
	return _char_out(c);
  10306d:	8b 15 04 30 14 00    	mov    0x143004,%edx
  103073:	8b 75 08             	mov    0x8(%ebp),%esi
  103076:	89 34 24             	mov    %esi,(%esp)
  103079:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10307c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10307f:	ff d2                	call   *%edx
  103081:	83 c4 10             	add    $0x10,%esp
  103084:	5e                   	pop    %esi
  103085:	5d                   	pop    %ebp
  103086:	c3                   	ret    
  103087:	66 90                	xchg   %ax,%ax
  103089:	66 90                	xchg   %ax,%ax
  10308b:	66 90                	xchg   %ax,%ax
  10308d:	66 90                	xchg   %ax,%ax
  10308f:	90                   	nop

00103090 <printk>:
{
  103090:	55                   	push   %ebp
  103091:	89 e5                	mov    %esp,%ebp
  103093:	56                   	push   %esi
  103094:	83 ec 10             	sub    $0x10,%esp
  103097:	8b 45 08             	mov    0x8(%ebp),%eax
  10309a:	8d 4d 0c             	lea    0xc(%ebp),%ecx
	va_start(ap, fmt);
  10309d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
		vprintk(fmt, ap);
  1030a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1030a3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1030a6:	89 e6                	mov    %esp,%esi
  1030a8:	89 56 04             	mov    %edx,0x4(%esi)
  1030ab:	89 0e                	mov    %ecx,(%esi)
  1030ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1030b0:	e8 2b ff ff ff       	call   102fe0 <vprintk>
}
  1030b5:	83 c4 10             	add    $0x10,%esp
  1030b8:	5e                   	pop    %esi
  1030b9:	5d                   	pop    %ebp
  1030ba:	c3                   	ret    
  1030bb:	66 90                	xchg   %ax,%ax
  1030bd:	66 90                	xchg   %ax,%ax
  1030bf:	90                   	nop

001030c0 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
  1030c0:	55                   	push   %ebp
  1030c1:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  1030c3:	5d                   	pop    %ebp
  1030c4:	c3                   	ret    
  1030c5:	66 90                	xchg   %ax,%ax
  1030c7:	66 90                	xchg   %ax,%ax
  1030c9:	66 90                	xchg   %ax,%ax
  1030cb:	66 90                	xchg   %ax,%ax
  1030cd:	66 90                	xchg   %ax,%ax
  1030cf:	90                   	nop

001030d0 <log_list_init>:
 */

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
  1030d0:	55                   	push   %ebp
  1030d1:	89 e5                	mov    %esp,%ebp
  1030d3:	8b 45 08             	mov    0x8(%ebp),%eax
	list->tail = NULL;
  1030d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1030d9:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	list->head = NULL;
  1030e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1030e3:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
}
  1030e9:	5d                   	pop    %ebp
  1030ea:	c3                   	ret    
  1030eb:	66 90                	xchg   %ax,%ax
  1030ed:	66 90                	xchg   %ax,%ax
  1030ef:	90                   	nop

001030f0 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
  1030f0:	55                   	push   %ebp
  1030f1:	89 e5                	mov    %esp,%ebp
  1030f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1030f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (list->head == NULL) {
  1030f9:	8b 55 08             	mov    0x8(%ebp),%edx
  1030fc:	83 3a 00             	cmpl   $0x0,(%edx)
  1030ff:	0f 85 0d 00 00 00    	jne    103112 <log_list_add_tail+0x22>
		list->head = msg;
  103105:	8b 45 0c             	mov    0xc(%ebp),%eax
  103108:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10310b:	89 01                	mov    %eax,(%ecx)
	} else {
  10310d:	e9 0b 00 00 00       	jmp    10311d <log_list_add_tail+0x2d>
		list->tail->next = msg;
  103112:	8b 45 0c             	mov    0xc(%ebp),%eax
  103115:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103118:	8b 49 04             	mov    0x4(%ecx),%ecx
  10311b:	89 01                	mov    %eax,(%ecx)
	}

	list->tail = msg;
  10311d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103120:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103123:	89 41 04             	mov    %eax,0x4(%ecx)
	msg->next = NULL;
  103126:	8b 45 0c             	mov    0xc(%ebp),%eax
  103129:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10312f:	5d                   	pop    %ebp
  103130:	c3                   	ret    
  103131:	66 90                	xchg   %ax,%ax
  103133:	66 90                	xchg   %ax,%ax
  103135:	66 90                	xchg   %ax,%ax
  103137:	66 90                	xchg   %ax,%ax
  103139:	66 90                	xchg   %ax,%ax
  10313b:	66 90                	xchg   %ax,%ax
  10313d:	66 90                	xchg   %ax,%ax
  10313f:	90                   	nop

00103140 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
  103140:	55                   	push   %ebp
  103141:	89 e5                	mov    %esp,%ebp
  103143:	50                   	push   %eax
  103144:	8b 45 08             	mov    0x8(%ebp),%eax
	return list->head;
  103147:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10314a:	8b 09                	mov    (%ecx),%ecx
  10314c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10314f:	89 c8                	mov    %ecx,%eax
  103151:	83 c4 04             	add    $0x4,%esp
  103154:	5d                   	pop    %ebp
  103155:	c3                   	ret    
  103156:	66 90                	xchg   %ax,%ax
  103158:	66 90                	xchg   %ax,%ax
  10315a:	66 90                	xchg   %ax,%ax
  10315c:	66 90                	xchg   %ax,%ax
  10315e:	66 90                	xchg   %ax,%ax

00103160 <log_list_head_get>:
}

struct log_msg *log_list_head_get(struct log_list_t *list)
{
  103160:	55                   	push   %ebp
  103161:	89 e5                	mov    %esp,%ebp
  103163:	50                   	push   %eax
  103164:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_msg *msg = list->head;
  103167:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10316a:	8b 09                	mov    (%ecx),%ecx
  10316c:	89 4d fc             	mov    %ecx,-0x4(%ebp)

	if (list->head != NULL) {
  10316f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103172:	83 39 00             	cmpl   $0x0,(%ecx)
  103175:	0f 84 0c 00 00 00    	je     103187 <log_list_head_get+0x27>
		list->head = list->head->next;
  10317b:	8b 45 08             	mov    0x8(%ebp),%eax
  10317e:	8b 00                	mov    (%eax),%eax
  103180:	8b 00                	mov    (%eax),%eax
  103182:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103185:	89 01                	mov    %eax,(%ecx)
	}

	return msg;
  103187:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10318a:	83 c4 04             	add    $0x4,%esp
  10318d:	5d                   	pop    %ebp
  10318e:	c3                   	ret    
  10318f:	90                   	nop

00103190 <z_impl_z_clock_hw_cycles_per_sec_runtime_get>:

#if defined(CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME)
__syscall int z_clock_hw_cycles_per_sec_runtime_get(void);

static inline int z_impl_z_clock_hw_cycles_per_sec_runtime_get(void)
{
  103190:	55                   	push   %ebp
  103191:	89 e5                	mov    %esp,%ebp
	extern int z_clock_hw_cycles_per_sec;

	return z_clock_hw_cycles_per_sec;
  103193:	a1 a8 33 14 00       	mov    0x1433a8,%eax
  103198:	5d                   	pop    %ebp
  103199:	c3                   	ret    
  10319a:	66 90                	xchg   %ax,%ax
  10319c:	66 90                	xchg   %ax,%ax
  10319e:	66 90                	xchg   %ax,%ax

001031a0 <log_0>:
		}
	}
}

void log_0(const char *str, struct log_msg_ids src_level)
{
  1031a0:	55                   	push   %ebp
  1031a1:	89 e5                	mov    %esp,%ebp
  1031a3:	83 ec 14             	sub    $0x14,%esp
  1031a6:	8d 45 0c             	lea    0xc(%ebp),%eax
  1031a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_0(str, src_level);
	} else {
		struct log_msg *msg = log_msg_create_0(str);
  1031ac:	8b 55 08             	mov    0x8(%ebp),%edx
  1031af:	89 14 24             	mov    %edx,(%esp)
  1031b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1031b5:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1031b8:	e8 33 00 00 00       	call   1031f0 <log_msg_create_0>
  1031bd:	89 45 fc             	mov    %eax,-0x4(%ebp)

		if (msg == NULL) {
  1031c0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1031c4:	0f 85 05 00 00 00    	jne    1031cf <log_0+0x2f>
			return;
  1031ca:	e9 16 00 00 00       	jmp    1031e5 <log_0+0x45>
		}
		msg_finalize(msg, src_level);
  1031cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031d2:	89 04 24             	mov    %eax,(%esp)
  1031d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031d8:	66 8b 08             	mov    (%eax),%cx
  1031db:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  1031e0:	e8 3b 00 00 00       	call   103220 <msg_finalize>
	}
}
  1031e5:	83 c4 14             	add    $0x14,%esp
  1031e8:	5d                   	pop    %ebp
  1031e9:	c3                   	ret    
  1031ea:	66 90                	xchg   %ax,%ax
  1031ec:	66 90                	xchg   %ax,%ax
  1031ee:	66 90                	xchg   %ax,%ax

001031f0 <log_msg_create_0>:
 *		- string pointer
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
  1031f0:	55                   	push   %ebp
  1031f1:	89 e5                	mov    %esp,%ebp
  1031f3:	83 ec 08             	sub    $0x8,%esp
  1031f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1031f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	struct log_msg *msg = z_log_msg_std_alloc();
  1031fc:	e8 0f 0f 00 00       	call   104110 <z_log_msg_std_alloc>
  103201:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (msg != NULL) {
  103204:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103208:	0f 84 09 00 00 00    	je     103217 <log_msg_create_0+0x27>
		msg->str = str;
  10320e:	8b 45 08             	mov    0x8(%ebp),%eax
  103211:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103214:	89 41 10             	mov    %eax,0x10(%ecx)
	}

	return msg;
  103217:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10321a:	83 c4 08             	add    $0x8,%esp
  10321d:	5d                   	pop    %ebp
  10321e:	c3                   	ret    
  10321f:	90                   	nop

00103220 <msg_finalize>:
{
  103220:	55                   	push   %ebp
  103221:	89 e5                	mov    %esp,%ebp
  103223:	56                   	push   %esi
  103224:	83 ec 30             	sub    $0x30,%esp
  103227:	8d 45 0c             	lea    0xc(%ebp),%eax
  10322a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	msg->hdr.ids = src_level;
  10322d:	8b 55 08             	mov    0x8(%ebp),%edx
  103230:	66 8b 30             	mov    (%eax),%si
  103233:	66 89 72 0a          	mov    %si,0xa(%edx)
  103237:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	msg->hdr.timestamp = timestamp_func();
  10323a:	ff 15 08 30 14 00    	call   *0x143008
  103240:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103243:	89 41 0c             	mov    %eax,0xc(%ecx)
	atomic_inc(&buffered_cnt);
  103246:	8d 05 5c 50 13 00    	lea    0x13505c,%eax
  10324c:	89 04 24             	mov    %eax,(%esp)
  10324f:	e8 0c 06 00 00       	call   103860 <atomic_inc>
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  103254:	9c                   	pushf  
  103255:	fa                   	cli    
  103256:	8f 45 f4             	popl   -0xc(%ebp)
	return key;
  103259:	8b 4d f4             	mov    -0xc(%ebp),%ecx
	key = irq_lock();
  10325c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	log_list_add_tail(&list, msg);
  10325f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103262:	8d 15 28 50 13 00    	lea    0x135028,%edx
  103268:	89 14 24             	mov    %edx,(%esp)
  10326b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10326f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  103272:	e8 79 fe ff ff       	call   1030f0 <log_list_add_tail>
	irq_unlock(key);
  103277:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10327a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10327d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103280:	25 00 02 00 00       	and    $0x200,%eax
  103285:	83 f8 00             	cmp    $0x0,%eax
  103288:	0f 84 01 00 00 00    	je     10328f <msg_finalize+0x6f>
		__asm__ volatile ("sti" ::: "memory");
  10328e:	fb                   	sti    
	if (panic_mode) {
  10328f:	f6 05 e6 96 13 00 01 	testb  $0x1,0x1396e6
  103296:	0f 84 3a 00 00 00    	je     1032d6 <msg_finalize+0xb6>
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  10329c:	9c                   	pushf  
  10329d:	fa                   	cli    
  10329e:	8f 45 f0             	popl   -0x10(%ebp)
  1032a1:	31 c0                	xor    %eax,%eax
	return key;
  1032a3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		key = irq_lock();
  1032a6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
		(void)log_process(false);
  1032a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1032b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1032b3:	e8 78 07 00 00       	call   103a30 <log_process>
		irq_unlock(key);
  1032b8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1032bb:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1032be:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1032c1:	81 e1 00 02 00 00    	and    $0x200,%ecx
  1032c7:	83 f9 00             	cmp    $0x0,%ecx
  1032ca:	0f 84 01 00 00 00    	je     1032d1 <msg_finalize+0xb1>
		__asm__ volatile ("sti" ::: "memory");
  1032d0:	fb                   	sti    
	} else if (proc_tid != NULL && buffered_cnt == 1) {
  1032d1:	e9 82 00 00 00       	jmp    103358 <msg_finalize+0x138>
  1032d6:	83 3d a0 50 13 00 00 	cmpl   $0x0,0x1350a0
  1032dd:	0f 84 35 00 00 00    	je     103318 <msg_finalize+0xf8>
  1032e3:	83 3d 5c 50 13 00 01 	cmpl   $0x1,0x13505c
  1032ea:	0f 85 28 00 00 00    	jne    103318 <msg_finalize+0xf8>
  1032f0:	31 c0                	xor    %eax,%eax
		k_timer_start(&log_process_thread_timer,
  1032f2:	8d 0d a4 50 13 00    	lea    0x1350a4,%ecx
  1032f8:	89 0c 24             	mov    %ecx,(%esp)
  1032fb:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  103302:	00 
  103303:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10330a:	00 
  10330b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10330e:	e8 3d 0e 00 00       	call   104150 <k_timer_start>
	} else if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
  103313:	e9 3b 00 00 00       	jmp    103353 <msg_finalize+0x133>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  103318:	83 3d 5c 50 13 00 0a 	cmpl   $0xa,0x13505c
  10331f:	0f 85 29 00 00 00    	jne    10334e <msg_finalize+0x12e>
		    (proc_tid != NULL)) {
  103325:	83 3d a0 50 13 00 00 	cmpl   $0x0,0x1350a0
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  10332c:	0f 84 1c 00 00 00    	je     10334e <msg_finalize+0x12e>
			k_timer_stop(&log_process_thread_timer);
  103332:	8d 05 a4 50 13 00    	lea    0x1350a4,%eax
  103338:	89 04 24             	mov    %eax,(%esp)
  10333b:	e8 40 0e 00 00       	call   104180 <k_timer_stop>
			k_sem_give(&log_process_thread_sem);
  103340:	8d 05 5c 34 14 00    	lea    0x14345c,%eax
  103346:	89 04 24             	mov    %eax,(%esp)
  103349:	e8 12 0b 00 00       	call   103e60 <k_sem_give>
  10334e:	e9 00 00 00 00       	jmp    103353 <msg_finalize+0x133>
  103353:	e9 00 00 00 00       	jmp    103358 <msg_finalize+0x138>
}
  103358:	83 c4 30             	add    $0x30,%esp
  10335b:	5e                   	pop    %esi
  10335c:	5d                   	pop    %ebp
  10335d:	c3                   	ret    
  10335e:	66 90                	xchg   %ax,%ax

00103360 <log_1>:

void log_1(const char *str,
	   log_arg_t arg0,
	   struct log_msg_ids src_level)
{
  103360:	55                   	push   %ebp
  103361:	89 e5                	mov    %esp,%ebp
  103363:	57                   	push   %edi
  103364:	56                   	push   %esi
  103365:	83 ec 18             	sub    $0x18,%esp
  103368:	8d 45 10             	lea    0x10(%ebp),%eax
  10336b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10336e:	8b 55 08             	mov    0x8(%ebp),%edx
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_1(str, arg0, src_level);
	} else {
		struct log_msg *msg = log_msg_create_1(str, arg0);
  103371:	8b 75 08             	mov    0x8(%ebp),%esi
  103374:	8b 7d 0c             	mov    0xc(%ebp),%edi
  103377:	89 34 24             	mov    %esi,(%esp)
  10337a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  10337e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103381:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103384:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103387:	e8 34 00 00 00       	call   1033c0 <log_msg_create_1>
  10338c:	89 45 f4             	mov    %eax,-0xc(%ebp)

		if (msg == NULL) {
  10338f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103393:	0f 85 05 00 00 00    	jne    10339e <log_1+0x3e>
			return;
  103399:	e9 16 00 00 00       	jmp    1033b4 <log_1+0x54>
		}
		msg_finalize(msg, src_level);
  10339e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033a1:	89 04 24             	mov    %eax,(%esp)
  1033a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1033a7:	66 8b 08             	mov    (%eax),%cx
  1033aa:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  1033af:	e8 6c fe ff ff       	call   103220 <msg_finalize>
	}
}
  1033b4:	83 c4 18             	add    $0x18,%esp
  1033b7:	5e                   	pop    %esi
  1033b8:	5f                   	pop    %edi
  1033b9:	5d                   	pop    %ebp
  1033ba:	c3                   	ret    
  1033bb:	66 90                	xchg   %ax,%ax
  1033bd:	66 90                	xchg   %ax,%ax
  1033bf:	90                   	nop

001033c0 <log_msg_create_1>:
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
  1033c0:	55                   	push   %ebp
  1033c1:	89 e5                	mov    %esp,%ebp
  1033c3:	83 ec 0c             	sub    $0xc,%esp
  1033c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1033c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1033cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1033cf:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	struct  log_msg *msg = z_log_msg_std_alloc();
  1033d2:	e8 39 0d 00 00       	call   104110 <z_log_msg_std_alloc>
  1033d7:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (msg != NULL) {
  1033da:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1033de:	0f 84 27 00 00 00    	je     10340b <log_msg_create_1+0x4b>
		msg->str = str;
  1033e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1033e7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1033ea:	89 41 10             	mov    %eax,0x10(%ecx)
		msg->hdr.params.std.nargs = 1U;
  1033ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1033f0:	66 8b 50 08          	mov    0x8(%eax),%dx
  1033f4:	66 81 e2 ff 0f       	and    $0xfff,%dx
  1033f9:	66 81 ca 00 10       	or     $0x1000,%dx
  1033fe:	66 89 50 08          	mov    %dx,0x8(%eax)
		msg->payload.single.args[0] = arg1;
  103402:	8b 45 0c             	mov    0xc(%ebp),%eax
  103405:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103408:	89 41 14             	mov    %eax,0x14(%ecx)
	}

	return msg;
  10340b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10340e:	83 c4 0c             	add    $0xc,%esp
  103411:	5d                   	pop    %ebp
  103412:	c3                   	ret    
  103413:	66 90                	xchg   %ax,%ax
  103415:	66 90                	xchg   %ax,%ax
  103417:	66 90                	xchg   %ax,%ax
  103419:	66 90                	xchg   %ax,%ax
  10341b:	66 90                	xchg   %ax,%ax
  10341d:	66 90                	xchg   %ax,%ax
  10341f:	90                   	nop

00103420 <log_2>:

void log_2(const char *str,
	   log_arg_t arg0,
	   log_arg_t arg1,
	   struct log_msg_ids src_level)
{
  103420:	55                   	push   %ebp
  103421:	89 e5                	mov    %esp,%ebp
  103423:	53                   	push   %ebx
  103424:	57                   	push   %edi
  103425:	56                   	push   %esi
  103426:	83 ec 20             	sub    $0x20,%esp
  103429:	8d 45 14             	lea    0x14(%ebp),%eax
  10342c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10342f:	8b 55 0c             	mov    0xc(%ebp),%edx
  103432:	8b 75 08             	mov    0x8(%ebp),%esi
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_2(str, arg0, arg1, src_level);
	} else {
		struct log_msg *msg = log_msg_create_2(str, arg0, arg1);
  103435:	8b 7d 08             	mov    0x8(%ebp),%edi
  103438:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10343b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10343e:	8b 45 10             	mov    0x10(%ebp),%eax
  103441:	89 3c 24             	mov    %edi,(%esp)
  103444:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  103448:	89 44 24 08          	mov    %eax,0x8(%esp)
  10344c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10344f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  103452:	89 75 e0             	mov    %esi,-0x20(%ebp)
  103455:	e8 36 00 00 00       	call   103490 <log_msg_create_2>
  10345a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if (msg == NULL) {
  10345d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103461:	0f 85 05 00 00 00    	jne    10346c <log_2+0x4c>
			return;
  103467:	e9 16 00 00 00       	jmp    103482 <log_2+0x62>
		}

		msg_finalize(msg, src_level);
  10346c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10346f:	89 04 24             	mov    %eax,(%esp)
  103472:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103475:	66 8b 08             	mov    (%eax),%cx
  103478:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10347d:	e8 9e fd ff ff       	call   103220 <msg_finalize>
	}
}
  103482:	83 c4 20             	add    $0x20,%esp
  103485:	5e                   	pop    %esi
  103486:	5f                   	pop    %edi
  103487:	5b                   	pop    %ebx
  103488:	5d                   	pop    %ebp
  103489:	c3                   	ret    
  10348a:	66 90                	xchg   %ax,%ax
  10348c:	66 90                	xchg   %ax,%ax
  10348e:	66 90                	xchg   %ax,%ax

00103490 <log_msg_create_2>:
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
  103490:	55                   	push   %ebp
  103491:	89 e5                	mov    %esp,%ebp
  103493:	83 ec 10             	sub    $0x10,%esp
  103496:	8b 45 10             	mov    0x10(%ebp),%eax
  103499:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10349c:	8b 55 08             	mov    0x8(%ebp),%edx
  10349f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1034a2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1034a5:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct  log_msg *msg = z_log_msg_std_alloc();
  1034a8:	e8 63 0c 00 00       	call   104110 <z_log_msg_std_alloc>
  1034ad:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (msg != NULL) {
  1034b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1034b4:	0f 84 30 00 00 00    	je     1034ea <log_msg_create_2+0x5a>
		msg->str = str;
  1034ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1034bd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1034c0:	89 41 10             	mov    %eax,0x10(%ecx)
		msg->hdr.params.std.nargs = 2U;
  1034c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034c6:	66 8b 50 08          	mov    0x8(%eax),%dx
  1034ca:	66 81 e2 ff 0f       	and    $0xfff,%dx
  1034cf:	66 81 ca 00 20       	or     $0x2000,%dx
  1034d4:	66 89 50 08          	mov    %dx,0x8(%eax)
		msg->payload.single.args[0] = arg1;
  1034d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1034db:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1034de:	89 41 14             	mov    %eax,0x14(%ecx)
		msg->payload.single.args[1] = arg2;
  1034e1:	8b 45 10             	mov    0x10(%ebp),%eax
  1034e4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1034e7:	89 41 18             	mov    %eax,0x18(%ecx)
	}

	return msg;
  1034ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034ed:	83 c4 10             	add    $0x10,%esp
  1034f0:	5d                   	pop    %ebp
  1034f1:	c3                   	ret    
  1034f2:	66 90                	xchg   %ax,%ax
  1034f4:	66 90                	xchg   %ax,%ax
  1034f6:	66 90                	xchg   %ax,%ax
  1034f8:	66 90                	xchg   %ax,%ax
  1034fa:	66 90                	xchg   %ax,%ax
  1034fc:	66 90                	xchg   %ax,%ax
  1034fe:	66 90                	xchg   %ax,%ax

00103500 <log_3>:
void log_3(const char *str,
	   log_arg_t arg0,
	   log_arg_t arg1,
	   log_arg_t arg2,
	   struct log_msg_ids src_level)
{
  103500:	55                   	push   %ebp
  103501:	89 e5                	mov    %esp,%ebp
  103503:	53                   	push   %ebx
  103504:	57                   	push   %edi
  103505:	56                   	push   %esi
  103506:	83 ec 30             	sub    $0x30,%esp
  103509:	8d 45 18             	lea    0x18(%ebp),%eax
  10350c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10350f:	8b 55 10             	mov    0x10(%ebp),%edx
  103512:	8b 75 0c             	mov    0xc(%ebp),%esi
  103515:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_3(str, arg0, arg1, arg2, src_level);
	} else {
		struct log_msg *msg = log_msg_create_3(str, arg0, arg1, arg2);
  103518:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10351b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10351e:	8b 45 0c             	mov    0xc(%ebp),%eax
  103521:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103524:	8b 45 10             	mov    0x10(%ebp),%eax
  103527:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10352a:	8b 45 14             	mov    0x14(%ebp),%eax
  10352d:	89 1c 24             	mov    %ebx,(%esp)
  103530:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  103533:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  103537:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  10353a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10353e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  103542:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  103545:	89 55 dc             	mov    %edx,-0x24(%ebp)
  103548:	89 75 d8             	mov    %esi,-0x28(%ebp)
  10354b:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  10354e:	e8 3d 00 00 00       	call   103590 <log_msg_create_3>
  103553:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if (msg == NULL) {
  103556:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10355a:	0f 85 05 00 00 00    	jne    103565 <log_3+0x65>
			return;
  103560:	e9 16 00 00 00       	jmp    10357b <log_3+0x7b>
		}

		msg_finalize(msg, src_level);
  103565:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103568:	89 04 24             	mov    %eax,(%esp)
  10356b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10356e:	66 8b 08             	mov    (%eax),%cx
  103571:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  103576:	e8 a5 fc ff ff       	call   103220 <msg_finalize>
	}
}
  10357b:	83 c4 30             	add    $0x30,%esp
  10357e:	5e                   	pop    %esi
  10357f:	5f                   	pop    %edi
  103580:	5b                   	pop    %ebx
  103581:	5d                   	pop    %ebp
  103582:	c3                   	ret    
  103583:	66 90                	xchg   %ax,%ax
  103585:	66 90                	xchg   %ax,%ax
  103587:	66 90                	xchg   %ax,%ax
  103589:	66 90                	xchg   %ax,%ax
  10358b:	66 90                	xchg   %ax,%ax
  10358d:	66 90                	xchg   %ax,%ax
  10358f:	90                   	nop

00103590 <log_msg_create_3>:
 */
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
  103590:	55                   	push   %ebp
  103591:	89 e5                	mov    %esp,%ebp
  103593:	56                   	push   %esi
  103594:	83 ec 14             	sub    $0x14,%esp
  103597:	8b 45 14             	mov    0x14(%ebp),%eax
  10359a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10359d:	8b 55 0c             	mov    0xc(%ebp),%edx
  1035a0:	8b 75 08             	mov    0x8(%ebp),%esi
  1035a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1035a6:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1035a9:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1035ac:	89 75 e8             	mov    %esi,-0x18(%ebp)
	struct  log_msg *msg = z_log_msg_std_alloc();
  1035af:	e8 5c 0b 00 00       	call   104110 <z_log_msg_std_alloc>
  1035b4:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (msg != NULL) {
  1035b7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1035bb:	0f 84 39 00 00 00    	je     1035fa <log_msg_create_3+0x6a>
		msg->str = str;
  1035c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1035c4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1035c7:	89 41 10             	mov    %eax,0x10(%ecx)
		msg->hdr.params.std.nargs = 3U;
  1035ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035cd:	66 8b 50 08          	mov    0x8(%eax),%dx
  1035d1:	66 81 e2 ff 0f       	and    $0xfff,%dx
  1035d6:	66 81 ca 00 30       	or     $0x3000,%dx
  1035db:	66 89 50 08          	mov    %dx,0x8(%eax)
		msg->payload.single.args[0] = arg1;
  1035df:	8b 45 0c             	mov    0xc(%ebp),%eax
  1035e2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1035e5:	89 41 14             	mov    %eax,0x14(%ecx)
		msg->payload.single.args[1] = arg2;
  1035e8:	8b 45 10             	mov    0x10(%ebp),%eax
  1035eb:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1035ee:	89 41 18             	mov    %eax,0x18(%ecx)
		msg->payload.single.args[2] = arg3;
  1035f1:	8b 45 14             	mov    0x14(%ebp),%eax
  1035f4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1035f7:	89 41 1c             	mov    %eax,0x1c(%ecx)
	}

	return msg;
  1035fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035fd:	83 c4 14             	add    $0x14,%esp
  103600:	5e                   	pop    %esi
  103601:	5d                   	pop    %ebp
  103602:	c3                   	ret    
  103603:	66 90                	xchg   %ax,%ax
  103605:	66 90                	xchg   %ax,%ax
  103607:	66 90                	xchg   %ax,%ax
  103609:	66 90                	xchg   %ax,%ax
  10360b:	66 90                	xchg   %ax,%ax
  10360d:	66 90                	xchg   %ax,%ax
  10360f:	90                   	nop

00103610 <log_n>:

void log_n(const char *str,
	   log_arg_t *args,
	   u32_t narg,
	   struct log_msg_ids src_level)
{
  103610:	55                   	push   %ebp
  103611:	89 e5                	mov    %esp,%ebp
  103613:	53                   	push   %ebx
  103614:	57                   	push   %edi
  103615:	56                   	push   %esi
  103616:	83 ec 20             	sub    $0x20,%esp
  103619:	8d 45 14             	lea    0x14(%ebp),%eax
  10361c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10361f:	8b 55 0c             	mov    0xc(%ebp),%edx
  103622:	8b 75 08             	mov    0x8(%ebp),%esi
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_n(str, args, narg, src_level);
	} else {
		struct log_msg *msg = log_msg_create_n(str, args, narg);
  103625:	8b 7d 08             	mov    0x8(%ebp),%edi
  103628:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10362b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10362e:	8b 45 10             	mov    0x10(%ebp),%eax
  103631:	89 3c 24             	mov    %edi,(%esp)
  103634:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  103638:	89 44 24 08          	mov    %eax,0x8(%esp)
  10363c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10363f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  103642:	89 75 e0             	mov    %esi,-0x20(%ebp)
  103645:	e8 f6 15 00 00       	call   104c40 <log_msg_create_n>
  10364a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if (msg == NULL) {
  10364d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103651:	0f 85 05 00 00 00    	jne    10365c <log_n+0x4c>
			return;
  103657:	e9 16 00 00 00       	jmp    103672 <log_n+0x62>
		}

		msg_finalize(msg, src_level);
  10365c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10365f:	89 04 24             	mov    %eax,(%esp)
  103662:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103665:	66 8b 08             	mov    (%eax),%cx
  103668:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10366d:	e8 ae fb ff ff       	call   103220 <msg_finalize>
	}
}
  103672:	83 c4 20             	add    $0x20,%esp
  103675:	5e                   	pop    %esi
  103676:	5f                   	pop    %edi
  103677:	5b                   	pop    %ebx
  103678:	5d                   	pop    %ebp
  103679:	c3                   	ret    
  10367a:	66 90                	xchg   %ax,%ax
  10367c:	66 90                	xchg   %ax,%ax
  10367e:	66 90                	xchg   %ax,%ax

00103680 <_is_user_context>:
{
  103680:	55                   	push   %ebp
  103681:	89 e5                	mov    %esp,%ebp
  103683:	31 c0                	xor    %eax,%eax
	return false;
  103685:	24 01                	and    $0x1,%al
  103687:	0f b6 c0             	movzbl %al,%eax
  10368a:	5d                   	pop    %ebp
  10368b:	c3                   	ret    
  10368c:	66 90                	xchg   %ax,%ax
  10368e:	66 90                	xchg   %ax,%ax

00103690 <log_backend_count_get>:
 * @brief Get number of backends.
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
  103690:	55                   	push   %ebp
  103691:	89 e5                	mov    %esp,%ebp
	return __log_backends_end - __log_backends_start;
  103693:	b8 a4 30 12 00       	mov    $0x1230a4,%eax
  103698:	b9 b4 30 12 00       	mov    $0x1230b4,%ecx
  10369d:	29 c1                	sub    %eax,%ecx
  10369f:	c1 f9 04             	sar    $0x4,%ecx
  1036a2:	89 c8                	mov    %ecx,%eax
  1036a4:	5d                   	pop    %ebp
  1036a5:	c3                   	ret    
  1036a6:	66 90                	xchg   %ax,%ax
  1036a8:	66 90                	xchg   %ax,%ax
  1036aa:	66 90                	xchg   %ax,%ax
  1036ac:	66 90                	xchg   %ax,%ax
  1036ae:	66 90                	xchg   %ax,%ax

001036b0 <log_backend_get>:
{
  1036b0:	55                   	push   %ebp
  1036b1:	89 e5                	mov    %esp,%ebp
  1036b3:	50                   	push   %eax
  1036b4:	8b 45 08             	mov    0x8(%ebp),%eax
	return &__log_backends_start[idx];
  1036b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1036ba:	c1 e1 04             	shl    $0x4,%ecx
  1036bd:	8d 15 a4 30 12 00    	lea    0x1230a4,%edx
  1036c3:	01 ca                	add    %ecx,%edx
  1036c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1036c8:	89 d0                	mov    %edx,%eax
  1036ca:	83 c4 04             	add    $0x4,%esp
  1036cd:	5d                   	pop    %ebp
  1036ce:	c3                   	ret    
  1036cf:	90                   	nop

001036d0 <log_backend_is_active>:
 *
 * @return True if backend is active, false otherwise.
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
  1036d0:	55                   	push   %ebp
  1036d1:	89 e5                	mov    %esp,%ebp
  1036d3:	50                   	push   %eax
  1036d4:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  1036d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1036da:	8b 49 04             	mov    0x4(%ecx),%ecx
  1036dd:	8a 51 05             	mov    0x5(%ecx),%dl
  1036e0:	80 e2 01             	and    $0x1,%dl
  1036e3:	0f b6 ca             	movzbl %dl,%ecx
  1036e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1036e9:	89 c8                	mov    %ecx,%eax
  1036eb:	83 c4 04             	add    $0x4,%esp
  1036ee:	5d                   	pop    %ebp
  1036ef:	c3                   	ret    

001036f0 <log_core_init>:
	 */
	return k_cycle_get_32();
}

void log_core_init(void)
{
  1036f0:	55                   	push   %ebp
  1036f1:	89 e5                	mov    %esp,%ebp
  1036f3:	83 ec 14             	sub    $0x14,%esp
	u32_t freq;

	if (!IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		log_msg_pool_init();
  1036f6:	e8 e5 10 00 00       	call   1047e0 <log_msg_pool_init>
		log_list_init(&list);
  1036fb:	8d 05 28 50 13 00    	lea    0x135028,%eax
  103701:	89 04 24             	mov    %eax,(%esp)
  103704:	e8 c7 f9 ff ff       	call   1030d0 <log_list_init>

		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
  103709:	8d 05 30 50 13 00    	lea    0x135030,%eax
  10370f:	89 04 24             	mov    %eax,(%esp)
  103712:	8d 05 f0 0e 14 00    	lea    0x140ef0,%eax
  103718:	89 44 24 04          	mov    %eax,0x4(%esp)
  10371c:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
  103723:	00 
  103724:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  10372b:	00 
  10372c:	e8 7f 9a 01 00       	call   11d1b0 <k_mem_slab_init>
					sizeof(struct log_strdup_buf),
					CONFIG_LOG_STRDUP_BUF_COUNT);
	}

	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
  103731:	e8 4a 00 00 00       	call   103780 <sys_clock_hw_cycles_per_sec>
  103736:	3d 40 42 0f 00       	cmp    $0xf4240,%eax
  10373b:	0f 8e 17 00 00 00    	jle    103758 <log_core_init+0x68>
		timestamp_func = k_uptime_get_32;
  103741:	8d 05 90 37 10 00    	lea    0x103790,%eax
  103747:	a3 08 30 14 00       	mov    %eax,0x143008
		freq = 1000;
  10374c:	c7 45 fc e8 03 00 00 	movl   $0x3e8,-0x4(%ebp)
	} else {
  103753:	e9 13 00 00 00       	jmp    10376b <log_core_init+0x7b>
		timestamp_func = k_cycle_get_32_wrapper;
  103758:	8d 05 a0 37 10 00    	lea    0x1037a0,%eax
  10375e:	a3 08 30 14 00       	mov    %eax,0x143008
		freq = sys_clock_hw_cycles_per_sec();
  103763:	e8 18 00 00 00       	call   103780 <sys_clock_hw_cycles_per_sec>
  103768:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}

	log_output_timestamp_freq_set(freq);
  10376b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10376e:	89 04 24             	mov    %eax,(%esp)
  103771:	e8 5a 31 00 00       	call   1068d0 <log_output_timestamp_freq_set>
			LOG_FILTER_SLOT_SET(filters,
					    LOG_FILTER_AGGR_SLOT_IDX,
					    level);
		}
	}
}
  103776:	83 c4 14             	add    $0x14,%esp
  103779:	5d                   	pop    %ebp
  10377a:	c3                   	ret    
  10377b:	66 90                	xchg   %ax,%ax
  10377d:	66 90                	xchg   %ax,%ax
  10377f:	90                   	nop

00103780 <sys_clock_hw_cycles_per_sec>:
}
#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */

static inline int sys_clock_hw_cycles_per_sec(void)
{
  103780:	55                   	push   %ebp
  103781:	89 e5                	mov    %esp,%ebp
#if defined(CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME)
	return z_clock_hw_cycles_per_sec_runtime_get();
  103783:	e8 28 0a 00 00       	call   1041b0 <z_clock_hw_cycles_per_sec_runtime_get>
  103788:	5d                   	pop    %ebp
  103789:	c3                   	ret    
  10378a:	66 90                	xchg   %ax,%ax
  10378c:	66 90                	xchg   %ax,%ax
  10378e:	66 90                	xchg   %ax,%ax

00103790 <k_uptime_get_32>:
 *    @endrst
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline u32_t k_uptime_get_32(void)
{
  103790:	55                   	push   %ebp
  103791:	89 e5                	mov    %esp,%ebp
	return (u32_t)k_uptime_get();
  103793:	e8 28 0a 00 00       	call   1041c0 <k_uptime_get>
  103798:	5d                   	pop    %ebp
  103799:	c3                   	ret    
  10379a:	66 90                	xchg   %ax,%ax
  10379c:	66 90                	xchg   %ax,%ax
  10379e:	66 90                	xchg   %ax,%ax

001037a0 <k_cycle_get_32_wrapper>:
{
  1037a0:	55                   	push   %ebp
  1037a1:	89 e5                	mov    %esp,%ebp
	return k_cycle_get_32();
  1037a3:	e8 28 0a 00 00       	call   1041d0 <k_cycle_get_32>
  1037a8:	5d                   	pop    %ebp
  1037a9:	c3                   	ret    
  1037aa:	66 90                	xchg   %ax,%ax
  1037ac:	66 90                	xchg   %ax,%ax
  1037ae:	66 90                	xchg   %ax,%ax

001037b0 <log_init>:

void log_init(void)
{
  1037b0:	55                   	push   %ebp
  1037b1:	89 e5                	mov    %esp,%ebp
  1037b3:	83 ec 1c             	sub    $0x1c,%esp

	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_init();
	}

	if (atomic_inc(&initialized) != 0) {
  1037b6:	8d 05 54 50 13 00    	lea    0x135054,%eax
  1037bc:	89 04 24             	mov    %eax,(%esp)
  1037bf:	e8 9c 00 00 00       	call   103860 <atomic_inc>
  1037c4:	83 f8 00             	cmp    $0x0,%eax
  1037c7:	0f 84 05 00 00 00    	je     1037d2 <log_init+0x22>
		return;
  1037cd:	e9 82 00 00 00       	jmp    103854 <log_init+0xa4>
	}

	/* Assign ids to backends. */
	for (i = 0; i < log_backend_count_get(); i++) {
  1037d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1037d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1037dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1037df:	e8 ac fe ff ff       	call   103690 <log_backend_count_get>
  1037e4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1037e7:	39 c1                	cmp    %eax,%ecx
  1037e9:	0f 8d 65 00 00 00    	jge    103854 <log_init+0xa4>
		const struct log_backend *backend = log_backend_get(i);
  1037ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1037f2:	89 04 24             	mov    %eax,(%esp)
  1037f5:	e8 b6 fe ff ff       	call   1036b0 <log_backend_get>
  1037fa:	89 45 f8             	mov    %eax,-0x8(%ebp)

		if (backend->autostart) {
  1037fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103800:	f6 40 0c 01          	testb  $0x1,0xc(%eax)
  103804:	0f 84 37 00 00 00    	je     103841 <log_init+0x91>
			if (backend->api->init != NULL) {
  10380a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10380d:	8b 00                	mov    (%eax),%eax
  10380f:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  103813:	0f 84 08 00 00 00    	je     103821 <log_init+0x71>
				backend->api->init();
  103819:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10381c:	8b 00                	mov    (%eax),%eax
  10381e:	ff 50 14             	call   *0x14(%eax)
  103821:	31 c0                	xor    %eax,%eax
			}

			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
  103823:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103826:	89 0c 24             	mov    %ecx,(%esp)
  103829:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103830:	00 
  103831:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103838:	00 
  103839:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10383c:	e8 4f 00 00 00       	call   103890 <log_backend_enable>
		}
	}
  103841:	e9 00 00 00 00       	jmp    103846 <log_init+0x96>
	for (i = 0; i < log_backend_count_get(); i++) {
  103846:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103849:	83 c0 01             	add    $0x1,%eax
  10384c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10384f:	e9 85 ff ff ff       	jmp    1037d9 <log_init+0x29>
}
  103854:	83 c4 1c             	add    $0x1c,%esp
  103857:	5d                   	pop    %ebp
  103858:	c3                   	ret    
  103859:	66 90                	xchg   %ax,%ax
  10385b:	66 90                	xchg   %ax,%ax
  10385d:	66 90                	xchg   %ax,%ax
  10385f:	90                   	nop

00103860 <atomic_inc>:
 *
 * @return Previous value of @a target.
 */
#if defined(CONFIG_ATOMIC_OPERATIONS_BUILTIN) || defined (CONFIG_ATOMIC_OPERATIONS_C)
static inline atomic_val_t atomic_inc(atomic_t *target)
{
  103860:	55                   	push   %ebp
  103861:	89 e5                	mov    %esp,%ebp
  103863:	83 ec 0c             	sub    $0xc,%esp
  103866:	8b 45 08             	mov    0x8(%ebp),%eax
	return atomic_add(target, 1);
  103869:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10386c:	89 0c 24             	mov    %ecx,(%esp)
  10386f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  103876:	00 
  103877:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10387a:	e8 71 09 00 00       	call   1041f0 <atomic_add>
  10387f:	83 c4 0c             	add    $0xc,%esp
  103882:	5d                   	pop    %ebp
  103883:	c3                   	ret    
  103884:	66 90                	xchg   %ax,%ax
  103886:	66 90                	xchg   %ax,%ax
  103888:	66 90                	xchg   %ax,%ax
  10388a:	66 90                	xchg   %ax,%ax
  10388c:	66 90                	xchg   %ax,%ax
  10388e:	66 90                	xchg   %ax,%ax

00103890 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			u32_t level)
{
  103890:	55                   	push   %ebp
  103891:	89 e5                	mov    %esp,%ebp
  103893:	57                   	push   %edi
  103894:	56                   	push   %esi
  103895:	83 ec 20             	sub    $0x20,%esp
  103898:	8b 45 10             	mov    0x10(%ebp),%eax
  10389b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10389e:	8b 55 08             	mov    0x8(%ebp),%edx
  1038a1:	31 f6                	xor    %esi,%esi
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	u32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
  1038a3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	id += backend - log_backend_get(0);
  1038aa:	8b 7d 08             	mov    0x8(%ebp),%edi
  1038ad:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1038b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1038b7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1038ba:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1038bd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  1038c0:	89 7d e0             	mov    %edi,-0x20(%ebp)
  1038c3:	e8 e8 fd ff ff       	call   1036b0 <log_backend_get>
  1038c8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1038cb:	29 c1                	sub    %eax,%ecx
  1038cd:	c1 f9 04             	sar    $0x4,%ecx
  1038d0:	03 4d f4             	add    -0xc(%ebp),%ecx
  1038d3:	89 4d f4             	mov    %ecx,-0xc(%ebp)

	log_backend_id_set(backend, id);
  1038d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1038d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1038dc:	89 04 24             	mov    %eax,(%esp)
  1038df:	0f b6 c1             	movzbl %cl,%eax
  1038e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1038e6:	e8 15 05 00 00       	call   103e00 <log_backend_id_set>
	backend_filter_set(backend, level);
  1038eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1038ee:	8b 55 10             	mov    0x10(%ebp),%edx
  1038f1:	89 04 24             	mov    %eax,(%esp)
  1038f4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1038f8:	e8 23 05 00 00       	call   103e20 <backend_filter_set>
	log_backend_activate(backend, ctx);
  1038fd:	8b 45 08             	mov    0x8(%ebp),%eax
  103900:	8b 55 0c             	mov    0xc(%ebp),%edx
  103903:	89 04 24             	mov    %eax,(%esp)
  103906:	89 54 24 04          	mov    %edx,0x4(%esp)
  10390a:	e8 21 05 00 00       	call   103e30 <log_backend_activate>

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
  10390f:	f6 05 e7 96 13 00 01 	testb  $0x1,0x1396e7
  103916:	0f 85 0e 00 00 00    	jne    10392a <log_backend_enable+0x9a>
		k_sem_give(&log_process_thread_sem);
  10391c:	8d 05 5c 34 14 00    	lea    0x14345c,%eax
  103922:	89 04 24             	mov    %eax,(%esp)
  103925:	e8 36 05 00 00       	call   103e60 <k_sem_give>
	}

	backend_attached = true;
  10392a:	c6 05 e7 96 13 00 01 	movb   $0x1,0x1396e7
}
  103931:	83 c4 20             	add    $0x20,%esp
  103934:	5e                   	pop    %esi
  103935:	5f                   	pop    %edi
  103936:	5d                   	pop    %ebp
  103937:	c3                   	ret    
  103938:	66 90                	xchg   %ax,%ax
  10393a:	66 90                	xchg   %ax,%ax
  10393c:	66 90                	xchg   %ax,%ax
  10393e:	66 90                	xchg   %ax,%ax

00103940 <z_impl_log_panic>:
{
  103940:	55                   	push   %ebp
  103941:	89 e5                	mov    %esp,%ebp
  103943:	83 ec 14             	sub    $0x14,%esp
	if (panic_mode) {
  103946:	f6 05 e6 96 13 00 01 	testb  $0x1,0x1396e6
  10394d:	0f 84 05 00 00 00    	je     103958 <z_impl_log_panic+0x18>
		return;
  103953:	e9 96 00 00 00       	jmp    1039ee <z_impl_log_panic+0xae>
	log_init();
  103958:	e8 53 fe ff ff       	call   1037b0 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
  10395d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  103964:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103967:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10396a:	e8 21 fd ff ff       	call   103690 <log_backend_count_get>
  10396f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103972:	39 c1                	cmp    %eax,%ecx
  103974:	0f 8d 44 00 00 00    	jge    1039be <z_impl_log_panic+0x7e>
		backend = log_backend_get(i);
  10397a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10397d:	89 04 24             	mov    %eax,(%esp)
  103980:	e8 2b fd ff ff       	call   1036b0 <log_backend_get>
  103985:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (log_backend_is_active(backend)) {
  103988:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10398b:	89 04 24             	mov    %eax,(%esp)
  10398e:	e8 3d fd ff ff       	call   1036d0 <log_backend_is_active>
  103993:	a8 01                	test   $0x1,%al
  103995:	0f 85 05 00 00 00    	jne    1039a0 <z_impl_log_panic+0x60>
  10399b:	e9 0b 00 00 00       	jmp    1039ab <z_impl_log_panic+0x6b>
			log_backend_panic(backend);
  1039a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039a3:	89 04 24             	mov    %eax,(%esp)
  1039a6:	e8 55 00 00 00       	call   103a00 <log_backend_panic>
	}
  1039ab:	e9 00 00 00 00       	jmp    1039b0 <z_impl_log_panic+0x70>
	for (int i = 0; i < log_backend_count_get(); i++) {
  1039b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1039b3:	83 c0 01             	add    $0x1,%eax
  1039b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1039b9:	e9 a6 ff ff ff       	jmp    103964 <z_impl_log_panic+0x24>
		while (log_process(false) == true) {
  1039be:	e9 00 00 00 00       	jmp    1039c3 <z_impl_log_panic+0x83>
  1039c3:	31 c0                	xor    %eax,%eax
  1039c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1039cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1039cf:	e8 5c 00 00 00       	call   103a30 <log_process>
  1039d4:	24 01                	and    $0x1,%al
  1039d6:	0f b6 c8             	movzbl %al,%ecx
  1039d9:	83 f9 01             	cmp    $0x1,%ecx
  1039dc:	0f 85 05 00 00 00    	jne    1039e7 <z_impl_log_panic+0xa7>
  1039e2:	e9 dc ff ff ff       	jmp    1039c3 <z_impl_log_panic+0x83>
	panic_mode = true;
  1039e7:	c6 05 e6 96 13 00 01 	movb   $0x1,0x1396e6
}
  1039ee:	83 c4 14             	add    $0x14,%esp
  1039f1:	5d                   	pop    %ebp
  1039f2:	c3                   	ret    
  1039f3:	66 90                	xchg   %ax,%ax
  1039f5:	66 90                	xchg   %ax,%ax
  1039f7:	66 90                	xchg   %ax,%ax
  1039f9:	66 90                	xchg   %ax,%ax
  1039fb:	66 90                	xchg   %ax,%ax
  1039fd:	66 90                	xchg   %ax,%ax
  1039ff:	90                   	nop

00103a00 <log_backend_panic>:
{
  103a00:	55                   	push   %ebp
  103a01:	89 e5                	mov    %esp,%ebp
  103a03:	83 ec 08             	sub    $0x8,%esp
  103a06:	8b 45 08             	mov    0x8(%ebp),%eax
	backend->api->panic(backend);
  103a09:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103a0c:	8b 09                	mov    (%ecx),%ecx
  103a0e:	8b 49 10             	mov    0x10(%ecx),%ecx
  103a11:	8b 55 08             	mov    0x8(%ebp),%edx
  103a14:	89 14 24             	mov    %edx,(%esp)
  103a17:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103a1a:	ff d1                	call   *%ecx
}
  103a1c:	83 c4 08             	add    $0x8,%esp
  103a1f:	5d                   	pop    %ebp
  103a20:	c3                   	ret    
  103a21:	66 90                	xchg   %ax,%ax
  103a23:	66 90                	xchg   %ax,%ax
  103a25:	66 90                	xchg   %ax,%ax
  103a27:	66 90                	xchg   %ax,%ax
  103a29:	66 90                	xchg   %ax,%ax
  103a2b:	66 90                	xchg   %ax,%ax
  103a2d:	66 90                	xchg   %ax,%ax
  103a2f:	90                   	nop

00103a30 <log_process>:
}


extern bool z_impl_log_process(bool bypass);
static inline bool log_process(bool bypass)
{
  103a30:	55                   	push   %ebp
  103a31:	89 e5                	mov    %esp,%ebp
  103a33:	83 ec 08             	sub    $0x8,%esp
  103a36:	8a 45 08             	mov    0x8(%ebp),%al
  103a39:	24 01                	and    $0x1,%al
  103a3b:	88 45 ff             	mov    %al,-0x1(%ebp)
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
  103a3e:	8a 45 ff             	mov    -0x1(%ebp),%al
  103a41:	24 01                	and    $0x1,%al
  103a43:	0f b6 c8             	movzbl %al,%ecx
  103a46:	89 0c 24             	mov    %ecx,(%esp)
  103a49:	e8 22 01 00 00       	call   103b70 <z_impl_log_process>
  103a4e:	24 01                	and    $0x1,%al
  103a50:	0f b6 c0             	movzbl %al,%eax
  103a53:	83 c4 08             	add    $0x8,%esp
  103a56:	5d                   	pop    %ebp
  103a57:	c3                   	ret    
  103a58:	66 90                	xchg   %ax,%ax
  103a5a:	66 90                	xchg   %ax,%ax
  103a5c:	66 90                	xchg   %ax,%ax
  103a5e:	66 90                	xchg   %ax,%ax

00103a60 <dropped_notify>:
{
  103a60:	55                   	push   %ebp
  103a61:	89 e5                	mov    %esp,%ebp
  103a63:	83 ec 1c             	sub    $0x1c,%esp
  103a66:	31 c0                	xor    %eax,%eax
	u32_t dropped = atomic_set(&dropped_cnt, 0);
  103a68:	8d 0d 58 50 13 00    	lea    0x135058,%ecx
  103a6e:	89 0c 24             	mov    %ecx,(%esp)
  103a71:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103a78:	00 
  103a79:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103a7c:	e8 7f 00 00 00       	call   103b00 <atomic_set>
  103a81:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (int i = 0; i < log_backend_count_get(); i++) {
  103a84:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  103a8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103a8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103a91:	e8 fa fb ff ff       	call   103690 <log_backend_count_get>
  103a96:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a99:	39 c1                	cmp    %eax,%ecx
  103a9b:	0f 8d 4b 00 00 00    	jge    103aec <dropped_notify+0x8c>
		struct log_backend const *backend = log_backend_get(i);
  103aa1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103aa4:	89 04 24             	mov    %eax,(%esp)
  103aa7:	e8 04 fc ff ff       	call   1036b0 <log_backend_get>
  103aac:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (log_backend_is_active(backend)) {
  103aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ab2:	89 04 24             	mov    %eax,(%esp)
  103ab5:	e8 16 fc ff ff       	call   1036d0 <log_backend_is_active>
  103aba:	a8 01                	test   $0x1,%al
  103abc:	0f 85 05 00 00 00    	jne    103ac7 <dropped_notify+0x67>
  103ac2:	e9 12 00 00 00       	jmp    103ad9 <dropped_notify+0x79>
			log_backend_dropped(backend, dropped);
  103ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103aca:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103acd:	89 04 24             	mov    %eax,(%esp)
  103ad0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103ad4:	e8 57 00 00 00       	call   103b30 <log_backend_dropped>
	}
  103ad9:	e9 00 00 00 00       	jmp    103ade <dropped_notify+0x7e>
	for (int i = 0; i < log_backend_count_get(); i++) {
  103ade:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ae1:	83 c0 01             	add    $0x1,%eax
  103ae4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  103ae7:	e9 9f ff ff ff       	jmp    103a8b <dropped_notify+0x2b>
}
  103aec:	83 c4 1c             	add    $0x1c,%esp
  103aef:	5d                   	pop    %ebp
  103af0:	c3                   	ret    
  103af1:	66 90                	xchg   %ax,%ax
  103af3:	66 90                	xchg   %ax,%ax
  103af5:	66 90                	xchg   %ax,%ax
  103af7:	66 90                	xchg   %ax,%ax
  103af9:	66 90                	xchg   %ax,%ax
  103afb:	66 90                	xchg   %ax,%ax
  103afd:	66 90                	xchg   %ax,%ax
  103aff:	90                   	nop

00103b00 <atomic_set>:
 *
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_set(atomic_t *target, atomic_val_t value)
{
  103b00:	55                   	push   %ebp
  103b01:	89 e5                	mov    %esp,%ebp
  103b03:	56                   	push   %esi
  103b04:	83 ec 0c             	sub    $0xc,%esp
  103b07:	8b 45 0c             	mov    0xc(%ebp),%eax
  103b0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  103b0d:	8b 55 08             	mov    0x8(%ebp),%edx
  103b10:	8b 75 0c             	mov    0xc(%ebp),%esi
  103b13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  103b16:	8b 75 f8             	mov    -0x8(%ebp),%esi
  103b19:	87 32                	xchg   %esi,(%edx)
  103b1b:	89 75 f4             	mov    %esi,-0xc(%ebp)
  103b1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103b21:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103b24:	89 d0                	mov    %edx,%eax
  103b26:	83 c4 0c             	add    $0xc,%esp
  103b29:	5e                   	pop    %esi
  103b2a:	5d                   	pop    %ebp
  103b2b:	c3                   	ret    
  103b2c:	66 90                	xchg   %ax,%ax
  103b2e:	66 90                	xchg   %ax,%ax

00103b30 <log_backend_dropped>:
{
  103b30:	55                   	push   %ebp
  103b31:	89 e5                	mov    %esp,%ebp
  103b33:	83 ec 08             	sub    $0x8,%esp
  103b36:	8b 45 0c             	mov    0xc(%ebp),%eax
  103b39:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (backend->api->dropped != NULL) {
  103b3c:	8b 55 08             	mov    0x8(%ebp),%edx
  103b3f:	8b 12                	mov    (%edx),%edx
  103b41:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  103b45:	0f 84 17 00 00 00    	je     103b62 <log_backend_dropped+0x32>
		backend->api->dropped(backend, cnt);
  103b4b:	8b 45 08             	mov    0x8(%ebp),%eax
  103b4e:	8b 00                	mov    (%eax),%eax
  103b50:	8b 40 0c             	mov    0xc(%eax),%eax
  103b53:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103b56:	8b 55 0c             	mov    0xc(%ebp),%edx
  103b59:	89 0c 24             	mov    %ecx,(%esp)
  103b5c:	89 54 24 04          	mov    %edx,0x4(%esp)
  103b60:	ff d0                	call   *%eax
}
  103b62:	83 c4 08             	add    $0x8,%esp
  103b65:	5d                   	pop    %ebp
  103b66:	c3                   	ret    
  103b67:	66 90                	xchg   %ax,%ax
  103b69:	66 90                	xchg   %ax,%ax
  103b6b:	66 90                	xchg   %ax,%ax
  103b6d:	66 90                	xchg   %ax,%ax
  103b6f:	90                   	nop

00103b70 <z_impl_log_process>:
{
  103b70:	55                   	push   %ebp
  103b71:	89 e5                	mov    %esp,%ebp
  103b73:	83 ec 20             	sub    $0x20,%esp
  103b76:	8a 45 08             	mov    0x8(%ebp),%al
  103b79:	24 01                	and    $0x1,%al
  103b7b:	88 45 f6             	mov    %al,-0xa(%ebp)
	if (!backend_attached && !bypass) {
  103b7e:	f6 05 e7 96 13 00 01 	testb  $0x1,0x1396e7
  103b85:	0f 85 13 00 00 00    	jne    103b9e <z_impl_log_process+0x2e>
  103b8b:	f6 45 f6 01          	testb  $0x1,-0xa(%ebp)
  103b8f:	0f 85 09 00 00 00    	jne    103b9e <z_impl_log_process+0x2e>
		return false;
  103b95:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  103b99:	e9 9d 00 00 00       	jmp    103c3b <z_impl_log_process+0xcb>
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  103b9e:	9c                   	pushf  
  103b9f:	fa                   	cli    
  103ba0:	8f 45 f8             	popl   -0x8(%ebp)
	return key;
  103ba3:	8b 45 f8             	mov    -0x8(%ebp),%eax
	unsigned int key = irq_lock();
  103ba6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	msg = log_list_head_get(&list);
  103ba9:	8d 05 28 50 13 00    	lea    0x135028,%eax
  103baf:	89 04 24             	mov    %eax,(%esp)
  103bb2:	e8 a9 f5 ff ff       	call   103160 <log_list_head_get>
  103bb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	irq_unlock(key);
  103bba:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  103bc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bc3:	25 00 02 00 00       	and    $0x200,%eax
  103bc8:	83 f8 00             	cmp    $0x0,%eax
  103bcb:	0f 84 01 00 00 00    	je     103bd2 <z_impl_log_process+0x62>
		__asm__ volatile ("sti" ::: "memory");
  103bd1:	fb                   	sti    
	if (msg != NULL) {
  103bd2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103bd6:	0f 84 29 00 00 00    	je     103c05 <z_impl_log_process+0x95>
		atomic_dec(&buffered_cnt);
  103bdc:	8d 05 5c 50 13 00    	lea    0x13505c,%eax
  103be2:	89 04 24             	mov    %eax,(%esp)
  103be5:	e8 66 00 00 00       	call   103c50 <atomic_dec>
		msg_process(msg, bypass);
  103bea:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103bed:	8a 55 f6             	mov    -0xa(%ebp),%dl
  103bf0:	80 e2 01             	and    $0x1,%dl
  103bf3:	89 0c 24             	mov    %ecx,(%esp)
  103bf6:	0f b6 ca             	movzbl %dl,%ecx
  103bf9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103bfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103c00:	e8 7b 00 00 00       	call   103c80 <msg_process>
	if (!bypass && dropped_cnt) {
  103c05:	f6 45 f6 01          	testb  $0x1,-0xa(%ebp)
  103c09:	0f 85 12 00 00 00    	jne    103c21 <z_impl_log_process+0xb1>
  103c0f:	83 3d 58 50 13 00 00 	cmpl   $0x0,0x135058
  103c16:	0f 84 05 00 00 00    	je     103c21 <z_impl_log_process+0xb1>
		dropped_notify();
  103c1c:	e8 3f fe ff ff       	call   103a60 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
  103c21:	8d 05 28 50 13 00    	lea    0x135028,%eax
  103c27:	89 04 24             	mov    %eax,(%esp)
  103c2a:	e8 11 f5 ff ff       	call   103140 <log_list_head_peek>
  103c2f:	83 f8 00             	cmp    $0x0,%eax
  103c32:	0f 95 c1             	setne  %cl
  103c35:	80 e1 01             	and    $0x1,%cl
  103c38:	88 4d f7             	mov    %cl,-0x9(%ebp)
}
  103c3b:	8a 45 f7             	mov    -0x9(%ebp),%al
  103c3e:	24 01                	and    $0x1,%al
  103c40:	0f b6 c0             	movzbl %al,%eax
  103c43:	83 c4 20             	add    $0x20,%esp
  103c46:	5d                   	pop    %ebp
  103c47:	c3                   	ret    
  103c48:	66 90                	xchg   %ax,%ax
  103c4a:	66 90                	xchg   %ax,%ax
  103c4c:	66 90                	xchg   %ax,%ax
  103c4e:	66 90                	xchg   %ax,%ax

00103c50 <atomic_dec>:
{
  103c50:	55                   	push   %ebp
  103c51:	89 e5                	mov    %esp,%ebp
  103c53:	83 ec 0c             	sub    $0xc,%esp
  103c56:	8b 45 08             	mov    0x8(%ebp),%eax
	return atomic_sub(target, 1);
  103c59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103c5c:	89 0c 24             	mov    %ecx,(%esp)
  103c5f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  103c66:	00 
  103c67:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103c6a:	e8 b1 05 00 00       	call   104220 <atomic_sub>
  103c6f:	83 c4 0c             	add    $0xc,%esp
  103c72:	5d                   	pop    %ebp
  103c73:	c3                   	ret    
  103c74:	66 90                	xchg   %ax,%ax
  103c76:	66 90                	xchg   %ax,%ax
  103c78:	66 90                	xchg   %ax,%ax
  103c7a:	66 90                	xchg   %ax,%ax
  103c7c:	66 90                	xchg   %ax,%ax
  103c7e:	66 90                	xchg   %ax,%ax

00103c80 <msg_process>:
{
  103c80:	55                   	push   %ebp
  103c81:	89 e5                	mov    %esp,%ebp
  103c83:	83 ec 18             	sub    $0x18,%esp
  103c86:	8a 45 0c             	mov    0xc(%ebp),%al
  103c89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103c8c:	24 01                	and    $0x1,%al
  103c8e:	88 45 ff             	mov    %al,-0x1(%ebp)
	if (!bypass) {
  103c91:	f6 45 ff 01          	testb  $0x1,-0x1(%ebp)
  103c95:	0f 85 a4 00 00 00    	jne    103d3f <msg_process+0xbf>
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
  103c9b:	f6 05 e6 96 13 00 01 	testb  $0x1,0x1396e6
  103ca2:	0f 85 0b 00 00 00    	jne    103cb3 <msg_process+0x33>
			detect_missed_strdup(msg);
  103ca8:	8b 45 08             	mov    0x8(%ebp),%eax
  103cab:	89 04 24             	mov    %eax,(%esp)
  103cae:	e8 9d 05 00 00       	call   104250 <detect_missed_strdup>
		for (int i = 0; i < log_backend_count_get(); i++) {
  103cb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103cba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103cbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103cc0:	e8 cb f9 ff ff       	call   103690 <log_backend_count_get>
  103cc5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103cc8:	39 c1                	cmp    %eax,%ecx
  103cca:	0f 8d 6a 00 00 00    	jge    103d3a <msg_process+0xba>
			backend = log_backend_get(i);
  103cd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103cd3:	89 04 24             	mov    %eax,(%esp)
  103cd6:	e8 d5 f9 ff ff       	call   1036b0 <log_backend_get>
  103cdb:	89 45 f8             	mov    %eax,-0x8(%ebp)
			if (log_backend_is_active(backend) &&
  103cde:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ce1:	89 04 24             	mov    %eax,(%esp)
  103ce4:	e8 e7 f9 ff ff       	call   1036d0 <log_backend_is_active>
  103ce9:	a8 01                	test   $0x1,%al
  103ceb:	0f 85 05 00 00 00    	jne    103cf6 <msg_process+0x76>
  103cf1:	e9 31 00 00 00       	jmp    103d27 <msg_process+0xa7>
			    msg_filter_check(backend, msg)) {
  103cf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103cf9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103cfc:	89 04 24             	mov    %eax,(%esp)
  103cff:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103d03:	e8 28 07 00 00       	call   104430 <msg_filter_check>
			if (log_backend_is_active(backend) &&
  103d08:	a8 01                	test   $0x1,%al
  103d0a:	0f 85 05 00 00 00    	jne    103d15 <msg_process+0x95>
  103d10:	e9 12 00 00 00       	jmp    103d27 <msg_process+0xa7>
				log_backend_put(backend, msg);
  103d15:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103d18:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103d1b:	89 04 24             	mov    %eax,(%esp)
  103d1e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103d22:	e8 29 07 00 00       	call   104450 <log_backend_put>
		}
  103d27:	e9 00 00 00 00       	jmp    103d2c <msg_process+0xac>
		for (int i = 0; i < log_backend_count_get(); i++) {
  103d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d2f:	83 c0 01             	add    $0x1,%eax
  103d32:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103d35:	e9 80 ff ff ff       	jmp    103cba <msg_process+0x3a>
	}
  103d3a:	e9 00 00 00 00       	jmp    103d3f <msg_process+0xbf>
	log_msg_put(msg);
  103d3f:	8b 45 08             	mov    0x8(%ebp),%eax
  103d42:	89 04 24             	mov    %eax,(%esp)
  103d45:	e8 56 0c 00 00       	call   1049a0 <log_msg_put>
}
  103d4a:	83 c4 18             	add    $0x18,%esp
  103d4d:	5d                   	pop    %ebp
  103d4e:	c3                   	ret    
  103d4f:	90                   	nop

00103d50 <log_dropped>:
{
  103d50:	55                   	push   %ebp
  103d51:	89 e5                	mov    %esp,%ebp
  103d53:	50                   	push   %eax
	atomic_inc(&dropped_cnt);
  103d54:	8d 05 58 50 13 00    	lea    0x135058,%eax
  103d5a:	89 04 24             	mov    %eax,(%esp)
  103d5d:	e8 fe fa ff ff       	call   103860 <atomic_inc>
}
  103d62:	83 c4 04             	add    $0x4,%esp
  103d65:	5d                   	pop    %ebp
  103d66:	c3                   	ret    
  103d67:	66 90                	xchg   %ax,%ax
  103d69:	66 90                	xchg   %ax,%ax
  103d6b:	66 90                	xchg   %ax,%ax
  103d6d:	66 90                	xchg   %ax,%ax
  103d6f:	90                   	nop

00103d70 <log_sources_count>:
			sizeof(struct log_source_const_data);
}

/** @brief Get number of registered sources. */
static inline u32_t log_sources_count(void)
{
  103d70:	55                   	push   %ebp
  103d71:	89 e5                	mov    %esp,%ebp
  103d73:	50                   	push   %eax
	return log_const_source_id(__log_const_end);
  103d74:	8d 05 a4 30 12 00    	lea    0x1230a4,%eax
  103d7a:	89 04 24             	mov    %eax,(%esp)
  103d7d:	e8 1e 08 00 00       	call   1045a0 <log_const_source_id>
  103d82:	83 c4 04             	add    $0x4,%esp
  103d85:	5d                   	pop    %ebp
  103d86:	c3                   	ret    
  103d87:	66 90                	xchg   %ax,%ax
  103d89:	66 90                	xchg   %ax,%ax
  103d8b:	66 90                	xchg   %ax,%ax
  103d8d:	66 90                	xchg   %ax,%ax
  103d8f:	90                   	nop

00103d90 <log_source_name_get>:
{
  103d90:	55                   	push   %ebp
  103d91:	89 e5                	mov    %esp,%ebp
  103d93:	83 ec 14             	sub    $0x14,%esp
  103d96:	8b 45 0c             	mov    0xc(%ebp),%eax
  103d99:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
  103d9c:	8b 55 0c             	mov    0xc(%ebp),%edx
  103d9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103da2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103da5:	89 55 f4             	mov    %edx,-0xc(%ebp)
  103da8:	e8 c3 ff ff ff       	call   103d70 <log_sources_count>
  103dad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103db0:	39 c1                	cmp    %eax,%ecx
  103db2:	0f 83 13 00 00 00    	jae    103dcb <log_source_name_get+0x3b>
  103db8:	8b 45 0c             	mov    0xc(%ebp),%eax
  103dbb:	89 04 24             	mov    %eax,(%esp)
  103dbe:	e8 1d 00 00 00       	call   103de0 <log_name_get>
  103dc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103dc6:	e9 0a 00 00 00       	jmp    103dd5 <log_source_name_get+0x45>
  103dcb:	31 c0                	xor    %eax,%eax
  103dcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103dd0:	e9 00 00 00 00       	jmp    103dd5 <log_source_name_get+0x45>
  103dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103dd8:	83 c4 14             	add    $0x14,%esp
  103ddb:	5d                   	pop    %ebp
  103ddc:	c3                   	ret    
  103ddd:	66 90                	xchg   %ax,%ax
  103ddf:	90                   	nop

00103de0 <log_name_get>:
{
  103de0:	55                   	push   %ebp
  103de1:	89 e5                	mov    %esp,%ebp
  103de3:	50                   	push   %eax
  103de4:	8b 45 08             	mov    0x8(%ebp),%eax
	return __log_const_start[source_id].name;
  103de7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103dea:	8b 0c cd 84 30 12 00 	mov    0x123084(,%ecx,8),%ecx
  103df1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103df4:	89 c8                	mov    %ecx,%eax
  103df6:	83 c4 04             	add    $0x4,%esp
  103df9:	5d                   	pop    %ebp
  103dfa:	c3                   	ret    
  103dfb:	66 90                	xchg   %ax,%ax
  103dfd:	66 90                	xchg   %ax,%ax
  103dff:	90                   	nop

00103e00 <log_backend_id_set>:
{
  103e00:	55                   	push   %ebp
  103e01:	89 e5                	mov    %esp,%ebp
  103e03:	56                   	push   %esi
  103e04:	8a 45 0c             	mov    0xc(%ebp),%al
  103e07:	8b 4d 08             	mov    0x8(%ebp),%ecx
	backend->cb->id = id;
  103e0a:	8a 55 0c             	mov    0xc(%ebp),%dl
  103e0d:	8b 75 08             	mov    0x8(%ebp),%esi
  103e10:	8b 76 04             	mov    0x4(%esi),%esi
  103e13:	88 56 04             	mov    %dl,0x4(%esi)
}
  103e16:	5e                   	pop    %esi
  103e17:	5d                   	pop    %ebp
  103e18:	c3                   	ret    
  103e19:	66 90                	xchg   %ax,%ax
  103e1b:	66 90                	xchg   %ax,%ax
  103e1d:	66 90                	xchg   %ax,%ax
  103e1f:	90                   	nop

00103e20 <backend_filter_set>:
{
  103e20:	55                   	push   %ebp
  103e21:	89 e5                	mov    %esp,%ebp
  103e23:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e26:	8b 4d 08             	mov    0x8(%ebp),%ecx
}
  103e29:	5d                   	pop    %ebp
  103e2a:	c3                   	ret    
  103e2b:	66 90                	xchg   %ax,%ax
  103e2d:	66 90                	xchg   %ax,%ax
  103e2f:	90                   	nop

00103e30 <log_backend_activate>:
{
  103e30:	55                   	push   %ebp
  103e31:	89 e5                	mov    %esp,%ebp
  103e33:	56                   	push   %esi
  103e34:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e37:	8b 4d 08             	mov    0x8(%ebp),%ecx
	backend->cb->ctx = ctx;
  103e3a:	8b 55 0c             	mov    0xc(%ebp),%edx
  103e3d:	8b 75 08             	mov    0x8(%ebp),%esi
  103e40:	8b 76 04             	mov    0x4(%esi),%esi
  103e43:	89 16                	mov    %edx,(%esi)
	backend->cb->active = true;
  103e45:	8b 55 08             	mov    0x8(%ebp),%edx
  103e48:	8b 52 04             	mov    0x4(%edx),%edx
  103e4b:	c6 42 05 01          	movb   $0x1,0x5(%edx)
}
  103e4f:	5e                   	pop    %esi
  103e50:	5d                   	pop    %ebp
  103e51:	c3                   	ret    
  103e52:	66 90                	xchg   %ax,%ax
  103e54:	66 90                	xchg   %ax,%ax
  103e56:	66 90                	xchg   %ax,%ax
  103e58:	66 90                	xchg   %ax,%ax
  103e5a:	66 90                	xchg   %ax,%ax
  103e5c:	66 90                	xchg   %ax,%ax
  103e5e:	66 90                	xchg   %ax,%ax

00103e60 <k_sem_give>:
}


extern void z_impl_k_sem_give(struct k_sem * sem);
static inline void k_sem_give(struct k_sem * sem)
{
  103e60:	55                   	push   %ebp
  103e61:	89 e5                	mov    %esp,%ebp
  103e63:	50                   	push   %eax
  103e64:	8b 45 08             	mov    0x8(%ebp),%eax
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  103e67:	8b 45 08             	mov    0x8(%ebp),%eax
  103e6a:	89 04 24             	mov    %eax,(%esp)
  103e6d:	e8 1e c0 01 00       	call   11fe90 <z_impl_k_sem_give>
}
  103e72:	83 c4 04             	add    $0x4,%esp
  103e75:	5d                   	pop    %ebp
  103e76:	c3                   	ret    
  103e77:	66 90                	xchg   %ax,%ax
  103e79:	66 90                	xchg   %ax,%ax
  103e7b:	66 90                	xchg   %ax,%ax
  103e7d:	66 90                	xchg   %ax,%ax
  103e7f:	90                   	nop

00103e80 <log_strdup>:
		return log_compiled_level_get(src_id);
	}
}

char *log_strdup(const char *str)
{
  103e80:	55                   	push   %ebp
  103e81:	89 e5                	mov    %esp,%ebp
  103e83:	83 ec 24             	sub    $0x24,%esp
  103e86:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_strdup_buf *dup;
	int err;

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
	    is_rodata(str) || _is_user_context()) {
  103e89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103e8c:	89 0c 24             	mov    %ecx,(%esp)
  103e8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103e92:	e8 b9 00 00 00       	call   103f50 <is_rodata>
  103e97:	a8 01                	test   $0x1,%al
  103e99:	0f 85 12 00 00 00    	jne    103eb1 <log_strdup+0x31>
  103e9f:	e8 dc f7 ff ff       	call   103680 <_is_user_context>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
  103ea4:	a8 01                	test   $0x1,%al
  103ea6:	0f 85 05 00 00 00    	jne    103eb1 <log_strdup+0x31>
  103eac:	e9 0b 00 00 00       	jmp    103ebc <log_strdup+0x3c>
		return (char *)str;
  103eb1:	8b 45 08             	mov    0x8(%ebp),%eax
  103eb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103eb7:	e9 86 00 00 00       	jmp    103f42 <log_strdup+0xc2>
  103ebc:	31 c0                	xor    %eax,%eax
	}

	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
  103ebe:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  103ec1:	8d 15 30 50 13 00    	lea    0x135030,%edx
  103ec7:	89 14 24             	mov    %edx,(%esp)
  103eca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103ece:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  103ed5:	00 
  103ed6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103ed9:	e8 22 94 01 00       	call   11d300 <k_mem_slab_alloc>
  103ede:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (err != 0) {
  103ee1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103ee5:	0f 84 0d 00 00 00    	je     103ef8 <log_strdup+0x78>
		/* failed to allocate */
		return (char *)log_strdup_fail_msg;
  103eeb:	a1 0c 30 14 00       	mov    0x14300c,%eax
  103ef0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103ef3:	e9 4a 00 00 00       	jmp    103f42 <log_strdup+0xc2>
		log_strdup_longest = MAX(slen, log_strdup_longest);
		k_spin_unlock(&lock, key);
	}

	/* Set 'allocated' flag. */
	(void)atomic_set(&dup->refcount, 1);
  103ef8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103efb:	89 04 24             	mov    %eax,(%esp)
  103efe:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  103f05:	00 
  103f06:	e8 f5 fb ff ff       	call   103b00 <atomic_set>

	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
  103f0b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103f0e:	83 c1 04             	add    $0x4,%ecx
  103f11:	8b 55 08             	mov    0x8(%ebp),%edx
  103f14:	89 0c 24             	mov    %ecx,(%esp)
  103f17:	89 54 24 04          	mov    %edx,0x4(%esp)
  103f1b:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  103f22:	00 
  103f23:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103f26:	e8 35 62 00 00       	call   10a160 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
  103f2b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103f2e:	c6 41 23 7e          	movb   $0x7e,0x23(%ecx)
	dup->buf[sizeof(dup->buf) - 1] = '\0';
  103f32:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103f35:	c6 41 24 00          	movb   $0x0,0x24(%ecx)

	return dup->buf;
  103f39:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103f3c:	83 c1 04             	add    $0x4,%ecx
  103f3f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
}
  103f42:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f45:	83 c4 24             	add    $0x24,%esp
  103f48:	5d                   	pop    %ebp
  103f49:	c3                   	ret    
  103f4a:	66 90                	xchg   %ax,%ax
  103f4c:	66 90                	xchg   %ax,%ax
  103f4e:	66 90                	xchg   %ax,%ax

00103f50 <is_rodata>:
{
  103f50:	55                   	push   %ebp
  103f51:	89 e5                	mov    %esp,%ebp
  103f53:	50                   	push   %eax
  103f54:	8b 45 08             	mov    0x8(%ebp),%eax
  103f57:	31 c9                	xor    %ecx,%ecx
  103f59:	8d 15 00 30 12 00    	lea    0x123000,%edx
	return (((const char *)addr >= (const char *)RO_START) &&
  103f5f:	39 55 08             	cmp    %edx,0x8(%ebp)
  103f62:	88 4d ff             	mov    %cl,-0x1(%ebp)
  103f65:	0f 82 0f 00 00 00    	jb     103f7a <is_rodata+0x2a>
  103f6b:	8d 05 00 60 12 00    	lea    0x126000,%eax
		((const char *)addr < (const char *)RO_END));
  103f71:	39 45 08             	cmp    %eax,0x8(%ebp)
  103f74:	0f 92 c1             	setb   %cl
  103f77:	88 4d ff             	mov    %cl,-0x1(%ebp)
  103f7a:	8a 45 ff             	mov    -0x1(%ebp),%al
	return (((const char *)addr >= (const char *)RO_START) &&
  103f7d:	24 01                	and    $0x1,%al
  103f7f:	0f b6 c0             	movzbl %al,%eax
  103f82:	83 c4 04             	add    $0x4,%esp
  103f85:	5d                   	pop    %ebp
  103f86:	c3                   	ret    
  103f87:	66 90                	xchg   %ax,%ax
  103f89:	66 90                	xchg   %ax,%ax
  103f8b:	66 90                	xchg   %ax,%ax
  103f8d:	66 90                	xchg   %ax,%ax
  103f8f:	90                   	nop

00103f90 <log_is_strdup>:
	return IS_ENABLED(CONFIG_LOG_STRDUP_POOL_PROFILING) ?
			log_strdup_longest : 0;
}

bool log_is_strdup(const void *buf)
{
  103f90:	55                   	push   %ebp
  103f91:	89 e5                	mov    %esp,%ebp
  103f93:	50                   	push   %eax
  103f94:	8b 45 08             	mov    0x8(%ebp),%eax
  103f97:	31 c9                	xor    %ecx,%ecx
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
  103f99:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103f9d:	88 4d ff             	mov    %cl,-0x1(%ebp)
  103fa0:	0f 84 2e 00 00 00    	je     103fd4 <log_is_strdup+0x44>
  103fa6:	31 c0                	xor    %eax,%eax
  103fa8:	8d 0d f0 0e 14 00    	lea    0x140ef0,%ecx
  103fae:	39 4d 08             	cmp    %ecx,0x8(%ebp)
  103fb1:	88 45 fe             	mov    %al,-0x2(%ebp)
  103fb4:	0f 82 14 00 00 00    	jb     103fce <log_is_strdup+0x3e>
  103fba:	8d 05 f0 0e 14 00    	lea    0x140ef0,%eax
  103fc0:	05 a0 00 00 00       	add    $0xa0,%eax
  103fc5:	39 45 08             	cmp    %eax,0x8(%ebp)
  103fc8:	0f 92 c1             	setb   %cl
  103fcb:	88 4d fe             	mov    %cl,-0x2(%ebp)
  103fce:	8a 45 fe             	mov    -0x2(%ebp),%al
  103fd1:	88 45 ff             	mov    %al,-0x1(%ebp)
  103fd4:	8a 45 ff             	mov    -0x1(%ebp),%al
  103fd7:	24 01                	and    $0x1,%al
  103fd9:	0f b6 c0             	movzbl %al,%eax
  103fdc:	83 c4 04             	add    $0x4,%esp
  103fdf:	5d                   	pop    %ebp
  103fe0:	c3                   	ret    
  103fe1:	66 90                	xchg   %ax,%ax
  103fe3:	66 90                	xchg   %ax,%ax
  103fe5:	66 90                	xchg   %ax,%ax
  103fe7:	66 90                	xchg   %ax,%ax
  103fe9:	66 90                	xchg   %ax,%ax
  103feb:	66 90                	xchg   %ax,%ax
  103fed:	66 90                	xchg   %ax,%ax
  103fef:	90                   	nop

00103ff0 <log_free>:

}

void log_free(void *str)
{
  103ff0:	55                   	push   %ebp
  103ff1:	89 e5                	mov    %esp,%ebp
  103ff3:	83 ec 10             	sub    $0x10,%esp
  103ff6:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
  103ff9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103ffc:	83 c1 fc             	add    $0xfffffffc,%ecx
  103fff:	89 4d fc             	mov    %ecx,-0x4(%ebp)
						  buf);

	if (atomic_dec(&dup->refcount) == 1) {
  104002:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104005:	89 0c 24             	mov    %ecx,(%esp)
  104008:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10400b:	e8 40 fc ff ff       	call   103c50 <atomic_dec>
  104010:	83 f8 01             	cmp    $0x1,%eax
  104013:	0f 85 15 00 00 00    	jne    10402e <log_free+0x3e>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
  104019:	8d 45 fc             	lea    -0x4(%ebp),%eax
  10401c:	8d 0d 30 50 13 00    	lea    0x135030,%ecx
  104022:	89 0c 24             	mov    %ecx,(%esp)
  104025:	89 44 24 04          	mov    %eax,0x4(%esp)
  104029:	e8 02 94 01 00       	call   11d430 <k_mem_slab_free>
		if (IS_ENABLED(CONFIG_LOG_STRDUP_POOL_PROFILING)) {
			atomic_dec((atomic_t *)&log_strdup_in_use);
		}
	}
}
  10402e:	83 c4 10             	add    $0x10,%esp
  104031:	5d                   	pop    %ebp
  104032:	c3                   	ret    
  104033:	66 90                	xchg   %ax,%ax
  104035:	66 90                	xchg   %ax,%ax
  104037:	66 90                	xchg   %ax,%ax
  104039:	66 90                	xchg   %ax,%ax
  10403b:	66 90                	xchg   %ax,%ax
  10403d:	66 90                	xchg   %ax,%ax
  10403f:	90                   	nop

00104040 <log_from_user>:

	__ASSERT_NO_MSG(false);
}

void log_from_user(struct log_msg_ids src_level, const char *fmt, ...)
{
  104040:	55                   	push   %ebp
  104041:	89 e5                	mov    %esp,%ebp
  104043:	8b 45 0c             	mov    0xc(%ebp),%eax
	ARG_UNUSED(src_level);
	ARG_UNUSED(fmt);

	__ASSERT_NO_MSG(false);
}
  104046:	5d                   	pop    %ebp
  104047:	c3                   	ret    
  104048:	66 90                	xchg   %ax,%ax
  10404a:	66 90                	xchg   %ax,%ax
  10404c:	66 90                	xchg   %ax,%ax
  10404e:	66 90                	xchg   %ax,%ax

00104050 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
  104050:	55                   	push   %ebp
  104051:	89 e5                	mov    %esp,%ebp
  104053:	83 ec 3c             	sub    $0x3c,%esp
  104056:	8b 45 08             	mov    0x8(%ebp),%eax
  104059:	31 c9                	xor    %ecx,%ecx
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
  10405b:	8d 15 a4 50 13 00    	lea    0x1350a4,%edx
  104061:	89 14 24             	mov    %edx,(%esp)
  104064:	8d 15 f0 45 10 00    	lea    0x1045f0,%edx
  10406a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10406e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  104075:	00 
  104076:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104079:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10407c:	e8 ff df 01 00       	call   122080 <k_timer_init>
  104081:	31 c0                	xor    %eax,%eax
				log_process_thread_timer_expiry_fn, NULL);
		/* start logging thread */
		k_thread_create(&logging_thread, logging_stack,
  104083:	8d 0d 60 50 13 00    	lea    0x135060,%ecx
  104089:	89 0c 24             	mov    %ecx,(%esp)
  10408c:	8d 0d 90 0f 14 00    	lea    0x140f90,%ecx
  104092:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104096:	c7 44 24 08 00 03 00 	movl   $0x300,0x8(%esp)
  10409d:	00 
  10409e:	8d 0d c0 46 10 00    	lea    0x1046c0,%ecx
  1040a4:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1040a8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1040af:	00 
  1040b0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1040b7:	00 
  1040b8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1040bf:	00 
  1040c0:	c7 44 24 1c 0e 00 00 	movl   $0xe,0x1c(%esp)
  1040c7:	00 
  1040c8:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
  1040cf:	00 
  1040d0:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  1040d7:	00 
  1040d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1040db:	e8 30 05 00 00       	call   104610 <k_thread_create>
				K_THREAD_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
		k_thread_name_set(&logging_thread, "logging");
  1040e0:	8d 0d 60 50 13 00    	lea    0x135060,%ecx
  1040e6:	89 0c 24             	mov    %ecx,(%esp)
  1040e9:	8d 0d 4b 37 12 00    	lea    0x12374b,%ecx
  1040ef:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1040f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1040f6:	e8 35 06 00 00       	call   104730 <k_thread_name_set>
  1040fb:	31 c9                	xor    %ecx,%ecx
  1040fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	} else {
		log_init();
	}

	return 0;
  104100:	89 c8                	mov    %ecx,%eax
  104102:	83 c4 3c             	add    $0x3c,%esp
  104105:	5d                   	pop    %ebp
  104106:	c3                   	ret    
  104107:	66 90                	xchg   %ax,%ax
  104109:	66 90                	xchg   %ax,%ax
  10410b:	66 90                	xchg   %ax,%ax
  10410d:	66 90                	xchg   %ax,%ax
  10410f:	90                   	nop

00104110 <z_log_msg_std_alloc>:
{
  104110:	55                   	push   %ebp
  104111:	89 e5                	mov    %esp,%ebp
  104113:	50                   	push   %eax
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
  104114:	e8 07 07 00 00       	call   104820 <log_msg_chunk_alloc>
  104119:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (msg != NULL) {
  10411c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  104120:	0f 84 22 00 00 00    	je     104148 <z_log_msg_std_alloc+0x38>
		msg->hdr.ref_cnt = 1;
  104126:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104129:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0U;
  104130:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104133:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
  104139:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10413c:	66 8b 48 08          	mov    0x8(%eax),%cx
  104140:	66 83 e1 fe          	and    $0xfffe,%cx
  104144:	66 89 48 08          	mov    %cx,0x8(%eax)
	return msg;
  104148:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10414b:	83 c4 04             	add    $0x4,%esp
  10414e:	5d                   	pop    %ebp
  10414f:	c3                   	ret    

00104150 <k_timer_start>:
{
  104150:	55                   	push   %ebp
  104151:	89 e5                	mov    %esp,%ebp
  104153:	83 ec 0c             	sub    $0xc,%esp
  104156:	8b 45 10             	mov    0x10(%ebp),%eax
  104159:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10415c:	8b 55 08             	mov    0x8(%ebp),%edx
	z_impl_k_timer_start(timer, duration, period);
  10415f:	8b 45 08             	mov    0x8(%ebp),%eax
  104162:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104165:	8b 55 10             	mov    0x10(%ebp),%edx
  104168:	89 04 24             	mov    %eax,(%esp)
  10416b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10416f:	89 54 24 08          	mov    %edx,0x8(%esp)
  104173:	e8 f8 df 01 00       	call   122170 <z_impl_k_timer_start>
}
  104178:	83 c4 0c             	add    $0xc,%esp
  10417b:	5d                   	pop    %ebp
  10417c:	c3                   	ret    
  10417d:	66 90                	xchg   %ax,%ax
  10417f:	90                   	nop

00104180 <k_timer_stop>:
{
  104180:	55                   	push   %ebp
  104181:	89 e5                	mov    %esp,%ebp
  104183:	50                   	push   %eax
  104184:	8b 45 08             	mov    0x8(%ebp),%eax
	z_impl_k_timer_stop(timer);
  104187:	8b 45 08             	mov    0x8(%ebp),%eax
  10418a:	89 04 24             	mov    %eax,(%esp)
  10418d:	e8 fe e3 01 00       	call   122590 <z_impl_k_timer_stop>
}
  104192:	83 c4 04             	add    $0x4,%esp
  104195:	5d                   	pop    %ebp
  104196:	c3                   	ret    
  104197:	66 90                	xchg   %ax,%ax
  104199:	66 90                	xchg   %ax,%ax
  10419b:	66 90                	xchg   %ax,%ax
  10419d:	66 90                	xchg   %ax,%ax
  10419f:	90                   	nop

001041a0 <dummy_timestamp>:
{
  1041a0:	55                   	push   %ebp
  1041a1:	89 e5                	mov    %esp,%ebp
  1041a3:	31 c0                	xor    %eax,%eax
	return 0;
  1041a5:	5d                   	pop    %ebp
  1041a6:	c3                   	ret    
  1041a7:	66 90                	xchg   %ax,%ax
  1041a9:	66 90                	xchg   %ax,%ax
  1041ab:	66 90                	xchg   %ax,%ax
  1041ad:	66 90                	xchg   %ax,%ax
  1041af:	90                   	nop

001041b0 <z_clock_hw_cycles_per_sec_runtime_get>:
extern "C" {
#endif

extern int z_impl_z_clock_hw_cycles_per_sec_runtime_get();
static inline int z_clock_hw_cycles_per_sec_runtime_get()
{
  1041b0:	55                   	push   %ebp
  1041b1:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke0(K_SYSCALL_Z_CLOCK_HW_CYCLES_PER_SEC_RUNTIME_GET);
	}
#endif
	compiler_barrier();
  1041b3:	e9 00 00 00 00       	jmp    1041b8 <z_clock_hw_cycles_per_sec_runtime_get+0x8>
	return z_impl_z_clock_hw_cycles_per_sec_runtime_get();
  1041b8:	e8 d3 ef ff ff       	call   103190 <z_impl_z_clock_hw_cycles_per_sec_runtime_get>
  1041bd:	5d                   	pop    %ebp
  1041be:	c3                   	ret    
  1041bf:	90                   	nop

001041c0 <k_uptime_get>:
{
  1041c0:	55                   	push   %ebp
  1041c1:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  1041c3:	e9 00 00 00 00       	jmp    1041c8 <k_uptime_get+0x8>
	return z_impl_k_uptime_get();
  1041c8:	e8 83 d8 01 00       	call   121a50 <z_impl_k_uptime_get>
  1041cd:	5d                   	pop    %ebp
  1041ce:	c3                   	ret    
  1041cf:	90                   	nop

001041d0 <k_cycle_get_32>:
 * clock.
 *
 * @return Current hardware clock up-counter (in cycles).
 */
static inline u32_t k_cycle_get_32(void)
{
  1041d0:	55                   	push   %ebp
  1041d1:	89 e5                	mov    %esp,%ebp
	return arch_k_cycle_get_32();
  1041d3:	e8 08 00 00 00       	call   1041e0 <arch_k_cycle_get_32>
  1041d8:	5d                   	pop    %ebp
  1041d9:	c3                   	ret    
  1041da:	66 90                	xchg   %ax,%ax
  1041dc:	66 90                	xchg   %ax,%ax
  1041de:	66 90                	xchg   %ax,%ax

001041e0 <arch_k_cycle_get_32>:
extern void arch_irq_disable(unsigned int irq);

extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
  1041e0:	55                   	push   %ebp
  1041e1:	89 e5                	mov    %esp,%ebp
	return z_timer_cycle_get_32();
  1041e3:	e8 d8 3a 00 00       	call   107cc0 <z_timer_cycle_get_32>
  1041e8:	5d                   	pop    %ebp
  1041e9:	c3                   	ret    
  1041ea:	66 90                	xchg   %ax,%ax
  1041ec:	66 90                	xchg   %ax,%ax
  1041ee:	66 90                	xchg   %ax,%ax

001041f0 <atomic_add>:
{
  1041f0:	55                   	push   %ebp
  1041f1:	89 e5                	mov    %esp,%ebp
  1041f3:	56                   	push   %esi
  1041f4:	83 ec 0c             	sub    $0xc,%esp
  1041f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1041fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  1041fd:	8b 55 08             	mov    0x8(%ebp),%edx
  104200:	8b 75 0c             	mov    0xc(%ebp),%esi
  104203:	89 75 f8             	mov    %esi,-0x8(%ebp)
  104206:	8b 75 f8             	mov    -0x8(%ebp),%esi
  104209:	f0 0f c1 32          	lock xadd %esi,(%edx)
  10420d:	89 75 f4             	mov    %esi,-0xc(%ebp)
  104210:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104213:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104216:	89 d0                	mov    %edx,%eax
  104218:	83 c4 0c             	add    $0xc,%esp
  10421b:	5e                   	pop    %esi
  10421c:	5d                   	pop    %ebp
  10421d:	c3                   	ret    
  10421e:	66 90                	xchg   %ax,%ax

00104220 <atomic_sub>:
{
  104220:	55                   	push   %ebp
  104221:	89 e5                	mov    %esp,%ebp
  104223:	56                   	push   %esi
  104224:	83 ec 0c             	sub    $0xc,%esp
  104227:	8b 45 0c             	mov    0xc(%ebp),%eax
  10422a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  10422d:	8b 55 08             	mov    0x8(%ebp),%edx
  104230:	8b 75 0c             	mov    0xc(%ebp),%esi
  104233:	89 75 f8             	mov    %esi,-0x8(%ebp)
  104236:	8b 75 f8             	mov    -0x8(%ebp),%esi
  104239:	f7 de                	neg    %esi
  10423b:	f0 0f c1 32          	lock xadd %esi,(%edx)
  10423f:	89 75 f4             	mov    %esi,-0xc(%ebp)
  104242:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104245:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104248:	89 d0                	mov    %edx,%eax
  10424a:	83 c4 0c             	add    $0xc,%esp
  10424d:	5e                   	pop    %esi
  10424e:	5d                   	pop    %ebp
  10424f:	c3                   	ret    

00104250 <detect_missed_strdup>:
{
  104250:	55                   	push   %ebp
  104251:	89 e5                	mov    %esp,%ebp
  104253:	56                   	push   %esi
  104254:	83 e4 f8             	and    $0xfffffff8,%esp
  104257:	83 ec 30             	sub    $0x30,%esp
  10425a:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!log_msg_is_std(msg)) {
  10425d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104260:	89 0c 24             	mov    %ecx,(%esp)
  104263:	89 44 24 14          	mov    %eax,0x14(%esp)
  104267:	e8 24 02 00 00       	call   104490 <log_msg_is_std>
  10426c:	a8 01                	test   $0x1,%al
  10426e:	0f 85 05 00 00 00    	jne    104279 <detect_missed_strdup+0x29>
		return;
  104274:	e9 a9 01 00 00       	jmp    104422 <detect_missed_strdup+0x1d2>
	msg_str = log_msg_str_get(msg);
  104279:	8b 45 08             	mov    0x8(%ebp),%eax
  10427c:	89 04 24             	mov    %eax,(%esp)
  10427f:	e8 9c 09 00 00       	call   104c20 <log_msg_str_get>
  104284:	89 44 24 20          	mov    %eax,0x20(%esp)
	mask = count_s(msg_str, log_msg_nargs_get(msg));
  104288:	8b 44 24 20          	mov    0x20(%esp),%eax
  10428c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10428f:	89 0c 24             	mov    %ecx,(%esp)
  104292:	89 44 24 10          	mov    %eax,0x10(%esp)
  104296:	e8 65 08 00 00       	call   104b00 <log_msg_nargs_get>
  10429b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10429f:	89 0c 24             	mov    %ecx,(%esp)
  1042a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1042a6:	e8 15 02 00 00       	call   1044c0 <count_s>
  1042ab:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (mask) {
  1042af:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  1042b4:	0f 84 68 01 00 00    	je     104422 <detect_missed_strdup+0x1d2>
		idx = 31 - __builtin_clz(mask);
  1042ba:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1042be:	0f bd c0             	bsr    %eax,%eax
  1042c1:	83 f0 1f             	xor    $0x1f,%eax
  1042c4:	b9 1f 00 00 00       	mov    $0x1f,%ecx
  1042c9:	29 c1                	sub    %eax,%ecx
  1042cb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
		str = (const char *)log_msg_arg_get(msg, idx);
  1042cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1042d2:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  1042d6:	89 04 24             	mov    %eax,(%esp)
  1042d9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1042dd:	e8 3e 08 00 00       	call   104b20 <log_msg_arg_get>
  1042e2:	89 44 24 24          	mov    %eax,0x24(%esp)
		if (!is_rodata(str) && !log_is_strdup(str) &&
  1042e6:	8b 44 24 24          	mov    0x24(%esp),%eax
  1042ea:	89 04 24             	mov    %eax,(%esp)
  1042ed:	e8 5e fc ff ff       	call   103f50 <is_rodata>
  1042f2:	a8 01                	test   $0x1,%al
  1042f4:	0f 85 0d 01 00 00    	jne    104407 <detect_missed_strdup+0x1b7>
  1042fa:	8b 44 24 24          	mov    0x24(%esp),%eax
  1042fe:	89 04 24             	mov    %eax,(%esp)
  104301:	e8 8a fc ff ff       	call   103f90 <log_is_strdup>
  104306:	a8 01                	test   $0x1,%al
  104308:	0f 85 f9 00 00 00    	jne    104407 <detect_missed_strdup+0x1b7>
			(str != log_strdup_fail_msg)) {
  10430e:	8b 44 24 24          	mov    0x24(%esp),%eax
  104312:	3b 05 0c 30 14 00    	cmp    0x14300c,%eax
		if (!is_rodata(str) && !log_is_strdup(str) &&
  104318:	0f 84 e9 00 00 00    	je     104407 <detect_missed_strdup+0x1b7>
				LOG_ERR(ERR_MSG, idx, msg_str);
  10431e:	e9 00 00 00 00       	jmp    104323 <detect_missed_strdup+0xd3>
  104323:	e8 58 f3 ff ff       	call   103680 <_is_user_context>
  104328:	24 01                	and    $0x1,%al
  10432a:	88 44 24 1b          	mov    %al,0x1b(%esp)
  10432e:	f6 44 24 1b 01       	testb  $0x1,0x1b(%esp)
  104333:	0f 85 0f 00 00 00    	jne    104348 <detect_missed_strdup+0xf8>
  104339:	b0 01                	mov    $0x1,%al
  10433b:	a8 01                	test   $0x1,%al
  10433d:	0f 85 05 00 00 00    	jne    104348 <detect_missed_strdup+0xf8>
  104343:	e9 b5 00 00 00       	jmp    1043fd <detect_missed_strdup+0x1ad>
  104348:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  10434d:	66 83 e0 f8          	and    $0xfff8,%ax
  104351:	66 83 c8 01          	or     $0x1,%ax
  104355:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  10435a:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  10435f:	66 83 e0 c7          	and    $0xffc7,%ax
  104363:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  104368:	8b 0d 10 30 14 00    	mov    0x143010,%ecx
  10436e:	89 0c 24             	mov    %ecx,(%esp)
  104371:	e8 2a 02 00 00       	call   1045a0 <log_const_source_id>
  104376:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  10437b:	66 25 ff 03          	and    $0x3ff,%ax
  10437f:	66 c1 e0 06          	shl    $0x6,%ax
  104383:	66 83 e2 3f          	and    $0x3f,%dx
  104387:	66 09 c2             	or     %ax,%dx
  10438a:	66 89 54 24 18       	mov    %dx,0x18(%esp)
  10438f:	f6 44 24 1b 01       	testb  $0x1,0x1b(%esp)
  104394:	0f 84 2f 00 00 00    	je     1043c9 <detect_missed_strdup+0x179>
  10439a:	8b 44 24 28          	mov    0x28(%esp),%eax
  10439e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1043a2:	8d 54 24 18          	lea    0x18(%esp),%edx
  1043a6:	66 8b 32             	mov    (%edx),%si
  1043a9:	66 89 34 24          	mov    %si,(%esp)
  1043ad:	8d 15 fb 36 12 00    	lea    0x1236fb,%edx
  1043b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  1043b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1043bb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1043bf:	e8 7c fc ff ff       	call   104040 <log_from_user>
  1043c4:	e9 2a 00 00 00       	jmp    1043f3 <detect_missed_strdup+0x1a3>
  1043c9:	8b 44 24 28          	mov    0x28(%esp),%eax
  1043cd:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1043d1:	8d 15 fb 36 12 00    	lea    0x1236fb,%edx
  1043d7:	89 14 24             	mov    %edx,(%esp)
  1043da:	89 44 24 04          	mov    %eax,0x4(%esp)
  1043de:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1043e2:	8d 44 24 18          	lea    0x18(%esp),%eax
  1043e6:	66 8b 30             	mov    (%eax),%si
  1043e9:	66 89 74 24 0c       	mov    %si,0xc(%esp)
  1043ee:	e8 2d f0 ff ff       	call   103420 <log_2>
  1043f3:	e9 00 00 00 00       	jmp    1043f8 <detect_missed_strdup+0x1a8>
  1043f8:	e9 00 00 00 00       	jmp    1043fd <detect_missed_strdup+0x1ad>
  1043fd:	e9 00 00 00 00       	jmp    104402 <detect_missed_strdup+0x1b2>
		}
  104402:	e9 00 00 00 00       	jmp    104407 <detect_missed_strdup+0x1b7>
		mask &= ~BIT(idx);
  104407:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  10440b:	b8 01 00 00 00       	mov    $0x1,%eax
  104410:	d3 e0                	shl    %cl,%eax
  104412:	83 f0 ff             	xor    $0xffffffff,%eax
  104415:	23 44 24 1c          	and    0x1c(%esp),%eax
  104419:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (mask) {
  10441d:	e9 8d fe ff ff       	jmp    1042af <detect_missed_strdup+0x5f>
}
  104422:	8d 65 fc             	lea    -0x4(%ebp),%esp
  104425:	5e                   	pop    %esi
  104426:	5d                   	pop    %ebp
  104427:	c3                   	ret    
  104428:	66 90                	xchg   %ax,%ax
  10442a:	66 90                	xchg   %ax,%ax
  10442c:	66 90                	xchg   %ax,%ax
  10442e:	66 90                	xchg   %ax,%ax

00104430 <msg_filter_check>:
{
  104430:	55                   	push   %ebp
  104431:	89 e5                	mov    %esp,%ebp
  104433:	56                   	push   %esi
  104434:	50                   	push   %eax
  104435:	8b 45 0c             	mov    0xc(%ebp),%eax
  104438:	8b 4d 08             	mov    0x8(%ebp),%ecx
		return true;
  10443b:	b2 01                	mov    $0x1,%dl
  10443d:	80 e2 01             	and    $0x1,%dl
  104440:	0f b6 f2             	movzbl %dl,%esi
  104443:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104446:	89 f0                	mov    %esi,%eax
  104448:	83 c4 04             	add    $0x4,%esp
  10444b:	5e                   	pop    %esi
  10444c:	5d                   	pop    %ebp
  10444d:	c3                   	ret    
  10444e:	66 90                	xchg   %ax,%ax

00104450 <log_backend_put>:
{
  104450:	55                   	push   %ebp
  104451:	89 e5                	mov    %esp,%ebp
  104453:	57                   	push   %edi
  104454:	56                   	push   %esi
  104455:	83 ec 10             	sub    $0x10,%esp
  104458:	8b 45 0c             	mov    0xc(%ebp),%eax
  10445b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	backend->api->put(backend, msg);
  10445e:	8b 55 08             	mov    0x8(%ebp),%edx
  104461:	8b 12                	mov    (%edx),%edx
  104463:	8b 12                	mov    (%edx),%edx
  104465:	8b 75 08             	mov    0x8(%ebp),%esi
  104468:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10446b:	89 34 24             	mov    %esi,(%esp)
  10446e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  104472:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104475:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  104478:	ff d2                	call   *%edx
}
  10447a:	83 c4 10             	add    $0x10,%esp
  10447d:	5e                   	pop    %esi
  10447e:	5f                   	pop    %edi
  10447f:	5d                   	pop    %ebp
  104480:	c3                   	ret    
  104481:	66 90                	xchg   %ax,%ax
  104483:	66 90                	xchg   %ax,%ax
  104485:	66 90                	xchg   %ax,%ax
  104487:	66 90                	xchg   %ax,%ax
  104489:	66 90                	xchg   %ax,%ax
  10448b:	66 90                	xchg   %ax,%ax
  10448d:	66 90                	xchg   %ax,%ax
  10448f:	90                   	nop

00104490 <log_msg_is_std>:
{
  104490:	55                   	push   %ebp
  104491:	89 e5                	mov    %esp,%ebp
  104493:	53                   	push   %ebx
  104494:	50                   	push   %eax
  104495:	8b 45 08             	mov    0x8(%ebp),%eax
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
  104498:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10449b:	66 8b 51 08          	mov    0x8(%ecx),%dx
  10449f:	66 83 e2 01          	and    $0x1,%dx
  1044a3:	0f b7 ca             	movzwl %dx,%ecx
  1044a6:	83 f9 00             	cmp    $0x0,%ecx
  1044a9:	0f 94 c3             	sete   %bl
  1044ac:	80 e3 01             	and    $0x1,%bl
  1044af:	0f b6 cb             	movzbl %bl,%ecx
  1044b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1044b5:	89 c8                	mov    %ecx,%eax
  1044b7:	83 c4 04             	add    $0x4,%esp
  1044ba:	5b                   	pop    %ebx
  1044bb:	5d                   	pop    %ebp
  1044bc:	c3                   	ret    
  1044bd:	66 90                	xchg   %ax,%ax
  1044bf:	90                   	nop

001044c0 <count_s>:
{
  1044c0:	55                   	push   %ebp
  1044c1:	89 e5                	mov    %esp,%ebp
  1044c3:	83 ec 14             	sub    $0x14,%esp
  1044c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	bool arm = false;
  1044cc:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)
	u32_t arg = 0;
  1044d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	u32_t mask = 0;
  1044d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1044de:	31 c0                	xor    %eax,%eax
	while ((curr = *str++) && arg < nargs) {
  1044e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1044e3:	89 ca                	mov    %ecx,%edx
  1044e5:	83 c2 01             	add    $0x1,%edx
  1044e8:	89 55 08             	mov    %edx,0x8(%ebp)
  1044eb:	8a 21                	mov    (%ecx),%ah
  1044ed:	88 65 ff             	mov    %ah,-0x1(%ebp)
  1044f0:	0f be cc             	movsbl %ah,%ecx
  1044f3:	83 f9 00             	cmp    $0x0,%ecx
  1044f6:	88 45 f3             	mov    %al,-0xd(%ebp)
  1044f9:	0f 84 0c 00 00 00    	je     10450b <count_s+0x4b>
  1044ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104502:	3b 45 0c             	cmp    0xc(%ebp),%eax
  104505:	0f 92 c1             	setb   %cl
  104508:	88 4d f3             	mov    %cl,-0xd(%ebp)
  10450b:	8a 45 f3             	mov    -0xd(%ebp),%al
  10450e:	a8 01                	test   $0x1,%al
  104510:	0f 85 05 00 00 00    	jne    10451b <count_s+0x5b>
  104516:	e9 6f 00 00 00       	jmp    10458a <count_s+0xca>
		if (curr == '%') {
  10451b:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  10451f:	83 f8 25             	cmp    $0x25,%eax
  104522:	0f 85 0f 00 00 00    	jne    104537 <count_s+0x77>
			arm = !arm;
  104528:	8a 45 fe             	mov    -0x2(%ebp),%al
  10452b:	34 ff                	xor    $0xff,%al
  10452d:	24 01                	and    $0x1,%al
  10452f:	88 45 fe             	mov    %al,-0x2(%ebp)
		} else if (arm && isalpha(curr)) {
  104532:	e9 4e 00 00 00       	jmp    104585 <count_s+0xc5>
  104537:	f6 45 fe 01          	testb  $0x1,-0x2(%ebp)
  10453b:	0f 84 3f 00 00 00    	je     104580 <count_s+0xc0>
  104541:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  104545:	89 04 24             	mov    %eax,(%esp)
  104548:	e8 73 00 00 00       	call   1045c0 <isalpha>
  10454d:	83 f8 00             	cmp    $0x0,%eax
  104550:	0f 84 2a 00 00 00    	je     104580 <count_s+0xc0>
			if (curr == 's') {
  104556:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  10455a:	83 f8 73             	cmp    $0x73,%eax
  10455d:	0f 85 10 00 00 00    	jne    104573 <count_s+0xb3>
				mask |= BIT(arg);
  104563:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104566:	b8 01 00 00 00       	mov    $0x1,%eax
  10456b:	d3 e0                	shl    %cl,%eax
  10456d:	0b 45 f4             	or     -0xc(%ebp),%eax
  104570:	89 45 f4             	mov    %eax,-0xc(%ebp)
			arm = false;
  104573:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)
			arg++;
  104577:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10457a:	83 c0 01             	add    $0x1,%eax
  10457d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104580:	e9 00 00 00 00       	jmp    104585 <count_s+0xc5>
	while ((curr = *str++) && arg < nargs) {
  104585:	e9 54 ff ff ff       	jmp    1044de <count_s+0x1e>
	return mask;
  10458a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10458d:	83 c4 14             	add    $0x14,%esp
  104590:	5d                   	pop    %ebp
  104591:	c3                   	ret    
  104592:	66 90                	xchg   %ax,%ax
  104594:	66 90                	xchg   %ax,%ax
  104596:	66 90                	xchg   %ax,%ax
  104598:	66 90                	xchg   %ax,%ax
  10459a:	66 90                	xchg   %ax,%ax
  10459c:	66 90                	xchg   %ax,%ax
  10459e:	66 90                	xchg   %ax,%ax

001045a0 <log_const_source_id>:
{
  1045a0:	55                   	push   %ebp
  1045a1:	89 e5                	mov    %esp,%ebp
  1045a3:	50                   	push   %eax
  1045a4:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  1045a7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1045aa:	8d 15 84 30 12 00    	lea    0x123084,%edx
  1045b0:	29 d1                	sub    %edx,%ecx
  1045b2:	c1 e9 03             	shr    $0x3,%ecx
  1045b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1045b8:	89 c8                	mov    %ecx,%eax
  1045ba:	83 c4 04             	add    $0x4,%esp
  1045bd:	5d                   	pop    %ebp
  1045be:	c3                   	ret    
  1045bf:	90                   	nop

001045c0 <isalpha>:
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
}

static inline int isalpha(int c)
{
  1045c0:	55                   	push   %ebp
  1045c1:	89 e5                	mov    %esp,%ebp
  1045c3:	50                   	push   %eax
  1045c4:	8b 45 08             	mov    0x8(%ebp),%eax
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  1045c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1045ca:	83 c9 20             	or     $0x20,%ecx
  1045cd:	83 e9 61             	sub    $0x61,%ecx
  1045d0:	83 f9 1a             	cmp    $0x1a,%ecx
  1045d3:	0f 92 c2             	setb   %dl
  1045d6:	80 e2 01             	and    $0x1,%dl
  1045d9:	0f b6 ca             	movzbl %dl,%ecx
  1045dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1045df:	89 c8                	mov    %ecx,%eax
  1045e1:	83 c4 04             	add    $0x4,%esp
  1045e4:	5d                   	pop    %ebp
  1045e5:	c3                   	ret    
  1045e6:	66 90                	xchg   %ax,%ax
  1045e8:	66 90                	xchg   %ax,%ax
  1045ea:	66 90                	xchg   %ax,%ax
  1045ec:	66 90                	xchg   %ax,%ax
  1045ee:	66 90                	xchg   %ax,%ax

001045f0 <log_process_thread_timer_expiry_fn>:
{
  1045f0:	55                   	push   %ebp
  1045f1:	89 e5                	mov    %esp,%ebp
  1045f3:	83 ec 08             	sub    $0x8,%esp
  1045f6:	8b 45 08             	mov    0x8(%ebp),%eax
	k_sem_give(&log_process_thread_sem);
  1045f9:	8d 0d 5c 34 14 00    	lea    0x14345c,%ecx
  1045ff:	89 0c 24             	mov    %ecx,(%esp)
  104602:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104605:	e8 56 f8 ff ff       	call   103e60 <k_sem_give>
}
  10460a:	83 c4 08             	add    $0x8,%esp
  10460d:	5d                   	pop    %ebp
  10460e:	c3                   	ret    
  10460f:	90                   	nop

00104610 <k_thread_create>:
{
  104610:	55                   	push   %ebp
  104611:	89 e5                	mov    %esp,%ebp
  104613:	53                   	push   %ebx
  104614:	57                   	push   %edi
  104615:	56                   	push   %esi
  104616:	83 ec 4c             	sub    $0x4c,%esp
  104619:	8b 45 2c             	mov    0x2c(%ebp),%eax
  10461c:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10461f:	8b 55 24             	mov    0x24(%ebp),%edx
  104622:	8b 75 20             	mov    0x20(%ebp),%esi
  104625:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  104628:	8b 5d 18             	mov    0x18(%ebp),%ebx
  10462b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10462e:	8b 45 14             	mov    0x14(%ebp),%eax
  104631:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104634:	8b 45 10             	mov    0x10(%ebp),%eax
  104637:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10463a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10463d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104640:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  104643:	8b 45 08             	mov    0x8(%ebp),%eax
  104646:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104649:	8b 55 10             	mov    0x10(%ebp),%edx
  10464c:	8b 75 14             	mov    0x14(%ebp),%esi
  10464f:	8b 7d 18             	mov    0x18(%ebp),%edi
  104652:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  104655:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104658:	8b 45 20             	mov    0x20(%ebp),%eax
  10465b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10465e:	8b 45 24             	mov    0x24(%ebp),%eax
  104661:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104664:	8b 45 28             	mov    0x28(%ebp),%eax
  104667:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10466a:	8b 45 2c             	mov    0x2c(%ebp),%eax
  10466d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  104670:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104673:	89 04 24             	mov    %eax,(%esp)
  104676:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10467a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10467e:	89 74 24 0c          	mov    %esi,0xc(%esp)
  104682:	89 7c 24 10          	mov    %edi,0x10(%esp)
  104686:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  10468a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10468d:	89 44 24 18          	mov    %eax,0x18(%esp)
  104691:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104694:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  104698:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10469b:	89 44 24 20          	mov    %eax,0x20(%esp)
  10469f:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1046a2:	89 44 24 24          	mov    %eax,0x24(%esp)
  1046a6:	e8 25 bf 01 00       	call   1205d0 <z_impl_k_thread_create>
  1046ab:	83 c4 4c             	add    $0x4c,%esp
  1046ae:	5e                   	pop    %esi
  1046af:	5f                   	pop    %edi
  1046b0:	5b                   	pop    %ebx
  1046b1:	5d                   	pop    %ebp
  1046b2:	c3                   	ret    
  1046b3:	66 90                	xchg   %ax,%ax
  1046b5:	66 90                	xchg   %ax,%ax
  1046b7:	66 90                	xchg   %ax,%ax
  1046b9:	66 90                	xchg   %ax,%ax
  1046bb:	66 90                	xchg   %ax,%ax
  1046bd:	66 90                	xchg   %ax,%ax
  1046bf:	90                   	nop

001046c0 <log_process_thread_func>:
{
  1046c0:	55                   	push   %ebp
  1046c1:	89 e5                	mov    %esp,%ebp
  1046c3:	83 ec 18             	sub    $0x18,%esp
  1046c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1046c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1046cc:	8b 55 08             	mov    0x8(%ebp),%edx
  1046cf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1046d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1046d5:	89 55 f4             	mov    %edx,-0xc(%ebp)
	log_init();
  1046d8:	e8 d3 f0 ff ff       	call   1037b0 <log_init>
	thread_set(k_current_get());
  1046dd:	e8 be 00 00 00       	call   1047a0 <k_current_get>
  1046e2:	89 04 24             	mov    %eax,(%esp)
  1046e5:	e8 76 00 00 00       	call   104760 <thread_set>
  1046ea:	31 c0                	xor    %eax,%eax
		if (log_process(false) == false) {
  1046ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1046f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1046f6:	e8 35 f3 ff ff       	call   103a30 <log_process>
  1046fb:	24 01                	and    $0x1,%al
  1046fd:	0f b6 c8             	movzbl %al,%ecx
  104700:	83 f9 00             	cmp    $0x0,%ecx
  104703:	0f 85 16 00 00 00    	jne    10471f <log_process_thread_func+0x5f>
			k_sem_take(&log_process_thread_sem, K_FOREVER);
  104709:	8d 05 5c 34 14 00    	lea    0x14345c,%eax
  10470f:	89 04 24             	mov    %eax,(%esp)
  104712:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  104719:	ff 
  10471a:	e8 91 00 00 00       	call   1047b0 <k_sem_take>
	while (true) {
  10471f:	e9 c6 ff ff ff       	jmp    1046ea <log_process_thread_func+0x2a>
  104724:	66 90                	xchg   %ax,%ax
  104726:	66 90                	xchg   %ax,%ax
  104728:	66 90                	xchg   %ax,%ax
  10472a:	66 90                	xchg   %ax,%ax
  10472c:	66 90                	xchg   %ax,%ax
  10472e:	66 90                	xchg   %ax,%ax

00104730 <k_thread_name_set>:
{
  104730:	55                   	push   %ebp
  104731:	89 e5                	mov    %esp,%ebp
  104733:	83 ec 08             	sub    $0x8,%esp
  104736:	8b 45 0c             	mov    0xc(%ebp),%eax
  104739:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return z_impl_k_thread_name_set(thread_id, value);
  10473c:	8b 45 08             	mov    0x8(%ebp),%eax
  10473f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104742:	89 04 24             	mov    %eax,(%esp)
  104745:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104749:	e8 62 bb 01 00       	call   1202b0 <z_impl_k_thread_name_set>
  10474e:	83 c4 08             	add    $0x8,%esp
  104751:	5d                   	pop    %ebp
  104752:	c3                   	ret    
  104753:	66 90                	xchg   %ax,%ax
  104755:	66 90                	xchg   %ax,%ax
  104757:	66 90                	xchg   %ax,%ax
  104759:	66 90                	xchg   %ax,%ax
  10475b:	66 90                	xchg   %ax,%ax
  10475d:	66 90                	xchg   %ax,%ax
  10475f:	90                   	nop

00104760 <thread_set>:
{
  104760:	55                   	push   %ebp
  104761:	89 e5                	mov    %esp,%ebp
  104763:	50                   	push   %eax
  104764:	8b 45 08             	mov    0x8(%ebp),%eax
	proc_tid = process_tid;
  104767:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10476a:	89 0d a0 50 13 00    	mov    %ecx,0x1350a0
	    process_tid &&
  104770:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104774:	0f 84 1b 00 00 00    	je     104795 <thread_set+0x35>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
  10477a:	83 3d 5c 50 13 00 0a 	cmpl   $0xa,0x13505c
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
  104781:	0f 8c 0e 00 00 00    	jl     104795 <thread_set+0x35>
		k_sem_give(&log_process_thread_sem);
  104787:	8d 05 5c 34 14 00    	lea    0x14345c,%eax
  10478d:	89 04 24             	mov    %eax,(%esp)
  104790:	e8 cb f6 ff ff       	call   103e60 <k_sem_give>
}
  104795:	83 c4 04             	add    $0x4,%esp
  104798:	5d                   	pop    %ebp
  104799:	c3                   	ret    
  10479a:	66 90                	xchg   %ax,%ax
  10479c:	66 90                	xchg   %ax,%ax
  10479e:	66 90                	xchg   %ax,%ax

001047a0 <k_current_get>:
{
  1047a0:	55                   	push   %ebp
  1047a1:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  1047a3:	e9 00 00 00 00       	jmp    1047a8 <k_current_get+0x8>
	return z_impl_k_current_get();
  1047a8:	e8 43 b4 01 00       	call   11fbf0 <z_impl_k_current_get>
  1047ad:	5d                   	pop    %ebp
  1047ae:	c3                   	ret    
  1047af:	90                   	nop

001047b0 <k_sem_take>:
{
  1047b0:	55                   	push   %ebp
  1047b1:	89 e5                	mov    %esp,%ebp
  1047b3:	83 ec 08             	sub    $0x8,%esp
  1047b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1047b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return z_impl_k_sem_take(sem, timeout);
  1047bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1047bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1047c2:	89 04 24             	mov    %eax,(%esp)
  1047c5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1047c9:	e8 b2 b7 01 00       	call   11ff80 <z_impl_k_sem_take>
  1047ce:	83 c4 08             	add    $0x8,%esp
  1047d1:	5d                   	pop    %ebp
  1047d2:	c3                   	ret    
  1047d3:	66 90                	xchg   %ax,%ax
  1047d5:	66 90                	xchg   %ax,%ax
  1047d7:	66 90                	xchg   %ax,%ax
  1047d9:	66 90                	xchg   %ax,%ax
  1047db:	66 90                	xchg   %ax,%ax
  1047dd:	66 90                	xchg   %ax,%ax
  1047df:	90                   	nop

001047e0 <log_msg_pool_init>:
struct k_mem_slab log_msg_pool;
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
  1047e0:	55                   	push   %ebp
  1047e1:	89 e5                	mov    %esp,%ebp
  1047e3:	83 ec 10             	sub    $0x10,%esp
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
  1047e6:	8d 05 d8 50 13 00    	lea    0x1350d8,%eax
  1047ec:	89 04 24             	mov    %eax,(%esp)
  1047ef:	8d 05 90 12 14 00    	lea    0x141290,%eax
  1047f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1047f9:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  104800:	00 
  104801:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  104808:	00 
  104809:	e8 a2 89 01 00       	call   11d1b0 <k_mem_slab_init>
}
  10480e:	83 c4 10             	add    $0x10,%esp
  104811:	5d                   	pop    %ebp
  104812:	c3                   	ret    
  104813:	66 90                	xchg   %ax,%ax
  104815:	66 90                	xchg   %ax,%ax
  104817:	66 90                	xchg   %ax,%ax
  104819:	66 90                	xchg   %ax,%ax
  10481b:	66 90                	xchg   %ax,%ax
  10481d:	66 90                	xchg   %ax,%ax
  10481f:	90                   	nop

00104820 <log_msg_chunk_alloc>:

	return (!k_is_in_isr() && !is_irq_locked());
}

union log_msg_chunk *log_msg_chunk_alloc(void)
{
  104820:	55                   	push   %ebp
  104821:	89 e5                	mov    %esp,%ebp
  104823:	83 ec 20             	sub    $0x20,%esp
	union log_msg_chunk *msg = NULL;
  104826:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
  10482d:	8d 45 fc             	lea    -0x4(%ebp),%eax
  104830:	89 45 f4             	mov    %eax,-0xc(%ebp)
			block_on_alloc() ?
  104833:	e8 58 00 00 00       	call   104890 <block_on_alloc>
  104838:	31 c9                	xor    %ecx,%ecx
  10483a:	a8 01                	test   $0x1,%al
  10483c:	89 ca                	mov    %ecx,%edx
  10483e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  104841:	89 55 ec             	mov    %edx,-0x14(%ebp)
  104844:	0f 85 06 00 00 00    	jne    104850 <log_msg_chunk_alloc+0x30>
  10484a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10484d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104850:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
  104853:	8d 0d d8 50 13 00    	lea    0x1350d8,%ecx
  104859:	89 0c 24             	mov    %ecx,(%esp)
  10485c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10485f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104863:	89 44 24 08          	mov    %eax,0x8(%esp)
  104867:	e8 94 8a 01 00       	call   11d300 <k_mem_slab_alloc>
  10486c:	89 45 f8             	mov    %eax,-0x8(%ebp)
			CONFIG_LOG_BLOCK_IN_THREAD_TIMEOUT_MS : K_NO_WAIT);

	if (err != 0) {
  10486f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  104873:	0f 84 08 00 00 00    	je     104881 <log_msg_chunk_alloc+0x61>
		msg = log_msg_no_space_handle();
  104879:	e8 22 00 00 00       	call   1048a0 <log_msg_no_space_handle>
  10487e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}

	return msg;
  104881:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104884:	83 c4 20             	add    $0x20,%esp
  104887:	5d                   	pop    %ebp
  104888:	c3                   	ret    
  104889:	66 90                	xchg   %ax,%ax
  10488b:	66 90                	xchg   %ax,%ax
  10488d:	66 90                	xchg   %ax,%ax
  10488f:	90                   	nop

00104890 <block_on_alloc>:
{
  104890:	55                   	push   %ebp
  104891:	89 e5                	mov    %esp,%ebp
  104893:	31 c0                	xor    %eax,%eax
		return false;
  104895:	24 01                	and    $0x1,%al
  104897:	0f b6 c0             	movzbl %al,%eax
  10489a:	5d                   	pop    %ebp
  10489b:	c3                   	ret    
  10489c:	66 90                	xchg   %ax,%ax
  10489e:	66 90                	xchg   %ax,%ax

001048a0 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
  1048a0:	55                   	push   %ebp
  1048a1:	89 e5                	mov    %esp,%ebp
  1048a3:	56                   	push   %esi
  1048a4:	83 ec 20             	sub    $0x20,%esp
	union log_msg_chunk *msg = NULL;
  1048a7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	bool more;
	int err;

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
  1048ae:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1048b5:	e8 b6 00 00 00       	call   104970 <log_process>
  1048ba:	24 01                	and    $0x1,%al
  1048bc:	88 45 f7             	mov    %al,-0x9(%ebp)
			log_dropped();
  1048bf:	e8 8c f4 ff ff       	call   103d50 <log_dropped>
  1048c4:	31 c9                	xor    %ecx,%ecx
			err = k_mem_slab_alloc(&log_msg_pool,
					       (void **)&msg,
  1048c6:	8d 55 f8             	lea    -0x8(%ebp),%edx
			err = k_mem_slab_alloc(&log_msg_pool,
  1048c9:	8d 35 d8 50 13 00    	lea    0x1350d8,%esi
  1048cf:	89 34 24             	mov    %esi,(%esp)
  1048d2:	89 54 24 04          	mov    %edx,0x4(%esp)
  1048d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1048dd:	00 
  1048de:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1048e1:	e8 1a 8a 01 00       	call   11d300 <k_mem_slab_alloc>
  1048e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1048e9:	31 c0                	xor    %eax,%eax
					       K_NO_WAIT);
		} while ((err != 0) && more);
  1048eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1048ef:	88 45 eb             	mov    %al,-0x15(%ebp)
  1048f2:	0f 84 06 00 00 00    	je     1048fe <log_msg_no_space_handle+0x5e>
  1048f8:	8a 45 f7             	mov    -0x9(%ebp),%al
  1048fb:	88 45 eb             	mov    %al,-0x15(%ebp)
  1048fe:	8a 45 eb             	mov    -0x15(%ebp),%al
  104901:	a8 01                	test   $0x1,%al
  104903:	0f 85 a5 ff ff ff    	jne    1048ae <log_msg_no_space_handle+0xe>
	} else {
		log_dropped();
	}
	return msg;
  104909:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10490c:	83 c4 20             	add    $0x20,%esp
  10490f:	5e                   	pop    %esi
  104910:	5d                   	pop    %ebp
  104911:	c3                   	ret    
  104912:	66 90                	xchg   %ax,%ax
  104914:	66 90                	xchg   %ax,%ax
  104916:	66 90                	xchg   %ax,%ax
  104918:	66 90                	xchg   %ax,%ax
  10491a:	66 90                	xchg   %ax,%ax
  10491c:	66 90                	xchg   %ax,%ax
  10491e:	66 90                	xchg   %ax,%ax

00104920 <log_msg_get>:
{
  104920:	55                   	push   %ebp
  104921:	89 e5                	mov    %esp,%ebp
  104923:	83 ec 08             	sub    $0x8,%esp
  104926:	8b 45 08             	mov    0x8(%ebp),%eax
	atomic_inc(&msg->hdr.ref_cnt);
  104929:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10492c:	83 c1 04             	add    $0x4,%ecx
  10492f:	89 0c 24             	mov    %ecx,(%esp)
  104932:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104935:	e8 06 00 00 00       	call   104940 <atomic_inc>
}
  10493a:	83 c4 08             	add    $0x8,%esp
  10493d:	5d                   	pop    %ebp
  10493e:	c3                   	ret    
  10493f:	90                   	nop

00104940 <atomic_inc>:
{
  104940:	55                   	push   %ebp
  104941:	89 e5                	mov    %esp,%ebp
  104943:	83 ec 0c             	sub    $0xc,%esp
  104946:	8b 45 08             	mov    0x8(%ebp),%eax
	return atomic_add(target, 1);
  104949:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10494c:	89 0c 24             	mov    %ecx,(%esp)
  10494f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  104956:	00 
  104957:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10495a:	e8 11 08 00 00       	call   105170 <atomic_add>
  10495f:	83 c4 0c             	add    $0xc,%esp
  104962:	5d                   	pop    %ebp
  104963:	c3                   	ret    
  104964:	66 90                	xchg   %ax,%ax
  104966:	66 90                	xchg   %ax,%ax
  104968:	66 90                	xchg   %ax,%ax
  10496a:	66 90                	xchg   %ax,%ax
  10496c:	66 90                	xchg   %ax,%ax
  10496e:	66 90                	xchg   %ax,%ax

00104970 <log_process>:
{
  104970:	55                   	push   %ebp
  104971:	89 e5                	mov    %esp,%ebp
  104973:	83 ec 08             	sub    $0x8,%esp
  104976:	8a 45 08             	mov    0x8(%ebp),%al
  104979:	24 01                	and    $0x1,%al
  10497b:	88 45 ff             	mov    %al,-0x1(%ebp)
	return z_impl_log_process(bypass);
  10497e:	8a 45 ff             	mov    -0x1(%ebp),%al
  104981:	24 01                	and    $0x1,%al
  104983:	0f b6 c8             	movzbl %al,%ecx
  104986:	89 0c 24             	mov    %ecx,(%esp)
  104989:	e8 e2 f1 ff ff       	call   103b70 <z_impl_log_process>
  10498e:	24 01                	and    $0x1,%al
  104990:	0f b6 c0             	movzbl %al,%eax
  104993:	83 c4 08             	add    $0x8,%esp
  104996:	5d                   	pop    %ebp
  104997:	c3                   	ret    
  104998:	66 90                	xchg   %ax,%ax
  10499a:	66 90                	xchg   %ax,%ax
  10499c:	66 90                	xchg   %ax,%ax
  10499e:	66 90                	xchg   %ax,%ax

001049a0 <log_msg_put>:

}
void log_msg_put(struct log_msg *msg)
{
  1049a0:	55                   	push   %ebp
  1049a1:	89 e5                	mov    %esp,%ebp
  1049a3:	83 ec 08             	sub    $0x8,%esp
  1049a6:	8b 45 08             	mov    0x8(%ebp),%eax
	atomic_dec(&msg->hdr.ref_cnt);
  1049a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1049ac:	83 c1 04             	add    $0x4,%ecx
  1049af:	89 0c 24             	mov    %ecx,(%esp)
  1049b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1049b5:	e8 26 00 00 00       	call   1049e0 <atomic_dec>

	if (msg->hdr.ref_cnt == 0) {
  1049ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1049bd:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
  1049c1:	0f 85 0b 00 00 00    	jne    1049d2 <log_msg_put+0x32>
		msg_free(msg);
  1049c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1049ca:	89 04 24             	mov    %eax,(%esp)
  1049cd:	e8 3e 00 00 00       	call   104a10 <msg_free>
	}
}
  1049d2:	83 c4 08             	add    $0x8,%esp
  1049d5:	5d                   	pop    %ebp
  1049d6:	c3                   	ret    
  1049d7:	66 90                	xchg   %ax,%ax
  1049d9:	66 90                	xchg   %ax,%ax
  1049db:	66 90                	xchg   %ax,%ax
  1049dd:	66 90                	xchg   %ax,%ax
  1049df:	90                   	nop

001049e0 <atomic_dec>:
{
  1049e0:	55                   	push   %ebp
  1049e1:	89 e5                	mov    %esp,%ebp
  1049e3:	83 ec 0c             	sub    $0xc,%esp
  1049e6:	8b 45 08             	mov    0x8(%ebp),%eax
	return atomic_sub(target, 1);
  1049e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1049ec:	89 0c 24             	mov    %ecx,(%esp)
  1049ef:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1049f6:	00 
  1049f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1049fa:	e8 a1 07 00 00       	call   1051a0 <atomic_sub>
  1049ff:	83 c4 0c             	add    $0xc,%esp
  104a02:	5d                   	pop    %ebp
  104a03:	c3                   	ret    
  104a04:	66 90                	xchg   %ax,%ax
  104a06:	66 90                	xchg   %ax,%ax
  104a08:	66 90                	xchg   %ax,%ax
  104a0a:	66 90                	xchg   %ax,%ax
  104a0c:	66 90                	xchg   %ax,%ax
  104a0e:	66 90                	xchg   %ax,%ax

00104a10 <msg_free>:
{
  104a10:	55                   	push   %ebp
  104a11:	89 e5                	mov    %esp,%ebp
  104a13:	83 ec 18             	sub    $0x18,%esp
  104a16:	8b 45 08             	mov    0x8(%ebp),%eax
	u32_t nargs = msg->hdr.params.std.nargs;
  104a19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104a1c:	66 8b 51 08          	mov    0x8(%ecx),%dx
  104a20:	66 c1 ea 0c          	shr    $0xc,%dx
  104a24:	0f b7 ca             	movzwl %dx,%ecx
  104a27:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	if (log_msg_is_std(msg) && nargs) {
  104a2a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104a2d:	89 0c 24             	mov    %ecx,(%esp)
  104a30:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104a33:	e8 98 07 00 00       	call   1051d0 <log_msg_is_std>
  104a38:	a8 01                	test   $0x1,%al
  104a3a:	0f 85 05 00 00 00    	jne    104a45 <msg_free+0x35>
  104a40:	e9 6d 00 00 00       	jmp    104ab2 <msg_free+0xa2>
  104a45:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  104a49:	0f 84 63 00 00 00    	je     104ab2 <msg_free+0xa2>
		for (i = 0; i < nargs; i++) {
  104a4f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  104a56:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a59:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  104a5c:	0f 83 4b 00 00 00    	jae    104aad <msg_free+0x9d>
			void *buf = (void *)log_msg_arg_get(msg, i);
  104a62:	8b 45 08             	mov    0x8(%ebp),%eax
  104a65:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104a68:	89 04 24             	mov    %eax,(%esp)
  104a6b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104a6f:	e8 ac 00 00 00       	call   104b20 <log_msg_arg_get>
  104a74:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if (log_is_strdup(buf)) {
  104a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a7a:	89 04 24             	mov    %eax,(%esp)
  104a7d:	e8 0e f5 ff ff       	call   103f90 <log_is_strdup>
  104a82:	a8 01                	test   $0x1,%al
  104a84:	0f 85 05 00 00 00    	jne    104a8f <msg_free+0x7f>
  104a8a:	e9 0b 00 00 00       	jmp    104a9a <msg_free+0x8a>
				log_free(buf);
  104a8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a92:	89 04 24             	mov    %eax,(%esp)
  104a95:	e8 56 f5 ff ff       	call   103ff0 <log_free>
		}
  104a9a:	e9 00 00 00 00       	jmp    104a9f <msg_free+0x8f>
		for (i = 0; i < nargs; i++) {
  104a9f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104aa2:	83 c0 01             	add    $0x1,%eax
  104aa5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104aa8:	e9 a9 ff ff ff       	jmp    104a56 <msg_free+0x46>
	} else if (IS_ENABLED(CONFIG_USERSPACE) &&
  104aad:	e9 05 00 00 00       	jmp    104ab7 <msg_free+0xa7>
  104ab2:	e9 00 00 00 00       	jmp    104ab7 <msg_free+0xa7>
	if (msg->hdr.params.generic.ext == 1) {
  104ab7:	8b 45 08             	mov    0x8(%ebp),%eax
  104aba:	66 8b 48 08          	mov    0x8(%eax),%cx
  104abe:	66 c1 e9 01          	shr    $0x1,%cx
  104ac2:	66 83 e1 01          	and    $0x1,%cx
  104ac6:	0f b7 c1             	movzwl %cx,%eax
  104ac9:	83 f8 01             	cmp    $0x1,%eax
  104acc:	0f 85 0e 00 00 00    	jne    104ae0 <msg_free+0xd0>
		cont_free(msg->payload.ext.next);
  104ad2:	8b 45 08             	mov    0x8(%ebp),%eax
  104ad5:	8b 40 14             	mov    0x14(%eax),%eax
  104ad8:	89 04 24             	mov    %eax,(%esp)
  104adb:	e8 20 07 00 00       	call   105200 <cont_free>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
  104ae0:	8d 45 08             	lea    0x8(%ebp),%eax
  104ae3:	8d 0d d8 50 13 00    	lea    0x1350d8,%ecx
  104ae9:	89 0c 24             	mov    %ecx,(%esp)
  104aec:	89 44 24 04          	mov    %eax,0x4(%esp)
  104af0:	e8 3b 89 01 00       	call   11d430 <k_mem_slab_free>
}
  104af5:	83 c4 18             	add    $0x18,%esp
  104af8:	5d                   	pop    %ebp
  104af9:	c3                   	ret    
  104afa:	66 90                	xchg   %ax,%ax
  104afc:	66 90                	xchg   %ax,%ax
  104afe:	66 90                	xchg   %ax,%ax

00104b00 <log_msg_nargs_get>:

u32_t log_msg_nargs_get(struct log_msg *msg)
{
  104b00:	55                   	push   %ebp
  104b01:	89 e5                	mov    %esp,%ebp
  104b03:	50                   	push   %eax
  104b04:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->hdr.params.std.nargs;
  104b07:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104b0a:	66 8b 51 08          	mov    0x8(%ecx),%dx
  104b0e:	66 c1 ea 0c          	shr    $0xc,%dx
  104b12:	0f b7 ca             	movzwl %dx,%ecx
  104b15:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104b18:	89 c8                	mov    %ecx,%eax
  104b1a:	83 c4 04             	add    $0x4,%esp
  104b1d:	5d                   	pop    %ebp
  104b1e:	c3                   	ret    
  104b1f:	90                   	nop

00104b20 <log_msg_arg_get>:

	return cont->payload.args[arg_idx];
}

log_arg_t log_msg_arg_get(struct log_msg *msg, u32_t arg_idx)
{
  104b20:	55                   	push   %ebp
  104b21:	89 e5                	mov    %esp,%ebp
  104b23:	57                   	push   %edi
  104b24:	56                   	push   %esi
  104b25:	83 ec 10             	sub    $0x10,%esp
  104b28:	8b 45 0c             	mov    0xc(%ebp),%eax
  104b2b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	log_arg_t arg;

	/* Return early if requested argument not present in the message. */
	if (arg_idx >= msg->hdr.params.std.nargs) {
  104b2e:	8b 55 0c             	mov    0xc(%ebp),%edx
  104b31:	8b 75 08             	mov    0x8(%ebp),%esi
  104b34:	66 8b 7e 08          	mov    0x8(%esi),%di
  104b38:	66 c1 ef 0c          	shr    $0xc,%di
  104b3c:	0f b7 f7             	movzwl %di,%esi
  104b3f:	39 f2                	cmp    %esi,%edx
  104b41:	0f 82 0c 00 00 00    	jb     104b53 <log_msg_arg_get+0x33>
		return 0;
  104b47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104b4e:	e9 44 00 00 00       	jmp    104b97 <log_msg_arg_get+0x77>
	}

	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
  104b53:	8b 45 08             	mov    0x8(%ebp),%eax
  104b56:	66 8b 48 08          	mov    0x8(%eax),%cx
  104b5a:	66 c1 e9 0c          	shr    $0xc,%cx
  104b5e:	0f b7 c1             	movzwl %cx,%eax
  104b61:	83 f8 03             	cmp    $0x3,%eax
  104b64:	0f 8f 12 00 00 00    	jg     104b7c <log_msg_arg_get+0x5c>
		arg = msg->payload.single.args[arg_idx];
  104b6a:	8b 45 08             	mov    0x8(%ebp),%eax
  104b6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104b70:	8b 44 88 14          	mov    0x14(%eax,%ecx,4),%eax
  104b74:	89 45 f0             	mov    %eax,-0x10(%ebp)
	} else {
  104b77:	e9 15 00 00 00       	jmp    104b91 <log_msg_arg_get+0x71>
		arg = cont_arg_get(msg, arg_idx);
  104b7c:	8b 45 08             	mov    0x8(%ebp),%eax
  104b7f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104b82:	89 04 24             	mov    %eax,(%esp)
  104b85:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104b89:	e8 22 00 00 00       	call   104bb0 <cont_arg_get>
  104b8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}

	return arg;
  104b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104b94:	89 45 f4             	mov    %eax,-0xc(%ebp)
}
  104b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104b9a:	83 c4 10             	add    $0x10,%esp
  104b9d:	5e                   	pop    %esi
  104b9e:	5f                   	pop    %edi
  104b9f:	5d                   	pop    %ebp
  104ba0:	c3                   	ret    
  104ba1:	66 90                	xchg   %ax,%ax
  104ba3:	66 90                	xchg   %ax,%ax
  104ba5:	66 90                	xchg   %ax,%ax
  104ba7:	66 90                	xchg   %ax,%ax
  104ba9:	66 90                	xchg   %ax,%ax
  104bab:	66 90                	xchg   %ax,%ax
  104bad:	66 90                	xchg   %ax,%ax
  104baf:	90                   	nop

00104bb0 <cont_arg_get>:
{
  104bb0:	55                   	push   %ebp
  104bb1:	89 e5                	mov    %esp,%ebp
  104bb3:	83 ec 08             	sub    $0x8,%esp
  104bb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104bb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
  104bbc:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  104bc0:	0f 83 12 00 00 00    	jae    104bd8 <cont_arg_get+0x28>
		return msg->payload.ext.data.args[arg_idx];
  104bc6:	8b 45 08             	mov    0x8(%ebp),%eax
  104bc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104bcc:	8b 44 88 18          	mov    0x18(%eax,%ecx,4),%eax
  104bd0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104bd3:	e9 3f 00 00 00       	jmp    104c17 <cont_arg_get+0x67>
	cont = msg->payload.ext.next;
  104bd8:	8b 45 08             	mov    0x8(%ebp),%eax
  104bdb:	8b 40 14             	mov    0x14(%eax),%eax
  104bde:	89 45 f8             	mov    %eax,-0x8(%ebp)
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
  104be1:	8b 45 0c             	mov    0xc(%ebp),%eax
  104be4:	83 e8 02             	sub    $0x2,%eax
  104be7:	89 45 0c             	mov    %eax,0xc(%ebp)
	while (arg_idx >= ARGS_CONT_MSG) {
  104bea:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
  104bee:	0f 82 16 00 00 00    	jb     104c0a <cont_arg_get+0x5a>
		arg_idx -= ARGS_CONT_MSG;
  104bf4:	8b 45 0c             	mov    0xc(%ebp),%eax
  104bf7:	83 e8 07             	sub    $0x7,%eax
  104bfa:	89 45 0c             	mov    %eax,0xc(%ebp)
		cont = cont->next;
  104bfd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c00:	8b 00                	mov    (%eax),%eax
  104c02:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (arg_idx >= ARGS_CONT_MSG) {
  104c05:	e9 e0 ff ff ff       	jmp    104bea <cont_arg_get+0x3a>
	return cont->payload.args[arg_idx];
  104c0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c0d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104c10:	8b 44 88 04          	mov    0x4(%eax,%ecx,4),%eax
  104c14:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104c17:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c1a:	83 c4 08             	add    $0x8,%esp
  104c1d:	5d                   	pop    %ebp
  104c1e:	c3                   	ret    
  104c1f:	90                   	nop

00104c20 <log_msg_str_get>:

const char *log_msg_str_get(struct log_msg *msg)
{
  104c20:	55                   	push   %ebp
  104c21:	89 e5                	mov    %esp,%ebp
  104c23:	50                   	push   %eax
  104c24:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->str;
  104c27:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104c2a:	8b 49 10             	mov    0x10(%ecx),%ecx
  104c2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104c30:	89 c8                	mov    %ecx,%eax
  104c32:	83 c4 04             	add    $0x4,%esp
  104c35:	5d                   	pop    %ebp
  104c36:	c3                   	ret    
  104c37:	66 90                	xchg   %ax,%ax
  104c39:	66 90                	xchg   %ax,%ax
  104c3b:	66 90                	xchg   %ax,%ax
  104c3d:	66 90                	xchg   %ax,%ax
  104c3f:	90                   	nop

00104c40 <log_msg_create_n>:
		cont = cont->next;
	}
}

struct log_msg *log_msg_create_n(const char *str, log_arg_t *args, u32_t nargs)
{
  104c40:	55                   	push   %ebp
  104c41:	89 e5                	mov    %esp,%ebp
  104c43:	57                   	push   %edi
  104c44:	56                   	push   %esi
  104c45:	83 ec 1c             	sub    $0x1c,%esp
  104c48:	8b 45 10             	mov    0x10(%ebp),%eax
  104c4b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104c4e:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT_NO_MSG(nargs < LOG_MAX_NARGS);

	struct  log_msg *msg = NULL;
  104c51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	msg = msg_alloc(nargs);
  104c58:	8b 75 10             	mov    0x10(%ebp),%esi
  104c5b:	89 34 24             	mov    %esi,(%esp)
  104c5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104c61:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104c64:	89 55 e8             	mov    %edx,-0x18(%ebp)
  104c67:	e8 64 00 00 00       	call   104cd0 <msg_alloc>
  104c6c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (msg != NULL) {
  104c6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104c73:	0f 84 40 00 00 00    	je     104cb9 <log_msg_create_n+0x79>
		msg->str = str;
  104c79:	8b 45 08             	mov    0x8(%ebp),%eax
  104c7c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104c7f:	89 41 10             	mov    %eax,0x10(%ecx)
		msg->hdr.params.std.nargs = nargs;
  104c82:	8b 45 10             	mov    0x10(%ebp),%eax
  104c85:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104c88:	66 8b 51 08          	mov    0x8(%ecx),%dx
  104c8c:	66 83 e0 0f          	and    $0xf,%ax
  104c90:	66 c1 e0 0c          	shl    $0xc,%ax
  104c94:	66 81 e2 ff 0f       	and    $0xfff,%dx
  104c99:	66 09 c2             	or     %ax,%dx
  104c9c:	66 89 51 08          	mov    %dx,0x8(%ecx)
		copy_args_to_msg(msg, args, nargs);
  104ca0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104ca3:	8b 75 0c             	mov    0xc(%ebp),%esi
  104ca6:	8b 7d 10             	mov    0x10(%ebp),%edi
  104ca9:	89 0c 24             	mov    %ecx,(%esp)
  104cac:	89 74 24 04          	mov    %esi,0x4(%esp)
  104cb0:	89 7c 24 08          	mov    %edi,0x8(%esp)
  104cb4:	e8 f7 00 00 00       	call   104db0 <copy_args_to_msg>
	}

	return msg;
  104cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104cbc:	83 c4 1c             	add    $0x1c,%esp
  104cbf:	5e                   	pop    %esi
  104cc0:	5f                   	pop    %edi
  104cc1:	5d                   	pop    %ebp
  104cc2:	c3                   	ret    
  104cc3:	66 90                	xchg   %ax,%ax
  104cc5:	66 90                	xchg   %ax,%ax
  104cc7:	66 90                	xchg   %ax,%ax
  104cc9:	66 90                	xchg   %ax,%ax
  104ccb:	66 90                	xchg   %ax,%ax
  104ccd:	66 90                	xchg   %ax,%ax
  104ccf:	90                   	nop

00104cd0 <msg_alloc>:
{
  104cd0:	55                   	push   %ebp
  104cd1:	89 e5                	mov    %esp,%ebp
  104cd3:	83 ec 1c             	sub    $0x1c,%esp
  104cd6:	8b 45 08             	mov    0x8(%ebp),%eax
  104cd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct  log_msg *msg = z_log_msg_std_alloc();
  104cdc:	e8 5f 05 00 00       	call   105240 <z_log_msg_std_alloc>
  104ce1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int n = (int)nargs;
  104ce4:	8b 45 08             	mov    0x8(%ebp),%eax
  104ce7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
  104cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104cee:	0f 84 0a 00 00 00    	je     104cfe <msg_alloc+0x2e>
  104cf4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
  104cf8:	0f 87 0b 00 00 00    	ja     104d09 <msg_alloc+0x39>
		return msg;
  104cfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d01:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104d04:	e9 9c 00 00 00       	jmp    104da5 <msg_alloc+0xd5>
	msg->hdr.params.std.nargs = 0U;
  104d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d0c:	66 8b 48 08          	mov    0x8(%eax),%cx
  104d10:	66 81 e1 ff 0f       	and    $0xfff,%cx
  104d15:	66 89 48 08          	mov    %cx,0x8(%eax)
	msg->hdr.params.generic.ext = 1;
  104d19:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d1c:	66 8b 48 08          	mov    0x8(%eax),%cx
  104d20:	66 83 e1 fd          	and    $0xfffd,%cx
  104d24:	66 83 c9 02          	or     $0x2,%cx
  104d28:	66 89 48 08          	mov    %cx,0x8(%eax)
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
  104d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104d2f:	83 e8 02             	sub    $0x2,%eax
  104d32:	89 45 ec             	mov    %eax,-0x14(%ebp)
	next = &msg->payload.ext.next;
  104d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d38:	83 c0 14             	add    $0x14,%eax
  104d3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	*next = NULL;
  104d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (n > 0) {
  104d47:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  104d4b:	0f 8e 4e 00 00 00    	jle    104d9f <msg_alloc+0xcf>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
  104d51:	e8 ca fa ff ff       	call   104820 <log_msg_chunk_alloc>
  104d56:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if (cont == NULL) {
  104d59:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  104d5d:	0f 85 17 00 00 00    	jne    104d7a <msg_alloc+0xaa>
			msg_free(msg);
  104d63:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d66:	89 04 24             	mov    %eax,(%esp)
  104d69:	e8 a2 fc ff ff       	call   104a10 <msg_free>
			return NULL;
  104d6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104d75:	e9 2b 00 00 00       	jmp    104da5 <msg_alloc+0xd5>
		*next = cont;
  104d7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d7d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104d80:	89 01                	mov    %eax,(%ecx)
		cont->next = NULL;
  104d82:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d85:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		next = &cont->next;
  104d8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		n -= ARGS_CONT_MSG;
  104d91:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104d94:	83 e8 07             	sub    $0x7,%eax
  104d97:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (n > 0) {
  104d9a:	e9 a8 ff ff ff       	jmp    104d47 <msg_alloc+0x77>
	return msg;
  104d9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104da2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104da5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104da8:	83 c4 1c             	add    $0x1c,%esp
  104dab:	5d                   	pop    %ebp
  104dac:	c3                   	ret    
  104dad:	66 90                	xchg   %ax,%ax
  104daf:	90                   	nop

00104db0 <copy_args_to_msg>:
{
  104db0:	55                   	push   %ebp
  104db1:	89 e5                	mov    %esp,%ebp
  104db3:	56                   	push   %esi
  104db4:	83 ec 18             	sub    $0x18,%esp
  104db7:	8b 45 10             	mov    0x10(%ebp),%eax
  104dba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104dbd:	8b 55 08             	mov    0x8(%ebp),%edx
	struct log_msg_cont *cont = msg->payload.ext.next;
  104dc0:	8b 75 08             	mov    0x8(%ebp),%esi
  104dc3:	8b 76 14             	mov    0x14(%esi),%esi
  104dc6:	89 75 f8             	mov    %esi,-0x8(%ebp)
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
  104dc9:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  104dcd:	0f 86 37 00 00 00    	jbe    104e0a <copy_args_to_msg+0x5a>
		(void)memcpy(msg->payload.ext.data.args, args,
  104dd3:	8b 45 08             	mov    0x8(%ebp),%eax
  104dd6:	83 c0 14             	add    $0x14,%eax
  104dd9:	83 c0 04             	add    $0x4,%eax
  104ddc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104ddf:	89 04 24             	mov    %eax,(%esp)
  104de2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104de6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  104ded:	00 
  104dee:	e8 5d 55 00 00       	call   10a350 <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
  104df3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  104df6:	83 e9 02             	sub    $0x2,%ecx
  104df9:	89 4d 10             	mov    %ecx,0x10(%ebp)
		args += LOG_MSG_NARGS_HEAD_CHUNK;
  104dfc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104dff:	83 c1 08             	add    $0x8,%ecx
  104e02:	89 4d 0c             	mov    %ecx,0xc(%ebp)
	} else {
  104e05:	e9 26 00 00 00       	jmp    104e30 <copy_args_to_msg+0x80>
		(void)memcpy(msg->payload.single.args, args,
  104e0a:	8b 45 08             	mov    0x8(%ebp),%eax
  104e0d:	83 c0 14             	add    $0x14,%eax
  104e10:	8b 4d 0c             	mov    0xc(%ebp),%ecx
			     nargs * sizeof(log_arg_t));
  104e13:	8b 55 10             	mov    0x10(%ebp),%edx
  104e16:	c1 e2 02             	shl    $0x2,%edx
		(void)memcpy(msg->payload.single.args, args,
  104e19:	89 04 24             	mov    %eax,(%esp)
  104e1c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e20:	89 54 24 08          	mov    %edx,0x8(%esp)
  104e24:	e8 27 55 00 00       	call   10a350 <memcpy>
		nargs  = 0U;
  104e29:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
	while (nargs != 0U) {
  104e30:	e9 00 00 00 00       	jmp    104e35 <copy_args_to_msg+0x85>
  104e35:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104e39:	0f 84 6b 00 00 00    	je     104eaa <copy_args_to_msg+0xfa>
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
  104e3f:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  104e43:	0f 83 0b 00 00 00    	jae    104e54 <copy_args_to_msg+0xa4>
  104e49:	8b 45 10             	mov    0x10(%ebp),%eax
  104e4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104e4f:	e9 0d 00 00 00       	jmp    104e61 <copy_args_to_msg+0xb1>
  104e54:	b8 07 00 00 00       	mov    $0x7,%eax
  104e59:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104e5c:	e9 00 00 00 00       	jmp    104e61 <copy_args_to_msg+0xb1>
  104e61:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e64:	89 45 f4             	mov    %eax,-0xc(%ebp)
		(void)memcpy(cont->payload.args, args,
  104e67:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e6a:	83 c0 04             	add    $0x4,%eax
  104e6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
			     cpy_args * sizeof(log_arg_t));
  104e70:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104e73:	c1 e2 02             	shl    $0x2,%edx
		(void)memcpy(cont->payload.args, args,
  104e76:	89 04 24             	mov    %eax,(%esp)
  104e79:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e7d:	89 54 24 08          	mov    %edx,0x8(%esp)
  104e81:	e8 ca 54 00 00       	call   10a350 <memcpy>
		nargs -= cpy_args;
  104e86:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104e89:	8b 55 10             	mov    0x10(%ebp),%edx
  104e8c:	29 ca                	sub    %ecx,%edx
  104e8e:	89 55 10             	mov    %edx,0x10(%ebp)
		args += cpy_args;
  104e91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104e94:	c1 e1 02             	shl    $0x2,%ecx
  104e97:	03 4d 0c             	add    0xc(%ebp),%ecx
  104e9a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
		cont = cont->next;
  104e9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104ea0:	8b 09                	mov    (%ecx),%ecx
  104ea2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	while (nargs != 0U) {
  104ea5:	e9 8b ff ff ff       	jmp    104e35 <copy_args_to_msg+0x85>
}
  104eaa:	83 c4 18             	add    $0x18,%esp
  104ead:	5e                   	pop    %esi
  104eae:	5d                   	pop    %ebp
  104eaf:	c3                   	ret    

00104eb0 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
  104eb0:	55                   	push   %ebp
  104eb1:	89 e5                	mov    %esp,%ebp
  104eb3:	53                   	push   %ebx
  104eb4:	57                   	push   %edi
  104eb5:	56                   	push   %esi
  104eb6:	83 ec 30             	sub    $0x30,%esp
  104eb9:	8a 45 18             	mov    0x18(%ebp),%al
  104ebc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  104ebf:	8b 55 10             	mov    0x10(%ebp),%edx
  104ec2:	8b 75 0c             	mov    0xc(%ebp),%esi
  104ec5:	8b 7d 08             	mov    0x8(%ebp),%edi
  104ec8:	24 01                	and    $0x1,%al
  104eca:	88 45 f3             	mov    %al,-0xd(%ebp)
	u32_t available_len = msg->hdr.params.hexdump.length;
  104ecd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104ed0:	66 8b 43 08          	mov    0x8(%ebx),%ax
  104ed4:	66 c1 e8 02          	shr    $0x2,%ax
  104ed8:	0f b7 d8             	movzwl %ax,%ebx
  104edb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
	struct log_msg_cont *cont = NULL;
  104ede:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
  104ee5:	8b 5d 14             	mov    0x14(%ebp),%ebx
  104ee8:	3b 5d ec             	cmp    -0x14(%ebp),%ebx
  104eeb:	0f 82 0e 00 00 00    	jb     104eff <log_msg_hexdump_data_op+0x4f>
		*length = 0;
  104ef1:	8b 45 10             	mov    0x10(%ebp),%eax
  104ef4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return;
  104efa:	e9 f2 01 00 00       	jmp    1050f1 <log_msg_hexdump_data_op+0x241>
	}

	if ((offset + *length) > available_len) {
  104eff:	8b 45 14             	mov    0x14(%ebp),%eax
  104f02:	8b 4d 10             	mov    0x10(%ebp),%ecx
  104f05:	03 01                	add    (%ecx),%eax
  104f07:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104f0a:	0f 86 0b 00 00 00    	jbe    104f1b <log_msg_hexdump_data_op+0x6b>
		*length = available_len - offset;
  104f10:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f13:	2b 45 14             	sub    0x14(%ebp),%eax
  104f16:	8b 4d 10             	mov    0x10(%ebp),%ecx
  104f19:	89 01                	mov    %eax,(%ecx)
	}

	req_len = *length;
  104f1b:	8b 45 10             	mov    0x10(%ebp),%eax
  104f1e:	8b 00                	mov    (%eax),%eax
  104f20:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
  104f23:	83 7d ec 0c          	cmpl   $0xc,-0x14(%ebp)
  104f27:	0f 86 21 00 00 00    	jbe    104f4e <log_msg_hexdump_data_op+0x9e>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
  104f2d:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
		head_data = msg->payload.ext.data.bytes;
  104f34:	8b 45 08             	mov    0x8(%ebp),%eax
  104f37:	83 c0 14             	add    $0x14,%eax
  104f3a:	83 c0 04             	add    $0x4,%eax
  104f3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		cont = msg->payload.ext.next;
  104f40:	8b 45 08             	mov    0x8(%ebp),%eax
  104f43:	8b 40 14             	mov    0x14(%eax),%eax
  104f46:	89 45 e8             	mov    %eax,-0x18(%ebp)
	} else {
  104f49:	e9 0f 00 00 00       	jmp    104f5d <log_msg_hexdump_data_op+0xad>
		head_data = msg->payload.single.bytes;
  104f4e:	8b 45 08             	mov    0x8(%ebp),%eax
  104f51:	83 c0 14             	add    $0x14,%eax
  104f54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		chunk_len = available_len;
  104f57:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f5a:	89 45 e0             	mov    %eax,-0x20(%ebp)

	}

	if (offset < chunk_len) {
  104f5d:	8b 45 14             	mov    0x14(%ebp),%eax
  104f60:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  104f63:	0f 83 83 00 00 00    	jae    104fec <log_msg_hexdump_data_op+0x13c>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  104f69:	8b 45 dc             	mov    -0x24(%ebp),%eax
  104f6c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  104f6f:	0f 86 0b 00 00 00    	jbe    104f80 <log_msg_hexdump_data_op+0xd0>
  104f75:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104f78:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  104f7b:	e9 06 00 00 00       	jmp    104f86 <log_msg_hexdump_data_op+0xd6>
  104f80:	8b 45 dc             	mov    -0x24(%ebp),%eax
  104f83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  104f86:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104f89:	89 45 d8             	mov    %eax,-0x28(%ebp)

		if (put_op) {
  104f8c:	f6 45 f3 01          	testb  $0x1,-0xd(%ebp)
  104f90:	0f 84 21 00 00 00    	je     104fb7 <log_msg_hexdump_data_op+0x107>
			(void)memcpy(&head_data[offset], data, cpy_len);
  104f96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104f99:	03 45 14             	add    0x14(%ebp),%eax
  104f9c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104f9f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104fa2:	89 04 24             	mov    %eax,(%esp)
  104fa5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104fa9:	89 54 24 08          	mov    %edx,0x8(%esp)
  104fad:	e8 9e 53 00 00       	call   10a350 <memcpy>
		} else {
  104fb2:	e9 1c 00 00 00       	jmp    104fd3 <log_msg_hexdump_data_op+0x123>
			(void)memcpy(data, &head_data[offset], cpy_len);
  104fb7:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fba:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104fbd:	03 4d 14             	add    0x14(%ebp),%ecx
  104fc0:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104fc3:	89 04 24             	mov    %eax,(%esp)
  104fc6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104fca:	89 54 24 08          	mov    %edx,0x8(%esp)
  104fce:	e8 7d 53 00 00       	call   10a350 <memcpy>
		}

		req_len -= cpy_len;
  104fd3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104fd6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  104fd9:	29 c1                	sub    %eax,%ecx
  104fdb:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		data += cpy_len;
  104fde:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104fe1:	03 45 0c             	add    0xc(%ebp),%eax
  104fe4:	89 45 0c             	mov    %eax,0xc(%ebp)
	} else {
  104fe7:	e9 53 00 00 00       	jmp    10503f <log_msg_hexdump_data_op+0x18f>
		offset -= chunk_len;
  104fec:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104fef:	8b 4d 14             	mov    0x14(%ebp),%ecx
  104ff2:	29 c1                	sub    %eax,%ecx
  104ff4:	89 4d 14             	mov    %ecx,0x14(%ebp)
		chunk_len = HEXDUMP_BYTES_CONT_MSG;
  104ff7:	c7 45 e0 1c 00 00 00 	movl   $0x1c,-0x20(%ebp)
		if (cont == NULL) {
  104ffe:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  105002:	0f 85 09 00 00 00    	jne    105011 <log_msg_hexdump_data_op+0x161>
			cont = msg->payload.ext.next;
  105008:	8b 45 08             	mov    0x8(%ebp),%eax
  10500b:	8b 40 14             	mov    0x14(%eax),%eax
  10500e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		}

		while (offset >= chunk_len) {
  105011:	e9 00 00 00 00       	jmp    105016 <log_msg_hexdump_data_op+0x166>
  105016:	8b 45 14             	mov    0x14(%ebp),%eax
  105019:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  10501c:	0f 82 18 00 00 00    	jb     10503a <log_msg_hexdump_data_op+0x18a>
			cont = cont->next;
  105022:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105025:	8b 00                	mov    (%eax),%eax
  105027:	89 45 e8             	mov    %eax,-0x18(%ebp)
			offset -= chunk_len;
  10502a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10502d:	8b 4d 14             	mov    0x14(%ebp),%ecx
  105030:	29 c1                	sub    %eax,%ecx
  105032:	89 4d 14             	mov    %ecx,0x14(%ebp)
		while (offset >= chunk_len) {
  105035:	e9 dc ff ff ff       	jmp    105016 <log_msg_hexdump_data_op+0x166>
  10503a:	e9 00 00 00 00       	jmp    10503f <log_msg_hexdump_data_op+0x18f>
		}
	}

	while (req_len > 0) {
  10503f:	e9 00 00 00 00       	jmp    105044 <log_msg_hexdump_data_op+0x194>
  105044:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  105048:	0f 86 a3 00 00 00    	jbe    1050f1 <log_msg_hexdump_data_op+0x241>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
  10504e:	b8 1c 00 00 00       	mov    $0x1c,%eax
  105053:	2b 45 14             	sub    0x14(%ebp),%eax
  105056:	89 45 e0             	mov    %eax,-0x20(%ebp)
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  105059:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10505c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  10505f:	0f 86 0b 00 00 00    	jbe    105070 <log_msg_hexdump_data_op+0x1c0>
  105065:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105068:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10506b:	e9 06 00 00 00       	jmp    105076 <log_msg_hexdump_data_op+0x1c6>
  105070:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105073:	89 45 d0             	mov    %eax,-0x30(%ebp)
  105076:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105079:	89 45 d8             	mov    %eax,-0x28(%ebp)

		if (put_op) {
  10507c:	f6 45 f3 01          	testb  $0x1,-0xd(%ebp)
  105080:	0f 84 24 00 00 00    	je     1050aa <log_msg_hexdump_data_op+0x1fa>
			(void)memcpy(&cont->payload.bytes[offset],
  105086:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105089:	83 c0 04             	add    $0x4,%eax
  10508c:	03 45 14             	add    0x14(%ebp),%eax
				     data, cpy_len);
  10508f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105092:	8b 55 d8             	mov    -0x28(%ebp),%edx
			(void)memcpy(&cont->payload.bytes[offset],
  105095:	89 04 24             	mov    %eax,(%esp)
  105098:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10509c:	89 54 24 08          	mov    %edx,0x8(%esp)
  1050a0:	e8 ab 52 00 00       	call   10a350 <memcpy>
		} else {
  1050a5:	e9 1f 00 00 00       	jmp    1050c9 <log_msg_hexdump_data_op+0x219>
			(void)memcpy(data, &cont->payload.bytes[offset],
  1050aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1050ad:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1050b0:	83 c1 04             	add    $0x4,%ecx
  1050b3:	03 4d 14             	add    0x14(%ebp),%ecx
				     cpy_len);
  1050b6:	8b 55 d8             	mov    -0x28(%ebp),%edx
			(void)memcpy(data, &cont->payload.bytes[offset],
  1050b9:	89 04 24             	mov    %eax,(%esp)
  1050bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1050c0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1050c4:	e8 87 52 00 00       	call   10a350 <memcpy>
		}

		offset = 0;
  1050c9:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
		cont = cont->next;
  1050d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1050d3:	8b 00                	mov    (%eax),%eax
  1050d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		req_len -= cpy_len;
  1050d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1050db:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1050de:	29 c1                	sub    %eax,%ecx
  1050e0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		data += cpy_len;
  1050e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1050e6:	03 45 0c             	add    0xc(%ebp),%eax
  1050e9:	89 45 0c             	mov    %eax,0xc(%ebp)
	while (req_len > 0) {
  1050ec:	e9 53 ff ff ff       	jmp    105044 <log_msg_hexdump_data_op+0x194>
	}
}
  1050f1:	83 c4 30             	add    $0x30,%esp
  1050f4:	5e                   	pop    %esi
  1050f5:	5f                   	pop    %edi
  1050f6:	5b                   	pop    %ebx
  1050f7:	5d                   	pop    %ebp
  1050f8:	c3                   	ret    
  1050f9:	66 90                	xchg   %ax,%ax
  1050fb:	66 90                	xchg   %ax,%ax
  1050fd:	66 90                	xchg   %ax,%ax
  1050ff:	90                   	nop

00105100 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
  105100:	55                   	push   %ebp
  105101:	89 e5                	mov    %esp,%ebp
  105103:	53                   	push   %ebx
  105104:	57                   	push   %edi
  105105:	56                   	push   %esi
  105106:	83 ec 30             	sub    $0x30,%esp
  105109:	8b 45 14             	mov    0x14(%ebp),%eax
  10510c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10510f:	8b 55 0c             	mov    0xc(%ebp),%edx
  105112:	8b 75 08             	mov    0x8(%ebp),%esi
  105115:	31 ff                	xor    %edi,%edi
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  105117:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10511a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10511d:	8b 45 0c             	mov    0xc(%ebp),%eax
  105120:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105123:	8b 45 10             	mov    0x10(%ebp),%eax
  105126:	89 45 e8             	mov    %eax,-0x18(%ebp)
  105129:	8b 45 14             	mov    0x14(%ebp),%eax
  10512c:	89 1c 24             	mov    %ebx,(%esp)
  10512f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  105132:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  105136:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  105139:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10513d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  105141:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105148:	00 
  105149:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10514c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  10514f:	89 75 dc             	mov    %esi,-0x24(%ebp)
  105152:	89 7d d8             	mov    %edi,-0x28(%ebp)
  105155:	e8 56 fd ff ff       	call   104eb0 <log_msg_hexdump_data_op>
}
  10515a:	83 c4 30             	add    $0x30,%esp
  10515d:	5e                   	pop    %esi
  10515e:	5f                   	pop    %edi
  10515f:	5b                   	pop    %ebx
  105160:	5d                   	pop    %ebp
  105161:	c3                   	ret    
  105162:	66 90                	xchg   %ax,%ax
  105164:	66 90                	xchg   %ax,%ax
  105166:	66 90                	xchg   %ax,%ax
  105168:	66 90                	xchg   %ax,%ax
  10516a:	66 90                	xchg   %ax,%ax
  10516c:	66 90                	xchg   %ax,%ax
  10516e:	66 90                	xchg   %ax,%ax

00105170 <atomic_add>:
{
  105170:	55                   	push   %ebp
  105171:	89 e5                	mov    %esp,%ebp
  105173:	56                   	push   %esi
  105174:	83 ec 0c             	sub    $0xc,%esp
  105177:	8b 45 0c             	mov    0xc(%ebp),%eax
  10517a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  10517d:	8b 55 08             	mov    0x8(%ebp),%edx
  105180:	8b 75 0c             	mov    0xc(%ebp),%esi
  105183:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105186:	8b 75 f8             	mov    -0x8(%ebp),%esi
  105189:	f0 0f c1 32          	lock xadd %esi,(%edx)
  10518d:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105190:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105193:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105196:	89 d0                	mov    %edx,%eax
  105198:	83 c4 0c             	add    $0xc,%esp
  10519b:	5e                   	pop    %esi
  10519c:	5d                   	pop    %ebp
  10519d:	c3                   	ret    
  10519e:	66 90                	xchg   %ax,%ax

001051a0 <atomic_sub>:
{
  1051a0:	55                   	push   %ebp
  1051a1:	89 e5                	mov    %esp,%ebp
  1051a3:	56                   	push   %esi
  1051a4:	83 ec 0c             	sub    $0xc,%esp
  1051a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1051aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1051ad:	8b 55 08             	mov    0x8(%ebp),%edx
  1051b0:	8b 75 0c             	mov    0xc(%ebp),%esi
  1051b3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  1051b6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1051b9:	f7 de                	neg    %esi
  1051bb:	f0 0f c1 32          	lock xadd %esi,(%edx)
  1051bf:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1051c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1051c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1051c8:	89 d0                	mov    %edx,%eax
  1051ca:	83 c4 0c             	add    $0xc,%esp
  1051cd:	5e                   	pop    %esi
  1051ce:	5d                   	pop    %ebp
  1051cf:	c3                   	ret    

001051d0 <log_msg_is_std>:
{
  1051d0:	55                   	push   %ebp
  1051d1:	89 e5                	mov    %esp,%ebp
  1051d3:	53                   	push   %ebx
  1051d4:	50                   	push   %eax
  1051d5:	8b 45 08             	mov    0x8(%ebp),%eax
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
  1051d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1051db:	66 8b 51 08          	mov    0x8(%ecx),%dx
  1051df:	66 83 e2 01          	and    $0x1,%dx
  1051e3:	0f b7 ca             	movzwl %dx,%ecx
  1051e6:	83 f9 00             	cmp    $0x0,%ecx
  1051e9:	0f 94 c3             	sete   %bl
  1051ec:	80 e3 01             	and    $0x1,%bl
  1051ef:	0f b6 cb             	movzbl %bl,%ecx
  1051f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1051f5:	89 c8                	mov    %ecx,%eax
  1051f7:	83 c4 04             	add    $0x4,%esp
  1051fa:	5b                   	pop    %ebx
  1051fb:	5d                   	pop    %ebp
  1051fc:	c3                   	ret    
  1051fd:	66 90                	xchg   %ax,%ax
  1051ff:	90                   	nop

00105200 <cont_free>:
{
  105200:	55                   	push   %ebp
  105201:	89 e5                	mov    %esp,%ebp
  105203:	83 ec 0c             	sub    $0xc,%esp
  105206:	8b 45 08             	mov    0x8(%ebp),%eax
	while (cont != NULL) {
  105209:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10520d:	0f 84 28 00 00 00    	je     10523b <cont_free+0x3b>
		next = cont->next;
  105213:	8b 45 08             	mov    0x8(%ebp),%eax
  105216:	8b 00                	mov    (%eax),%eax
  105218:	89 45 fc             	mov    %eax,-0x4(%ebp)
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
  10521b:	8d 45 08             	lea    0x8(%ebp),%eax
  10521e:	8d 0d d8 50 13 00    	lea    0x1350d8,%ecx
  105224:	89 0c 24             	mov    %ecx,(%esp)
  105227:	89 44 24 04          	mov    %eax,0x4(%esp)
  10522b:	e8 00 82 01 00       	call   11d430 <k_mem_slab_free>
		cont = next;
  105230:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105233:	89 45 08             	mov    %eax,0x8(%ebp)
	while (cont != NULL) {
  105236:	e9 ce ff ff ff       	jmp    105209 <cont_free+0x9>
}
  10523b:	83 c4 0c             	add    $0xc,%esp
  10523e:	5d                   	pop    %ebp
  10523f:	c3                   	ret    

00105240 <z_log_msg_std_alloc>:
{
  105240:	55                   	push   %ebp
  105241:	89 e5                	mov    %esp,%ebp
  105243:	50                   	push   %eax
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
  105244:	e8 d7 f5 ff ff       	call   104820 <log_msg_chunk_alloc>
  105249:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (msg != NULL) {
  10524c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  105250:	0f 84 22 00 00 00    	je     105278 <z_log_msg_std_alloc+0x38>
		msg->hdr.ref_cnt = 1;
  105256:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105259:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0U;
  105260:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105263:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
  105269:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10526c:	66 8b 48 08          	mov    0x8(%eax),%cx
  105270:	66 83 e1 fe          	and    $0xfffe,%cx
  105274:	66 89 48 08          	mov    %cx,0x8(%eax)
	return msg;
  105278:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10527b:	83 c4 04             	add    $0x4,%esp
  10527e:	5d                   	pop    %ebp
  10527f:	c3                   	ret    

00105280 <log_output_flush>:
		buf += processed;
	} while (len != 0);
}

void log_output_flush(const struct log_output *log_output)
{
  105280:	55                   	push   %ebp
  105281:	89 e5                	mov    %esp,%ebp
  105283:	57                   	push   %edi
  105284:	56                   	push   %esi
  105285:	83 ec 14             	sub    $0x14,%esp
  105288:	8b 45 08             	mov    0x8(%ebp),%eax
	buffer_write(log_output->func, log_output->buf,
  10528b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10528e:	8b 09                	mov    (%ecx),%ecx
  105290:	8b 55 08             	mov    0x8(%ebp),%edx
  105293:	8b 52 08             	mov    0x8(%edx),%edx
		     log_output->control_block->offset,
  105296:	8b 75 08             	mov    0x8(%ebp),%esi
  105299:	8b 76 04             	mov    0x4(%esi),%esi
  10529c:	8b 36                	mov    (%esi),%esi
		     log_output->control_block->ctx);
  10529e:	8b 7d 08             	mov    0x8(%ebp),%edi
  1052a1:	8b 7f 04             	mov    0x4(%edi),%edi
  1052a4:	8b 7f 04             	mov    0x4(%edi),%edi
	buffer_write(log_output->func, log_output->buf,
  1052a7:	89 0c 24             	mov    %ecx,(%esp)
  1052aa:	89 54 24 04          	mov    %edx,0x4(%esp)
  1052ae:	89 74 24 08          	mov    %esi,0x8(%esp)
  1052b2:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1052b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1052b9:	e8 22 00 00 00       	call   1052e0 <buffer_write>

	log_output->control_block->offset = 0;
  1052be:	8b 45 08             	mov    0x8(%ebp),%eax
  1052c1:	8b 40 04             	mov    0x4(%eax),%eax
  1052c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  1052ca:	83 c4 14             	add    $0x14,%esp
  1052cd:	5e                   	pop    %esi
  1052ce:	5f                   	pop    %edi
  1052cf:	5d                   	pop    %ebp
  1052d0:	c3                   	ret    
  1052d1:	66 90                	xchg   %ax,%ax
  1052d3:	66 90                	xchg   %ax,%ax
  1052d5:	66 90                	xchg   %ax,%ax
  1052d7:	66 90                	xchg   %ax,%ax
  1052d9:	66 90                	xchg   %ax,%ax
  1052db:	66 90                	xchg   %ax,%ax
  1052dd:	66 90                	xchg   %ax,%ax
  1052df:	90                   	nop

001052e0 <buffer_write>:
{
  1052e0:	55                   	push   %ebp
  1052e1:	89 e5                	mov    %esp,%ebp
  1052e3:	56                   	push   %esi
  1052e4:	83 ec 10             	sub    $0x10,%esp
  1052e7:	8b 45 14             	mov    0x14(%ebp),%eax
  1052ea:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1052ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  1052f0:	8b 75 08             	mov    0x8(%ebp),%esi
		processed = outf(buf, len, ctx);
  1052f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1052f6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1052f9:	8b 55 10             	mov    0x10(%ebp),%edx
  1052fc:	8b 75 14             	mov    0x14(%ebp),%esi
  1052ff:	89 0c 24             	mov    %ecx,(%esp)
  105302:	89 54 24 04          	mov    %edx,0x4(%esp)
  105306:	89 74 24 08          	mov    %esi,0x8(%esp)
  10530a:	ff d0                	call   *%eax
  10530c:	89 45 f8             	mov    %eax,-0x8(%ebp)
		len -= processed;
  10530f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105312:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105315:	29 c1                	sub    %eax,%ecx
  105317:	89 4d 10             	mov    %ecx,0x10(%ebp)
		buf += processed;
  10531a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10531d:	03 45 0c             	add    0xc(%ebp),%eax
  105320:	89 45 0c             	mov    %eax,0xc(%ebp)
	} while (len != 0);
  105323:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  105327:	0f 85 c6 ff ff ff    	jne    1052f3 <buffer_write+0x13>
}
  10532d:	83 c4 10             	add    $0x10,%esp
  105330:	5e                   	pop    %esi
  105331:	5d                   	pop    %ebp
  105332:	c3                   	ret    
  105333:	66 90                	xchg   %ax,%ax
  105335:	66 90                	xchg   %ax,%ax
  105337:	66 90                	xchg   %ax,%ax
  105339:	66 90                	xchg   %ax,%ax
  10533b:	66 90                	xchg   %ax,%ax
  10533d:	66 90                	xchg   %ax,%ax
  10533f:	90                   	nop

00105340 <log_output_msg_process>:
}

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
  105340:	55                   	push   %ebp
  105341:	89 e5                	mov    %esp,%ebp
  105343:	53                   	push   %ebx
  105344:	56                   	push   %esi
  105345:	83 ec 40             	sub    $0x40,%esp
  105348:	8b 45 10             	mov    0x10(%ebp),%eax
  10534b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10534e:	8b 55 08             	mov    0x8(%ebp),%edx
	bool std_msg = log_msg_is_std(msg);
  105351:	8b 75 0c             	mov    0xc(%ebp),%esi
  105354:	89 34 24             	mov    %esi,(%esp)
  105357:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10535a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10535d:	89 55 d8             	mov    %edx,-0x28(%ebp)
  105360:	e8 5b 01 00 00       	call   1054c0 <log_msg_is_std>
  105365:	24 01                	and    $0x1,%al
  105367:	88 45 f7             	mov    %al,-0x9(%ebp)
	u32_t timestamp = log_msg_timestamp_get(msg);
  10536a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10536d:	89 0c 24             	mov    %ecx,(%esp)
  105370:	e8 7b 01 00 00       	call   1054f0 <log_msg_timestamp_get>
  105375:	89 45 f0             	mov    %eax,-0x10(%ebp)
	u8_t level = (u8_t)log_msg_level_get(msg);
  105378:	8b 45 0c             	mov    0xc(%ebp),%eax
  10537b:	89 04 24             	mov    %eax,(%esp)
  10537e:	e8 8d 01 00 00       	call   105510 <log_msg_level_get>
  105383:	88 45 ef             	mov    %al,-0x11(%ebp)
	u8_t domain_id = (u8_t)log_msg_domain_id_get(msg);
  105386:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105389:	89 0c 24             	mov    %ecx,(%esp)
  10538c:	e8 9f 01 00 00       	call   105530 <log_msg_domain_id_get>
  105391:	88 45 ee             	mov    %al,-0x12(%ebp)
	u16_t source_id = (u16_t)log_msg_source_id_get(msg);
  105394:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105397:	89 0c 24             	mov    %ecx,(%esp)
  10539a:	e8 c1 01 00 00       	call   105560 <log_msg_source_id_get>
  10539f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
  1053a3:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  1053a7:	83 f9 00             	cmp    $0x0,%ecx
  1053aa:	0f 94 c3             	sete   %bl
  1053ad:	80 e3 01             	and    $0x1,%bl
  1053b0:	88 5d eb             	mov    %bl,-0x15(%ebp)
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYST) {
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
  1053b3:	f6 45 eb 01          	testb  $0x1,-0x15(%ebp)
  1053b7:	0f 84 0a 00 00 00    	je     1053c7 <log_output_msg_process+0x87>
  1053bd:	31 c0                	xor    %eax,%eax
  1053bf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1053c2:	e9 45 00 00 00       	jmp    10540c <log_output_msg_process+0xcc>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  1053c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1053ca:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1053cd:	8a 55 f7             	mov    -0x9(%ebp),%dl
  1053d0:	8b 75 f0             	mov    -0x10(%ebp),%esi
					 level, domain_id, source_id);
  1053d3:	8a 75 ef             	mov    -0x11(%ebp),%dh
  1053d6:	8a 5d ee             	mov    -0x12(%ebp),%bl
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  1053d9:	80 e2 01             	and    $0x1,%dl
  1053dc:	89 04 24             	mov    %eax,(%esp)
  1053df:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1053e3:	0f b6 c2             	movzbl %dl,%eax
  1053e6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1053ea:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1053ee:	0f b6 c6             	movzbl %dh,%eax
  1053f1:	89 44 24 10          	mov    %eax,0x10(%esp)
  1053f5:	0f b6 c3             	movzbl %bl,%eax
  1053f8:	89 44 24 14          	mov    %eax,0x14(%esp)
  1053fc:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  105400:	89 44 24 18          	mov    %eax,0x18(%esp)
  105404:	e8 77 01 00 00       	call   105580 <prefix_print>
  105409:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10540c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	prefix_offset = raw_string ?
  10540f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	if (log_msg_is_std(msg)) {
  105412:	8b 45 0c             	mov    0xc(%ebp),%eax
  105415:	89 04 24             	mov    %eax,(%esp)
  105418:	e8 a3 00 00 00       	call   1054c0 <log_msg_is_std>
  10541d:	a8 01                	test   $0x1,%al
  10541f:	0f 85 05 00 00 00    	jne    10542a <log_output_msg_process+0xea>
  105425:	e9 17 00 00 00       	jmp    105441 <log_output_msg_process+0x101>
		std_print(msg, log_output);
  10542a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10542d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105430:	89 04 24             	mov    %eax,(%esp)
  105433:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105437:	e8 44 02 00 00       	call   105680 <std_print>
	} else if (raw_string) {
  10543c:	e9 46 00 00 00       	jmp    105487 <log_output_msg_process+0x147>
  105441:	f6 45 eb 01          	testb  $0x1,-0x15(%ebp)
  105445:	0f 84 17 00 00 00    	je     105462 <log_output_msg_process+0x122>
		raw_string_print(msg, log_output);
  10544b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10544e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105451:	89 04 24             	mov    %eax,(%esp)
  105454:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105458:	e8 c3 0e 00 00       	call   106320 <raw_string_print>
	} else {
  10545d:	e9 20 00 00 00       	jmp    105482 <log_output_msg_process+0x142>
		hexdump_print(msg, log_output, prefix_offset, flags);
  105462:	8b 45 0c             	mov    0xc(%ebp),%eax
  105465:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105468:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10546b:	8b 75 10             	mov    0x10(%ebp),%esi
  10546e:	89 04 24             	mov    %eax,(%esp)
  105471:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105475:	89 54 24 08          	mov    %edx,0x8(%esp)
  105479:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10547d:	e8 5e 0f 00 00       	call   1063e0 <hexdump_print>
  105482:	e9 00 00 00 00       	jmp    105487 <log_output_msg_process+0x147>
	}

	if (!raw_string) {
  105487:	f6 45 eb 01          	testb  $0x1,-0x15(%ebp)
  10548b:	0f 85 1a 00 00 00    	jne    1054ab <log_output_msg_process+0x16b>
		postfix_print(log_output, flags, level);
  105491:	8b 45 08             	mov    0x8(%ebp),%eax
  105494:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105497:	89 04 24             	mov    %eax,(%esp)
  10549a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10549e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  1054a2:	89 44 24 08          	mov    %eax,0x8(%esp)
  1054a6:	e8 15 10 00 00       	call   1064c0 <postfix_print>
	}

	log_output_flush(log_output);
  1054ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1054ae:	89 04 24             	mov    %eax,(%esp)
  1054b1:	e8 ca fd ff ff       	call   105280 <log_output_flush>
}
  1054b6:	83 c4 40             	add    $0x40,%esp
  1054b9:	5e                   	pop    %esi
  1054ba:	5b                   	pop    %ebx
  1054bb:	5d                   	pop    %ebp
  1054bc:	c3                   	ret    
  1054bd:	66 90                	xchg   %ax,%ax
  1054bf:	90                   	nop

001054c0 <log_msg_is_std>:
{
  1054c0:	55                   	push   %ebp
  1054c1:	89 e5                	mov    %esp,%ebp
  1054c3:	53                   	push   %ebx
  1054c4:	50                   	push   %eax
  1054c5:	8b 45 08             	mov    0x8(%ebp),%eax
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
  1054c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1054cb:	66 8b 51 08          	mov    0x8(%ecx),%dx
  1054cf:	66 83 e2 01          	and    $0x1,%dx
  1054d3:	0f b7 ca             	movzwl %dx,%ecx
  1054d6:	83 f9 00             	cmp    $0x0,%ecx
  1054d9:	0f 94 c3             	sete   %bl
  1054dc:	80 e3 01             	and    $0x1,%bl
  1054df:	0f b6 cb             	movzbl %bl,%ecx
  1054e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1054e5:	89 c8                	mov    %ecx,%eax
  1054e7:	83 c4 04             	add    $0x4,%esp
  1054ea:	5b                   	pop    %ebx
  1054eb:	5d                   	pop    %ebp
  1054ec:	c3                   	ret    
  1054ed:	66 90                	xchg   %ax,%ax
  1054ef:	90                   	nop

001054f0 <log_msg_timestamp_get>:
{
  1054f0:	55                   	push   %ebp
  1054f1:	89 e5                	mov    %esp,%ebp
  1054f3:	50                   	push   %eax
  1054f4:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->hdr.timestamp;
  1054f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1054fa:	8b 49 0c             	mov    0xc(%ecx),%ecx
  1054fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105500:	89 c8                	mov    %ecx,%eax
  105502:	83 c4 04             	add    $0x4,%esp
  105505:	5d                   	pop    %ebp
  105506:	c3                   	ret    
  105507:	66 90                	xchg   %ax,%ax
  105509:	66 90                	xchg   %ax,%ax
  10550b:	66 90                	xchg   %ax,%ax
  10550d:	66 90                	xchg   %ax,%ax
  10550f:	90                   	nop

00105510 <log_msg_level_get>:
{
  105510:	55                   	push   %ebp
  105511:	89 e5                	mov    %esp,%ebp
  105513:	50                   	push   %eax
  105514:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->hdr.ids.level;
  105517:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10551a:	66 8b 51 0a          	mov    0xa(%ecx),%dx
  10551e:	66 83 e2 07          	and    $0x7,%dx
  105522:	0f b7 ca             	movzwl %dx,%ecx
  105525:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105528:	89 c8                	mov    %ecx,%eax
  10552a:	83 c4 04             	add    $0x4,%esp
  10552d:	5d                   	pop    %ebp
  10552e:	c3                   	ret    
  10552f:	90                   	nop

00105530 <log_msg_domain_id_get>:
{
  105530:	55                   	push   %ebp
  105531:	89 e5                	mov    %esp,%ebp
  105533:	50                   	push   %eax
  105534:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->hdr.ids.domain_id;
  105537:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10553a:	66 8b 51 0a          	mov    0xa(%ecx),%dx
  10553e:	66 c1 ea 03          	shr    $0x3,%dx
  105542:	66 83 e2 07          	and    $0x7,%dx
  105546:	0f b7 ca             	movzwl %dx,%ecx
  105549:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10554c:	89 c8                	mov    %ecx,%eax
  10554e:	83 c4 04             	add    $0x4,%esp
  105551:	5d                   	pop    %ebp
  105552:	c3                   	ret    
  105553:	66 90                	xchg   %ax,%ax
  105555:	66 90                	xchg   %ax,%ax
  105557:	66 90                	xchg   %ax,%ax
  105559:	66 90                	xchg   %ax,%ax
  10555b:	66 90                	xchg   %ax,%ax
  10555d:	66 90                	xchg   %ax,%ax
  10555f:	90                   	nop

00105560 <log_msg_source_id_get>:
{
  105560:	55                   	push   %ebp
  105561:	89 e5                	mov    %esp,%ebp
  105563:	50                   	push   %eax
  105564:	8b 45 08             	mov    0x8(%ebp),%eax
	return msg->hdr.ids.source_id;
  105567:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10556a:	66 8b 51 0a          	mov    0xa(%ecx),%dx
  10556e:	66 c1 ea 06          	shr    $0x6,%dx
  105572:	0f b7 ca             	movzwl %dx,%ecx
  105575:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105578:	89 c8                	mov    %ecx,%eax
  10557a:	83 c4 04             	add    $0x4,%esp
  10557d:	5d                   	pop    %ebp
  10557e:	c3                   	ret    
  10557f:	90                   	nop

00105580 <prefix_print>:
{
  105580:	55                   	push   %ebp
  105581:	89 e5                	mov    %esp,%ebp
  105583:	53                   	push   %ebx
  105584:	57                   	push   %edi
  105585:	56                   	push   %esi
  105586:	83 ec 24             	sub    $0x24,%esp
  105589:	66 8b 45 20          	mov    0x20(%ebp),%ax
  10558d:	8a 4d 1c             	mov    0x1c(%ebp),%cl
  105590:	8a 55 18             	mov    0x18(%ebp),%dl
  105593:	8b 75 14             	mov    0x14(%ebp),%esi
  105596:	8a 6d 10             	mov    0x10(%ebp),%ch
  105599:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10559c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10559f:	80 e5 01             	and    $0x1,%ch
  1055a2:	88 6d f3             	mov    %ch,-0xd(%ebp)
	u32_t length = 0U;
  1055a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1055ac:	88 55 e8             	mov    %dl,-0x18(%ebp)
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
  1055af:	8b 55 0c             	mov    0xc(%ebp),%edx
  1055b2:	83 e2 02             	and    $0x2,%edx
  1055b5:	83 fa 00             	cmp    $0x0,%edx
  1055b8:	0f 95 c5             	setne  %ch
  1055bb:	80 e5 01             	and    $0x1,%ch
  1055be:	88 6d eb             	mov    %ch,-0x15(%ebp)
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
  1055c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  1055c4:	83 e2 01             	and    $0x1,%edx
  1055c7:	83 fa 00             	cmp    $0x0,%edx
  1055ca:	0f 95 c5             	setne  %ch
  1055cd:	80 e5 01             	and    $0x1,%ch
  1055d0:	88 6d ea             	mov    %ch,-0x16(%ebp)
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  1055d3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1055d6:	83 e2 08             	and    $0x8,%edx
  1055d9:	83 fa 00             	cmp    $0x0,%edx
  1055dc:	0f 95 c5             	setne  %ch
  1055df:	80 e5 01             	and    $0x1,%ch
  1055e2:	88 6d e9             	mov    %ch,-0x17(%ebp)
	if (stamp) {
  1055e5:	f6 45 eb 01          	testb  $0x1,-0x15(%ebp)
  1055e9:	0f 84 1f 00 00 00    	je     10560e <prefix_print+0x8e>
		length += timestamp_print(log_output, flags, timestamp);
  1055ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1055f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1055f5:	8b 55 14             	mov    0x14(%ebp),%edx
  1055f8:	89 04 24             	mov    %eax,(%esp)
  1055fb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1055ff:	89 54 24 08          	mov    %edx,0x8(%esp)
  105603:	e8 18 13 00 00       	call   106920 <timestamp_print>
  105608:	03 45 ec             	add    -0x14(%ebp),%eax
  10560b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		color_prefix(log_output, colors_on, level);
  10560e:	8b 45 08             	mov    0x8(%ebp),%eax
  105611:	8a 4d ea             	mov    -0x16(%ebp),%cl
  105614:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  105618:	80 e1 01             	and    $0x1,%cl
  10561b:	89 04 24             	mov    %eax,(%esp)
  10561e:	0f b6 c1             	movzbl %cl,%eax
  105621:	89 44 24 04          	mov    %eax,0x4(%esp)
  105625:	89 54 24 08          	mov    %edx,0x8(%esp)
  105629:	e8 72 14 00 00       	call   106aa0 <color_prefix>
		length += ids_print(log_output, level_on, func_on,
  10562e:	8b 45 08             	mov    0x8(%ebp),%eax
  105631:	8a 4d e9             	mov    -0x17(%ebp),%cl
  105634:	8a 6d f3             	mov    -0xd(%ebp),%ch
				    domain_id, source_id, level);
  105637:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  10563b:	0f b7 75 20          	movzwl 0x20(%ebp),%esi
  10563f:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
		length += ids_print(log_output, level_on, func_on,
  105643:	80 e1 01             	and    $0x1,%cl
  105646:	80 e5 01             	and    $0x1,%ch
  105649:	89 04 24             	mov    %eax,(%esp)
  10564c:	0f b6 c1             	movzbl %cl,%eax
  10564f:	89 44 24 04          	mov    %eax,0x4(%esp)
  105653:	0f b6 c5             	movzbl %ch,%eax
  105656:	89 44 24 08          	mov    %eax,0x8(%esp)
  10565a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10565e:	89 74 24 10          	mov    %esi,0x10(%esp)
  105662:	89 7c 24 14          	mov    %edi,0x14(%esp)
  105666:	e8 85 14 00 00       	call   106af0 <ids_print>
  10566b:	03 45 ec             	add    -0x14(%ebp),%eax
  10566e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return length;
  105671:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105674:	83 c4 24             	add    $0x24,%esp
  105677:	5e                   	pop    %esi
  105678:	5f                   	pop    %edi
  105679:	5b                   	pop    %ebx
  10567a:	5d                   	pop    %ebp
  10567b:	c3                   	ret    
  10567c:	66 90                	xchg   %ax,%ax
  10567e:	66 90                	xchg   %ax,%ax

00105680 <std_print>:
{
  105680:	55                   	push   %ebp
  105681:	89 e5                	mov    %esp,%ebp
  105683:	53                   	push   %ebx
  105684:	57                   	push   %edi
  105685:	56                   	push   %esi
  105686:	83 e4 f0             	and    $0xfffffff0,%esp
  105689:	81 ec a0 01 00 00    	sub    $0x1a0,%esp
  10568f:	89 e6                	mov    %esp,%esi
  105691:	8b 45 0c             	mov    0xc(%ebp),%eax
  105694:	8b 4d 08             	mov    0x8(%ebp),%ecx
	const char *str = log_msg_str_get(msg);
  105697:	8b 55 08             	mov    0x8(%ebp),%edx
  10569a:	83 ec 04             	sub    $0x4,%esp
  10569d:	89 e7                	mov    %esp,%edi
  10569f:	89 17                	mov    %edx,(%edi)
  1056a1:	89 86 7c 01 00 00    	mov    %eax,0x17c(%esi)
  1056a7:	89 8e 78 01 00 00    	mov    %ecx,0x178(%esi)
  1056ad:	e8 6e f5 ff ff       	call   104c20 <log_msg_str_get>
  1056b2:	83 c4 04             	add    $0x4,%esp
  1056b5:	89 86 98 01 00 00    	mov    %eax,0x198(%esi)
	u32_t nargs = log_msg_nargs_get(msg);
  1056bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1056be:	83 ec 04             	sub    $0x4,%esp
  1056c1:	89 e1                	mov    %esp,%ecx
  1056c3:	89 01                	mov    %eax,(%ecx)
  1056c5:	e8 36 f4 ff ff       	call   104b00 <log_msg_nargs_get>
  1056ca:	83 c4 04             	add    $0x4,%esp
  1056cd:	89 86 94 01 00 00    	mov    %eax,0x194(%esi)
	u32_t *args = alloca(sizeof(u32_t)*nargs);
  1056d3:	8b 86 94 01 00 00    	mov    0x194(%esi),%eax
  1056d9:	c1 e0 02             	shl    $0x2,%eax
  1056dc:	89 e1                	mov    %esp,%ecx
  1056de:	29 c1                	sub    %eax,%ecx
  1056e0:	83 e1 f0             	and    $0xfffffff0,%ecx
  1056e3:	89 cc                	mov    %ecx,%esp
  1056e5:	89 8e 90 01 00 00    	mov    %ecx,0x190(%esi)
	for (i = 0; i < nargs; i++) {
  1056eb:	c7 86 8c 01 00 00 00 	movl   $0x0,0x18c(%esi)
  1056f2:	00 00 00 
  1056f5:	8b 86 8c 01 00 00    	mov    0x18c(%esi),%eax
  1056fb:	3b 86 94 01 00 00    	cmp    0x194(%esi),%eax
  105701:	0f 83 3e 00 00 00    	jae    105745 <std_print+0xc5>
		args[i] = log_msg_arg_get(msg, i);
  105707:	8b 45 08             	mov    0x8(%ebp),%eax
  10570a:	8b 8e 8c 01 00 00    	mov    0x18c(%esi),%ecx
  105710:	83 ec 08             	sub    $0x8,%esp
  105713:	89 04 24             	mov    %eax,(%esp)
  105716:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10571a:	e8 01 f4 ff ff       	call   104b20 <log_msg_arg_get>
  10571f:	83 c4 08             	add    $0x8,%esp
  105722:	8b 8e 90 01 00 00    	mov    0x190(%esi),%ecx
  105728:	8b 96 8c 01 00 00    	mov    0x18c(%esi),%edx
  10572e:	89 04 91             	mov    %eax,(%ecx,%edx,4)
	for (i = 0; i < nargs; i++) {
  105731:	8b 86 8c 01 00 00    	mov    0x18c(%esi),%eax
  105737:	83 c0 01             	add    $0x1,%eax
  10573a:	89 86 8c 01 00 00    	mov    %eax,0x18c(%esi)
  105740:	e9 b0 ff ff ff       	jmp    1056f5 <std_print+0x75>
	switch (log_msg_nargs_get(msg)) {
  105745:	8b 45 08             	mov    0x8(%ebp),%eax
  105748:	83 ec 04             	sub    $0x4,%esp
  10574b:	89 e1                	mov    %esp,%ecx
  10574d:	89 01                	mov    %eax,(%ecx)
  10574f:	e8 ac f3 ff ff       	call   104b00 <log_msg_nargs_get>
  105754:	83 c4 04             	add    $0x4,%esp
  105757:	89 c1                	mov    %eax,%ecx
  105759:	83 e8 0f             	sub    $0xf,%eax
  10575c:	89 8e 74 01 00 00    	mov    %ecx,0x174(%esi)
  105762:	0f 87 a2 0b 00 00    	ja     10630a <std_print+0xc8a>
  105768:	8b 86 74 01 00 00    	mov    0x174(%esi),%eax
  10576e:	8b 0c 85 0c 32 12 00 	mov    0x12320c(,%eax,4),%ecx
  105775:	ff e1                	jmp    *%ecx
		print_formatted(log_output, str);
  105777:	8b 45 0c             	mov    0xc(%ebp),%eax
  10577a:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105780:	83 ec 08             	sub    $0x8,%esp
  105783:	89 04 24             	mov    %eax,(%esp)
  105786:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10578a:	e8 f1 0d 00 00       	call   106580 <print_formatted>
  10578f:	83 c4 08             	add    $0x8,%esp
		break;
  105792:	e9 78 0b 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0]);
  105797:	8b 45 0c             	mov    0xc(%ebp),%eax
  10579a:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1057a0:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1057a6:	8b 12                	mov    (%edx),%edx
  1057a8:	83 ec 0c             	sub    $0xc,%esp
  1057ab:	89 04 24             	mov    %eax,(%esp)
  1057ae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1057b2:	89 54 24 08          	mov    %edx,0x8(%esp)
  1057b6:	e8 c5 0d 00 00       	call   106580 <print_formatted>
  1057bb:	83 c4 0c             	add    $0xc,%esp
		break;
  1057be:	e9 4c 0b 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1]);
  1057c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1057c6:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1057cc:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1057d2:	8b 12                	mov    (%edx),%edx
  1057d4:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  1057da:	8b 7f 04             	mov    0x4(%edi),%edi
  1057dd:	83 ec 10             	sub    $0x10,%esp
  1057e0:	89 04 24             	mov    %eax,(%esp)
  1057e3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1057e7:	89 54 24 08          	mov    %edx,0x8(%esp)
  1057eb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1057ef:	e8 8c 0d 00 00       	call   106580 <print_formatted>
  1057f4:	83 c4 10             	add    $0x10,%esp
		break;
  1057f7:	e9 13 0b 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2]);
  1057fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1057ff:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105805:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  10580b:	8b 12                	mov    (%edx),%edx
  10580d:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105813:	8b 7f 04             	mov    0x4(%edi),%edi
  105816:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  10581c:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10581f:	83 ec 14             	sub    $0x14,%esp
  105822:	89 04 24             	mov    %eax,(%esp)
  105825:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105829:	89 54 24 08          	mov    %edx,0x8(%esp)
  10582d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105831:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105835:	e8 46 0d 00 00       	call   106580 <print_formatted>
  10583a:	83 c4 14             	add    $0x14,%esp
		break;
  10583d:	e9 cd 0a 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105842:	8b 45 0c             	mov    0xc(%ebp),%eax
  105845:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  10584b:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105851:	8b 12                	mov    (%edx),%edx
  105853:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105859:	8b 7f 04             	mov    0x4(%edi),%edi
  10585c:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105862:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105865:	89 86 70 01 00 00    	mov    %eax,0x170(%esi)
				args[3]);
  10586b:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105871:	8b 40 0c             	mov    0xc(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105874:	83 ec 18             	sub    $0x18,%esp
  105877:	89 86 6c 01 00 00    	mov    %eax,0x16c(%esi)
  10587d:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
  105883:	89 04 24             	mov    %eax,(%esp)
  105886:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10588a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10588e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105892:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105896:	8b 86 6c 01 00 00    	mov    0x16c(%esi),%eax
  10589c:	89 44 24 14          	mov    %eax,0x14(%esp)
  1058a0:	e8 db 0c 00 00       	call   106580 <print_formatted>
  1058a5:	83 c4 18             	add    $0x18,%esp
		break;
  1058a8:	e9 62 0a 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  1058ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  1058b0:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1058b6:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1058bc:	8b 12                	mov    (%edx),%edx
  1058be:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  1058c4:	8b 7f 04             	mov    0x4(%edi),%edi
  1058c7:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  1058cd:	8b 5b 08             	mov    0x8(%ebx),%ebx
  1058d0:	89 86 68 01 00 00    	mov    %eax,0x168(%esi)
				args[3], args[4]);
  1058d6:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  1058dc:	8b 40 0c             	mov    0xc(%eax),%eax
  1058df:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
  1058e5:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  1058eb:	8b 40 10             	mov    0x10(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  1058ee:	83 ec 1c             	sub    $0x1c,%esp
  1058f1:	89 86 60 01 00 00    	mov    %eax,0x160(%esi)
  1058f7:	8b 86 68 01 00 00    	mov    0x168(%esi),%eax
  1058fd:	89 04 24             	mov    %eax,(%esp)
  105900:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105904:	89 54 24 08          	mov    %edx,0x8(%esp)
  105908:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10590c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105910:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
  105916:	89 44 24 14          	mov    %eax,0x14(%esp)
  10591a:	8b 86 60 01 00 00    	mov    0x160(%esi),%eax
  105920:	89 44 24 18          	mov    %eax,0x18(%esp)
  105924:	e8 57 0c 00 00       	call   106580 <print_formatted>
  105929:	83 c4 1c             	add    $0x1c,%esp
		break;
  10592c:	e9 de 09 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105931:	8b 45 0c             	mov    0xc(%ebp),%eax
  105934:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  10593a:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105940:	8b 12                	mov    (%edx),%edx
  105942:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105948:	8b 7f 04             	mov    0x4(%edi),%edi
  10594b:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105951:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105954:	89 86 5c 01 00 00    	mov    %eax,0x15c(%esi)
				args[3], args[4], args[5]);
  10595a:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105960:	8b 40 0c             	mov    0xc(%eax),%eax
  105963:	89 86 58 01 00 00    	mov    %eax,0x158(%esi)
  105969:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10596f:	8b 40 10             	mov    0x10(%eax),%eax
  105972:	89 86 54 01 00 00    	mov    %eax,0x154(%esi)
  105978:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10597e:	8b 40 14             	mov    0x14(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105981:	83 ec 20             	sub    $0x20,%esp
  105984:	89 86 50 01 00 00    	mov    %eax,0x150(%esi)
  10598a:	8b 86 5c 01 00 00    	mov    0x15c(%esi),%eax
  105990:	89 04 24             	mov    %eax,(%esp)
  105993:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105997:	89 54 24 08          	mov    %edx,0x8(%esp)
  10599b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10599f:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1059a3:	8b 86 58 01 00 00    	mov    0x158(%esi),%eax
  1059a9:	89 44 24 14          	mov    %eax,0x14(%esp)
  1059ad:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
  1059b3:	89 44 24 18          	mov    %eax,0x18(%esp)
  1059b7:	8b 86 50 01 00 00    	mov    0x150(%esi),%eax
  1059bd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1059c1:	e8 ba 0b 00 00       	call   106580 <print_formatted>
  1059c6:	83 c4 20             	add    $0x20,%esp
		break;
  1059c9:	e9 41 09 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  1059ce:	8b 45 0c             	mov    0xc(%ebp),%eax
  1059d1:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1059d7:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1059dd:	8b 12                	mov    (%edx),%edx
  1059df:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  1059e5:	8b 7f 04             	mov    0x4(%edi),%edi
  1059e8:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  1059ee:	8b 5b 08             	mov    0x8(%ebx),%ebx
  1059f1:	89 86 4c 01 00 00    	mov    %eax,0x14c(%esi)
				args[3], args[4], args[5], args[6]);
  1059f7:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  1059fd:	8b 40 0c             	mov    0xc(%eax),%eax
  105a00:	89 86 48 01 00 00    	mov    %eax,0x148(%esi)
  105a06:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105a0c:	8b 40 10             	mov    0x10(%eax),%eax
  105a0f:	89 86 44 01 00 00    	mov    %eax,0x144(%esi)
  105a15:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105a1b:	8b 40 14             	mov    0x14(%eax),%eax
  105a1e:	89 86 40 01 00 00    	mov    %eax,0x140(%esi)
  105a24:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105a2a:	8b 40 18             	mov    0x18(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105a2d:	83 ec 24             	sub    $0x24,%esp
  105a30:	89 86 3c 01 00 00    	mov    %eax,0x13c(%esi)
  105a36:	8b 86 4c 01 00 00    	mov    0x14c(%esi),%eax
  105a3c:	89 04 24             	mov    %eax,(%esp)
  105a3f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a43:	89 54 24 08          	mov    %edx,0x8(%esp)
  105a47:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105a4b:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105a4f:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
  105a55:	89 44 24 14          	mov    %eax,0x14(%esp)
  105a59:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
  105a5f:	89 44 24 18          	mov    %eax,0x18(%esp)
  105a63:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
  105a69:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105a6d:	8b 86 3c 01 00 00    	mov    0x13c(%esi),%eax
  105a73:	89 44 24 20          	mov    %eax,0x20(%esp)
  105a77:	e8 04 0b 00 00       	call   106580 <print_formatted>
  105a7c:	83 c4 24             	add    $0x24,%esp
		break;
  105a7f:	e9 8b 08 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105a84:	8b 45 0c             	mov    0xc(%ebp),%eax
  105a87:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105a8d:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105a93:	8b 12                	mov    (%edx),%edx
  105a95:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105a9b:	8b 7f 04             	mov    0x4(%edi),%edi
  105a9e:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105aa4:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105aa7:	89 86 38 01 00 00    	mov    %eax,0x138(%esi)
				args[3], args[4], args[5], args[6], args[7]);
  105aad:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ab3:	8b 40 0c             	mov    0xc(%eax),%eax
  105ab6:	89 86 34 01 00 00    	mov    %eax,0x134(%esi)
  105abc:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ac2:	8b 40 10             	mov    0x10(%eax),%eax
  105ac5:	89 86 30 01 00 00    	mov    %eax,0x130(%esi)
  105acb:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ad1:	8b 40 14             	mov    0x14(%eax),%eax
  105ad4:	89 86 2c 01 00 00    	mov    %eax,0x12c(%esi)
  105ada:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ae0:	8b 40 18             	mov    0x18(%eax),%eax
  105ae3:	89 86 28 01 00 00    	mov    %eax,0x128(%esi)
  105ae9:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105aef:	8b 40 1c             	mov    0x1c(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105af2:	83 ec 28             	sub    $0x28,%esp
  105af5:	89 86 24 01 00 00    	mov    %eax,0x124(%esi)
  105afb:	8b 86 38 01 00 00    	mov    0x138(%esi),%eax
  105b01:	89 04 24             	mov    %eax,(%esp)
  105b04:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105b08:	89 54 24 08          	mov    %edx,0x8(%esp)
  105b0c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105b10:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105b14:	8b 86 34 01 00 00    	mov    0x134(%esi),%eax
  105b1a:	89 44 24 14          	mov    %eax,0x14(%esp)
  105b1e:	8b 86 30 01 00 00    	mov    0x130(%esi),%eax
  105b24:	89 44 24 18          	mov    %eax,0x18(%esp)
  105b28:	8b 86 2c 01 00 00    	mov    0x12c(%esi),%eax
  105b2e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105b32:	8b 86 28 01 00 00    	mov    0x128(%esi),%eax
  105b38:	89 44 24 20          	mov    %eax,0x20(%esp)
  105b3c:	8b 86 24 01 00 00    	mov    0x124(%esi),%eax
  105b42:	89 44 24 24          	mov    %eax,0x24(%esp)
  105b46:	e8 35 0a 00 00       	call   106580 <print_formatted>
  105b4b:	83 c4 28             	add    $0x28,%esp
		break;
  105b4e:	e9 bc 07 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105b53:	8b 45 0c             	mov    0xc(%ebp),%eax
  105b56:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105b5c:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105b62:	8b 12                	mov    (%edx),%edx
  105b64:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105b6a:	8b 7f 04             	mov    0x4(%edi),%edi
  105b6d:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105b73:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105b76:	89 86 20 01 00 00    	mov    %eax,0x120(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  105b7c:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105b82:	8b 40 0c             	mov    0xc(%eax),%eax
  105b85:	89 86 1c 01 00 00    	mov    %eax,0x11c(%esi)
  105b8b:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105b91:	8b 40 10             	mov    0x10(%eax),%eax
  105b94:	89 86 18 01 00 00    	mov    %eax,0x118(%esi)
  105b9a:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ba0:	8b 40 14             	mov    0x14(%eax),%eax
  105ba3:	89 86 14 01 00 00    	mov    %eax,0x114(%esi)
  105ba9:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105baf:	8b 40 18             	mov    0x18(%eax),%eax
  105bb2:	89 86 10 01 00 00    	mov    %eax,0x110(%esi)
  105bb8:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105bbe:	8b 40 1c             	mov    0x1c(%eax),%eax
  105bc1:	89 86 0c 01 00 00    	mov    %eax,0x10c(%esi)
				args[8]);
  105bc7:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105bcd:	8b 40 20             	mov    0x20(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105bd0:	83 ec 2c             	sub    $0x2c,%esp
  105bd3:	89 86 08 01 00 00    	mov    %eax,0x108(%esi)
  105bd9:	8b 86 20 01 00 00    	mov    0x120(%esi),%eax
  105bdf:	89 04 24             	mov    %eax,(%esp)
  105be2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105be6:	89 54 24 08          	mov    %edx,0x8(%esp)
  105bea:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105bee:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105bf2:	8b 86 1c 01 00 00    	mov    0x11c(%esi),%eax
  105bf8:	89 44 24 14          	mov    %eax,0x14(%esp)
  105bfc:	8b 86 18 01 00 00    	mov    0x118(%esi),%eax
  105c02:	89 44 24 18          	mov    %eax,0x18(%esp)
  105c06:	8b 86 14 01 00 00    	mov    0x114(%esi),%eax
  105c0c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105c10:	8b 86 10 01 00 00    	mov    0x110(%esi),%eax
  105c16:	89 44 24 20          	mov    %eax,0x20(%esp)
  105c1a:	8b 86 0c 01 00 00    	mov    0x10c(%esi),%eax
  105c20:	89 44 24 24          	mov    %eax,0x24(%esp)
  105c24:	8b 86 08 01 00 00    	mov    0x108(%esi),%eax
  105c2a:	89 44 24 28          	mov    %eax,0x28(%esp)
  105c2e:	e8 4d 09 00 00       	call   106580 <print_formatted>
  105c33:	83 c4 2c             	add    $0x2c,%esp
		break;
  105c36:	e9 d4 06 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105c3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  105c3e:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105c44:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105c4a:	8b 12                	mov    (%edx),%edx
  105c4c:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105c52:	8b 7f 04             	mov    0x4(%edi),%edi
  105c55:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105c5b:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105c5e:	89 86 04 01 00 00    	mov    %eax,0x104(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  105c64:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105c6a:	8b 40 0c             	mov    0xc(%eax),%eax
  105c6d:	89 86 00 01 00 00    	mov    %eax,0x100(%esi)
  105c73:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105c79:	8b 40 10             	mov    0x10(%eax),%eax
  105c7c:	89 86 fc 00 00 00    	mov    %eax,0xfc(%esi)
  105c82:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105c88:	8b 40 14             	mov    0x14(%eax),%eax
  105c8b:	89 86 f8 00 00 00    	mov    %eax,0xf8(%esi)
  105c91:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105c97:	8b 40 18             	mov    0x18(%eax),%eax
  105c9a:	89 86 f4 00 00 00    	mov    %eax,0xf4(%esi)
  105ca0:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ca6:	8b 40 1c             	mov    0x1c(%eax),%eax
  105ca9:	89 86 f0 00 00 00    	mov    %eax,0xf0(%esi)
				args[8], args[9]);
  105caf:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105cb5:	8b 40 20             	mov    0x20(%eax),%eax
  105cb8:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  105cbe:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105cc4:	8b 40 24             	mov    0x24(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105cc7:	83 ec 30             	sub    $0x30,%esp
  105cca:	89 86 e8 00 00 00    	mov    %eax,0xe8(%esi)
  105cd0:	8b 86 04 01 00 00    	mov    0x104(%esi),%eax
  105cd6:	89 04 24             	mov    %eax,(%esp)
  105cd9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105cdd:	89 54 24 08          	mov    %edx,0x8(%esp)
  105ce1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105ce5:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105ce9:	8b 86 00 01 00 00    	mov    0x100(%esi),%eax
  105cef:	89 44 24 14          	mov    %eax,0x14(%esp)
  105cf3:	8b 86 fc 00 00 00    	mov    0xfc(%esi),%eax
  105cf9:	89 44 24 18          	mov    %eax,0x18(%esp)
  105cfd:	8b 86 f8 00 00 00    	mov    0xf8(%esi),%eax
  105d03:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105d07:	8b 86 f4 00 00 00    	mov    0xf4(%esi),%eax
  105d0d:	89 44 24 20          	mov    %eax,0x20(%esp)
  105d11:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
  105d17:	89 44 24 24          	mov    %eax,0x24(%esp)
  105d1b:	8b 86 ec 00 00 00    	mov    0xec(%esi),%eax
  105d21:	89 44 24 28          	mov    %eax,0x28(%esp)
  105d25:	8b 86 e8 00 00 00    	mov    0xe8(%esi),%eax
  105d2b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105d2f:	e8 4c 08 00 00       	call   106580 <print_formatted>
  105d34:	83 c4 30             	add    $0x30,%esp
		break;
  105d37:	e9 d3 05 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105d3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  105d3f:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105d45:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105d4b:	8b 12                	mov    (%edx),%edx
  105d4d:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105d53:	8b 7f 04             	mov    0x4(%edi),%edi
  105d56:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105d5c:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105d5f:	89 86 e4 00 00 00    	mov    %eax,0xe4(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  105d65:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105d6b:	8b 40 0c             	mov    0xc(%eax),%eax
  105d6e:	89 86 e0 00 00 00    	mov    %eax,0xe0(%esi)
  105d74:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105d7a:	8b 40 10             	mov    0x10(%eax),%eax
  105d7d:	89 86 dc 00 00 00    	mov    %eax,0xdc(%esi)
  105d83:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105d89:	8b 40 14             	mov    0x14(%eax),%eax
  105d8c:	89 86 d8 00 00 00    	mov    %eax,0xd8(%esi)
  105d92:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105d98:	8b 40 18             	mov    0x18(%eax),%eax
  105d9b:	89 86 d4 00 00 00    	mov    %eax,0xd4(%esi)
  105da1:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105da7:	8b 40 1c             	mov    0x1c(%eax),%eax
  105daa:	89 86 d0 00 00 00    	mov    %eax,0xd0(%esi)
				args[8], args[9], args[10]);
  105db0:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105db6:	8b 40 20             	mov    0x20(%eax),%eax
  105db9:	89 86 cc 00 00 00    	mov    %eax,0xcc(%esi)
  105dbf:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105dc5:	8b 40 24             	mov    0x24(%eax),%eax
  105dc8:	89 86 c8 00 00 00    	mov    %eax,0xc8(%esi)
  105dce:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105dd4:	8b 40 28             	mov    0x28(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105dd7:	83 ec 34             	sub    $0x34,%esp
  105dda:	89 86 c4 00 00 00    	mov    %eax,0xc4(%esi)
  105de0:	8b 86 e4 00 00 00    	mov    0xe4(%esi),%eax
  105de6:	89 04 24             	mov    %eax,(%esp)
  105de9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105ded:	89 54 24 08          	mov    %edx,0x8(%esp)
  105df1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105df5:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105df9:	8b 86 e0 00 00 00    	mov    0xe0(%esi),%eax
  105dff:	89 44 24 14          	mov    %eax,0x14(%esp)
  105e03:	8b 86 dc 00 00 00    	mov    0xdc(%esi),%eax
  105e09:	89 44 24 18          	mov    %eax,0x18(%esp)
  105e0d:	8b 86 d8 00 00 00    	mov    0xd8(%esi),%eax
  105e13:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105e17:	8b 86 d4 00 00 00    	mov    0xd4(%esi),%eax
  105e1d:	89 44 24 20          	mov    %eax,0x20(%esp)
  105e21:	8b 86 d0 00 00 00    	mov    0xd0(%esi),%eax
  105e27:	89 44 24 24          	mov    %eax,0x24(%esp)
  105e2b:	8b 86 cc 00 00 00    	mov    0xcc(%esi),%eax
  105e31:	89 44 24 28          	mov    %eax,0x28(%esp)
  105e35:	8b 86 c8 00 00 00    	mov    0xc8(%esi),%eax
  105e3b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105e3f:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
  105e45:	89 44 24 30          	mov    %eax,0x30(%esp)
  105e49:	e8 32 07 00 00       	call   106580 <print_formatted>
  105e4e:	83 c4 34             	add    $0x34,%esp
		break;
  105e51:	e9 b9 04 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105e56:	8b 45 0c             	mov    0xc(%ebp),%eax
  105e59:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105e5f:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105e65:	8b 12                	mov    (%edx),%edx
  105e67:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105e6d:	8b 7f 04             	mov    0x4(%edi),%edi
  105e70:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105e76:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105e79:	89 86 c0 00 00 00    	mov    %eax,0xc0(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  105e7f:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105e85:	8b 40 0c             	mov    0xc(%eax),%eax
  105e88:	89 86 bc 00 00 00    	mov    %eax,0xbc(%esi)
  105e8e:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105e94:	8b 40 10             	mov    0x10(%eax),%eax
  105e97:	89 86 b8 00 00 00    	mov    %eax,0xb8(%esi)
  105e9d:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ea3:	8b 40 14             	mov    0x14(%eax),%eax
  105ea6:	89 86 b4 00 00 00    	mov    %eax,0xb4(%esi)
  105eac:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105eb2:	8b 40 18             	mov    0x18(%eax),%eax
  105eb5:	89 86 b0 00 00 00    	mov    %eax,0xb0(%esi)
  105ebb:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ec1:	8b 40 1c             	mov    0x1c(%eax),%eax
  105ec4:	89 86 ac 00 00 00    	mov    %eax,0xac(%esi)
				args[8], args[9], args[10], args[11]);
  105eca:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ed0:	8b 40 20             	mov    0x20(%eax),%eax
  105ed3:	89 86 a8 00 00 00    	mov    %eax,0xa8(%esi)
  105ed9:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105edf:	8b 40 24             	mov    0x24(%eax),%eax
  105ee2:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
  105ee8:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105eee:	8b 40 28             	mov    0x28(%eax),%eax
  105ef1:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
  105ef7:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105efd:	8b 40 2c             	mov    0x2c(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  105f00:	83 ec 38             	sub    $0x38,%esp
  105f03:	89 86 9c 00 00 00    	mov    %eax,0x9c(%esi)
  105f09:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
  105f0f:	89 04 24             	mov    %eax,(%esp)
  105f12:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105f16:	89 54 24 08          	mov    %edx,0x8(%esp)
  105f1a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  105f1e:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  105f22:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
  105f28:	89 44 24 14          	mov    %eax,0x14(%esp)
  105f2c:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
  105f32:	89 44 24 18          	mov    %eax,0x18(%esp)
  105f36:	8b 86 b4 00 00 00    	mov    0xb4(%esi),%eax
  105f3c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  105f40:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
  105f46:	89 44 24 20          	mov    %eax,0x20(%esp)
  105f4a:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
  105f50:	89 44 24 24          	mov    %eax,0x24(%esp)
  105f54:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
  105f5a:	89 44 24 28          	mov    %eax,0x28(%esp)
  105f5e:	8b 86 a4 00 00 00    	mov    0xa4(%esi),%eax
  105f64:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105f68:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
  105f6e:	89 44 24 30          	mov    %eax,0x30(%esp)
  105f72:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
  105f78:	89 44 24 34          	mov    %eax,0x34(%esp)
  105f7c:	e8 ff 05 00 00       	call   106580 <print_formatted>
  105f81:	83 c4 38             	add    $0x38,%esp
		break;
  105f84:	e9 86 03 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  105f89:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f8c:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  105f92:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  105f98:	8b 12                	mov    (%edx),%edx
  105f9a:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  105fa0:	8b 7f 04             	mov    0x4(%edi),%edi
  105fa3:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  105fa9:	8b 5b 08             	mov    0x8(%ebx),%ebx
  105fac:	89 86 98 00 00 00    	mov    %eax,0x98(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  105fb2:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105fb8:	8b 40 0c             	mov    0xc(%eax),%eax
  105fbb:	89 86 94 00 00 00    	mov    %eax,0x94(%esi)
  105fc1:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105fc7:	8b 40 10             	mov    0x10(%eax),%eax
  105fca:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
  105fd0:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105fd6:	8b 40 14             	mov    0x14(%eax),%eax
  105fd9:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
  105fdf:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105fe5:	8b 40 18             	mov    0x18(%eax),%eax
  105fe8:	89 86 88 00 00 00    	mov    %eax,0x88(%esi)
  105fee:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  105ff4:	8b 40 1c             	mov    0x1c(%eax),%eax
  105ff7:	89 86 84 00 00 00    	mov    %eax,0x84(%esi)
				args[8], args[9], args[10], args[11], args[12]);
  105ffd:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106003:	8b 40 20             	mov    0x20(%eax),%eax
  106006:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
  10600c:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106012:	8b 40 24             	mov    0x24(%eax),%eax
  106015:	89 46 7c             	mov    %eax,0x7c(%esi)
  106018:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10601e:	8b 40 28             	mov    0x28(%eax),%eax
  106021:	89 46 78             	mov    %eax,0x78(%esi)
  106024:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10602a:	8b 40 2c             	mov    0x2c(%eax),%eax
  10602d:	89 46 74             	mov    %eax,0x74(%esi)
  106030:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106036:	8b 40 30             	mov    0x30(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  106039:	83 ec 3c             	sub    $0x3c,%esp
  10603c:	89 46 70             	mov    %eax,0x70(%esi)
  10603f:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
  106045:	89 04 24             	mov    %eax,(%esp)
  106048:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10604c:	89 54 24 08          	mov    %edx,0x8(%esp)
  106050:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  106054:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  106058:	8b 86 94 00 00 00    	mov    0x94(%esi),%eax
  10605e:	89 44 24 14          	mov    %eax,0x14(%esp)
  106062:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
  106068:	89 44 24 18          	mov    %eax,0x18(%esp)
  10606c:	8b 86 8c 00 00 00    	mov    0x8c(%esi),%eax
  106072:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  106076:	8b 86 88 00 00 00    	mov    0x88(%esi),%eax
  10607c:	89 44 24 20          	mov    %eax,0x20(%esp)
  106080:	8b 86 84 00 00 00    	mov    0x84(%esi),%eax
  106086:	89 44 24 24          	mov    %eax,0x24(%esp)
  10608a:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
  106090:	89 44 24 28          	mov    %eax,0x28(%esp)
  106094:	8b 46 7c             	mov    0x7c(%esi),%eax
  106097:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10609b:	8b 46 78             	mov    0x78(%esi),%eax
  10609e:	89 44 24 30          	mov    %eax,0x30(%esp)
  1060a2:	8b 46 74             	mov    0x74(%esi),%eax
  1060a5:	89 44 24 34          	mov    %eax,0x34(%esp)
  1060a9:	8b 46 70             	mov    0x70(%esi),%eax
  1060ac:	89 44 24 38          	mov    %eax,0x38(%esp)
  1060b0:	e8 cb 04 00 00       	call   106580 <print_formatted>
  1060b5:	83 c4 3c             	add    $0x3c,%esp
		break;
  1060b8:	e9 52 02 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  1060bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1060c0:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1060c6:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1060cc:	8b 12                	mov    (%edx),%edx
  1060ce:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  1060d4:	8b 7f 04             	mov    0x4(%edi),%edi
  1060d7:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  1060dd:	8b 5b 08             	mov    0x8(%ebx),%ebx
  1060e0:	89 46 6c             	mov    %eax,0x6c(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  1060e3:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  1060e9:	8b 40 0c             	mov    0xc(%eax),%eax
  1060ec:	89 46 68             	mov    %eax,0x68(%esi)
  1060ef:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  1060f5:	8b 40 10             	mov    0x10(%eax),%eax
  1060f8:	89 46 64             	mov    %eax,0x64(%esi)
  1060fb:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106101:	8b 40 14             	mov    0x14(%eax),%eax
  106104:	89 46 60             	mov    %eax,0x60(%esi)
  106107:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10610d:	8b 40 18             	mov    0x18(%eax),%eax
  106110:	89 46 5c             	mov    %eax,0x5c(%esi)
  106113:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106119:	8b 40 1c             	mov    0x1c(%eax),%eax
  10611c:	89 46 58             	mov    %eax,0x58(%esi)
				args[8], args[9], args[10], args[11], args[12],
  10611f:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106125:	8b 40 20             	mov    0x20(%eax),%eax
  106128:	89 46 54             	mov    %eax,0x54(%esi)
  10612b:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106131:	8b 40 24             	mov    0x24(%eax),%eax
  106134:	89 46 50             	mov    %eax,0x50(%esi)
  106137:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10613d:	8b 40 28             	mov    0x28(%eax),%eax
  106140:	89 46 4c             	mov    %eax,0x4c(%esi)
  106143:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106149:	8b 40 2c             	mov    0x2c(%eax),%eax
  10614c:	89 46 48             	mov    %eax,0x48(%esi)
  10614f:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106155:	8b 40 30             	mov    0x30(%eax),%eax
  106158:	89 46 44             	mov    %eax,0x44(%esi)
				args[13]);
  10615b:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106161:	8b 40 34             	mov    0x34(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  106164:	83 ec 40             	sub    $0x40,%esp
  106167:	89 46 40             	mov    %eax,0x40(%esi)
  10616a:	8b 46 6c             	mov    0x6c(%esi),%eax
  10616d:	89 04 24             	mov    %eax,(%esp)
  106170:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106174:	89 54 24 08          	mov    %edx,0x8(%esp)
  106178:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10617c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  106180:	8b 46 68             	mov    0x68(%esi),%eax
  106183:	89 44 24 14          	mov    %eax,0x14(%esp)
  106187:	8b 46 64             	mov    0x64(%esi),%eax
  10618a:	89 44 24 18          	mov    %eax,0x18(%esp)
  10618e:	8b 46 60             	mov    0x60(%esi),%eax
  106191:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  106195:	8b 46 5c             	mov    0x5c(%esi),%eax
  106198:	89 44 24 20          	mov    %eax,0x20(%esp)
  10619c:	8b 46 58             	mov    0x58(%esi),%eax
  10619f:	89 44 24 24          	mov    %eax,0x24(%esp)
  1061a3:	8b 46 54             	mov    0x54(%esi),%eax
  1061a6:	89 44 24 28          	mov    %eax,0x28(%esp)
  1061aa:	8b 46 50             	mov    0x50(%esi),%eax
  1061ad:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  1061b1:	8b 46 4c             	mov    0x4c(%esi),%eax
  1061b4:	89 44 24 30          	mov    %eax,0x30(%esp)
  1061b8:	8b 46 48             	mov    0x48(%esi),%eax
  1061bb:	89 44 24 34          	mov    %eax,0x34(%esp)
  1061bf:	8b 46 44             	mov    0x44(%esi),%eax
  1061c2:	89 44 24 38          	mov    %eax,0x38(%esp)
  1061c6:	8b 46 40             	mov    0x40(%esi),%eax
  1061c9:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1061cd:	e8 ae 03 00 00       	call   106580 <print_formatted>
  1061d2:	83 c4 40             	add    $0x40,%esp
		break;
  1061d5:	e9 35 01 00 00       	jmp    10630f <std_print+0xc8f>
		print_formatted(log_output, str, args[0], args[1], args[2],
  1061da:	8b 45 0c             	mov    0xc(%ebp),%eax
  1061dd:	8b 8e 98 01 00 00    	mov    0x198(%esi),%ecx
  1061e3:	8b 96 90 01 00 00    	mov    0x190(%esi),%edx
  1061e9:	8b 12                	mov    (%edx),%edx
  1061eb:	8b be 90 01 00 00    	mov    0x190(%esi),%edi
  1061f1:	8b 7f 04             	mov    0x4(%edi),%edi
  1061f4:	8b 9e 90 01 00 00    	mov    0x190(%esi),%ebx
  1061fa:	8b 5b 08             	mov    0x8(%ebx),%ebx
  1061fd:	89 46 3c             	mov    %eax,0x3c(%esi)
				args[3], args[4], args[5], args[6],  args[7],
  106200:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106206:	8b 40 0c             	mov    0xc(%eax),%eax
  106209:	89 46 38             	mov    %eax,0x38(%esi)
  10620c:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106212:	8b 40 10             	mov    0x10(%eax),%eax
  106215:	89 46 34             	mov    %eax,0x34(%esi)
  106218:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10621e:	8b 40 14             	mov    0x14(%eax),%eax
  106221:	89 46 30             	mov    %eax,0x30(%esi)
  106224:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10622a:	8b 40 18             	mov    0x18(%eax),%eax
  10622d:	89 46 2c             	mov    %eax,0x2c(%esi)
  106230:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106236:	8b 40 1c             	mov    0x1c(%eax),%eax
  106239:	89 46 28             	mov    %eax,0x28(%esi)
				args[8], args[9], args[10], args[11], args[12],
  10623c:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106242:	8b 40 20             	mov    0x20(%eax),%eax
  106245:	89 46 24             	mov    %eax,0x24(%esi)
  106248:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10624e:	8b 40 24             	mov    0x24(%eax),%eax
  106251:	89 46 20             	mov    %eax,0x20(%esi)
  106254:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10625a:	8b 40 28             	mov    0x28(%eax),%eax
  10625d:	89 46 1c             	mov    %eax,0x1c(%esi)
  106260:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106266:	8b 40 2c             	mov    0x2c(%eax),%eax
  106269:	89 46 18             	mov    %eax,0x18(%esi)
  10626c:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  106272:	8b 40 30             	mov    0x30(%eax),%eax
  106275:	89 46 14             	mov    %eax,0x14(%esi)
				args[13], args[14]);
  106278:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10627e:	8b 40 34             	mov    0x34(%eax),%eax
  106281:	89 46 10             	mov    %eax,0x10(%esi)
  106284:	8b 86 90 01 00 00    	mov    0x190(%esi),%eax
  10628a:	8b 40 38             	mov    0x38(%eax),%eax
		print_formatted(log_output, str, args[0], args[1], args[2],
  10628d:	83 ec 44             	sub    $0x44,%esp
  106290:	89 46 0c             	mov    %eax,0xc(%esi)
  106293:	8b 46 3c             	mov    0x3c(%esi),%eax
  106296:	89 04 24             	mov    %eax,(%esp)
  106299:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10629d:	89 54 24 08          	mov    %edx,0x8(%esp)
  1062a1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1062a5:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1062a9:	8b 46 38             	mov    0x38(%esi),%eax
  1062ac:	89 44 24 14          	mov    %eax,0x14(%esp)
  1062b0:	8b 46 34             	mov    0x34(%esi),%eax
  1062b3:	89 44 24 18          	mov    %eax,0x18(%esp)
  1062b7:	8b 46 30             	mov    0x30(%esi),%eax
  1062ba:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1062be:	8b 46 2c             	mov    0x2c(%esi),%eax
  1062c1:	89 44 24 20          	mov    %eax,0x20(%esp)
  1062c5:	8b 46 28             	mov    0x28(%esi),%eax
  1062c8:	89 44 24 24          	mov    %eax,0x24(%esp)
  1062cc:	8b 46 24             	mov    0x24(%esi),%eax
  1062cf:	89 44 24 28          	mov    %eax,0x28(%esp)
  1062d3:	8b 46 20             	mov    0x20(%esi),%eax
  1062d6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  1062da:	8b 46 1c             	mov    0x1c(%esi),%eax
  1062dd:	89 44 24 30          	mov    %eax,0x30(%esp)
  1062e1:	8b 46 18             	mov    0x18(%esi),%eax
  1062e4:	89 44 24 34          	mov    %eax,0x34(%esp)
  1062e8:	8b 46 14             	mov    0x14(%esi),%eax
  1062eb:	89 44 24 38          	mov    %eax,0x38(%esp)
  1062ef:	8b 46 10             	mov    0x10(%esi),%eax
  1062f2:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1062f6:	8b 46 0c             	mov    0xc(%esi),%eax
  1062f9:	89 44 24 40          	mov    %eax,0x40(%esp)
  1062fd:	e8 7e 02 00 00       	call   106580 <print_formatted>
  106302:	83 c4 44             	add    $0x44,%esp
		break;
  106305:	e9 05 00 00 00       	jmp    10630f <std_print+0xc8f>
		break;
  10630a:	e9 00 00 00 00       	jmp    10630f <std_print+0xc8f>
}
  10630f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106312:	5e                   	pop    %esi
  106313:	5f                   	pop    %edi
  106314:	5b                   	pop    %ebx
  106315:	5d                   	pop    %ebp
  106316:	c3                   	ret    
  106317:	66 90                	xchg   %ax,%ax
  106319:	66 90                	xchg   %ax,%ax
  10631b:	66 90                	xchg   %ax,%ax
  10631d:	66 90                	xchg   %ax,%ax
  10631f:	90                   	nop

00106320 <raw_string_print>:
{
  106320:	55                   	push   %ebp
  106321:	89 e5                	mov    %esp,%ebp
  106323:	83 ec 1c             	sub    $0x1c,%esp
  106326:	8b 45 0c             	mov    0xc(%ebp),%eax
  106329:	8b 4d 08             	mov    0x8(%ebp),%ecx
	size_t offset = 0;
  10632c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	bool eol = false;
  106333:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
		length = log_output->size;
  106337:	8b 45 0c             	mov    0xc(%ebp),%eax
  10633a:	8b 40 0c             	mov    0xc(%eax),%eax
  10633d:	89 45 f8             	mov    %eax,-0x8(%ebp)
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  106340:	8b 45 08             	mov    0x8(%ebp),%eax
  106343:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106346:	8b 49 08             	mov    0x8(%ecx),%ecx
  106349:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10634c:	89 04 24             	mov    %eax,(%esp)
  10634f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106353:	8d 45 f8             	lea    -0x8(%ebp),%eax
  106356:	89 44 24 08          	mov    %eax,0x8(%esp)
  10635a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10635e:	e8 9d ed ff ff       	call   105100 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
  106363:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106366:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106369:	8b 49 04             	mov    0x4(%ecx),%ecx
  10636c:	89 01                	mov    %eax,(%ecx)
		if (length != 0) {
  10636e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  106372:	0f 84 1c 00 00 00    	je     106394 <raw_string_print+0x74>
			eol = (log_output->buf[length - 1] == '\n');
  106378:	8b 45 0c             	mov    0xc(%ebp),%eax
  10637b:	8b 40 08             	mov    0x8(%eax),%eax
  10637e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106381:	83 e9 01             	sub    $0x1,%ecx
  106384:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  106388:	83 f8 0a             	cmp    $0xa,%eax
  10638b:	0f 94 c2             	sete   %dl
  10638e:	80 e2 01             	and    $0x1,%dl
  106391:	88 55 f7             	mov    %dl,-0x9(%ebp)
		log_output_flush(log_output);
  106394:	8b 45 0c             	mov    0xc(%ebp),%eax
  106397:	89 04 24             	mov    %eax,(%esp)
  10639a:	e8 e1 ee ff ff       	call   105280 <log_output_flush>
		offset += length;
  10639f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1063a2:	03 45 fc             	add    -0x4(%ebp),%eax
  1063a5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	} while (length > 0);
  1063a8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1063ac:	0f 87 85 ff ff ff    	ja     106337 <raw_string_print+0x17>
	if (eol) {
  1063b2:	f6 45 f7 01          	testb  $0x1,-0x9(%ebp)
  1063b6:	0f 84 15 00 00 00    	je     1063d1 <raw_string_print+0xb1>
		print_formatted(log_output, "\r");
  1063bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1063bf:	89 04 24             	mov    %eax,(%esp)
  1063c2:	8d 05 53 37 12 00    	lea    0x123753,%eax
  1063c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1063cc:	e8 af 01 00 00       	call   106580 <print_formatted>
}
  1063d1:	83 c4 1c             	add    $0x1c,%esp
  1063d4:	5d                   	pop    %ebp
  1063d5:	c3                   	ret    
  1063d6:	66 90                	xchg   %ax,%ax
  1063d8:	66 90                	xchg   %ax,%ax
  1063da:	66 90                	xchg   %ax,%ax
  1063dc:	66 90                	xchg   %ax,%ax
  1063de:	66 90                	xchg   %ax,%ax

001063e0 <hexdump_print>:
{
  1063e0:	55                   	push   %ebp
  1063e1:	89 e5                	mov    %esp,%ebp
  1063e3:	53                   	push   %ebx
  1063e4:	57                   	push   %edi
  1063e5:	56                   	push   %esi
  1063e6:	83 ec 40             	sub    $0x40,%esp
  1063e9:	8b 45 14             	mov    0x14(%ebp),%eax
  1063ec:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1063ef:	8b 55 0c             	mov    0xc(%ebp),%edx
  1063f2:	8b 75 08             	mov    0x8(%ebp),%esi
	u32_t offset = 0U;
  1063f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	print_formatted(log_output, "%s", log_msg_str_get(msg));
  1063fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1063ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  106402:	89 1c 24             	mov    %ebx,(%esp)
  106405:	89 45 d8             	mov    %eax,-0x28(%ebp)
  106408:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  10640b:	89 55 d0             	mov    %edx,-0x30(%ebp)
  10640e:	89 75 cc             	mov    %esi,-0x34(%ebp)
  106411:	89 7d c8             	mov    %edi,-0x38(%ebp)
  106414:	e8 07 e8 ff ff       	call   104c20 <log_msg_str_get>
  106419:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  10641c:	89 0c 24             	mov    %ecx,(%esp)
  10641f:	8d 0d 91 39 12 00    	lea    0x123991,%ecx
  106425:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106429:	89 44 24 08          	mov    %eax,0x8(%esp)
  10642d:	e8 4e 01 00 00       	call   106580 <print_formatted>
  106432:	8d 45 e0             	lea    -0x20(%ebp),%eax
		length = sizeof(buf);
  106435:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  10643c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10643f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106442:	89 0c 24             	mov    %ecx,(%esp)
  106445:	89 44 24 04          	mov    %eax,0x4(%esp)
  106449:	8d 45 dc             	lea    -0x24(%ebp),%eax
  10644c:	89 44 24 08          	mov    %eax,0x8(%esp)
  106450:	89 54 24 0c          	mov    %edx,0xc(%esp)
  106454:	e8 a7 ec ff ff       	call   105100 <log_msg_hexdump_data_get>
		if (length) {
  106459:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  10645d:	0f 84 35 00 00 00    	je     106498 <hexdump_print+0xb8>
  106463:	8d 45 e0             	lea    -0x20(%ebp),%eax
			hexdump_line_print(log_output, buf, length,
  106466:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106469:	8b 55 dc             	mov    -0x24(%ebp),%edx
					   prefix_offset, flags);
  10646c:	8b 75 10             	mov    0x10(%ebp),%esi
  10646f:	8b 7d 14             	mov    0x14(%ebp),%edi
			hexdump_line_print(log_output, buf, length,
  106472:	89 0c 24             	mov    %ecx,(%esp)
  106475:	89 44 24 04          	mov    %eax,0x4(%esp)
  106479:	89 54 24 08          	mov    %edx,0x8(%esp)
  10647d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  106481:	89 7c 24 10          	mov    %edi,0x10(%esp)
  106485:	e8 46 01 00 00       	call   1065d0 <hexdump_line_print>
			offset += length;
  10648a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10648d:	03 45 f0             	add    -0x10(%ebp),%eax
  106490:	89 45 f0             	mov    %eax,-0x10(%ebp)
		} else {
  106493:	e9 05 00 00 00       	jmp    10649d <hexdump_print+0xbd>
			break;
  106498:	e9 14 00 00 00       	jmp    1064b1 <hexdump_print+0xd1>
	} while (true);
  10649d:	e9 00 00 00 00       	jmp    1064a2 <hexdump_print+0xc2>
  1064a2:	b0 01                	mov    $0x1,%al
  1064a4:	a8 01                	test   $0x1,%al
  1064a6:	0f 85 86 ff ff ff    	jne    106432 <hexdump_print+0x52>
  1064ac:	e9 00 00 00 00       	jmp    1064b1 <hexdump_print+0xd1>
}
  1064b1:	83 c4 40             	add    $0x40,%esp
  1064b4:	5e                   	pop    %esi
  1064b5:	5f                   	pop    %edi
  1064b6:	5b                   	pop    %ebx
  1064b7:	5d                   	pop    %ebp
  1064b8:	c3                   	ret    
  1064b9:	66 90                	xchg   %ax,%ax
  1064bb:	66 90                	xchg   %ax,%ax
  1064bd:	66 90                	xchg   %ax,%ax
  1064bf:	90                   	nop

001064c0 <postfix_print>:
{
  1064c0:	55                   	push   %ebp
  1064c1:	89 e5                	mov    %esp,%ebp
  1064c3:	53                   	push   %ebx
  1064c4:	57                   	push   %edi
  1064c5:	56                   	push   %esi
  1064c6:	83 ec 18             	sub    $0x18,%esp
  1064c9:	8a 45 10             	mov    0x10(%ebp),%al
  1064cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1064cf:	8b 55 08             	mov    0x8(%ebp),%edx
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
  1064d2:	8b 75 08             	mov    0x8(%ebp),%esi
  1064d5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1064d8:	83 e7 01             	and    $0x1,%edi
  1064db:	83 ff 00             	cmp    $0x0,%edi
  1064de:	0f 95 c4             	setne  %ah
			      level);
  1064e1:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
  1064e5:	89 e3                	mov    %esp,%ebx
  1064e7:	89 7b 08             	mov    %edi,0x8(%ebx)
  1064ea:	89 33                	mov    %esi,(%ebx)
  1064ec:	0f b6 f4             	movzbl %ah,%esi
  1064ef:	83 e6 01             	and    $0x1,%esi
  1064f2:	89 73 04             	mov    %esi,0x4(%ebx)
  1064f5:	88 45 f3             	mov    %al,-0xd(%ebp)
  1064f8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1064fb:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1064fe:	e8 6d 07 00 00       	call   106c70 <color_postfix>
	newline_print(log_output, flags);
  106503:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106506:	8b 55 0c             	mov    0xc(%ebp),%edx
  106509:	89 0c 24             	mov    %ecx,(%esp)
  10650c:	89 54 24 04          	mov    %edx,0x4(%esp)
  106510:	e8 bb 07 00 00       	call   106cd0 <newline_print>
}
  106515:	83 c4 18             	add    $0x18,%esp
  106518:	5e                   	pop    %esi
  106519:	5f                   	pop    %edi
  10651a:	5b                   	pop    %ebx
  10651b:	5d                   	pop    %ebp
  10651c:	c3                   	ret    
  10651d:	66 90                	xchg   %ax,%ax
  10651f:	90                   	nop

00106520 <out_func>:
{
  106520:	55                   	push   %ebp
  106521:	89 e5                	mov    %esp,%ebp
  106523:	57                   	push   %edi
  106524:	56                   	push   %esi
  106525:	83 ec 08             	sub    $0x8,%esp
  106528:	8b 45 0c             	mov    0xc(%ebp),%eax
  10652b:	8b 4d 08             	mov    0x8(%ebp),%ecx
					(const struct log_output *)ctx;
  10652e:	8b 55 0c             	mov    0xc(%ebp),%edx
	const struct log_output *out_ctx =
  106531:	89 55 f4             	mov    %edx,-0xc(%ebp)
	out_ctx->buf[out_ctx->control_block->offset] = (u8_t)c;
  106534:	8b 55 08             	mov    0x8(%ebp),%edx
  106537:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10653a:	8b 76 08             	mov    0x8(%esi),%esi
  10653d:	8b 7d f4             	mov    -0xc(%ebp),%edi
  106540:	8b 7f 04             	mov    0x4(%edi),%edi
  106543:	8b 3f                	mov    (%edi),%edi
  106545:	88 14 3e             	mov    %dl,(%esi,%edi,1)
	out_ctx->control_block->offset++;
  106548:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10654b:	8b 76 04             	mov    0x4(%esi),%esi
  10654e:	8b 3e                	mov    (%esi),%edi
  106550:	83 c7 01             	add    $0x1,%edi
  106553:	89 3e                	mov    %edi,(%esi)
	if (out_ctx->control_block->offset == out_ctx->size) {
  106555:	8b 75 f4             	mov    -0xc(%ebp),%esi
  106558:	8b 76 04             	mov    0x4(%esi),%esi
  10655b:	8b 36                	mov    (%esi),%esi
  10655d:	8b 7d f4             	mov    -0xc(%ebp),%edi
  106560:	3b 77 0c             	cmp    0xc(%edi),%esi
  106563:	0f 85 0b 00 00 00    	jne    106574 <out_func+0x54>
		log_output_flush(out_ctx);
  106569:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10656c:	89 04 24             	mov    %eax,(%esp)
  10656f:	e8 0c ed ff ff       	call   105280 <log_output_flush>
  106574:	31 c0                	xor    %eax,%eax
	return 0;
  106576:	83 c4 08             	add    $0x8,%esp
  106579:	5e                   	pop    %esi
  10657a:	5f                   	pop    %edi
  10657b:	5d                   	pop    %ebp
  10657c:	c3                   	ret    
  10657d:	66 90                	xchg   %ax,%ax
  10657f:	90                   	nop

00106580 <print_formatted>:
{
  106580:	55                   	push   %ebp
  106581:	89 e5                	mov    %esp,%ebp
  106583:	53                   	push   %ebx
  106584:	57                   	push   %edi
  106585:	56                   	push   %esi
  106586:	83 ec 20             	sub    $0x20,%esp
  106589:	8b 45 0c             	mov    0xc(%ebp),%eax
  10658c:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int length = 0;
  10658f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106596:	8d 55 10             	lea    0x10(%ebp),%edx
	va_start(args, fmt);
  106599:	89 55 f0             	mov    %edx,-0x10(%ebp)
	z_vprintk(out_func, (void *)log_output, fmt, args);
  10659c:	8b 55 08             	mov    0x8(%ebp),%edx
  10659f:	8b 75 0c             	mov    0xc(%ebp),%esi
  1065a2:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1065a5:	89 e3                	mov    %esp,%ebx
  1065a7:	89 7b 0c             	mov    %edi,0xc(%ebx)
  1065aa:	89 73 08             	mov    %esi,0x8(%ebx)
  1065ad:	89 53 04             	mov    %edx,0x4(%ebx)
  1065b0:	c7 03 20 65 10 00    	movl   $0x106520,(%ebx)
  1065b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1065b9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1065bc:	e8 cf bf ff ff       	call   102590 <z_vprintk>
	return length;
  1065c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1065c4:	83 c4 20             	add    $0x20,%esp
  1065c7:	5e                   	pop    %esi
  1065c8:	5f                   	pop    %edi
  1065c9:	5b                   	pop    %ebx
  1065ca:	5d                   	pop    %ebp
  1065cb:	c3                   	ret    
  1065cc:	66 90                	xchg   %ax,%ax
  1065ce:	66 90                	xchg   %ax,%ax

001065d0 <hexdump_line_print>:
{
  1065d0:	55                   	push   %ebp
  1065d1:	89 e5                	mov    %esp,%ebp
  1065d3:	53                   	push   %ebx
  1065d4:	57                   	push   %edi
  1065d5:	56                   	push   %esi
  1065d6:	83 ec 38             	sub    $0x38,%esp
  1065d9:	8b 45 18             	mov    0x18(%ebp),%eax
  1065dc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1065df:	8b 55 10             	mov    0x10(%ebp),%edx
  1065e2:	8b 75 0c             	mov    0xc(%ebp),%esi
  1065e5:	8b 7d 08             	mov    0x8(%ebp),%edi
	newline_print(log_output, flags);
  1065e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1065eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1065ee:	8b 45 18             	mov    0x18(%ebp),%eax
  1065f1:	89 1c 24             	mov    %ebx,(%esp)
  1065f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1065f8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1065fb:	89 55 d8             	mov    %edx,-0x28(%ebp)
  1065fe:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  106601:	89 7d d0             	mov    %edi,-0x30(%ebp)
  106604:	e8 c7 06 00 00       	call   106cd0 <newline_print>
	for (int i = 0; i < prefix_offset; i++) {
  106609:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  106610:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106613:	3b 45 14             	cmp    0x14(%ebp),%eax
  106616:	0f 8d 23 00 00 00    	jge    10663f <hexdump_line_print+0x6f>
		print_formatted(log_output, " ");
  10661c:	8b 45 08             	mov    0x8(%ebp),%eax
  10661f:	89 04 24             	mov    %eax,(%esp)
  106622:	8d 05 b9 37 12 00    	lea    0x1237b9,%eax
  106628:	89 44 24 04          	mov    %eax,0x4(%esp)
  10662c:	e8 4f ff ff ff       	call   106580 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  106631:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106634:	83 c0 01             	add    $0x1,%eax
  106637:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10663a:	e9 d1 ff ff ff       	jmp    106610 <hexdump_line_print+0x40>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  10663f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106646:	83 7d ec 10          	cmpl   $0x10,-0x14(%ebp)
  10664a:	0f 8d 8f 00 00 00    	jge    1066df <hexdump_line_print+0x10f>
		if (i > 0 && !(i % 8)) {
  106650:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  106654:	0f 8e 29 00 00 00    	jle    106683 <hexdump_line_print+0xb3>
  10665a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10665d:	99                   	cltd   
  10665e:	b9 08 00 00 00       	mov    $0x8,%ecx
  106663:	f7 f9                	idiv   %ecx
  106665:	83 fa 00             	cmp    $0x0,%edx
  106668:	0f 85 15 00 00 00    	jne    106683 <hexdump_line_print+0xb3>
			print_formatted(log_output, " ");
  10666e:	8b 45 08             	mov    0x8(%ebp),%eax
  106671:	89 04 24             	mov    %eax,(%esp)
  106674:	8d 05 b9 37 12 00    	lea    0x1237b9,%eax
  10667a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10667e:	e8 fd fe ff ff       	call   106580 <print_formatted>
		if (i < length) {
  106683:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106686:	3b 45 10             	cmp    0x10(%ebp),%eax
  106689:	0f 83 28 00 00 00    	jae    1066b7 <hexdump_line_print+0xe7>
			print_formatted(log_output, "%02x ", data[i]);
  10668f:	8b 45 08             	mov    0x8(%ebp),%eax
  106692:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106695:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106698:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  10669c:	89 04 24             	mov    %eax,(%esp)
  10669f:	8d 05 b1 37 12 00    	lea    0x1237b1,%eax
  1066a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066a9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1066ad:	e8 ce fe ff ff       	call   106580 <print_formatted>
		} else {
  1066b2:	e9 15 00 00 00       	jmp    1066cc <hexdump_line_print+0xfc>
			print_formatted(log_output, "   ");
  1066b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1066ba:	89 04 24             	mov    %eax,(%esp)
  1066bd:	8d 05 b7 37 12 00    	lea    0x1237b7,%eax
  1066c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066c7:	e8 b4 fe ff ff       	call   106580 <print_formatted>
	}
  1066cc:	e9 00 00 00 00       	jmp    1066d1 <hexdump_line_print+0x101>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  1066d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1066d4:	83 c0 01             	add    $0x1,%eax
  1066d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1066da:	e9 67 ff ff ff       	jmp    106646 <hexdump_line_print+0x76>
	print_formatted(log_output, "|");
  1066df:	8b 45 08             	mov    0x8(%ebp),%eax
  1066e2:	89 04 24             	mov    %eax,(%esp)
  1066e5:	8d 05 bb 37 12 00    	lea    0x1237bb,%eax
  1066eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066ef:	e8 8c fe ff ff       	call   106580 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  1066f4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1066fb:	83 7d e8 10          	cmpl   $0x10,-0x18(%ebp)
  1066ff:	0f 8d c8 00 00 00    	jge    1067cd <hexdump_line_print+0x1fd>
		if (i > 0 && !(i % 8)) {
  106705:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  106709:	0f 8e 29 00 00 00    	jle    106738 <hexdump_line_print+0x168>
  10670f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106712:	99                   	cltd   
  106713:	b9 08 00 00 00       	mov    $0x8,%ecx
  106718:	f7 f9                	idiv   %ecx
  10671a:	83 fa 00             	cmp    $0x0,%edx
  10671d:	0f 85 15 00 00 00    	jne    106738 <hexdump_line_print+0x168>
			print_formatted(log_output, " ");
  106723:	8b 45 08             	mov    0x8(%ebp),%eax
  106726:	89 04 24             	mov    %eax,(%esp)
  106729:	8d 05 b9 37 12 00    	lea    0x1237b9,%eax
  10672f:	89 44 24 04          	mov    %eax,0x4(%esp)
  106733:	e8 48 fe ff ff       	call   106580 <print_formatted>
		if (i < length) {
  106738:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10673b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10673e:	0f 83 61 00 00 00    	jae    1067a5 <hexdump_line_print+0x1d5>
			char c = (char)data[i];
  106744:	8b 45 0c             	mov    0xc(%ebp),%eax
  106747:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10674a:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  10674d:	88 55 e7             	mov    %dl,-0x19(%ebp)
			print_formatted(log_output, "%c",
  106750:	8b 45 08             	mov    0x8(%ebp),%eax
			      isprint((int)c) ? c : '.');
  106753:	0f be 4d e7          	movsbl -0x19(%ebp),%ecx
  106757:	89 0c 24             	mov    %ecx,(%esp)
  10675a:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10675d:	e8 de 05 00 00       	call   106d40 <isprint>
  106762:	83 f8 00             	cmp    $0x0,%eax
  106765:	0f 84 0c 00 00 00    	je     106777 <hexdump_line_print+0x1a7>
  10676b:	0f be 45 e7          	movsbl -0x19(%ebp),%eax
  10676f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  106772:	e9 0d 00 00 00       	jmp    106784 <hexdump_line_print+0x1b4>
  106777:	b8 2e 00 00 00       	mov    $0x2e,%eax
  10677c:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10677f:	e9 00 00 00 00       	jmp    106784 <hexdump_line_print+0x1b4>
  106784:	8b 45 c8             	mov    -0x38(%ebp),%eax
  106787:	8b 4d cc             	mov    -0x34(%ebp),%ecx
			print_formatted(log_output, "%c",
  10678a:	89 0c 24             	mov    %ecx,(%esp)
  10678d:	8d 15 bd 37 12 00    	lea    0x1237bd,%edx
  106793:	89 54 24 04          	mov    %edx,0x4(%esp)
  106797:	89 44 24 08          	mov    %eax,0x8(%esp)
  10679b:	e8 e0 fd ff ff       	call   106580 <print_formatted>
		} else {
  1067a0:	e9 15 00 00 00       	jmp    1067ba <hexdump_line_print+0x1ea>
			print_formatted(log_output, " ");
  1067a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1067a8:	89 04 24             	mov    %eax,(%esp)
  1067ab:	8d 05 b9 37 12 00    	lea    0x1237b9,%eax
  1067b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1067b5:	e8 c6 fd ff ff       	call   106580 <print_formatted>
	}
  1067ba:	e9 00 00 00 00       	jmp    1067bf <hexdump_line_print+0x1ef>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  1067bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1067c2:	83 c0 01             	add    $0x1,%eax
  1067c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1067c8:	e9 2e ff ff ff       	jmp    1066fb <hexdump_line_print+0x12b>
}
  1067cd:	83 c4 38             	add    $0x38,%esp
  1067d0:	5e                   	pop    %esi
  1067d1:	5f                   	pop    %edi
  1067d2:	5b                   	pop    %ebx
  1067d3:	5d                   	pop    %ebp
  1067d4:	c3                   	ret    
  1067d5:	66 90                	xchg   %ax,%ax
  1067d7:	66 90                	xchg   %ax,%ax
  1067d9:	66 90                	xchg   %ax,%ax
  1067db:	66 90                	xchg   %ax,%ax
  1067dd:	66 90                	xchg   %ax,%ax
  1067df:	90                   	nop

001067e0 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
  1067e0:	55                   	push   %ebp
  1067e1:	89 e5                	mov    %esp,%ebp
  1067e3:	56                   	push   %esi
  1067e4:	83 ec 28             	sub    $0x28,%esp
  1067e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1067ea:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
  1067ed:	8b 55 08             	mov    0x8(%ebp),%edx
  1067f0:	8b 12                	mov    (%edx),%edx
  1067f2:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct device *dev = (struct device *)log_output->control_block->ctx;
  1067f5:	8b 55 08             	mov    0x8(%ebp),%edx
  1067f8:	8b 52 04             	mov    0x4(%edx),%edx
  1067fb:	8b 52 04             	mov    0x4(%edx),%edx
  1067fe:	89 55 e8             	mov    %edx,-0x18(%ebp)

	cnt = MIN(cnt, 9999);
  106801:	81 7d 0c 0f 27 00 00 	cmpl   $0x270f,0xc(%ebp)
  106808:	0f 83 0b 00 00 00    	jae    106819 <log_output_dropped_process+0x39>
  10680e:	8b 45 0c             	mov    0xc(%ebp),%eax
  106811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106814:	e9 0d 00 00 00       	jmp    106826 <log_output_dropped_process+0x46>
  106819:	b8 0f 27 00 00       	mov    $0x270f,%eax
  10681e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106821:	e9 00 00 00 00       	jmp    106826 <log_output_dropped_process+0x46>
  106826:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106829:	8d 4d f7             	lea    -0x9(%ebp),%ecx
  10682c:	89 45 0c             	mov    %eax,0xc(%ebp)
	len = snprintf(buf, sizeof(buf), "%d", cnt);
  10682f:	8b 45 0c             	mov    0xc(%ebp),%eax
  106832:	89 0c 24             	mov    %ecx,(%esp)
  106835:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  10683c:	00 
  10683d:	8d 0d 9d 3a 12 00    	lea    0x123a9d,%ecx
  106843:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  106847:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10684b:	e8 70 5c 00 00       	call   10c4c0 <snprintf>
  106850:	89 45 f0             	mov    %eax,-0x10(%ebp)

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
  106853:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106856:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  106859:	89 04 24             	mov    %eax,(%esp)
  10685c:	8d 05 c0 37 12 00    	lea    0x1237c0,%eax
  106862:	89 44 24 04          	mov    %eax,0x4(%esp)
  106866:	c7 44 24 08 0b 00 00 	movl   $0xb,0x8(%esp)
  10686d:	00 
  10686e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  106872:	e8 69 ea ff ff       	call   1052e0 <buffer_write>
  106877:	8d 45 f7             	lea    -0x9(%ebp),%eax
	buffer_write(outf, buf, len, dev);
  10687a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10687d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106880:	8b 75 e8             	mov    -0x18(%ebp),%esi
  106883:	89 0c 24             	mov    %ecx,(%esp)
  106886:	89 44 24 04          	mov    %eax,0x4(%esp)
  10688a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10688e:	89 74 24 0c          	mov    %esi,0xc(%esp)
  106892:	e8 49 ea ff ff       	call   1052e0 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
  106897:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10689a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10689d:	89 04 24             	mov    %eax,(%esp)
  1068a0:	8d 05 cc 37 12 00    	lea    0x1237cc,%eax
  1068a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1068aa:	c7 44 24 08 1b 00 00 	movl   $0x1b,0x8(%esp)
  1068b1:	00 
  1068b2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1068b6:	e8 25 ea ff ff       	call   1052e0 <buffer_write>
}
  1068bb:	83 c4 28             	add    $0x28,%esp
  1068be:	5e                   	pop    %esi
  1068bf:	5d                   	pop    %ebp
  1068c0:	c3                   	ret    
  1068c1:	66 90                	xchg   %ax,%ax
  1068c3:	66 90                	xchg   %ax,%ax
  1068c5:	66 90                	xchg   %ax,%ax
  1068c7:	66 90                	xchg   %ax,%ax
  1068c9:	66 90                	xchg   %ax,%ax
  1068cb:	66 90                	xchg   %ax,%ax
  1068cd:	66 90                	xchg   %ax,%ax
  1068cf:	90                   	nop

001068d0 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
  1068d0:	55                   	push   %ebp
  1068d1:	89 e5                	mov    %esp,%ebp
  1068d3:	8b 45 08             	mov    0x8(%ebp),%eax
	timestamp_div = 1U;
  1068d6:	c7 05 fc 50 13 00 01 	movl   $0x1,0x1350fc
  1068dd:	00 00 00 
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  1068e0:	81 7d 08 40 42 0f 00 	cmpl   $0xf4240,0x8(%ebp)
  1068e7:	0f 86 1b 00 00 00    	jbe    106908 <log_output_timestamp_freq_set+0x38>
		frequency /= 2U;
  1068ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1068f0:	c1 e8 01             	shr    $0x1,%eax
  1068f3:	89 45 08             	mov    %eax,0x8(%ebp)
		timestamp_div *= 2U;
  1068f6:	a1 fc 50 13 00       	mov    0x1350fc,%eax
  1068fb:	c1 e0 01             	shl    $0x1,%eax
  1068fe:	a3 fc 50 13 00       	mov    %eax,0x1350fc
	while (frequency > 1000000) {
  106903:	e9 d8 ff ff ff       	jmp    1068e0 <log_output_timestamp_freq_set+0x10>
	}

	freq = frequency;
  106908:	8b 45 08             	mov    0x8(%ebp),%eax
  10690b:	a3 00 51 13 00       	mov    %eax,0x135100
}
  106910:	5d                   	pop    %ebp
  106911:	c3                   	ret    
  106912:	66 90                	xchg   %ax,%ax
  106914:	66 90                	xchg   %ax,%ax
  106916:	66 90                	xchg   %ax,%ax
  106918:	66 90                	xchg   %ax,%ax
  10691a:	66 90                	xchg   %ax,%ax
  10691c:	66 90                	xchg   %ax,%ax
  10691e:	66 90                	xchg   %ax,%ax

00106920 <timestamp_print>:
{
  106920:	55                   	push   %ebp
  106921:	89 e5                	mov    %esp,%ebp
  106923:	53                   	push   %ebx
  106924:	57                   	push   %edi
  106925:	56                   	push   %esi
  106926:	83 ec 48             	sub    $0x48,%esp
  106929:	8b 45 10             	mov    0x10(%ebp),%eax
  10692c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10692f:	8b 55 08             	mov    0x8(%ebp),%edx
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
  106932:	8b 75 0c             	mov    0xc(%ebp),%esi
  106935:	83 e6 04             	and    $0x4,%esi
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG);
  106938:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10693b:	83 e7 40             	and    $0x40,%edi
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
  10693e:	09 fe                	or     %edi,%esi
  106940:	83 fe 00             	cmp    $0x0,%esi
  106943:	0f 95 c3             	setne  %bl
	bool format =
  106946:	80 e3 01             	and    $0x1,%bl
  106949:	88 5d ef             	mov    %bl,-0x11(%ebp)
	if (!format) {
  10694c:	f6 45 ef 01          	testb  $0x1,-0x11(%ebp)
  106950:	0f 85 24 00 00 00    	jne    10697a <timestamp_print+0x5a>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
  106956:	8b 45 08             	mov    0x8(%ebp),%eax
  106959:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10695c:	89 04 24             	mov    %eax,(%esp)
  10695f:	8d 05 55 37 12 00    	lea    0x123755,%eax
  106965:	89 44 24 04          	mov    %eax,0x4(%esp)
  106969:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10696d:	e8 0e fc ff ff       	call   106580 <print_formatted>
  106972:	89 45 f0             	mov    %eax,-0x10(%ebp)
	} else if (freq != 0U) {
  106975:	e9 13 01 00 00       	jmp    106a8d <timestamp_print+0x16d>
  10697a:	83 3d 00 51 13 00 00 	cmpl   $0x0,0x135100
  106981:	0f 84 fa 00 00 00    	je     106a81 <timestamp_print+0x161>
		timestamp /= timestamp_div;
  106987:	a1 fc 50 13 00       	mov    0x1350fc,%eax
  10698c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10698f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  106992:	89 c8                	mov    %ecx,%eax
  106994:	31 d2                	xor    %edx,%edx
  106996:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  106999:	f7 f1                	div    %ecx
  10699b:	89 45 10             	mov    %eax,0x10(%ebp)
		seconds = timestamp / freq;
  10699e:	8b 45 10             	mov    0x10(%ebp),%eax
  1069a1:	31 f6                	xor    %esi,%esi
  1069a3:	89 f2                	mov    %esi,%edx
  1069a5:	f7 35 00 51 13 00    	divl   0x135100
  1069ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		hours = seconds / 3600U;
  1069ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1069b1:	31 f6                	xor    %esi,%esi
  1069b3:	89 f2                	mov    %esi,%edx
  1069b5:	be 10 0e 00 00       	mov    $0xe10,%esi
  1069ba:	f7 f6                	div    %esi
  1069bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
		seconds -= hours * 3600U;
  1069bf:	69 45 e0 10 0e 00 00 	imul   $0xe10,-0x20(%ebp),%eax
  1069c6:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  1069c9:	29 c6                	sub    %eax,%esi
  1069cb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
		mins = seconds / 60U;
  1069ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1069d1:	31 f6                	xor    %esi,%esi
  1069d3:	89 f2                	mov    %esi,%edx
  1069d5:	be 3c 00 00 00       	mov    $0x3c,%esi
  1069da:	f7 f6                	div    %esi
  1069dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
		seconds -= mins * 60U;
  1069df:	6b 45 dc 3c          	imul   $0x3c,-0x24(%ebp),%eax
  1069e3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  1069e6:	29 c6                	sub    %eax,%esi
  1069e8:	89 75 e4             	mov    %esi,-0x1c(%ebp)
		remainder = timestamp % freq;
  1069eb:	8b 45 10             	mov    0x10(%ebp),%eax
  1069ee:	31 f6                	xor    %esi,%esi
  1069f0:	89 f2                	mov    %esi,%edx
  1069f2:	f7 35 00 51 13 00    	divl   0x135100
  1069f8:	89 55 e8             	mov    %edx,-0x18(%ebp)
		ms = (remainder * 1000U) / freq;
  1069fb:	69 55 e8 e8 03 00 00 	imul   $0x3e8,-0x18(%ebp),%edx
  106a02:	89 d0                	mov    %edx,%eax
  106a04:	31 d2                	xor    %edx,%edx
  106a06:	f7 35 00 51 13 00    	divl   0x135100
  106a0c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  106a0f:	69 45 e8 e8 03 00 00 	imul   $0x3e8,-0x18(%ebp),%eax
  106a16:	8b 75 d8             	mov    -0x28(%ebp),%esi
  106a19:	0f af 35 00 51 13 00 	imul   0x135100,%esi
  106a20:	29 f0                	sub    %esi,%eax
  106a22:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
  106a28:	31 f6                	xor    %esi,%esi
  106a2a:	89 f2                	mov    %esi,%edx
  106a2c:	f7 35 00 51 13 00    	divl   0x135100
  106a32:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			length = print_formatted(log_output,
  106a35:	8b 45 08             	mov    0x8(%ebp),%eax
						 hours, mins, seconds, ms, us);
  106a38:	8b 75 e0             	mov    -0x20(%ebp),%esi
  106a3b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  106a3e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  106a41:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106a44:	89 45 cc             	mov    %eax,-0x34(%ebp)
  106a47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106a4a:	89 45 c8             	mov    %eax,-0x38(%ebp)
  106a4d:	8b 45 cc             	mov    -0x34(%ebp),%eax
			length = print_formatted(log_output,
  106a50:	89 04 24             	mov    %eax,(%esp)
  106a53:	8d 05 5e 37 12 00    	lea    0x12375e,%eax
  106a59:	89 44 24 04          	mov    %eax,0x4(%esp)
  106a5d:	89 74 24 08          	mov    %esi,0x8(%esp)
  106a61:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  106a65:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  106a69:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  106a6d:	8b 45 c8             	mov    -0x38(%ebp),%eax
  106a70:	89 44 24 18          	mov    %eax,0x18(%esp)
  106a74:	e8 07 fb ff ff       	call   106580 <print_formatted>
  106a79:	89 45 f0             	mov    %eax,-0x10(%ebp)
	} else {
  106a7c:	e9 07 00 00 00       	jmp    106a88 <timestamp_print+0x168>
		length = 0;
  106a81:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  106a88:	e9 00 00 00 00       	jmp    106a8d <timestamp_print+0x16d>
	return length;
  106a8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106a90:	83 c4 48             	add    $0x48,%esp
  106a93:	5e                   	pop    %esi
  106a94:	5f                   	pop    %edi
  106a95:	5b                   	pop    %ebx
  106a96:	5d                   	pop    %ebp
  106a97:	c3                   	ret    
  106a98:	66 90                	xchg   %ax,%ax
  106a9a:	66 90                	xchg   %ax,%ax
  106a9c:	66 90                	xchg   %ax,%ax
  106a9e:	66 90                	xchg   %ax,%ax

00106aa0 <color_prefix>:
{
  106aa0:	55                   	push   %ebp
  106aa1:	89 e5                	mov    %esp,%ebp
  106aa3:	57                   	push   %edi
  106aa4:	56                   	push   %esi
  106aa5:	83 ec 1c             	sub    $0x1c,%esp
  106aa8:	8b 45 10             	mov    0x10(%ebp),%eax
  106aab:	8a 4d 0c             	mov    0xc(%ebp),%cl
  106aae:	8b 55 08             	mov    0x8(%ebp),%edx
  106ab1:	80 e1 01             	and    $0x1,%cl
  106ab4:	88 4d f7             	mov    %cl,-0x9(%ebp)
	color_print(log_output, color, true, level);
  106ab7:	8b 75 08             	mov    0x8(%ebp),%esi
  106aba:	8a 4d f7             	mov    -0x9(%ebp),%cl
  106abd:	8b 7d 10             	mov    0x10(%ebp),%edi
  106ac0:	80 e1 01             	and    $0x1,%cl
  106ac3:	89 34 24             	mov    %esi,(%esp)
  106ac6:	0f b6 f1             	movzbl %cl,%esi
  106ac9:	89 74 24 04          	mov    %esi,0x4(%esp)
  106acd:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  106ad4:	00 
  106ad5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  106ad9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106adc:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106adf:	e8 fc 00 00 00       	call   106be0 <color_print>
}
  106ae4:	83 c4 1c             	add    $0x1c,%esp
  106ae7:	5e                   	pop    %esi
  106ae8:	5f                   	pop    %edi
  106ae9:	5d                   	pop    %ebp
  106aea:	c3                   	ret    
  106aeb:	66 90                	xchg   %ax,%ax
  106aed:	66 90                	xchg   %ax,%ax
  106aef:	90                   	nop

00106af0 <ids_print>:
{
  106af0:	55                   	push   %ebp
  106af1:	89 e5                	mov    %esp,%ebp
  106af3:	53                   	push   %ebx
  106af4:	56                   	push   %esi
  106af5:	83 ec 28             	sub    $0x28,%esp
  106af8:	8b 45 1c             	mov    0x1c(%ebp),%eax
  106afb:	8b 4d 18             	mov    0x18(%ebp),%ecx
  106afe:	8b 55 14             	mov    0x14(%ebp),%edx
  106b01:	8a 5d 10             	mov    0x10(%ebp),%bl
  106b04:	8a 7d 0c             	mov    0xc(%ebp),%bh
  106b07:	8b 75 08             	mov    0x8(%ebp),%esi
  106b0a:	80 e7 01             	and    $0x1,%bh
  106b0d:	88 7d f7             	mov    %bh,-0x9(%ebp)
  106b10:	80 e3 01             	and    $0x1,%bl
  106b13:	88 5d f6             	mov    %bl,-0xa(%ebp)
	int total = 0;
  106b16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (level_on) {
  106b1d:	f6 45 f7 01          	testb  $0x1,-0x9(%ebp)
  106b21:	0f 84 29 00 00 00    	je     106b50 <ids_print+0x60>
		total += print_formatted(log_output, "<%s> ", severity[level]);
  106b27:	8b 45 08             	mov    0x8(%ebp),%eax
  106b2a:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  106b2d:	8b 0c 8d 60 32 12 00 	mov    0x123260(,%ecx,4),%ecx
  106b34:	89 04 24             	mov    %eax,(%esp)
  106b37:	8d 05 8f 37 12 00    	lea    0x12378f,%eax
  106b3d:	89 44 24 04          	mov    %eax,0x4(%esp)
  106b41:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  106b45:	e8 36 fa ff ff       	call   106580 <print_formatted>
  106b4a:	03 45 f0             	add    -0x10(%ebp),%eax
  106b4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106b50:	31 c0                	xor    %eax,%eax
	total += print_formatted(log_output,
  106b52:	8b 4d 08             	mov    0x8(%ebp),%ecx
				(func_on &&
  106b55:	f6 45 f6 01          	testb  $0x1,-0xa(%ebp)
  106b59:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  106b5c:	88 45 eb             	mov    %al,-0x15(%ebp)
  106b5f:	0f 84 16 00 00 00    	je     106b7b <ids_print+0x8b>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
  106b65:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  106b68:	b8 01 00 00 00       	mov    $0x1,%eax
  106b6d:	d3 e0                	shl    %cl,%eax
  106b6f:	83 e0 10             	and    $0x10,%eax
				(func_on &&
  106b72:	83 f8 00             	cmp    $0x0,%eax
  106b75:	0f 95 c1             	setne  %cl
  106b78:	88 4d eb             	mov    %cl,-0x15(%ebp)
  106b7b:	8a 45 eb             	mov    -0x15(%ebp),%al
  106b7e:	a8 01                	test   $0x1,%al
  106b80:	8d 0d 99 37 12 00    	lea    0x123799,%ecx
  106b86:	8d 15 95 37 12 00    	lea    0x123795,%edx
  106b8c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  106b8f:	89 55 e0             	mov    %edx,-0x20(%ebp)
  106b92:	0f 85 06 00 00 00    	jne    106b9e <ids_print+0xae>
  106b98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106b9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106b9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
				log_source_name_get(domain_id, source_id));
  106ba1:	8b 4d 14             	mov    0x14(%ebp),%ecx
  106ba4:	8b 55 18             	mov    0x18(%ebp),%edx
  106ba7:	89 0c 24             	mov    %ecx,(%esp)
  106baa:	89 54 24 04          	mov    %edx,0x4(%esp)
  106bae:	89 45 dc             	mov    %eax,-0x24(%ebp)
  106bb1:	e8 da d1 ff ff       	call   103d90 <log_source_name_get>
  106bb6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	total += print_formatted(log_output,
  106bb9:	89 0c 24             	mov    %ecx,(%esp)
  106bbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
  106bbf:	89 54 24 04          	mov    %edx,0x4(%esp)
  106bc3:	89 44 24 08          	mov    %eax,0x8(%esp)
  106bc7:	e8 b4 f9 ff ff       	call   106580 <print_formatted>
  106bcc:	03 45 f0             	add    -0x10(%ebp),%eax
  106bcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return total;
  106bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106bd5:	83 c4 28             	add    $0x28,%esp
  106bd8:	5e                   	pop    %esi
  106bd9:	5b                   	pop    %ebx
  106bda:	5d                   	pop    %ebp
  106bdb:	c3                   	ret    
  106bdc:	66 90                	xchg   %ax,%ax
  106bde:	66 90                	xchg   %ax,%ax

00106be0 <color_print>:
{
  106be0:	55                   	push   %ebp
  106be1:	89 e5                	mov    %esp,%ebp
  106be3:	56                   	push   %esi
  106be4:	83 ec 18             	sub    $0x18,%esp
  106be7:	8b 45 14             	mov    0x14(%ebp),%eax
  106bea:	8a 4d 10             	mov    0x10(%ebp),%cl
  106bed:	8a 55 0c             	mov    0xc(%ebp),%dl
  106bf0:	8b 75 08             	mov    0x8(%ebp),%esi
  106bf3:	80 e2 01             	and    $0x1,%dl
  106bf6:	88 55 fb             	mov    %dl,-0x5(%ebp)
  106bf9:	80 e1 01             	and    $0x1,%cl
  106bfc:	88 4d fa             	mov    %cl,-0x6(%ebp)
	if (color) {
  106bff:	f6 45 fb 01          	testb  $0x1,-0x5(%ebp)
  106c03:	0f 84 5d 00 00 00    	je     106c66 <color_print+0x86>
		const char *color = start && (colors[level] != NULL) ?
  106c09:	f6 45 fa 01          	testb  $0x1,-0x6(%ebp)
  106c0d:	0f 84 23 00 00 00    	je     106c36 <color_print+0x56>
  106c13:	8b 45 14             	mov    0x14(%ebp),%eax
  106c16:	83 3c 85 4c 32 12 00 	cmpl   $0x0,0x12324c(,%eax,4)
  106c1d:	00 
  106c1e:	0f 84 12 00 00 00    	je     106c36 <color_print+0x56>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  106c24:	8b 45 14             	mov    0x14(%ebp),%eax
  106c27:	8b 04 85 4c 32 12 00 	mov    0x12324c(,%eax,4),%eax
  106c2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		const char *color = start && (colors[level] != NULL) ?
  106c31:	e9 0e 00 00 00       	jmp    106c44 <color_print+0x64>
  106c36:	8d 05 7a 37 12 00    	lea    0x12377a,%eax
  106c3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106c3f:	e9 00 00 00 00       	jmp    106c44 <color_print+0x64>
  106c44:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106c47:	89 45 f4             	mov    %eax,-0xc(%ebp)
		print_formatted(log_output, "%s", color);
  106c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  106c4d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106c50:	89 04 24             	mov    %eax,(%esp)
  106c53:	8d 05 91 39 12 00    	lea    0x123991,%eax
  106c59:	89 44 24 04          	mov    %eax,0x4(%esp)
  106c5d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  106c61:	e8 1a f9 ff ff       	call   106580 <print_formatted>
}
  106c66:	83 c4 18             	add    $0x18,%esp
  106c69:	5e                   	pop    %esi
  106c6a:	5d                   	pop    %ebp
  106c6b:	c3                   	ret    
  106c6c:	66 90                	xchg   %ax,%ax
  106c6e:	66 90                	xchg   %ax,%ax

00106c70 <color_postfix>:
{
  106c70:	55                   	push   %ebp
  106c71:	89 e5                	mov    %esp,%ebp
  106c73:	53                   	push   %ebx
  106c74:	57                   	push   %edi
  106c75:	56                   	push   %esi
  106c76:	83 ec 20             	sub    $0x20,%esp
  106c79:	8b 45 10             	mov    0x10(%ebp),%eax
  106c7c:	8a 4d 0c             	mov    0xc(%ebp),%cl
  106c7f:	8b 55 08             	mov    0x8(%ebp),%edx
  106c82:	31 f6                	xor    %esi,%esi
  106c84:	80 e1 01             	and    $0x1,%cl
  106c87:	88 4d f3             	mov    %cl,-0xd(%ebp)
	color_print(log_output, color, false, level);
  106c8a:	8b 7d 08             	mov    0x8(%ebp),%edi
  106c8d:	8a 4d f3             	mov    -0xd(%ebp),%cl
  106c90:	8b 5d 10             	mov    0x10(%ebp),%ebx
  106c93:	80 e1 01             	and    $0x1,%cl
  106c96:	89 3c 24             	mov    %edi,(%esp)
  106c99:	0f b6 f9             	movzbl %cl,%edi
  106c9c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  106ca0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106ca7:	00 
  106ca8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  106cac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106caf:	89 55 e8             	mov    %edx,-0x18(%ebp)
  106cb2:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  106cb5:	e8 26 ff ff ff       	call   106be0 <color_print>
}
  106cba:	83 c4 20             	add    $0x20,%esp
  106cbd:	5e                   	pop    %esi
  106cbe:	5f                   	pop    %edi
  106cbf:	5b                   	pop    %ebx
  106cc0:	5d                   	pop    %ebp
  106cc1:	c3                   	ret    
  106cc2:	66 90                	xchg   %ax,%ax
  106cc4:	66 90                	xchg   %ax,%ax
  106cc6:	66 90                	xchg   %ax,%ax
  106cc8:	66 90                	xchg   %ax,%ax
  106cca:	66 90                	xchg   %ax,%ax
  106ccc:	66 90                	xchg   %ax,%ax
  106cce:	66 90                	xchg   %ax,%ax

00106cd0 <newline_print>:
{
  106cd0:	55                   	push   %ebp
  106cd1:	89 e5                	mov    %esp,%ebp
  106cd3:	83 ec 08             	sub    $0x8,%esp
  106cd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  106cd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  106cdc:	8b 55 0c             	mov    0xc(%ebp),%edx
  106cdf:	83 e2 10             	and    $0x10,%edx
  106ce2:	83 fa 00             	cmp    $0x0,%edx
  106ce5:	0f 84 05 00 00 00    	je     106cf0 <newline_print+0x20>
		return;
  106ceb:	e9 3e 00 00 00       	jmp    106d2e <newline_print+0x5e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  106cf0:	8b 45 0c             	mov    0xc(%ebp),%eax
  106cf3:	83 e0 20             	and    $0x20,%eax
  106cf6:	83 f8 00             	cmp    $0x0,%eax
  106cf9:	0f 84 1a 00 00 00    	je     106d19 <newline_print+0x49>
		print_formatted(ctx, "\n");
  106cff:	8b 45 08             	mov    0x8(%ebp),%eax
  106d02:	89 04 24             	mov    %eax,(%esp)
  106d05:	8d 05 af 37 12 00    	lea    0x1237af,%eax
  106d0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  106d0f:	e8 6c f8 ff ff       	call   106580 <print_formatted>
	} else {
  106d14:	e9 15 00 00 00       	jmp    106d2e <newline_print+0x5e>
		print_formatted(ctx, "\r\n");
  106d19:	8b 45 08             	mov    0x8(%ebp),%eax
  106d1c:	89 04 24             	mov    %eax,(%esp)
  106d1f:	8d 05 ae 37 12 00    	lea    0x1237ae,%eax
  106d25:	89 44 24 04          	mov    %eax,0x4(%esp)
  106d29:	e8 52 f8 ff ff       	call   106580 <print_formatted>
}
  106d2e:	83 c4 08             	add    $0x8,%esp
  106d31:	5d                   	pop    %ebp
  106d32:	c3                   	ret    
  106d33:	66 90                	xchg   %ax,%ax
  106d35:	66 90                	xchg   %ax,%ax
  106d37:	66 90                	xchg   %ax,%ax
  106d39:	66 90                	xchg   %ax,%ax
  106d3b:	66 90                	xchg   %ax,%ax
  106d3d:	66 90                	xchg   %ax,%ax
  106d3f:	90                   	nop

00106d40 <isprint>:
	return (int)((((unsigned)c) > ' ') &&
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
  106d40:	55                   	push   %ebp
  106d41:	89 e5                	mov    %esp,%ebp
  106d43:	50                   	push   %eax
  106d44:	8b 45 08             	mov    0x8(%ebp),%eax
  106d47:	31 c9                	xor    %ecx,%ecx
	return (int)((((unsigned)c) >= ' ') &&
  106d49:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
  106d4d:	88 4d ff             	mov    %cl,-0x1(%ebp)
  106d50:	0f 82 0a 00 00 00    	jb     106d60 <isprint+0x20>
			(((unsigned)c) <= (unsigned)'~'));
  106d56:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
  106d5a:	0f 96 c0             	setbe  %al
  106d5d:	88 45 ff             	mov    %al,-0x1(%ebp)
  106d60:	8a 45 ff             	mov    -0x1(%ebp),%al
	return (int)((((unsigned)c) >= ' ') &&
  106d63:	24 01                	and    $0x1,%al
  106d65:	0f b6 c0             	movzbl %al,%eax
  106d68:	83 c4 04             	add    $0x4,%esp
  106d6b:	5d                   	pop    %ebp
  106d6c:	c3                   	ret    
  106d6d:	66 90                	xchg   %ax,%ax
  106d6f:	90                   	nop

00106d70 <z_impl_uart_poll_out>:
__syscall void uart_poll_out(struct device *dev,
				      unsigned char out_char);

static inline void z_impl_uart_poll_out(struct device *dev,
						unsigned char out_char)
{
  106d70:	55                   	push   %ebp
  106d71:	89 e5                	mov    %esp,%ebp
  106d73:	56                   	push   %esi
  106d74:	83 ec 14             	sub    $0x14,%esp
  106d77:	8a 45 0c             	mov    0xc(%ebp),%al
  106d7a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;
  106d7d:	8b 55 08             	mov    0x8(%ebp),%edx
  106d80:	8b 52 04             	mov    0x4(%edx),%edx
	const struct uart_driver_api *api =
  106d83:	89 55 f8             	mov    %edx,-0x8(%ebp)

	api->poll_out(dev, out_char);
  106d86:	8b 55 f8             	mov    -0x8(%ebp),%edx
  106d89:	8b 52 04             	mov    0x4(%edx),%edx
  106d8c:	8b 75 08             	mov    0x8(%ebp),%esi
  106d8f:	89 34 24             	mov    %esi,(%esp)
  106d92:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  106d96:	89 74 24 04          	mov    %esi,0x4(%esp)
  106d9a:	88 45 f7             	mov    %al,-0x9(%ebp)
  106d9d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106da0:	ff d2                	call   *%edx
}
  106da2:	83 c4 14             	add    $0x14,%esp
  106da5:	5e                   	pop    %esi
  106da6:	5d                   	pop    %ebp
  106da7:	c3                   	ret    
  106da8:	66 90                	xchg   %ax,%ax
  106daa:	66 90                	xchg   %ax,%ax
  106dac:	66 90                	xchg   %ax,%ax
  106dae:	66 90                	xchg   %ax,%ax

00106db0 <put>:

LOG_OUTPUT_DEFINE(log_output, char_out, &buf, 1);

static void put(const struct log_backend *const backend,
		struct log_msg *msg)
{
  106db0:	55                   	push   %ebp
  106db1:	89 e5                	mov    %esp,%ebp
  106db3:	57                   	push   %edi
  106db4:	56                   	push   %esi
  106db5:	83 ec 18             	sub    $0x18,%esp
  106db8:	8b 45 0c             	mov    0xc(%ebp),%eax
  106dbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	u32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_UART_SYST_ENABLE) ?
  106dbe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_put(&log_output, flag, msg);
  106dc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106dc8:	8b 75 0c             	mov    0xc(%ebp),%esi
  106dcb:	8d 3d 8c 32 12 00    	lea    0x12328c,%edi
  106dd1:	89 3c 24             	mov    %edi,(%esp)
  106dd4:	89 54 24 04          	mov    %edx,0x4(%esp)
  106dd8:	89 74 24 08          	mov    %esi,0x8(%esp)
  106ddc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106ddf:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  106de2:	e8 99 00 00 00       	call   106e80 <log_backend_std_put>
}
  106de7:	83 c4 18             	add    $0x18,%esp
  106dea:	5e                   	pop    %esi
  106deb:	5f                   	pop    %edi
  106dec:	5d                   	pop    %ebp
  106ded:	c3                   	ret    
  106dee:	66 90                	xchg   %ax,%ax

00106df0 <dropped>:
{
	log_backend_std_panic(&log_output);
}

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
  106df0:	55                   	push   %ebp
  106df1:	89 e5                	mov    %esp,%ebp
  106df3:	56                   	push   %esi
  106df4:	83 ec 10             	sub    $0x10,%esp
  106df7:	8b 45 0c             	mov    0xc(%ebp),%eax
  106dfa:	8b 4d 08             	mov    0x8(%ebp),%ecx
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output, cnt);
  106dfd:	8b 55 0c             	mov    0xc(%ebp),%edx
  106e00:	8d 35 8c 32 12 00    	lea    0x12328c,%esi
  106e06:	89 34 24             	mov    %esi,(%esp)
  106e09:	89 54 24 04          	mov    %edx,0x4(%esp)
  106e0d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  106e10:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106e13:	e8 68 01 00 00       	call   106f80 <log_backend_std_dropped>
}
  106e18:	83 c4 10             	add    $0x10,%esp
  106e1b:	5e                   	pop    %esi
  106e1c:	5d                   	pop    %ebp
  106e1d:	c3                   	ret    
  106e1e:	66 90                	xchg   %ax,%ax

00106e20 <panic>:
{
  106e20:	55                   	push   %ebp
  106e21:	89 e5                	mov    %esp,%ebp
  106e23:	83 ec 08             	sub    $0x8,%esp
  106e26:	8b 45 08             	mov    0x8(%ebp),%eax
	log_backend_std_panic(&log_output);
  106e29:	8d 0d 8c 32 12 00    	lea    0x12328c,%ecx
  106e2f:	89 0c 24             	mov    %ecx,(%esp)
  106e32:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106e35:	e8 76 01 00 00       	call   106fb0 <log_backend_std_panic>
}
  106e3a:	83 c4 08             	add    $0x8,%esp
  106e3d:	5d                   	pop    %ebp
  106e3e:	c3                   	ret    
  106e3f:	90                   	nop

00106e40 <log_backend_uart_init>:
{
  106e40:	55                   	push   %ebp
  106e41:	89 e5                	mov    %esp,%ebp
  106e43:	83 ec 0c             	sub    $0xc,%esp
	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  106e46:	8d 05 f9 37 12 00    	lea    0x1237f9,%eax
  106e4c:	89 04 24             	mov    %eax,(%esp)
  106e4f:	e8 7c 01 00 00       	call   106fd0 <device_get_binding>
  106e54:	89 45 fc             	mov    %eax,-0x4(%ebp)
	log_output_ctx_set(&log_output, dev);
  106e57:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106e5a:	8d 0d 8c 32 12 00    	lea    0x12328c,%ecx
  106e60:	89 0c 24             	mov    %ecx,(%esp)
  106e63:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e67:	e8 84 01 00 00       	call   106ff0 <log_output_ctx_set>
}
  106e6c:	83 c4 0c             	add    $0xc,%esp
  106e6f:	5d                   	pop    %ebp
  106e70:	c3                   	ret    
  106e71:	66 90                	xchg   %ax,%ax
  106e73:	66 90                	xchg   %ax,%ax
  106e75:	66 90                	xchg   %ax,%ax
  106e77:	66 90                	xchg   %ax,%ax
  106e79:	66 90                	xchg   %ax,%ax
  106e7b:	66 90                	xchg   %ax,%ax
  106e7d:	66 90                	xchg   %ax,%ax
  106e7f:	90                   	nop

00106e80 <log_backend_std_put>:
 * @param msg		Log message.
 */
static inline void
log_backend_std_put(const struct log_output *const log_output, u32_t flags,
		    struct log_msg *msg)
{
  106e80:	55                   	push   %ebp
  106e81:	89 e5                	mov    %esp,%ebp
  106e83:	56                   	push   %esi
  106e84:	83 ec 18             	sub    $0x18,%esp
  106e87:	8b 45 10             	mov    0x10(%ebp),%eax
  106e8a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106e8d:	8b 55 08             	mov    0x8(%ebp),%edx
	log_msg_get(msg);
  106e90:	8b 75 10             	mov    0x10(%ebp),%esi
  106e93:	89 34 24             	mov    %esi,(%esp)
  106e96:	89 45 f8             	mov    %eax,-0x8(%ebp)
  106e99:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106e9c:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106e9f:	e8 7c da ff ff       	call   104920 <log_msg_get>

	flags |= (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
  106ea4:	8b 45 0c             	mov    0xc(%ebp),%eax
  106ea7:	83 c8 0a             	or     $0xa,%eax
  106eaa:	89 45 0c             	mov    %eax,0xc(%ebp)

	if (IS_ENABLED(CONFIG_LOG_BACKEND_SHOW_COLOR)) {
		flags |= LOG_OUTPUT_FLAG_COLORS;
  106ead:	8b 45 0c             	mov    0xc(%ebp),%eax
  106eb0:	83 c8 01             	or     $0x1,%eax
  106eb3:	89 45 0c             	mov    %eax,0xc(%ebp)
	}

	if (IS_ENABLED(CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP)) {
		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
  106eb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  106eb9:	83 c8 04             	or     $0x4,%eax
  106ebc:	89 45 0c             	mov    %eax,0xc(%ebp)
	}

	log_output_msg_process(log_output, msg, flags);
  106ebf:	8b 45 08             	mov    0x8(%ebp),%eax
  106ec2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  106ec5:	8b 55 0c             	mov    0xc(%ebp),%edx
  106ec8:	89 04 24             	mov    %eax,(%esp)
  106ecb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106ecf:	89 54 24 08          	mov    %edx,0x8(%esp)
  106ed3:	e8 68 e4 ff ff       	call   105340 <log_output_msg_process>

	log_msg_put(msg);
  106ed8:	8b 45 10             	mov    0x10(%ebp),%eax
  106edb:	89 04 24             	mov    %eax,(%esp)
  106ede:	e8 bd da ff ff       	call   1049a0 <log_msg_put>
}
  106ee3:	83 c4 18             	add    $0x18,%esp
  106ee6:	5e                   	pop    %esi
  106ee7:	5d                   	pop    %ebp
  106ee8:	c3                   	ret    
  106ee9:	66 90                	xchg   %ax,%ax
  106eeb:	66 90                	xchg   %ax,%ax
  106eed:	66 90                	xchg   %ax,%ax
  106eef:	90                   	nop

00106ef0 <char_out>:
{
  106ef0:	55                   	push   %ebp
  106ef1:	89 e5                	mov    %esp,%ebp
  106ef3:	56                   	push   %esi
  106ef4:	83 ec 10             	sub    $0x10,%esp
  106ef7:	8b 45 10             	mov    0x10(%ebp),%eax
  106efa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106efd:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *dev = (struct device *)ctx;
  106f00:	8b 75 10             	mov    0x10(%ebp),%esi
  106f03:	89 75 f8             	mov    %esi,-0x8(%ebp)
	for (size_t i = 0; i < length; i++) {
  106f06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  106f0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106f10:	3b 45 0c             	cmp    0xc(%ebp),%eax
  106f13:	0f 83 27 00 00 00    	jae    106f40 <char_out+0x50>
		uart_poll_out(dev, data[i]);
  106f19:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106f1c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106f1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106f22:	89 04 24             	mov    %eax,(%esp)
  106f25:	0f b6 04 11          	movzbl (%ecx,%edx,1),%eax
  106f29:	89 44 24 04          	mov    %eax,0x4(%esp)
  106f2d:	e8 1e 00 00 00       	call   106f50 <uart_poll_out>
	for (size_t i = 0; i < length; i++) {
  106f32:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106f35:	83 c0 01             	add    $0x1,%eax
  106f38:	89 45 f4             	mov    %eax,-0xc(%ebp)
  106f3b:	e9 cd ff ff ff       	jmp    106f0d <char_out+0x1d>
	return length;
  106f40:	8b 45 0c             	mov    0xc(%ebp),%eax
  106f43:	83 c4 10             	add    $0x10,%esp
  106f46:	5e                   	pop    %esi
  106f47:	5d                   	pop    %ebp
  106f48:	c3                   	ret    
  106f49:	66 90                	xchg   %ax,%ax
  106f4b:	66 90                	xchg   %ax,%ax
  106f4d:	66 90                	xchg   %ax,%ax
  106f4f:	90                   	nop

00106f50 <uart_poll_out>:
}


extern void z_impl_uart_poll_out(struct device * dev, unsigned char out_char);
static inline void uart_poll_out(struct device * dev, unsigned char out_char)
{
  106f50:	55                   	push   %ebp
  106f51:	89 e5                	mov    %esp,%ebp
  106f53:	83 ec 08             	sub    $0x8,%esp
  106f56:	8a 45 0c             	mov    0xc(%ebp),%al
  106f59:	8b 4d 08             	mov    0x8(%ebp),%ecx
		arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&out_char, K_SYSCALL_UART_POLL_OUT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
  106f5c:	8b 45 08             	mov    0x8(%ebp),%eax
  106f5f:	89 04 24             	mov    %eax,(%esp)
  106f62:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  106f66:	89 44 24 04          	mov    %eax,0x4(%esp)
  106f6a:	e8 01 fe ff ff       	call   106d70 <z_impl_uart_poll_out>
}
  106f6f:	83 c4 08             	add    $0x8,%esp
  106f72:	5d                   	pop    %ebp
  106f73:	c3                   	ret    
  106f74:	66 90                	xchg   %ax,%ax
  106f76:	66 90                	xchg   %ax,%ax
  106f78:	66 90                	xchg   %ax,%ax
  106f7a:	66 90                	xchg   %ax,%ax
  106f7c:	66 90                	xchg   %ax,%ax
  106f7e:	66 90                	xchg   %ax,%ax

00106f80 <log_backend_std_dropped>:
 * @param log_output	Log output instance.
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
  106f80:	55                   	push   %ebp
  106f81:	89 e5                	mov    %esp,%ebp
  106f83:	56                   	push   %esi
  106f84:	83 ec 10             	sub    $0x10,%esp
  106f87:	8b 45 0c             	mov    0xc(%ebp),%eax
  106f8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	log_output_dropped_process(log_output, cnt);
  106f8d:	8b 55 08             	mov    0x8(%ebp),%edx
  106f90:	8b 75 0c             	mov    0xc(%ebp),%esi
  106f93:	89 14 24             	mov    %edx,(%esp)
  106f96:	89 74 24 04          	mov    %esi,0x4(%esp)
  106f9a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  106f9d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106fa0:	e8 3b f8 ff ff       	call   1067e0 <log_output_dropped_process>
}
  106fa5:	83 c4 10             	add    $0x10,%esp
  106fa8:	5e                   	pop    %esi
  106fa9:	5d                   	pop    %ebp
  106faa:	c3                   	ret    
  106fab:	66 90                	xchg   %ax,%ax
  106fad:	66 90                	xchg   %ax,%ax
  106faf:	90                   	nop

00106fb0 <log_backend_std_panic>:
{
  106fb0:	55                   	push   %ebp
  106fb1:	89 e5                	mov    %esp,%ebp
  106fb3:	83 ec 08             	sub    $0x8,%esp
  106fb6:	8b 45 08             	mov    0x8(%ebp),%eax
	log_output_flush(log_output);
  106fb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106fbc:	89 0c 24             	mov    %ecx,(%esp)
  106fbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106fc2:	e8 b9 e2 ff ff       	call   105280 <log_output_flush>
}
  106fc7:	83 c4 08             	add    $0x8,%esp
  106fca:	5d                   	pop    %ebp
  106fcb:	c3                   	ret    
  106fcc:	66 90                	xchg   %ax,%ax
  106fce:	66 90                	xchg   %ax,%ax

00106fd0 <device_get_binding>:
{
  106fd0:	55                   	push   %ebp
  106fd1:	89 e5                	mov    %esp,%ebp
  106fd3:	50                   	push   %eax
  106fd4:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_impl_device_get_binding(name);
  106fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  106fda:	89 04 24             	mov    %eax,(%esp)
  106fdd:	e8 2e 57 01 00       	call   11c710 <z_impl_device_get_binding>
  106fe2:	83 c4 04             	add    $0x4,%esp
  106fe5:	5d                   	pop    %ebp
  106fe6:	c3                   	ret    
  106fe7:	66 90                	xchg   %ax,%ax
  106fe9:	66 90                	xchg   %ax,%ax
  106feb:	66 90                	xchg   %ax,%ax
  106fed:	66 90                	xchg   %ax,%ax
  106fef:	90                   	nop

00106ff0 <log_output_ctx_set>:
 * @param log_output	Pointer to the log output instance.
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
  106ff0:	55                   	push   %ebp
  106ff1:	89 e5                	mov    %esp,%ebp
  106ff3:	56                   	push   %esi
  106ff4:	8b 45 0c             	mov    0xc(%ebp),%eax
  106ff7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	log_output->control_block->ctx = ctx;
  106ffa:	8b 55 0c             	mov    0xc(%ebp),%edx
  106ffd:	8b 75 08             	mov    0x8(%ebp),%esi
  107000:	8b 76 04             	mov    0x4(%esi),%esi
  107003:	89 56 04             	mov    %edx,0x4(%esi)
}
  107006:	5e                   	pop    %esi
  107007:	5d                   	pop    %ebp
  107008:	c3                   	ret    
  107009:	66 90                	xchg   %ax,%ax
  10700b:	66 90                	xchg   %ax,%ax
  10700d:	66 90                	xchg   %ax,%ax
  10700f:	90                   	nop

00107010 <z_impl_uart_poll_out>:
{
  107010:	55                   	push   %ebp
  107011:	89 e5                	mov    %esp,%ebp
  107013:	56                   	push   %esi
  107014:	83 ec 14             	sub    $0x14,%esp
  107017:	8a 45 0c             	mov    0xc(%ebp),%al
  10701a:	8b 4d 08             	mov    0x8(%ebp),%ecx
		(const struct uart_driver_api *)dev->driver_api;
  10701d:	8b 55 08             	mov    0x8(%ebp),%edx
  107020:	8b 52 04             	mov    0x4(%edx),%edx
	const struct uart_driver_api *api =
  107023:	89 55 f8             	mov    %edx,-0x8(%ebp)
	api->poll_out(dev, out_char);
  107026:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107029:	8b 52 04             	mov    0x4(%edx),%edx
  10702c:	8b 75 08             	mov    0x8(%ebp),%esi
  10702f:	89 34 24             	mov    %esi,(%esp)
  107032:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  107036:	89 74 24 04          	mov    %esi,0x4(%esp)
  10703a:	88 45 f7             	mov    %al,-0x9(%ebp)
  10703d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107040:	ff d2                	call   *%edx
}
  107042:	83 c4 14             	add    $0x14,%esp
  107045:	5e                   	pop    %esi
  107046:	5d                   	pop    %ebp
  107047:	c3                   	ret    
  107048:	66 90                	xchg   %ax,%ax
  10704a:	66 90                	xchg   %ax,%ax
  10704c:	66 90                	xchg   %ax,%ax
  10704e:	66 90                	xchg   %ax,%ax

00107050 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  107050:	55                   	push   %ebp
  107051:	89 e5                	mov    %esp,%ebp
  107053:	50                   	push   %eax
	__stdout_hook_install(console_out);
  107054:	8d 05 80 70 10 00    	lea    0x107080,%eax
  10705a:	89 04 24             	mov    %eax,(%esp)
  10705d:	e8 1e 54 00 00       	call   10c480 <__stdout_hook_install>
	__printk_hook_install(console_out);
  107062:	8d 05 80 70 10 00    	lea    0x107080,%eax
  107068:	89 04 24             	mov    %eax,(%esp)
  10706b:	e8 00 b5 ff ff       	call   102570 <__printk_hook_install>
}
  107070:	83 c4 04             	add    $0x4,%esp
  107073:	5d                   	pop    %ebp
  107074:	c3                   	ret    
  107075:	66 90                	xchg   %ax,%ax
  107077:	66 90                	xchg   %ax,%ax
  107079:	66 90                	xchg   %ax,%ax
  10707b:	66 90                	xchg   %ax,%ax
  10707d:	66 90                	xchg   %ax,%ax
  10707f:	90                   	nop

00107080 <console_out>:
{
  107080:	55                   	push   %ebp
  107081:	89 e5                	mov    %esp,%ebp
  107083:	83 ec 08             	sub    $0x8,%esp
  107086:	8b 45 08             	mov    0x8(%ebp),%eax
	if ('\n' == c) {
  107089:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10708e:	3b 4d 08             	cmp    0x8(%ebp),%ecx
  107091:	0f 85 15 00 00 00    	jne    1070ac <console_out+0x2c>
		uart_poll_out(uart_console_dev, '\r');
  107097:	a1 18 51 13 00       	mov    0x135118,%eax
  10709c:	89 04 24             	mov    %eax,(%esp)
  10709f:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
  1070a6:	00 
  1070a7:	e8 54 00 00 00       	call   107100 <uart_poll_out>
	uart_poll_out(uart_console_dev, c);
  1070ac:	a1 18 51 13 00       	mov    0x135118,%eax
  1070b1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1070b4:	89 04 24             	mov    %eax,(%esp)
  1070b7:	0f b6 c1             	movzbl %cl,%eax
  1070ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1070be:	e8 3d 00 00 00       	call   107100 <uart_poll_out>
	return c;
  1070c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1070c6:	83 c4 08             	add    $0x8,%esp
  1070c9:	5d                   	pop    %ebp
  1070ca:	c3                   	ret    
  1070cb:	66 90                	xchg   %ax,%ax
  1070cd:	66 90                	xchg   %ax,%ax
  1070cf:	90                   	nop

001070d0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  1070d0:	55                   	push   %ebp
  1070d1:	89 e5                	mov    %esp,%ebp
  1070d3:	83 ec 08             	sub    $0x8,%esp
  1070d6:	8b 45 08             	mov    0x8(%ebp),%eax

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1070d9:	8d 0d f9 37 12 00    	lea    0x1237f9,%ecx
  1070df:	89 0c 24             	mov    %ecx,(%esp)
  1070e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1070e5:	e8 46 00 00 00       	call   107130 <device_get_binding>
  1070ea:	a3 18 51 13 00       	mov    %eax,0x135118
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  1070ef:	e8 5c ff ff ff       	call   107050 <uart_console_hook_install>
  1070f4:	31 c0                	xor    %eax,%eax

	return 0;
  1070f6:	83 c4 08             	add    $0x8,%esp
  1070f9:	5d                   	pop    %ebp
  1070fa:	c3                   	ret    
  1070fb:	66 90                	xchg   %ax,%ax
  1070fd:	66 90                	xchg   %ax,%ax
  1070ff:	90                   	nop

00107100 <uart_poll_out>:
{
  107100:	55                   	push   %ebp
  107101:	89 e5                	mov    %esp,%ebp
  107103:	83 ec 08             	sub    $0x8,%esp
  107106:	8a 45 0c             	mov    0xc(%ebp),%al
  107109:	8b 4d 08             	mov    0x8(%ebp),%ecx
	z_impl_uart_poll_out(dev, out_char);
  10710c:	8b 45 08             	mov    0x8(%ebp),%eax
  10710f:	89 04 24             	mov    %eax,(%esp)
  107112:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  107116:	89 44 24 04          	mov    %eax,0x4(%esp)
  10711a:	e8 f1 fe ff ff       	call   107010 <z_impl_uart_poll_out>
}
  10711f:	83 c4 08             	add    $0x8,%esp
  107122:	5d                   	pop    %ebp
  107123:	c3                   	ret    
  107124:	66 90                	xchg   %ax,%ax
  107126:	66 90                	xchg   %ax,%ax
  107128:	66 90                	xchg   %ax,%ax
  10712a:	66 90                	xchg   %ax,%ax
  10712c:	66 90                	xchg   %ax,%ax
  10712e:	66 90                	xchg   %ax,%ax

00107130 <device_get_binding>:
{
  107130:	55                   	push   %ebp
  107131:	89 e5                	mov    %esp,%ebp
  107133:	50                   	push   %eax
  107134:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_impl_device_get_binding(name);
  107137:	8b 45 08             	mov    0x8(%ebp),%eax
  10713a:	89 04 24             	mov    %eax,(%esp)
  10713d:	e8 ce 55 01 00       	call   11c710 <z_impl_device_get_binding>
  107142:	83 c4 04             	add    $0x4,%esp
  107145:	5d                   	pop    %ebp
  107146:	c3                   	ret    
  107147:	66 90                	xchg   %ax,%ax
  107149:	66 90                	xchg   %ax,%ax
  10714b:	66 90                	xchg   %ax,%ax
  10714d:	66 90                	xchg   %ax,%ax
  10714f:	90                   	nop

00107150 <_ioapic_init>:
 * This routine initializes the IO APIC or xAPIC.
 *
 * @return N/A
 */
int _ioapic_init(struct device *unused)
{
  107150:	55                   	push   %ebp
  107151:	89 e5                	mov    %esp,%ebp
  107153:	83 ec 10             	sub    $0x10,%esp
  107156:	8b 45 08             	mov    0x8(%ebp),%eax
	 * Note: The number of actual IRQs supported by the IOAPIC can be
	 * determined at runtime by computing:
	 *
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
  107159:	c7 45 f8 00 00 01 00 	movl   $0x10000,-0x8(%ebp)
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  107160:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  107167:	83 7d fc 18          	cmpl   $0x18,-0x4(%ebp)
  10716b:	0f 8d 33 00 00 00    	jge    1071a4 <_ioapic_init+0x54>
		ioApicRedSetHi(ix, 0xFF000000);
  107171:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107174:	89 04 24             	mov    %eax,(%esp)
  107177:	c7 44 24 04 00 00 00 	movl   $0xff000000,0x4(%esp)
  10717e:	ff 
  10717f:	e8 2c 00 00 00       	call   1071b0 <ioApicRedSetHi>
		ioApicRedSetLo(ix, rteValue);
  107184:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107187:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10718a:	89 04 24             	mov    %eax,(%esp)
  10718d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107191:	e8 5a 00 00 00       	call   1071f0 <ioApicRedSetLo>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  107196:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107199:	83 c0 01             	add    $0x1,%eax
  10719c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10719f:	e9 c3 ff ff ff       	jmp    107167 <_ioapic_init+0x17>
  1071a4:	31 c0                	xor    %eax,%eax
	}
#endif
	return 0;
  1071a6:	83 c4 10             	add    $0x10,%esp
  1071a9:	5d                   	pop    %ebp
  1071aa:	c3                   	ret    
  1071ab:	66 90                	xchg   %ax,%ax
  1071ad:	66 90                	xchg   %ax,%ax
  1071af:	90                   	nop

001071b0 <ioApicRedSetHi>:
 * @param irq INTIN number
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, u32_t upper32)
{
  1071b0:	55                   	push   %ebp
  1071b1:	89 e5                	mov    %esp,%ebp
  1071b3:	56                   	push   %esi
  1071b4:	83 ec 14             	sub    $0x14,%esp
  1071b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1071ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  1071bd:	8b 55 08             	mov    0x8(%ebp),%edx
  1071c0:	c1 e2 01             	shl    $0x1,%edx
  1071c3:	83 c2 10             	add    $0x10,%edx
  1071c6:	83 c2 01             	add    $0x1,%edx
  1071c9:	89 55 f8             	mov    %edx,-0x8(%ebp)

	__IoApicSet(offset, upper32);
  1071cc:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1071cf:	8b 75 0c             	mov    0xc(%ebp),%esi
  1071d2:	89 14 24             	mov    %edx,(%esp)
  1071d5:	89 74 24 04          	mov    %esi,0x4(%esp)
  1071d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1071dc:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1071df:	e8 4c 01 00 00       	call   107330 <__IoApicSet>
}
  1071e4:	83 c4 14             	add    $0x14,%esp
  1071e7:	5e                   	pop    %esi
  1071e8:	5d                   	pop    %ebp
  1071e9:	c3                   	ret    
  1071ea:	66 90                	xchg   %ax,%ax
  1071ec:	66 90                	xchg   %ax,%ax
  1071ee:	66 90                	xchg   %ax,%ax

001071f0 <ioApicRedSetLo>:
{
  1071f0:	55                   	push   %ebp
  1071f1:	89 e5                	mov    %esp,%ebp
  1071f3:	56                   	push   %esi
  1071f4:	83 ec 14             	sub    $0x14,%esp
  1071f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1071fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  1071fd:	8b 55 08             	mov    0x8(%ebp),%edx
  107200:	c1 e2 01             	shl    $0x1,%edx
  107203:	83 c2 10             	add    $0x10,%edx
  107206:	89 55 f8             	mov    %edx,-0x8(%ebp)
	__IoApicSet(offset, lower32);
  107209:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10720c:	8b 75 0c             	mov    0xc(%ebp),%esi
  10720f:	89 14 24             	mov    %edx,(%esp)
  107212:	89 74 24 04          	mov    %esi,0x4(%esp)
  107216:	89 45 f4             	mov    %eax,-0xc(%ebp)
  107219:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10721c:	e8 0f 01 00 00       	call   107330 <__IoApicSet>
}
  107221:	83 c4 14             	add    $0x14,%esp
  107224:	5e                   	pop    %esi
  107225:	5d                   	pop    %ebp
  107226:	c3                   	ret    
  107227:	66 90                	xchg   %ax,%ax
  107229:	66 90                	xchg   %ax,%ax
  10722b:	66 90                	xchg   %ax,%ax
  10722d:	66 90                	xchg   %ax,%ax
  10722f:	90                   	nop

00107230 <z_ioapic_irq_enable>:
{
  107230:	55                   	push   %ebp
  107231:	89 e5                	mov    %esp,%ebp
  107233:	83 ec 14             	sub    $0x14,%esp
  107236:	8b 45 08             	mov    0x8(%ebp),%eax
  107239:	31 c9                	xor    %ecx,%ecx
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10723b:	8b 55 08             	mov    0x8(%ebp),%edx
  10723e:	89 14 24             	mov    %edx,(%esp)
  107241:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107248:	00 
  107249:	c7 44 24 08 00 00 01 	movl   $0x10000,0x8(%esp)
  107250:	00 
  107251:	89 45 fc             	mov    %eax,-0x4(%ebp)
  107254:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  107257:	e8 14 00 00 00       	call   107270 <IoApicRedUpdateLo>
}
  10725c:	83 c4 14             	add    $0x14,%esp
  10725f:	5d                   	pop    %ebp
  107260:	c3                   	ret    
  107261:	66 90                	xchg   %ax,%ax
  107263:	66 90                	xchg   %ax,%ax
  107265:	66 90                	xchg   %ax,%ax
  107267:	66 90                	xchg   %ax,%ax
  107269:	66 90                	xchg   %ax,%ax
  10726b:	66 90                	xchg   %ax,%ax
  10726d:	66 90                	xchg   %ax,%ax
  10726f:	90                   	nop

00107270 <IoApicRedUpdateLo>:
 * @return N/A
 */
static void IoApicRedUpdateLo(unsigned int irq,
				u32_t value,
				u32_t mask)
{
  107270:	55                   	push   %ebp
  107271:	89 e5                	mov    %esp,%ebp
  107273:	57                   	push   %edi
  107274:	56                   	push   %esi
  107275:	83 ec 18             	sub    $0x18,%esp
  107278:	8b 45 10             	mov    0x10(%ebp),%eax
  10727b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10727e:	8b 55 08             	mov    0x8(%ebp),%edx
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
  107281:	8b 75 08             	mov    0x8(%ebp),%esi
  107284:	8b 7d 08             	mov    0x8(%ebp),%edi
  107287:	89 3c 24             	mov    %edi,(%esp)
  10728a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10728d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107290:	89 55 ec             	mov    %edx,-0x14(%ebp)
  107293:	89 75 e8             	mov    %esi,-0x18(%ebp)
  107296:	e8 e5 00 00 00       	call   107380 <ioApicRedGetLo>
  10729b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10729e:	83 f1 ff             	xor    $0xffffffff,%ecx
  1072a1:	21 c8                	and    %ecx,%eax
  1072a3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1072a6:	23 4d 10             	and    0x10(%ebp),%ecx
  1072a9:	09 c8                	or     %ecx,%eax
  1072ab:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1072ae:	89 0c 24             	mov    %ecx,(%esp)
  1072b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1072b5:	e8 36 ff ff ff       	call   1071f0 <ioApicRedSetLo>
}
  1072ba:	83 c4 18             	add    $0x18,%esp
  1072bd:	5e                   	pop    %esi
  1072be:	5f                   	pop    %edi
  1072bf:	5d                   	pop    %ebp
  1072c0:	c3                   	ret    
  1072c1:	66 90                	xchg   %ax,%ax
  1072c3:	66 90                	xchg   %ax,%ax
  1072c5:	66 90                	xchg   %ax,%ax
  1072c7:	66 90                	xchg   %ax,%ax
  1072c9:	66 90                	xchg   %ax,%ax
  1072cb:	66 90                	xchg   %ax,%ax
  1072cd:	66 90                	xchg   %ax,%ax
  1072cf:	90                   	nop

001072d0 <z_ioapic_irq_set>:
{
  1072d0:	55                   	push   %ebp
  1072d1:	89 e5                	mov    %esp,%ebp
  1072d3:	56                   	push   %esi
  1072d4:	83 ec 18             	sub    $0x18,%esp
  1072d7:	8b 45 10             	mov    0x10(%ebp),%eax
  1072da:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1072dd:	8b 55 08             	mov    0x8(%ebp),%edx
		   (vector & IOAPIC_VEC_MASK) | flags;
  1072e0:	8b 75 0c             	mov    0xc(%ebp),%esi
  1072e3:	81 e6 ff 00 00 00    	and    $0xff,%esi
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  1072e9:	81 ce 00 00 01 00    	or     $0x10000,%esi
		   (vector & IOAPIC_VEC_MASK) | flags;
  1072ef:	0b 75 10             	or     0x10(%ebp),%esi
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  1072f2:	89 75 f8             	mov    %esi,-0x8(%ebp)
	ioApicRedSetHi(irq, 0xFF000000);
  1072f5:	8b 75 08             	mov    0x8(%ebp),%esi
  1072f8:	89 34 24             	mov    %esi,(%esp)
  1072fb:	c7 44 24 04 00 00 00 	movl   $0xff000000,0x4(%esp)
  107302:	ff 
  107303:	89 45 f4             	mov    %eax,-0xc(%ebp)
  107306:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107309:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10730c:	e8 9f fe ff ff       	call   1071b0 <ioApicRedSetHi>
	ioApicRedSetLo(irq, rteValue);
  107311:	8b 45 08             	mov    0x8(%ebp),%eax
  107314:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  107317:	89 04 24             	mov    %eax,(%esp)
  10731a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10731e:	e8 cd fe ff ff       	call   1071f0 <ioApicRedSetLo>
}
  107323:	83 c4 18             	add    $0x18,%esp
  107326:	5e                   	pop    %esi
  107327:	5d                   	pop    %ebp
  107328:	c3                   	ret    
  107329:	66 90                	xchg   %ax,%ax
  10732b:	66 90                	xchg   %ax,%ax
  10732d:	66 90                	xchg   %ax,%ax
  10732f:	90                   	nop

00107330 <__IoApicSet>:
{
  107330:	55                   	push   %ebp
  107331:	89 e5                	mov    %esp,%ebp
  107333:	57                   	push   %edi
  107334:	56                   	push   %esi
  107335:	83 ec 0c             	sub    $0xc,%esp
  107338:	8b 45 0c             	mov    0xc(%ebp),%eax
  10733b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  10733e:	9c                   	pushf  
  10733f:	fa                   	cli    
  107340:	8f 45 f0             	popl   -0x10(%ebp)
	return key;
  107343:	8b 55 f0             	mov    -0x10(%ebp),%edx
	key = irq_lock();
  107346:	89 55 ec             	mov    %edx,-0x14(%ebp)
	*(volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  107349:	8b 55 08             	mov    0x8(%ebp),%edx
  10734c:	0f be f2             	movsbl %dl,%esi
  10734f:	bf 00 00 c0 fe       	mov    $0xfec00000,%edi
  107354:	89 37                	mov    %esi,(%edi)
	*((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  107356:	8b 75 0c             	mov    0xc(%ebp),%esi
  107359:	bf 10 00 c0 fe       	mov    $0xfec00010,%edi
  10735e:	89 37                	mov    %esi,(%edi)
	irq_unlock(key);
  107360:	8b 75 ec             	mov    -0x14(%ebp),%esi
  107363:	89 75 f4             	mov    %esi,-0xc(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  107366:	8b 75 f4             	mov    -0xc(%ebp),%esi
  107369:	81 e6 00 02 00 00    	and    $0x200,%esi
  10736f:	83 fe 00             	cmp    $0x0,%esi
  107372:	0f 84 01 00 00 00    	je     107379 <__IoApicSet+0x49>
		__asm__ volatile ("sti" ::: "memory");
  107378:	fb                   	sti    
}
  107379:	83 c4 0c             	add    $0xc,%esp
  10737c:	5e                   	pop    %esi
  10737d:	5f                   	pop    %edi
  10737e:	5d                   	pop    %ebp
  10737f:	c3                   	ret    

00107380 <ioApicRedGetLo>:
{
  107380:	55                   	push   %ebp
  107381:	89 e5                	mov    %esp,%ebp
  107383:	83 ec 0c             	sub    $0xc,%esp
  107386:	8b 45 08             	mov    0x8(%ebp),%eax
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  107389:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10738c:	c1 e1 01             	shl    $0x1,%ecx
  10738f:	83 c1 10             	add    $0x10,%ecx
  107392:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	return __IoApicGet(offset);
  107395:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  107398:	89 0c 24             	mov    %ecx,(%esp)
  10739b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10739e:	e8 0d 00 00 00       	call   1073b0 <__IoApicGet>
  1073a3:	83 c4 0c             	add    $0xc,%esp
  1073a6:	5d                   	pop    %ebp
  1073a7:	c3                   	ret    
  1073a8:	66 90                	xchg   %ax,%ax
  1073aa:	66 90                	xchg   %ax,%ax
  1073ac:	66 90                	xchg   %ax,%ax
  1073ae:	66 90                	xchg   %ax,%ax

001073b0 <__IoApicGet>:
{
  1073b0:	55                   	push   %ebp
  1073b1:	89 e5                	mov    %esp,%ebp
  1073b3:	56                   	push   %esi
  1073b4:	83 ec 10             	sub    $0x10,%esp
  1073b7:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1073ba:	9c                   	pushf  
  1073bb:	fa                   	cli    
  1073bc:	8f 45 f4             	popl   -0xc(%ebp)
	return key;
  1073bf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
	key = irq_lock();
  1073c2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  1073c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1073c8:	0f be d1             	movsbl %cl,%edx
  1073cb:	be 00 00 c0 fe       	mov    $0xfec00000,%esi
  1073d0:	89 16                	mov    %edx,(%esi)
	value = *((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  1073d2:	ba 10 00 c0 fe       	mov    $0xfec00010,%edx
  1073d7:	8b 12                	mov    (%edx),%edx
  1073d9:	89 55 f0             	mov    %edx,-0x10(%ebp)
	irq_unlock(key);
  1073dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1073df:	89 55 f8             	mov    %edx,-0x8(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1073e2:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1073e5:	81 e2 00 02 00 00    	and    $0x200,%edx
  1073eb:	83 fa 00             	cmp    $0x0,%edx
  1073ee:	0f 84 01 00 00 00    	je     1073f5 <__IoApicGet+0x45>
		__asm__ volatile ("sti" ::: "memory");
  1073f4:	fb                   	sti    
	return value;
  1073f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1073f8:	83 c4 10             	add    $0x10,%esp
  1073fb:	5e                   	pop    %esi
  1073fc:	5d                   	pop    %ebp
  1073fd:	c3                   	ret    
  1073fe:	66 90                	xchg   %ax,%ax

00107400 <z_loapic_enable>:
 *
 * Called from early assembly layer (e.g., crt0.S).
 */

void z_loapic_enable(void)
{
  107400:	55                   	push   %ebp
  107401:	89 e5                	mov    %esp,%ebp
  107403:	83 ec 1c             	sub    $0x1c,%esp
	 * enable the local APIC. note that we use xAPIC mode here, since
	 * x2APIC access is not enabled until the next step (if at all).
	 */

	x86_write_xapic(LOAPIC_SVR,
			x86_read_xapic(LOAPIC_SVR) | LOAPIC_ENABLE);
  107406:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  10740d:	e8 8e 01 00 00       	call   1075a0 <x86_read_xapic>
  107412:	0d 00 01 00 00       	or     $0x100,%eax
	x86_write_xapic(LOAPIC_SVR,
  107417:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  10741e:	89 44 24 04          	mov    %eax,0x4(%esp)
  107422:	e8 49 01 00 00       	call   107570 <x86_write_xapic>
	u64_t msr = z_x86_msr_read(X86_APIC_BASE_MSR);
	msr |= X86_APIC_BASE_MSR_X2APIC;
	z_x86_msr_write(X86_APIC_BASE_MSR, msr);
#endif

	loApicMaxLvt = (x86_read_loapic(LOAPIC_VER) & LOAPIC_MAXLVT_MASK) >> 16;
  107427:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10742e:	e8 9d 01 00 00       	call   1075d0 <x86_read_loapic>
  107433:	25 00 00 ff 00       	and    $0xff0000,%eax
  107438:	c1 e8 10             	shr    $0x10,%eax
  10743b:	89 45 fc             	mov    %eax,-0x4(%ebp)

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

#ifndef CONFIG_X2APIC
	x86_write_loapic(LOAPIC_DFR, 0xffffffff);  /* no DFR in x2APIC mode */
  10743e:	c7 04 24 e0 00 00 00 	movl   $0xe0,(%esp)
  107445:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10744c:	ff 
  10744d:	e8 9e 01 00 00       	call   1075f0 <x86_write_loapic>
  107452:	31 c0                	xor    %eax,%eax
#endif

	x86_write_loapic(LOAPIC_TPR, 0x0);
  107454:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp)
  10745b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107462:	00 
  107463:	89 45 f8             	mov    %eax,-0x8(%ebp)
  107466:	e8 85 01 00 00       	call   1075f0 <x86_write_loapic>
  10746b:	31 c0                	xor    %eax,%eax
	x86_write_loapic(LOAPIC_TIMER_CONFIG, 0x0);
  10746d:	c7 04 24 e0 03 00 00 	movl   $0x3e0,(%esp)
  107474:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10747b:	00 
  10747c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10747f:	e8 6c 01 00 00       	call   1075f0 <x86_write_loapic>
  107484:	31 c0                	xor    %eax,%eax
	x86_write_loapic(LOAPIC_TIMER_ICR, 0x0);
  107486:	c7 04 24 80 03 00 00 	movl   $0x380,(%esp)
  10748d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107494:	00 
  107495:	89 45 f0             	mov    %eax,-0x10(%ebp)
  107498:	e8 53 01 00 00       	call   1075f0 <x86_write_loapic>
	/* skip LINT0/LINT1 for Jailhouse guest case, because we won't
	 * ever be waiting for interrupts on those
	 */
	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	x86_write_loapic(LOAPIC_LINT0, (x86_read_loapic(LOAPIC_LINT0) &
  10749d:	c7 04 24 50 03 00 00 	movl   $0x350,(%esp)
  1074a4:	e8 27 01 00 00       	call   1075d0 <x86_read_loapic>
  1074a9:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
		~(LOAPIC_MODE | LOAPIC_LOW |
		  LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  1074ae:	0d 00 07 00 00       	or     $0x700,%eax
	x86_write_loapic(LOAPIC_LINT0, (x86_read_loapic(LOAPIC_LINT0) &
  1074b3:	c7 04 24 50 03 00 00 	movl   $0x350,(%esp)
  1074ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  1074be:	e8 2d 01 00 00       	call   1075f0 <x86_write_loapic>
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE));

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	x86_write_loapic(LOAPIC_LINT1, (x86_read_loapic(LOAPIC_LINT1) &
  1074c3:	c7 04 24 60 03 00 00 	movl   $0x360,(%esp)
  1074ca:	e8 01 01 00 00       	call   1075d0 <x86_read_loapic>
  1074cf:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
		~(LOAPIC_MODE | LOAPIC_LOW |
		  LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  1074d4:	0d 00 04 00 00       	or     $0x400,%eax
	x86_write_loapic(LOAPIC_LINT1, (x86_read_loapic(LOAPIC_LINT1) &
  1074d9:	c7 04 24 60 03 00 00 	movl   $0x360,(%esp)
  1074e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1074e4:	e8 07 01 00 00       	call   1075f0 <x86_write_loapic>
		(LOAPIC_NMI | LOAPIC_HIGH | LOAPIC_EDGE));

	/* lock the Local APIC interrupts */

	x86_write_loapic(LOAPIC_TIMER, LOAPIC_LVT_MASKED);
  1074e9:	c7 04 24 20 03 00 00 	movl   $0x320,(%esp)
  1074f0:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  1074f7:	00 
  1074f8:	e8 f3 00 00 00       	call   1075f0 <x86_write_loapic>
	x86_write_loapic(LOAPIC_ERROR, LOAPIC_LVT_MASKED);
  1074fd:	c7 04 24 70 03 00 00 	movl   $0x370,(%esp)
  107504:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  10750b:	00 
  10750c:	e8 df 00 00 00       	call   1075f0 <x86_write_loapic>

	if (loApicMaxLvt >= LOAPIC_LVT_P6) {
  107511:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
  107515:	0f 8c 14 00 00 00    	jl     10752f <z_loapic_enable+0x12f>
		x86_write_loapic(LOAPIC_PMC, LOAPIC_LVT_MASKED);
  10751b:	c7 04 24 40 03 00 00 	movl   $0x340,(%esp)
  107522:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  107529:	00 
  10752a:	e8 c1 00 00 00       	call   1075f0 <x86_write_loapic>
	}

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4) {
  10752f:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp)
  107533:	0f 8c 14 00 00 00    	jl     10754d <z_loapic_enable+0x14d>
		x86_write_loapic(LOAPIC_THERMAL, LOAPIC_LVT_MASKED);
  107539:	c7 04 24 30 03 00 00 	movl   $0x330,(%esp)
  107540:	c7 44 24 04 00 00 01 	movl   $0x10000,0x4(%esp)
  107547:	00 
  107548:	e8 a3 00 00 00       	call   1075f0 <x86_write_loapic>
  10754d:	31 c0                	xor    %eax,%eax
	x86_write_loapic(LOAPIC_SVR, (x86_read_loapic(LOAPIC_SVR) & 0xFFFFFF00) |
		     (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF));
#endif

	/* discard a pending interrupt if any */
	x86_write_loapic(LOAPIC_EOI, 0);
  10754f:	c7 04 24 b0 00 00 00 	movl   $0xb0,(%esp)
  107556:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10755d:	00 
  10755e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107561:	e8 8a 00 00 00       	call   1075f0 <x86_write_loapic>
}
  107566:	83 c4 1c             	add    $0x1c,%esp
  107569:	5d                   	pop    %ebp
  10756a:	c3                   	ret    
  10756b:	66 90                	xchg   %ax,%ax
  10756d:	66 90                	xchg   %ax,%ax
  10756f:	90                   	nop

00107570 <x86_write_xapic>:
 *
 * @param reg the LOAPIC register number to write (one of LOAPIC_*)
 * @param val 32-bit value to write
 */
static inline void x86_write_xapic(unsigned int reg, u32_t val)
{
  107570:	55                   	push   %ebp
  107571:	89 e5                	mov    %esp,%ebp
  107573:	56                   	push   %esi
  107574:	83 ec 08             	sub    $0x8,%esp
  107577:	8b 45 0c             	mov    0xc(%ebp),%eax
  10757a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	sys_write32(val, CONFIG_LOAPIC_BASE_ADDRESS + reg);
  10757d:	8b 55 0c             	mov    0xc(%ebp),%edx
  107580:	8b 75 08             	mov    0x8(%ebp),%esi
  107583:	81 c6 00 00 e0 fe    	add    $0xfee00000,%esi
  107589:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10758c:	89 75 f4             	mov    %esi,-0xc(%ebp)
			 : "r"(data), "m" (*(volatile u32_t *)(uintptr_t) addr)
  10758f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107592:	8b 75 f4             	mov    -0xc(%ebp),%esi
	__asm__ volatile("movl %0, %1"
  107595:	89 16                	mov    %edx,(%esi)
}
  107597:	83 c4 08             	add    $0x8,%esp
  10759a:	5e                   	pop    %esi
  10759b:	5d                   	pop    %ebp
  10759c:	c3                   	ret    
  10759d:	66 90                	xchg   %ax,%ax
  10759f:	90                   	nop

001075a0 <x86_read_xapic>:
{
  1075a0:	55                   	push   %ebp
  1075a1:	89 e5                	mov    %esp,%ebp
  1075a3:	83 ec 0c             	sub    $0xc,%esp
  1075a6:	8b 45 08             	mov    0x8(%ebp),%eax
	return sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + reg);
  1075a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1075ac:	81 c1 00 00 e0 fe    	add    $0xfee00000,%ecx
  1075b2:	89 4d fc             	mov    %ecx,-0x4(%ebp)
			 : "m" (*(volatile u32_t *)(uintptr_t) addr)
  1075b5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
	__asm__ volatile("movl %1, %0"
  1075b8:	8b 09                	mov    (%ecx),%ecx
  1075ba:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	return ret;
  1075bd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1075c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1075c3:	89 c8                	mov    %ecx,%eax
  1075c5:	83 c4 0c             	add    $0xc,%esp
  1075c8:	5d                   	pop    %ebp
  1075c9:	c3                   	ret    
  1075ca:	66 90                	xchg   %ax,%ax
  1075cc:	66 90                	xchg   %ax,%ax
  1075ce:	66 90                	xchg   %ax,%ax

001075d0 <x86_read_loapic>:
{
  1075d0:	55                   	push   %ebp
  1075d1:	89 e5                	mov    %esp,%ebp
  1075d3:	83 ec 08             	sub    $0x8,%esp
  1075d6:	8b 45 08             	mov    0x8(%ebp),%eax
	return x86_read_xapic(reg);
  1075d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1075dc:	89 0c 24             	mov    %ecx,(%esp)
  1075df:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1075e2:	e8 b9 ff ff ff       	call   1075a0 <x86_read_xapic>
  1075e7:	83 c4 08             	add    $0x8,%esp
  1075ea:	5d                   	pop    %ebp
  1075eb:	c3                   	ret    
  1075ec:	66 90                	xchg   %ax,%ax
  1075ee:	66 90                	xchg   %ax,%ax

001075f0 <x86_write_loapic>:
 *
 * @param reg the LOAPIC register number to write (one of LOAPIC_*)
 * @param val 32-bit value to write
 */
static inline void x86_write_loapic(unsigned int reg, u32_t val)
{
  1075f0:	55                   	push   %ebp
  1075f1:	89 e5                	mov    %esp,%ebp
  1075f3:	56                   	push   %esi
  1075f4:	83 ec 10             	sub    $0x10,%esp
  1075f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1075fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
#ifdef CONFIG_X2APIC
	x86_write_x2apic(reg, val);
#else
	x86_write_xapic(reg, val);
  1075fd:	8b 55 08             	mov    0x8(%ebp),%edx
  107600:	8b 75 0c             	mov    0xc(%ebp),%esi
  107603:	89 14 24             	mov    %edx,(%esp)
  107606:	89 74 24 04          	mov    %esi,0x4(%esp)
  10760a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10760d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  107610:	e8 5b ff ff ff       	call   107570 <x86_write_xapic>
#endif
}
  107615:	83 c4 10             	add    $0x10,%esp
  107618:	5e                   	pop    %esi
  107619:	5d                   	pop    %ebp
  10761a:	c3                   	ret    
  10761b:	66 90                	xchg   %ax,%ax
  10761d:	66 90                	xchg   %ax,%ax
  10761f:	90                   	nop

00107620 <z_loapic_int_vec_set>:
 */

void z_loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  107620:	55                   	push   %ebp
  107621:	89 e5                	mov    %esp,%ebp
  107623:	56                   	push   %esi
  107624:	83 ec 20             	sub    $0x20,%esp
  107627:	8b 45 0c             	mov    0xc(%ebp),%eax
  10762a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  10762d:	9c                   	pushf  
  10762e:	fa                   	cli    
  10762f:	8f 45 f4             	popl   -0xc(%ebp)
	return key;
  107632:	8b 55 f4             	mov    -0xc(%ebp),%edx
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
  107635:	89 55 f0             	mov    %edx,-0x10(%ebp)
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  107638:	8b 55 08             	mov    0x8(%ebp),%edx
  10763b:	c1 e2 04             	shl    $0x4,%edx
  10763e:	81 c2 20 03 00 00    	add    $0x320,%edx
		     (x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  107644:	8b 75 08             	mov    0x8(%ebp),%esi
  107647:	c1 e6 04             	shl    $0x4,%esi
  10764a:	81 c6 20 03 00 00    	add    $0x320,%esi
  107650:	89 34 24             	mov    %esi,(%esp)
  107653:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107656:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  107659:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10765c:	e8 6f ff ff ff       	call   1075d0 <x86_read_loapic>
  107661:	25 00 ff ff ff       	and    $0xffffff00,%eax
		      ~LOAPIC_VECTOR) | vector);
  107666:	0b 45 0c             	or     0xc(%ebp),%eax
  107669:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  10766c:	89 0c 24             	mov    %ecx,(%esp)
  10766f:	89 44 24 04          	mov    %eax,0x4(%esp)
  107673:	e8 78 ff ff ff       	call   1075f0 <x86_write_loapic>
	irq_unlock(oldLevel);
  107678:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10767b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10767e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107681:	25 00 02 00 00       	and    $0x200,%eax
  107686:	83 f8 00             	cmp    $0x0,%eax
  107689:	0f 84 01 00 00 00    	je     107690 <z_loapic_int_vec_set+0x70>
		__asm__ volatile ("sti" ::: "memory");
  10768f:	fb                   	sti    
}
  107690:	83 c4 20             	add    $0x20,%esp
  107693:	5e                   	pop    %esi
  107694:	5d                   	pop    %ebp
  107695:	c3                   	ret    
  107696:	66 90                	xchg   %ax,%ax
  107698:	66 90                	xchg   %ax,%ax
  10769a:	66 90                	xchg   %ax,%ax
  10769c:	66 90                	xchg   %ax,%ax
  10769e:	66 90                	xchg   %ax,%ax

001076a0 <z_loapic_irq_enable>:
 *
 * @return N/A
 */

void z_loapic_irq_enable(unsigned int irq)
{
  1076a0:	55                   	push   %ebp
  1076a1:	89 e5                	mov    %esp,%ebp
  1076a3:	83 ec 1c             	sub    $0x1c,%esp
  1076a6:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1076a9:	9c                   	pushf  
  1076aa:	fa                   	cli    
  1076ab:	8f 45 f8             	popl   -0x8(%ebp)
	return key;
  1076ae:	8b 4d f8             	mov    -0x8(%ebp),%ecx
	 * and ths assumption concerning LVT spacing.
	 */

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
  1076b1:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  1076b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1076b7:	c1 e1 04             	shl    $0x4,%ecx
  1076ba:	81 c1 20 03 00 00    	add    $0x320,%ecx
		     x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  1076c0:	8b 55 08             	mov    0x8(%ebp),%edx
  1076c3:	c1 e2 04             	shl    $0x4,%edx
  1076c6:	81 c2 20 03 00 00    	add    $0x320,%edx
  1076cc:	89 14 24             	mov    %edx,(%esp)
  1076cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1076d2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1076d5:	e8 f6 fe ff ff       	call   1075d0 <x86_read_loapic>
  1076da:	25 ff ff fe ff       	and    $0xfffeffff,%eax
  1076df:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  1076e2:	89 0c 24             	mov    %ecx,(%esp)
  1076e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076e9:	e8 02 ff ff ff       	call   1075f0 <x86_write_loapic>
		     ~LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
  1076ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1076f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1076f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1076f7:	25 00 02 00 00       	and    $0x200,%eax
  1076fc:	83 f8 00             	cmp    $0x0,%eax
  1076ff:	0f 84 01 00 00 00    	je     107706 <z_loapic_irq_enable+0x66>
		__asm__ volatile ("sti" ::: "memory");
  107705:	fb                   	sti    
}
  107706:	83 c4 1c             	add    $0x1c,%esp
  107709:	5d                   	pop    %ebp
  10770a:	c3                   	ret    
  10770b:	66 90                	xchg   %ax,%ax
  10770d:	66 90                	xchg   %ax,%ax
  10770f:	90                   	nop

00107710 <z_irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int z_irq_controller_isr_vector_get(void)
{
  107710:	55                   	push   %ebp
  107711:	89 e5                	mov    %esp,%ebp
  107713:	83 ec 1c             	sub    $0x1c,%esp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  107716:	c7 45 ec 07 00 00 00 	movl   $0x7,-0x14(%ebp)
  10771d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  107721:	0f 9f c0             	setg   %al
  107724:	34 ff                	xor    $0xff,%al
  107726:	34 ff                	xor    $0xff,%al
  107728:	a8 01                	test   $0x1,%al
  10772a:	0f 85 05 00 00 00    	jne    107735 <z_irq_controller_isr_vector_get+0x25>
  107730:	e9 7e 00 00 00       	jmp    1077b3 <z_irq_controller_isr_vector_get+0xa3>
		pReg = x86_read_loapic(LOAPIC_ISR + (block * 0x10));
  107735:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107738:	c1 e0 04             	shl    $0x4,%eax
  10773b:	05 00 01 00 00       	add    $0x100,%eax
  107740:	89 04 24             	mov    %eax,(%esp)
  107743:	e8 88 fe ff ff       	call   1075d0 <x86_read_loapic>
  107748:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (pReg) {
  10774b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10774f:	0f 84 4b 00 00 00    	je     1077a0 <z_irq_controller_isr_vector_get+0x90>
			return (block * 32) + (find_msb_set(pReg) - 1);
  107755:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107758:	c1 e0 05             	shl    $0x5,%eax
  10775b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10775e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
 * @return most significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_msb_set(u32_t op)
{
	if (op == 0) {
  107761:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  107765:	89 45 e8             	mov    %eax,-0x18(%ebp)
  107768:	0f 85 0c 00 00 00    	jne    10777a <z_irq_controller_isr_vector_get+0x6a>
		return 0;
  10776e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  107775:	e9 13 00 00 00       	jmp    10778d <z_irq_controller_isr_vector_get+0x7d>
	}

	return 32 - __builtin_clz(op);
  10777a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10777d:	0f bd c0             	bsr    %eax,%eax
  107780:	83 f0 1f             	xor    $0x1f,%eax
  107783:	b9 20 00 00 00       	mov    $0x20,%ecx
  107788:	29 c1                	sub    %eax,%ecx
  10778a:	89 4d fc             	mov    %ecx,-0x4(%ebp)
}
  10778d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107790:	83 e8 01             	sub    $0x1,%eax
  107793:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  107796:	01 c1                	add    %eax,%ecx
  107798:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10779b:	e9 1a 00 00 00       	jmp    1077ba <z_irq_controller_isr_vector_get+0xaa>
		}

	}
  1077a0:	e9 00 00 00 00       	jmp    1077a5 <z_irq_controller_isr_vector_get+0x95>
	for (block = 7; likely(block > 0); block--) {
  1077a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1077a8:	83 c0 ff             	add    $0xffffffff,%eax
  1077ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1077ae:	e9 6a ff ff ff       	jmp    10771d <z_irq_controller_isr_vector_get+0xd>
	return -1;
  1077b3:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
}
  1077ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1077bd:	83 c4 1c             	add    $0x1c,%esp
  1077c0:	5d                   	pop    %ebp
  1077c1:	c3                   	ret    
  1077c2:	66 90                	xchg   %ax,%ax
  1077c4:	66 90                	xchg   %ax,%ax
  1077c6:	66 90                	xchg   %ax,%ax
  1077c8:	66 90                	xchg   %ax,%ax
  1077ca:	66 90                	xchg   %ax,%ax
  1077cc:	66 90                	xchg   %ax,%ax
  1077ce:	66 90                	xchg   %ax,%ax

001077d0 <loapic_init>:
{
  1077d0:	55                   	push   %ebp
  1077d1:	89 e5                	mov    %esp,%ebp
  1077d3:	50                   	push   %eax
  1077d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1077d7:	31 c9                	xor    %ecx,%ecx
  1077d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return 0;
  1077dc:	89 c8                	mov    %ecx,%eax
  1077de:	83 c4 04             	add    $0x4,%esp
  1077e1:	5d                   	pop    %ebp
  1077e2:	c3                   	ret    
  1077e3:	66 90                	xchg   %ax,%ax
  1077e5:	66 90                	xchg   %ax,%ax
  1077e7:	66 90                	xchg   %ax,%ax
  1077e9:	66 90                	xchg   %ax,%ax
  1077eb:	66 90                	xchg   %ax,%ax
  1077ed:	66 90                	xchg   %ax,%ax
  1077ef:	90                   	nop

001077f0 <z_irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void z_irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 u32_t flags)
{
  1077f0:	55                   	push   %ebp
  1077f1:	89 e5                	mov    %esp,%ebp
  1077f3:	83 ec 0c             	sub    $0xc,%esp
  1077f6:	8b 45 10             	mov    0x10(%ebp),%eax
  1077f9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1077fc:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
  1077ff:	83 7d 0c 18          	cmpl   $0x18,0xc(%ebp)
  107803:	0f 83 1e 00 00 00    	jae    107827 <z_irq_controller_irq_config+0x37>
		z_ioapic_irq_set(irq, vector, flags);
  107809:	8b 45 0c             	mov    0xc(%ebp),%eax
  10780c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10780f:	8b 55 10             	mov    0x10(%ebp),%edx
  107812:	89 04 24             	mov    %eax,(%esp)
  107815:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107819:	89 54 24 08          	mov    %edx,0x8(%esp)
  10781d:	e8 ae fa ff ff       	call   1072d0 <z_ioapic_irq_set>
	} else {
  107822:	e9 15 00 00 00       	jmp    10783c <z_irq_controller_irq_config+0x4c>
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  107827:	8b 45 0c             	mov    0xc(%ebp),%eax
  10782a:	83 e8 18             	sub    $0x18,%eax
  10782d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107830:	89 04 24             	mov    %eax,(%esp)
  107833:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107837:	e8 e4 fd ff ff       	call   107620 <z_loapic_int_vec_set>
	}
}
  10783c:	83 c4 0c             	add    $0xc,%esp
  10783f:	5d                   	pop    %ebp
  107840:	c3                   	ret    
  107841:	66 90                	xchg   %ax,%ax
  107843:	66 90                	xchg   %ax,%ax
  107845:	66 90                	xchg   %ax,%ax
  107847:	66 90                	xchg   %ax,%ax
  107849:	66 90                	xchg   %ax,%ax
  10784b:	66 90                	xchg   %ax,%ax
  10784d:	66 90                	xchg   %ax,%ax
  10784f:	90                   	nop

00107850 <arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void arch_irq_enable(unsigned int irq)
{
  107850:	55                   	push   %ebp
  107851:	89 e5                	mov    %esp,%ebp
  107853:	50                   	push   %eax
  107854:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  107857:	83 7d 08 18          	cmpl   $0x18,0x8(%ebp)
  10785b:	0f 83 10 00 00 00    	jae    107871 <arch_irq_enable+0x21>
		z_ioapic_irq_enable(irq);
  107861:	8b 45 08             	mov    0x8(%ebp),%eax
  107864:	89 04 24             	mov    %eax,(%esp)
  107867:	e8 c4 f9 ff ff       	call   107230 <z_ioapic_irq_enable>
	} else {
  10786c:	e9 0e 00 00 00       	jmp    10787f <arch_irq_enable+0x2f>
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  107871:	8b 45 08             	mov    0x8(%ebp),%eax
  107874:	83 e8 18             	sub    $0x18,%eax
  107877:	89 04 24             	mov    %eax,(%esp)
  10787a:	e8 21 fe ff ff       	call   1076a0 <z_loapic_irq_enable>
	}
}
  10787f:	83 c4 04             	add    $0x4,%esp
  107882:	5d                   	pop    %ebp
  107883:	c3                   	ret    
  107884:	66 90                	xchg   %ax,%ax
  107886:	66 90                	xchg   %ax,%ax
  107888:	66 90                	xchg   %ax,%ax
  10788a:	66 90                	xchg   %ax,%ax
  10788c:	66 90                	xchg   %ax,%ax
  10788e:	66 90                	xchg   %ax,%ax

00107890 <z_clock_driver_init>:

	TIMER0_CONF_REG = val;
}

int z_clock_driver_init(struct device *device)
{
  107890:	55                   	push   %ebp
  107891:	89 e5                	mov    %esp,%ebp
  107893:	56                   	push   %esi
  107894:	83 ec 24             	sub    $0x24,%esp
  107897:	8b 45 08             	mov    0x8(%ebp),%eax
  10789a:	31 c9                	xor    %ecx,%ecx
  10789c:	0f b6 15 d2 51 12 00 	movzbl 0x1251d2,%edx
  1078a3:	89 e6                	mov    %esp,%esi
  1078a5:	89 16                	mov    %edx,(%esi)
  1078a7:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  1078ae:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
  1078b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1078b8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1078bb:	e8 30 ff ff ff       	call   1077f0 <z_irq_controller_irq_config>
  1078c0:	0f b6 05 d2 51 12 00 	movzbl 0x1251d2,%eax
  1078c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	u32_t hz;

	IRQ_CONNECT(DT_INST_0_INTEL_HPET_IRQ_0,
		    DT_INST_0_INTEL_HPET_IRQ_0_PRIORITY,
		    hpet_isr, 0, 0);
	set_timer0_irq(DT_INST_0_INTEL_HPET_IRQ_0);
  1078ca:	89 e0                	mov    %esp,%eax
  1078cc:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  1078d2:	e8 79 01 00 00       	call   107a50 <set_timer0_irq>
	irq_enable(DT_INST_0_INTEL_HPET_IRQ_0);
  1078d7:	89 e0                	mov    %esp,%eax
  1078d9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  1078df:	e8 6c ff ff ff       	call   107850 <arch_irq_enable>

	/* CLK_PERIOD_REG is in femtoseconds (1e-15 sec) */
	hz = (u32_t)(1000000000000000ull / CLK_PERIOD_REG);
  1078e4:	a1 04 00 d0 fe       	mov    0xfed00004,%eax
  1078e9:	89 e1                	mov    %esp,%ecx
  1078eb:	89 41 08             	mov    %eax,0x8(%ecx)
  1078ee:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
  1078f5:	c7 41 04 7e 8d 03 00 	movl   $0x38d7e,0x4(%ecx)
  1078fc:	c7 01 00 80 c6 a4    	movl   $0xa4c68000,(%ecx)
  107902:	e8 c9 87 ff ff       	call   1000d0 <__udivdi3>
  107907:	89 45 f8             	mov    %eax,-0x8(%ebp)
	z_clock_hw_cycles_per_sec = hz;
  10790a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10790d:	a3 a8 33 14 00       	mov    %eax,0x1433a8
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  107912:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107915:	31 d2                	xor    %edx,%edx
  107917:	b9 64 00 00 00       	mov    $0x64,%ecx
  10791c:	f7 f1                	div    %ecx
  10791e:	a3 1c 51 13 00       	mov    %eax,0x13511c
	 * nothing in Zephyr disables the PIT which then fires
	 * interrupts into the same IRQ.  But that means we're then
	 * forced to use IRQ2 contra the way the kconfig IRQ selection
	 * is supposed to work.  Should fix this.
	 */
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
  107923:	b8 10 00 d0 fe       	mov    $0xfed00010,%eax
  107928:	8b 08                	mov    (%eax),%ecx
  10792a:	83 c9 03             	or     $0x3,%ecx
  10792d:	89 08                	mov    %ecx,(%eax)
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
  10792f:	b8 00 01 d0 fe       	mov    $0xfed00100,%eax
  107934:	8b 08                	mov    (%eax),%ecx
  107936:	83 e1 f7             	and    $0xfffffff7,%ecx
  107939:	89 08                	mov    %ecx,(%eax)
	TIMER0_CONF_REG |= TCONF_MODE32;
  10793b:	8b 08                	mov    (%eax),%ecx
  10793d:	81 c9 00 01 00 00    	or     $0x100,%ecx
  107943:	89 08                	mov    %ecx,(%eax)

	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
  107945:	b9 ff ff ff 7f       	mov    $0x7fffffff,%ecx
  10794a:	2b 0d 1c 51 13 00    	sub    0x13511c,%ecx
  107950:	89 45 e8             	mov    %eax,-0x18(%ebp)
  107953:	89 c8                	mov    %ecx,%eax
  107955:	31 c9                	xor    %ecx,%ecx
  107957:	89 ca                	mov    %ecx,%edx
  107959:	f7 35 1c 51 13 00    	divl   0x13511c
  10795f:	a3 20 51 13 00       	mov    %eax,0x135120
	last_count = MAIN_COUNTER_REG;
  107964:	b8 f0 00 d0 fe       	mov    $0xfed000f0,%eax
  107969:	8b 08                	mov    (%eax),%ecx
  10796b:	89 0d 24 51 13 00    	mov    %ecx,0x135124
  107971:	8b 4d e8             	mov    -0x18(%ebp),%ecx

	TIMER0_CONF_REG |= TCONF_INT_ENABLE;
  107974:	8b 31                	mov    (%ecx),%esi
  107976:	83 ce 04             	or     $0x4,%esi
  107979:	89 31                	mov    %esi,(%ecx)
	TIMER0_COMPARATOR_REG = MAIN_COUNTER_REG + cyc_per_tick;
  10797b:	8b 00                	mov    (%eax),%eax
  10797d:	03 05 1c 51 13 00    	add    0x13511c,%eax
  107983:	be 08 01 d0 fe       	mov    $0xfed00108,%esi
  107988:	89 06                	mov    %eax,(%esi)
  10798a:	8b 45 ec             	mov    -0x14(%ebp),%eax

	return 0;
  10798d:	83 c4 24             	add    $0x24,%esp
  107990:	5e                   	pop    %esi
  107991:	5d                   	pop    %ebp
  107992:	c3                   	ret    
  107993:	66 90                	xchg   %ax,%ax
  107995:	66 90                	xchg   %ax,%ax
  107997:	66 90                	xchg   %ax,%ax
  107999:	66 90                	xchg   %ax,%ax
  10799b:	66 90                	xchg   %ax,%ax
  10799d:	66 90                	xchg   %ax,%ax
  10799f:	90                   	nop

001079a0 <hpet_isr>:
{
  1079a0:	55                   	push   %ebp
  1079a1:	89 e5                	mov    %esp,%ebp
  1079a3:	83 e4 f8             	and    $0xfffffff8,%esp
  1079a6:	83 ec 30             	sub    $0x30,%esp
  1079a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1079ac:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  1079b0:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  1079b4:	8d 0d e9 96 13 00    	lea    0x1396e9,%ecx
  1079ba:	89 4c 24 18          	mov    %ecx,0x18(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1079be:	9c                   	pushf  
  1079bf:	fa                   	cli    
  1079c0:	8f 44 24 20          	popl   0x20(%esp)
	return key;
  1079c4:	8b 4c 24 20          	mov    0x20(%esp),%ecx

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
  1079c8:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	u32_t now = MAIN_COUNTER_REG;
  1079cc:	b9 f0 00 d0 fe       	mov    $0xfed000f0,%ecx
  1079d1:	8b 09                	mov    (%ecx),%ecx
  1079d3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	u32_t dticks = (now - last_count) / cyc_per_tick;
  1079d7:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1079db:	2b 0d 24 51 13 00    	sub    0x135124,%ecx
  1079e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1079e5:	89 c8                	mov    %ecx,%eax
  1079e7:	31 d2                	xor    %edx,%edx
  1079e9:	f7 35 1c 51 13 00    	divl   0x13511c
  1079ef:	89 44 24 08          	mov    %eax,0x8(%esp)
	last_count += dticks * cyc_per_tick;
  1079f3:	8b 44 24 08          	mov    0x8(%esp),%eax
  1079f7:	0f af 05 1c 51 13 00 	imul   0x13511c,%eax
  1079fe:	03 05 24 51 13 00    	add    0x135124,%eax
  107a04:	a3 24 51 13 00       	mov    %eax,0x135124
	k_spin_unlock(&lock, key);
  107a09:	8b 44 24 10          	mov    0x10(%esp),%eax
  107a0d:	89 44 24 28          	mov    %eax,0x28(%esp)
  107a11:	8d 05 e9 96 13 00    	lea    0x1396e9,%eax
  107a17:	89 44 24 24          	mov    %eax,0x24(%esp)
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
  107a1b:	8b 44 24 28          	mov    0x28(%esp),%eax
  107a1f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  107a23:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  107a27:	25 00 02 00 00       	and    $0x200,%eax
  107a2c:	83 f8 00             	cmp    $0x0,%eax
  107a2f:	0f 84 01 00 00 00    	je     107a36 <hpet_isr+0x96>
		__asm__ volatile ("sti" ::: "memory");
  107a35:	fb                   	sti    
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
  107a36:	8b 44 24 08          	mov    0x8(%esp),%eax
  107a3a:	89 04 24             	mov    %eax,(%esp)
  107a3d:	e8 2e 9d 01 00       	call   121770 <z_clock_announce>
}
  107a42:	89 ec                	mov    %ebp,%esp
  107a44:	5d                   	pop    %ebp
  107a45:	c3                   	ret    
  107a46:	66 90                	xchg   %ax,%ax
  107a48:	66 90                	xchg   %ax,%ax
  107a4a:	66 90                	xchg   %ax,%ax
  107a4c:	66 90                	xchg   %ax,%ax
  107a4e:	66 90                	xchg   %ax,%ax

00107a50 <set_timer0_irq>:
{
  107a50:	55                   	push   %ebp
  107a51:	89 e5                	mov    %esp,%ebp
  107a53:	56                   	push   %esi
  107a54:	50                   	push   %eax
  107a55:	8b 45 08             	mov    0x8(%ebp),%eax
	u32_t val = (TIMER0_CONF_REG & ~(0x1f << 9)) | ((irq & 0x1f) << 9);
  107a58:	b9 00 01 d0 fe       	mov    $0xfed00100,%ecx
  107a5d:	8b 11                	mov    (%ecx),%edx
  107a5f:	81 e2 ff c1 ff ff    	and    $0xffffc1ff,%edx
  107a65:	8b 75 08             	mov    0x8(%ebp),%esi
  107a68:	83 e6 1f             	and    $0x1f,%esi
  107a6b:	c1 e6 09             	shl    $0x9,%esi
  107a6e:	09 f2                	or     %esi,%edx
  107a70:	89 55 f8             	mov    %edx,-0x8(%ebp)
	TIMER0_CONF_REG = val;
  107a73:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107a76:	89 11                	mov    %edx,(%ecx)
}
  107a78:	83 c4 04             	add    $0x4,%esp
  107a7b:	5e                   	pop    %esi
  107a7c:	5d                   	pop    %ebp
  107a7d:	c3                   	ret    
  107a7e:	66 90                	xchg   %ax,%ax

00107a80 <z_clock_set_timeout>:
	 * nothing to do at initialization on auxiliary CPUs.
	 */
}

void z_clock_set_timeout(s32_t ticks, bool idle)
{
  107a80:	55                   	push   %ebp
  107a81:	89 e5                	mov    %esp,%ebp
  107a83:	83 e4 f8             	and    $0xfffffff8,%esp
  107a86:	83 ec 38             	sub    $0x38,%esp
  107a89:	8a 45 0c             	mov    0xc(%ebp),%al
  107a8c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107a8f:	24 01                	and    $0x1,%al
  107a91:	88 44 24 1f          	mov    %al,0x1f(%esp)
	ARG_UNUSED(idle);

#if defined(CONFIG_TICKLESS_KERNEL) && !defined(CONFIG_QEMU_TICKLESS_WORKAROUND)
	if (ticks == K_FOREVER && idle) {
  107a95:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
  107a99:	0f 85 1c 00 00 00    	jne    107abb <z_clock_set_timeout+0x3b>
  107a9f:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  107aa4:	0f 84 11 00 00 00    	je     107abb <z_clock_set_timeout+0x3b>
		GENERAL_CONF_REG &= ~GCONF_ENABLE;
  107aaa:	b8 10 00 d0 fe       	mov    $0xfed00010,%eax
  107aaf:	8b 08                	mov    (%eax),%ecx
  107ab1:	83 e1 fe             	and    $0xfffffffe,%ecx
  107ab4:	89 08                	mov    %ecx,(%eax)
		return;
  107ab6:	e9 74 01 00 00       	jmp    107c2f <z_clock_set_timeout+0x1af>
	}

	ticks = ticks == K_FOREVER ? max_ticks : ticks;
  107abb:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
  107abf:	0f 85 0e 00 00 00    	jne    107ad3 <z_clock_set_timeout+0x53>
  107ac5:	a1 20 51 13 00       	mov    0x135120,%eax
  107aca:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107ace:	e9 07 00 00 00       	jmp    107ada <z_clock_set_timeout+0x5a>
  107ad3:	8b 45 08             	mov    0x8(%ebp),%eax
  107ad6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107ada:	8b 44 24 0c          	mov    0xc(%esp),%eax
  107ade:	89 45 08             	mov    %eax,0x8(%ebp)
	ticks = MAX(MIN(ticks - 1, (s32_t)max_ticks), 0);
  107ae1:	8b 45 08             	mov    0x8(%ebp),%eax
  107ae4:	83 e8 01             	sub    $0x1,%eax
  107ae7:	3b 05 20 51 13 00    	cmp    0x135120,%eax
  107aed:	0f 8d 0f 00 00 00    	jge    107b02 <z_clock_set_timeout+0x82>
  107af3:	8b 45 08             	mov    0x8(%ebp),%eax
  107af6:	83 e8 01             	sub    $0x1,%eax
  107af9:	89 44 24 08          	mov    %eax,0x8(%esp)
  107afd:	e9 09 00 00 00       	jmp    107b0b <z_clock_set_timeout+0x8b>
  107b02:	a1 20 51 13 00       	mov    0x135120,%eax
  107b07:	89 44 24 08          	mov    %eax,0x8(%esp)
  107b0b:	8b 44 24 08          	mov    0x8(%esp),%eax
  107b0f:	83 f8 00             	cmp    $0x0,%eax
  107b12:	0f 8e 36 00 00 00    	jle    107b4e <z_clock_set_timeout+0xce>
  107b18:	8b 45 08             	mov    0x8(%ebp),%eax
  107b1b:	83 e8 01             	sub    $0x1,%eax
  107b1e:	3b 05 20 51 13 00    	cmp    0x135120,%eax
  107b24:	0f 8d 0f 00 00 00    	jge    107b39 <z_clock_set_timeout+0xb9>
  107b2a:	8b 45 08             	mov    0x8(%ebp),%eax
  107b2d:	83 e8 01             	sub    $0x1,%eax
  107b30:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b34:	e9 09 00 00 00       	jmp    107b42 <z_clock_set_timeout+0xc2>
  107b39:	a1 20 51 13 00       	mov    0x135120,%eax
  107b3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b42:	8b 44 24 04          	mov    0x4(%esp),%eax
  107b46:	89 04 24             	mov    %eax,(%esp)
  107b49:	e9 0a 00 00 00       	jmp    107b58 <z_clock_set_timeout+0xd8>
  107b4e:	31 c0                	xor    %eax,%eax
  107b50:	89 04 24             	mov    %eax,(%esp)
  107b53:	e9 00 00 00 00       	jmp    107b58 <z_clock_set_timeout+0xd8>
  107b58:	8b 04 24             	mov    (%esp),%eax
  107b5b:	89 45 08             	mov    %eax,0x8(%ebp)
  107b5e:	8d 44 24 18          	lea    0x18(%esp),%eax
  107b62:	89 44 24 24          	mov    %eax,0x24(%esp)
  107b66:	8d 05 e9 96 13 00    	lea    0x1396e9,%eax
  107b6c:	89 44 24 20          	mov    %eax,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  107b70:	9c                   	pushf  
  107b71:	fa                   	cli    
  107b72:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  107b76:	8b 44 24 28          	mov    0x28(%esp),%eax
	k.key = arch_irq_lock();
  107b7a:	89 44 24 18          	mov    %eax,0x18(%esp)

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t now = MAIN_COUNTER_REG, cyc;
  107b7e:	b8 f0 00 d0 fe       	mov    $0xfed000f0,%eax
  107b83:	8b 00                	mov    (%eax),%eax
  107b85:	89 44 24 14          	mov    %eax,0x14(%esp)

	/* Round up to next tick boundary */
	cyc = ticks * cyc_per_tick + (now - last_count) + (cyc_per_tick - 1);
  107b89:	8b 45 08             	mov    0x8(%ebp),%eax
  107b8c:	0f af 05 1c 51 13 00 	imul   0x13511c,%eax
  107b93:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  107b97:	2b 0d 24 51 13 00    	sub    0x135124,%ecx
  107b9d:	01 c8                	add    %ecx,%eax
  107b9f:	8b 0d 1c 51 13 00    	mov    0x13511c,%ecx
  107ba5:	83 e9 01             	sub    $0x1,%ecx
  107ba8:	01 c8                	add    %ecx,%eax
  107baa:	89 44 24 10          	mov    %eax,0x10(%esp)
	cyc = (cyc / cyc_per_tick) * cyc_per_tick;
  107bae:	8b 44 24 10          	mov    0x10(%esp),%eax
  107bb2:	31 d2                	xor    %edx,%edx
  107bb4:	f7 35 1c 51 13 00    	divl   0x13511c
  107bba:	0f af 05 1c 51 13 00 	imul   0x13511c,%eax
  107bc1:	89 44 24 10          	mov    %eax,0x10(%esp)
	cyc += last_count;
  107bc5:	a1 24 51 13 00       	mov    0x135124,%eax
  107bca:	03 44 24 10          	add    0x10(%esp),%eax
  107bce:	89 44 24 10          	mov    %eax,0x10(%esp)

	if ((cyc - now) < MIN_DELAY) {
  107bd2:	8b 44 24 10          	mov    0x10(%esp),%eax
  107bd6:	2b 44 24 14          	sub    0x14(%esp),%eax
  107bda:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  107bdf:	0f 83 0d 00 00 00    	jae    107bf2 <z_clock_set_timeout+0x172>
		cyc += cyc_per_tick;
  107be5:	a1 1c 51 13 00       	mov    0x13511c,%eax
  107bea:	03 44 24 10          	add    0x10(%esp),%eax
  107bee:	89 44 24 10          	mov    %eax,0x10(%esp)
	}

	TIMER0_COMPARATOR_REG = cyc;
  107bf2:	8b 44 24 10          	mov    0x10(%esp),%eax
  107bf6:	b9 08 01 d0 fe       	mov    $0xfed00108,%ecx
  107bfb:	89 01                	mov    %eax,(%ecx)
	k_spin_unlock(&lock, key);
  107bfd:	8b 44 24 18          	mov    0x18(%esp),%eax
  107c01:	89 44 24 30          	mov    %eax,0x30(%esp)
  107c05:	8d 05 e9 96 13 00    	lea    0x1396e9,%eax
  107c0b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  107c0f:	8b 44 24 30          	mov    0x30(%esp),%eax
  107c13:	89 44 24 34          	mov    %eax,0x34(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  107c17:	8b 44 24 34          	mov    0x34(%esp),%eax
  107c1b:	25 00 02 00 00       	and    $0x200,%eax
  107c20:	83 f8 00             	cmp    $0x0,%eax
  107c23:	0f 84 01 00 00 00    	je     107c2a <z_clock_set_timeout+0x1aa>
		__asm__ volatile ("sti" ::: "memory");
  107c29:	fb                   	sti    
#endif
}
  107c2a:	e9 00 00 00 00       	jmp    107c2f <z_clock_set_timeout+0x1af>
  107c2f:	89 ec                	mov    %ebp,%esp
  107c31:	5d                   	pop    %ebp
  107c32:	c3                   	ret    
  107c33:	66 90                	xchg   %ax,%ax
  107c35:	66 90                	xchg   %ax,%ax
  107c37:	66 90                	xchg   %ax,%ax
  107c39:	66 90                	xchg   %ax,%ax
  107c3b:	66 90                	xchg   %ax,%ax
  107c3d:	66 90                	xchg   %ax,%ax
  107c3f:	90                   	nop

00107c40 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
  107c40:	55                   	push   %ebp
  107c41:	89 e5                	mov    %esp,%ebp
  107c43:	83 e4 f8             	and    $0xfffffff8,%esp
  107c46:	83 ec 28             	sub    $0x28,%esp
  107c49:	8d 44 24 08          	lea    0x8(%esp),%eax
  107c4d:	89 44 24 14          	mov    %eax,0x14(%esp)
  107c51:	8d 05 e9 96 13 00    	lea    0x1396e9,%eax
  107c57:	89 44 24 10          	mov    %eax,0x10(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  107c5b:	9c                   	pushf  
  107c5c:	fa                   	cli    
  107c5d:	8f 44 24 18          	popl   0x18(%esp)
	return key;
  107c61:	8b 44 24 18          	mov    0x18(%esp),%eax
	k.key = arch_irq_lock();
  107c65:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = (MAIN_COUNTER_REG - last_count) / cyc_per_tick;
  107c69:	b8 f0 00 d0 fe       	mov    $0xfed000f0,%eax
  107c6e:	8b 00                	mov    (%eax),%eax
  107c70:	2b 05 24 51 13 00    	sub    0x135124,%eax
  107c76:	31 d2                	xor    %edx,%edx
  107c78:	f7 35 1c 51 13 00    	divl   0x13511c
  107c7e:	89 44 24 04          	mov    %eax,0x4(%esp)

	k_spin_unlock(&lock, key);
  107c82:	8b 44 24 08          	mov    0x8(%esp),%eax
  107c86:	89 44 24 20          	mov    %eax,0x20(%esp)
  107c8a:	8d 05 e9 96 13 00    	lea    0x1396e9,%eax
  107c90:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	arch_irq_unlock(key.key);
  107c94:	8b 44 24 20          	mov    0x20(%esp),%eax
  107c98:	89 44 24 24          	mov    %eax,0x24(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  107c9c:	8b 44 24 24          	mov    0x24(%esp),%eax
  107ca0:	25 00 02 00 00       	and    $0x200,%eax
  107ca5:	83 f8 00             	cmp    $0x0,%eax
  107ca8:	0f 84 01 00 00 00    	je     107caf <z_clock_elapsed+0x6f>
		__asm__ volatile ("sti" ::: "memory");
  107cae:	fb                   	sti    
	return ret;
  107caf:	8b 44 24 04          	mov    0x4(%esp),%eax
  107cb3:	89 ec                	mov    %ebp,%esp
  107cb5:	5d                   	pop    %ebp
  107cb6:	c3                   	ret    
  107cb7:	66 90                	xchg   %ax,%ax
  107cb9:	66 90                	xchg   %ax,%ax
  107cbb:	66 90                	xchg   %ax,%ax
  107cbd:	66 90                	xchg   %ax,%ax
  107cbf:	90                   	nop

00107cc0 <z_timer_cycle_get_32>:
}

u32_t z_timer_cycle_get_32(void)
{
  107cc0:	55                   	push   %ebp
  107cc1:	89 e5                	mov    %esp,%ebp
	return MAIN_COUNTER_REG;
  107cc3:	b8 f0 00 d0 fe       	mov    $0xfed000f0,%eax
  107cc8:	8b 00                	mov    (%eax),%eax
  107cca:	5d                   	pop    %ebp
  107ccb:	c3                   	ret    
  107ccc:	66 90                	xchg   %ax,%ax
  107cce:	66 90                	xchg   %ax,%ax

00107cd0 <arch_cpu_idle>:
#include <zephyr.h>
#include <debug/tracing.h>
#include <arch/cpu.h>

void arch_cpu_idle(void)
{
  107cd0:	55                   	push   %ebp
  107cd1:	89 e5                	mov    %esp,%ebp
	sys_trace_idle();
	__asm__ volatile (
  107cd3:	fb                   	sti    
  107cd4:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  107cd5:	5d                   	pop    %ebp
  107cd6:	c3                   	ret    
  107cd7:	66 90                	xchg   %ax,%ax
  107cd9:	66 90                	xchg   %ax,%ax
  107cdb:	66 90                	xchg   %ax,%ax
  107cdd:	66 90                	xchg   %ax,%ax
  107cdf:	90                   	nop

00107ce0 <z_x86_prep_c>:
#include <arch/x86/multiboot.h>

extern FUNC_NORETURN void z_cstart(void);

FUNC_NORETURN void z_x86_prep_c(int unused, struct multiboot_info *info)
{
  107ce0:	55                   	push   %ebp
  107ce1:	89 e5                	mov    %esp,%ebp
  107ce3:	83 ec 0c             	sub    $0xc,%esp
  107ce6:	8b 45 0c             	mov    0xc(%ebp),%eax
  107ce9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	ARG_UNUSED(unused);

	_kernel.cpus[0].nested = 0;
  107cec:	c7 05 a8 96 13 00 00 	movl   $0x0,0x1396a8
  107cf3:	00 00 00 
	_kernel.cpus[0].irq_stack = Z_THREAD_STACK_BUFFER(_interrupt_stack) +
  107cf6:	8d 15 90 1b 14 00    	lea    0x141b90,%edx
  107cfc:	89 14 24             	mov    %edx,(%esp)
  107cff:	89 45 fc             	mov    %eax,-0x4(%ebp)
  107d02:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  107d05:	e8 26 00 00 00       	call   107d30 <Z_THREAD_STACK_BUFFER>
  107d0a:	05 00 08 00 00       	add    $0x800,%eax
  107d0f:	a3 ac 96 13 00       	mov    %eax,0x1396ac
					CONFIG_ISR_STACK_SIZE;

#ifdef CONFIG_X86_VERY_EARLY_CONSOLE
	z_x86_early_serial_init();
  107d14:	e8 57 19 00 00       	call   109670 <z_x86_early_serial_init>
#ifdef CONFIG_ACPI
	z_acpi_init();
#endif

#ifdef CONFIG_X86_MMU
	z_x86_paging_init();
  107d19:	e8 e2 14 00 00       	call   109200 <z_x86_paging_init>

#if defined(CONFIG_SMP)
	z_x86_ipi_setup();
#endif

	z_cstart();
  107d1e:	e8 8d 4f 01 00       	call   11ccb0 <z_cstart>
  107d23:	66 90                	xchg   %ax,%ax
  107d25:	66 90                	xchg   %ax,%ax
  107d27:	66 90                	xchg   %ax,%ax
  107d29:	66 90                	xchg   %ax,%ax
  107d2b:	66 90                	xchg   %ax,%ax
  107d2d:	66 90                	xchg   %ax,%ax
  107d2f:	90                   	nop

00107d30 <Z_THREAD_STACK_BUFFER>:
#define K_THREAD_STACK_LEN(size) ARCH_THREAD_STACK_LEN(size)
#define K_THREAD_STACK_MEMBER(sym, size) ARCH_THREAD_STACK_MEMBER(sym, size)
#define K_THREAD_STACK_SIZEOF(sym) ARCH_THREAD_STACK_SIZEOF(sym)
#define K_THREAD_STACK_RESERVED ARCH_THREAD_STACK_RESERVED
static inline char *Z_THREAD_STACK_BUFFER(k_thread_stack_t *sym)
{
  107d30:	55                   	push   %ebp
  107d31:	89 e5                	mov    %esp,%ebp
  107d33:	50                   	push   %eax
  107d34:	8b 45 08             	mov    0x8(%ebp),%eax
	return ARCH_THREAD_STACK_BUFFER(sym);
  107d37:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107d3a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  107d3d:	89 c8                	mov    %ecx,%eax
  107d3f:	83 c4 04             	add    $0x4,%esp
  107d42:	5d                   	pop    %ebp
  107d43:	c3                   	ret    
  107d44:	66 90                	xchg   %ax,%ax
  107d46:	66 90                	xchg   %ax,%ax
  107d48:	66 90                	xchg   %ax,%ax
  107d4a:	66 90                	xchg   %ax,%ax
  107d4c:	66 90                	xchg   %ax,%ax
  107d4e:	66 90                	xchg   %ax,%ax

00107d50 <z_x86_fatal_error>:
}
#endif /* CONFIG_X86_64 */

FUNC_NORETURN void z_x86_fatal_error(unsigned int reason,
				     const z_arch_esf_t *esf)
{
  107d50:	55                   	push   %ebp
  107d51:	89 e5                	mov    %esp,%ebp
  107d53:	83 ec 08             	sub    $0x8,%esp
  107d56:	8b 45 0c             	mov    0xc(%ebp),%eax
  107d59:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (esf != NULL) {
  107d5c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  107d60:	0f 84 0b 00 00 00    	je     107d71 <z_x86_fatal_error+0x21>
		dump_regs(esf);
  107d66:	8b 45 0c             	mov    0xc(%ebp),%eax
  107d69:	89 04 24             	mov    %eax,(%esp)
  107d6c:	e8 1f 00 00 00       	call   107d90 <dump_regs>
	}

	z_fatal_error(reason, esf);
  107d71:	8b 45 08             	mov    0x8(%ebp),%eax
  107d74:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  107d77:	89 04 24             	mov    %eax,(%esp)
  107d7a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107d7e:	e8 9d 4b 01 00       	call   11c920 <z_fatal_error>
  107d83:	66 90                	xchg   %ax,%ax
  107d85:	66 90                	xchg   %ax,%ax
  107d87:	66 90                	xchg   %ax,%ax
  107d89:	66 90                	xchg   %ax,%ax
  107d8b:	66 90                	xchg   %ax,%ax
  107d8d:	66 90                	xchg   %ax,%ax
  107d8f:	90                   	nop

00107d90 <dump_regs>:
{
  107d90:	55                   	push   %ebp
  107d91:	89 e5                	mov    %esp,%ebp
  107d93:	53                   	push   %ebx
  107d94:	57                   	push   %edi
  107d95:	56                   	push   %esi
  107d96:	83 e4 f8             	and    $0xfffffff8,%esp
  107d99:	83 ec 70             	sub    $0x70,%esp
  107d9c:	8b 45 08             	mov    0x8(%ebp),%eax
	LOG_ERR("EAX: 0x%08x, EBX: 0x%08x, ECX: 0x%08x, EDX: 0x%08x",
  107d9f:	e8 8c 08 00 00       	call   108630 <_is_user_context>
  107da4:	24 01                	and    $0x1,%al
  107da6:	88 44 24 6b          	mov    %al,0x6b(%esp)
  107daa:	f6 44 24 6b 01       	testb  $0x1,0x6b(%esp)
  107daf:	0f 85 0f 00 00 00    	jne    107dc4 <dump_regs+0x34>
  107db5:	b0 01                	mov    $0x1,%al
  107db7:	a8 01                	test   $0x1,%al
  107db9:	0f 85 05 00 00 00    	jne    107dc4 <dump_regs+0x34>
  107dbf:	e9 ff 00 00 00       	jmp    107ec3 <dump_regs+0x133>
  107dc4:	66 8b 44 24 68       	mov    0x68(%esp),%ax
  107dc9:	66 83 e0 f8          	and    $0xfff8,%ax
  107dcd:	66 83 c8 01          	or     $0x1,%ax
  107dd1:	66 89 44 24 68       	mov    %ax,0x68(%esp)
  107dd6:	66 8b 44 24 68       	mov    0x68(%esp),%ax
  107ddb:	66 83 e0 c7          	and    $0xffc7,%ax
  107ddf:	66 89 44 24 68       	mov    %ax,0x68(%esp)
  107de4:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  107dea:	89 0c 24             	mov    %ecx,(%esp)
  107ded:	e8 4e 08 00 00       	call   108640 <log_const_source_id>
  107df2:	66 8b 54 24 68       	mov    0x68(%esp),%dx
  107df7:	66 25 ff 03          	and    $0x3ff,%ax
  107dfb:	66 c1 e0 06          	shl    $0x6,%ax
  107dff:	66 83 e2 3f          	and    $0x3f,%dx
  107e03:	66 09 c2             	or     %ax,%dx
  107e06:	66 89 54 24 68       	mov    %dx,0x68(%esp)
  107e0b:	f6 44 24 6b 01       	testb  $0x1,0x6b(%esp)
  107e10:	0f 84 47 00 00 00    	je     107e5d <dump_regs+0xcd>
  107e16:	8b 45 08             	mov    0x8(%ebp),%eax
  107e19:	8b 40 18             	mov    0x18(%eax),%eax
  107e1c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107e1f:	8b 49 08             	mov    0x8(%ecx),%ecx
  107e22:	8b 55 08             	mov    0x8(%ebp),%edx
  107e25:	8b 52 1c             	mov    0x1c(%edx),%edx
  107e28:	8b 75 08             	mov    0x8(%ebp),%esi
  107e2b:	8b 76 14             	mov    0x14(%esi),%esi
  107e2e:	8d 7c 24 68          	lea    0x68(%esp),%edi
  107e32:	66 8b 1f             	mov    (%edi),%bx
  107e35:	66 89 1c 24          	mov    %bx,(%esp)
  107e39:	8d 3d 0a 38 12 00    	lea    0x12380a,%edi
  107e3f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  107e43:	89 44 24 08          	mov    %eax,0x8(%esp)
  107e47:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  107e4b:	89 54 24 10          	mov    %edx,0x10(%esp)
  107e4f:	89 74 24 14          	mov    %esi,0x14(%esp)
  107e53:	e8 e8 c1 ff ff       	call   104040 <log_from_user>
  107e58:	e9 5c 00 00 00       	jmp    107eb9 <dump_regs+0x129>
  107e5d:	e9 00 00 00 00       	jmp    107e62 <dump_regs+0xd2>
  107e62:	8d 44 24 58          	lea    0x58(%esp),%eax
  107e66:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107e69:	8b 49 18             	mov    0x18(%ecx),%ecx
  107e6c:	89 4c 24 58          	mov    %ecx,0x58(%esp)
  107e70:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107e73:	8b 49 08             	mov    0x8(%ecx),%ecx
  107e76:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
  107e7a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107e7d:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  107e80:	89 4c 24 60          	mov    %ecx,0x60(%esp)
  107e84:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107e87:	8b 49 14             	mov    0x14(%ecx),%ecx
  107e8a:	89 4c 24 64          	mov    %ecx,0x64(%esp)
  107e8e:	8d 0d 0a 38 12 00    	lea    0x12380a,%ecx
  107e94:	89 0c 24             	mov    %ecx,(%esp)
  107e97:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e9b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107ea2:	00 
  107ea3:	8d 44 24 68          	lea    0x68(%esp),%eax
  107ea7:	66 8b 10             	mov    (%eax),%dx
  107eaa:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
  107eaf:	e8 5c b7 ff ff       	call   103610 <log_n>
  107eb4:	e9 00 00 00 00       	jmp    107eb9 <dump_regs+0x129>
  107eb9:	e9 00 00 00 00       	jmp    107ebe <dump_regs+0x12e>
  107ebe:	e9 00 00 00 00       	jmp    107ec3 <dump_regs+0x133>
  107ec3:	e9 00 00 00 00       	jmp    107ec8 <dump_regs+0x138>
	LOG_ERR("ESI: 0x%08x, EDI: 0x%08x, EBP: 0x%08x, ESP: 0x%08x",
  107ec8:	e9 00 00 00 00       	jmp    107ecd <dump_regs+0x13d>
  107ecd:	e8 5e 07 00 00       	call   108630 <_is_user_context>
  107ed2:	24 01                	and    $0x1,%al
  107ed4:	88 44 24 57          	mov    %al,0x57(%esp)
  107ed8:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  107edd:	0f 85 0f 00 00 00    	jne    107ef2 <dump_regs+0x162>
  107ee3:	b0 01                	mov    $0x1,%al
  107ee5:	a8 01                	test   $0x1,%al
  107ee7:	0f 85 05 00 00 00    	jne    107ef2 <dump_regs+0x162>
  107eed:	e9 fd 00 00 00       	jmp    107fef <dump_regs+0x25f>
  107ef2:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  107ef7:	66 83 e0 f8          	and    $0xfff8,%ax
  107efb:	66 83 c8 01          	or     $0x1,%ax
  107eff:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  107f04:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  107f09:	66 83 e0 c7          	and    $0xffc7,%ax
  107f0d:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  107f12:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  107f18:	89 0c 24             	mov    %ecx,(%esp)
  107f1b:	e8 20 07 00 00       	call   108640 <log_const_source_id>
  107f20:	66 8b 54 24 50       	mov    0x50(%esp),%dx
  107f25:	66 25 ff 03          	and    $0x3ff,%ax
  107f29:	66 c1 e0 06          	shl    $0x6,%ax
  107f2d:	66 83 e2 3f          	and    $0x3f,%dx
  107f31:	66 09 c2             	or     %ax,%dx
  107f34:	66 89 54 24 50       	mov    %dx,0x50(%esp)
  107f39:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  107f3e:	0f 84 46 00 00 00    	je     107f8a <dump_regs+0x1fa>
  107f44:	8b 45 08             	mov    0x8(%ebp),%eax
  107f47:	8b 40 0c             	mov    0xc(%eax),%eax
  107f4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107f4d:	8b 49 10             	mov    0x10(%ecx),%ecx
  107f50:	8b 55 08             	mov    0x8(%ebp),%edx
  107f53:	8b 52 04             	mov    0x4(%edx),%edx
  107f56:	8b 75 08             	mov    0x8(%ebp),%esi
  107f59:	8b 36                	mov    (%esi),%esi
  107f5b:	8d 7c 24 50          	lea    0x50(%esp),%edi
  107f5f:	66 8b 1f             	mov    (%edi),%bx
  107f62:	66 89 1c 24          	mov    %bx,(%esp)
  107f66:	8d 3d 3d 38 12 00    	lea    0x12383d,%edi
  107f6c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  107f70:	89 44 24 08          	mov    %eax,0x8(%esp)
  107f74:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  107f78:	89 54 24 10          	mov    %edx,0x10(%esp)
  107f7c:	89 74 24 14          	mov    %esi,0x14(%esp)
  107f80:	e8 bb c0 ff ff       	call   104040 <log_from_user>
  107f85:	e9 5b 00 00 00       	jmp    107fe5 <dump_regs+0x255>
  107f8a:	e9 00 00 00 00       	jmp    107f8f <dump_regs+0x1ff>
  107f8f:	8d 44 24 40          	lea    0x40(%esp),%eax
  107f93:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107f96:	8b 49 0c             	mov    0xc(%ecx),%ecx
  107f99:	89 4c 24 40          	mov    %ecx,0x40(%esp)
  107f9d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107fa0:	8b 49 10             	mov    0x10(%ecx),%ecx
  107fa3:	89 4c 24 44          	mov    %ecx,0x44(%esp)
  107fa7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107faa:	8b 49 04             	mov    0x4(%ecx),%ecx
  107fad:	89 4c 24 48          	mov    %ecx,0x48(%esp)
  107fb1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107fb4:	8b 09                	mov    (%ecx),%ecx
  107fb6:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
  107fba:	8d 0d 3d 38 12 00    	lea    0x12383d,%ecx
  107fc0:	89 0c 24             	mov    %ecx,(%esp)
  107fc3:	89 44 24 04          	mov    %eax,0x4(%esp)
  107fc7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  107fce:	00 
  107fcf:	8d 44 24 50          	lea    0x50(%esp),%eax
  107fd3:	66 8b 10             	mov    (%eax),%dx
  107fd6:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
  107fdb:	e8 30 b6 ff ff       	call   103610 <log_n>
  107fe0:	e9 00 00 00 00       	jmp    107fe5 <dump_regs+0x255>
  107fe5:	e9 00 00 00 00       	jmp    107fea <dump_regs+0x25a>
  107fea:	e9 00 00 00 00       	jmp    107fef <dump_regs+0x25f>
  107fef:	e9 00 00 00 00       	jmp    107ff4 <dump_regs+0x264>
	LOG_ERR("EFLAGS: 0x%08x CS: 0x%04x CR3: %p", esf->eflags,
  107ff4:	e9 00 00 00 00       	jmp    107ff9 <dump_regs+0x269>
  107ff9:	e8 32 06 00 00       	call   108630 <_is_user_context>
  107ffe:	24 01                	and    $0x1,%al
  108000:	88 44 24 3f          	mov    %al,0x3f(%esp)
  108004:	f6 44 24 3f 01       	testb  $0x1,0x3f(%esp)
  108009:	0f 85 0f 00 00 00    	jne    10801e <dump_regs+0x28e>
  10800f:	b0 01                	mov    $0x1,%al
  108011:	a8 01                	test   $0x1,%al
  108013:	0f 85 05 00 00 00    	jne    10801e <dump_regs+0x28e>
  108019:	e9 fb 00 00 00       	jmp    108119 <dump_regs+0x389>
  10801e:	66 8b 44 24 38       	mov    0x38(%esp),%ax
  108023:	66 83 e0 f8          	and    $0xfff8,%ax
  108027:	66 83 c8 01          	or     $0x1,%ax
  10802b:	66 89 44 24 38       	mov    %ax,0x38(%esp)
  108030:	66 8b 44 24 38       	mov    0x38(%esp),%ax
  108035:	66 83 e0 c7          	and    $0xffc7,%ax
  108039:	66 89 44 24 38       	mov    %ax,0x38(%esp)
  10803e:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108044:	89 0c 24             	mov    %ecx,(%esp)
  108047:	e8 f4 05 00 00       	call   108640 <log_const_source_id>
  10804c:	66 8b 54 24 38       	mov    0x38(%esp),%dx
  108051:	66 25 ff 03          	and    $0x3ff,%ax
  108055:	66 c1 e0 06          	shl    $0x6,%ax
  108059:	66 83 e2 3f          	and    $0x3f,%dx
  10805d:	66 09 c2             	or     %ax,%dx
  108060:	66 89 54 24 38       	mov    %dx,0x38(%esp)
  108065:	f6 44 24 3f 01       	testb  $0x1,0x3f(%esp)
  10806a:	0f 84 52 00 00 00    	je     1080c2 <dump_regs+0x332>
  108070:	8b 45 08             	mov    0x8(%ebp),%eax
  108073:	8b 40 2c             	mov    0x2c(%eax),%eax
  108076:	8b 4d 08             	mov    0x8(%ebp),%ecx
  108079:	8b 49 28             	mov    0x28(%ecx),%ecx
  10807c:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  108082:	89 44 24 24          	mov    %eax,0x24(%esp)
  108086:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10808a:	e8 d1 05 00 00       	call   108660 <z_x86_page_tables_get>
  10808f:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  108093:	66 8b 11             	mov    (%ecx),%dx
  108096:	66 89 14 24          	mov    %dx,(%esp)
  10809a:	8d 0d 70 38 12 00    	lea    0x123870,%ecx
  1080a0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1080a4:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  1080a8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1080ac:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1080b0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1080b4:	89 44 24 10          	mov    %eax,0x10(%esp)
  1080b8:	e8 83 bf ff ff       	call   104040 <log_from_user>
  1080bd:	e9 4d 00 00 00       	jmp    10810f <dump_regs+0x37f>
  1080c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1080c5:	8b 40 2c             	mov    0x2c(%eax),%eax
  1080c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1080cb:	8b 49 28             	mov    0x28(%ecx),%ecx
  1080ce:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  1080d4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1080d8:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  1080dc:	e8 7f 05 00 00       	call   108660 <z_x86_page_tables_get>
  1080e1:	8d 0d 70 38 12 00    	lea    0x123870,%ecx
  1080e7:	89 0c 24             	mov    %ecx,(%esp)
  1080ea:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  1080ee:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1080f2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  1080f6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1080fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1080fe:	8d 44 24 38          	lea    0x38(%esp),%eax
  108102:	66 8b 10             	mov    (%eax),%dx
  108105:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  10810a:	e8 f1 b3 ff ff       	call   103500 <log_3>
  10810f:	e9 00 00 00 00       	jmp    108114 <dump_regs+0x384>
  108114:	e9 00 00 00 00       	jmp    108119 <dump_regs+0x389>
  108119:	e9 00 00 00 00       	jmp    10811e <dump_regs+0x38e>
	LOG_ERR("call trace:");
  10811e:	e9 00 00 00 00       	jmp    108123 <dump_regs+0x393>
  108123:	e8 08 05 00 00       	call   108630 <_is_user_context>
  108128:	24 01                	and    $0x1,%al
  10812a:	88 44 24 37          	mov    %al,0x37(%esp)
  10812e:	f6 44 24 37 01       	testb  $0x1,0x37(%esp)
  108133:	0f 85 0f 00 00 00    	jne    108148 <dump_regs+0x3b8>
  108139:	b0 01                	mov    $0x1,%al
  10813b:	a8 01                	test   $0x1,%al
  10813d:	0f 85 05 00 00 00    	jne    108148 <dump_regs+0x3b8>
  108143:	e9 95 00 00 00       	jmp    1081dd <dump_regs+0x44d>
  108148:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  10814d:	66 83 e0 f8          	and    $0xfff8,%ax
  108151:	66 83 c8 01          	or     $0x1,%ax
  108155:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  10815a:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  10815f:	66 83 e0 c7          	and    $0xffc7,%ax
  108163:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  108168:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  10816e:	89 0c 24             	mov    %ecx,(%esp)
  108171:	e8 ca 04 00 00       	call   108640 <log_const_source_id>
  108176:	66 8b 54 24 30       	mov    0x30(%esp),%dx
  10817b:	66 25 ff 03          	and    $0x3ff,%ax
  10817f:	66 c1 e0 06          	shl    $0x6,%ax
  108183:	66 83 e2 3f          	and    $0x3f,%dx
  108187:	66 09 c2             	or     %ax,%dx
  10818a:	66 89 54 24 30       	mov    %dx,0x30(%esp)
  10818f:	f6 44 24 37 01       	testb  $0x1,0x37(%esp)
  108194:	0f 84 1f 00 00 00    	je     1081b9 <dump_regs+0x429>
  10819a:	8d 44 24 30          	lea    0x30(%esp),%eax
  10819e:	66 8b 08             	mov    (%eax),%cx
  1081a1:	66 89 0c 24          	mov    %cx,(%esp)
  1081a5:	8d 05 92 38 12 00    	lea    0x123892,%eax
  1081ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  1081af:	e8 8c be ff ff       	call   104040 <log_from_user>
  1081b4:	e9 1a 00 00 00       	jmp    1081d3 <dump_regs+0x443>
  1081b9:	8d 05 92 38 12 00    	lea    0x123892,%eax
  1081bf:	89 04 24             	mov    %eax,(%esp)
  1081c2:	8d 44 24 30          	lea    0x30(%esp),%eax
  1081c6:	66 8b 08             	mov    (%eax),%cx
  1081c9:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  1081ce:	e8 cd af ff ff       	call   1031a0 <log_0>
  1081d3:	e9 00 00 00 00       	jmp    1081d8 <dump_regs+0x448>
  1081d8:	e9 00 00 00 00       	jmp    1081dd <dump_regs+0x44d>
  1081dd:	e9 00 00 00 00       	jmp    1081e2 <dump_regs+0x452>
	LOG_ERR("EIP: 0x%08x", esf->eip);
  1081e2:	e9 00 00 00 00       	jmp    1081e7 <dump_regs+0x457>
  1081e7:	e8 44 04 00 00       	call   108630 <_is_user_context>
  1081ec:	24 01                	and    $0x1,%al
  1081ee:	88 44 24 2f          	mov    %al,0x2f(%esp)
  1081f2:	f6 44 24 2f 01       	testb  $0x1,0x2f(%esp)
  1081f7:	0f 85 0f 00 00 00    	jne    10820c <dump_regs+0x47c>
  1081fd:	b0 01                	mov    $0x1,%al
  1081ff:	a8 01                	test   $0x1,%al
  108201:	0f 85 05 00 00 00    	jne    10820c <dump_regs+0x47c>
  108207:	e9 a9 00 00 00       	jmp    1082b5 <dump_regs+0x525>
  10820c:	66 8b 44 24 28       	mov    0x28(%esp),%ax
  108211:	66 83 e0 f8          	and    $0xfff8,%ax
  108215:	66 83 c8 01          	or     $0x1,%ax
  108219:	66 89 44 24 28       	mov    %ax,0x28(%esp)
  10821e:	66 8b 44 24 28       	mov    0x28(%esp),%ax
  108223:	66 83 e0 c7          	and    $0xffc7,%ax
  108227:	66 89 44 24 28       	mov    %ax,0x28(%esp)
  10822c:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108232:	89 0c 24             	mov    %ecx,(%esp)
  108235:	e8 06 04 00 00       	call   108640 <log_const_source_id>
  10823a:	66 8b 54 24 28       	mov    0x28(%esp),%dx
  10823f:	66 25 ff 03          	and    $0x3ff,%ax
  108243:	66 c1 e0 06          	shl    $0x6,%ax
  108247:	66 83 e2 3f          	and    $0x3f,%dx
  10824b:	66 09 c2             	or     %ax,%dx
  10824e:	66 89 54 24 28       	mov    %dx,0x28(%esp)
  108253:	f6 44 24 2f 01       	testb  $0x1,0x2f(%esp)
  108258:	0f 84 29 00 00 00    	je     108287 <dump_regs+0x4f7>
  10825e:	8b 45 08             	mov    0x8(%ebp),%eax
  108261:	8b 40 24             	mov    0x24(%eax),%eax
  108264:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  108268:	66 8b 11             	mov    (%ecx),%dx
  10826b:	66 89 14 24          	mov    %dx,(%esp)
  10826f:	8d 0d 9e 38 12 00    	lea    0x12389e,%ecx
  108275:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108279:	89 44 24 08          	mov    %eax,0x8(%esp)
  10827d:	e8 be bd ff ff       	call   104040 <log_from_user>
  108282:	e9 24 00 00 00       	jmp    1082ab <dump_regs+0x51b>
  108287:	8b 45 08             	mov    0x8(%ebp),%eax
  10828a:	8b 40 24             	mov    0x24(%eax),%eax
  10828d:	8d 0d 9e 38 12 00    	lea    0x12389e,%ecx
  108293:	89 0c 24             	mov    %ecx,(%esp)
  108296:	89 44 24 04          	mov    %eax,0x4(%esp)
  10829a:	8d 44 24 28          	lea    0x28(%esp),%eax
  10829e:	66 8b 10             	mov    (%eax),%dx
  1082a1:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  1082a6:	e8 b5 b0 ff ff       	call   103360 <log_1>
  1082ab:	e9 00 00 00 00       	jmp    1082b0 <dump_regs+0x520>
  1082b0:	e9 00 00 00 00       	jmp    1082b5 <dump_regs+0x525>
  1082b5:	e9 00 00 00 00       	jmp    1082ba <dump_regs+0x52a>
	unwind_stack(esf->ebp, esf->cs);
  1082ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1082bd:	8b 40 04             	mov    0x4(%eax),%eax
  1082c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1082c3:	8b 49 28             	mov    0x28(%ecx),%ecx
  1082c6:	89 04 24             	mov    %eax,(%esp)
  1082c9:	0f b7 c1             	movzwl %cx,%eax
  1082cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1082d0:	e8 ab 03 00 00       	call   108680 <unwind_stack>
}
  1082d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1082d8:	5e                   	pop    %esi
  1082d9:	5f                   	pop    %edi
  1082da:	5b                   	pop    %ebx
  1082db:	5d                   	pop    %ebp
  1082dc:	c3                   	ret    
  1082dd:	66 90                	xchg   %ax,%ax
  1082df:	90                   	nop

001082e0 <z_x86_page_fault_handler>:
	Z_EXC_HANDLE(z_x86_user_string_nlen)
};
#endif

void z_x86_page_fault_handler(z_arch_esf_t *esf)
{
  1082e0:	55                   	push   %ebp
  1082e1:	89 e5                	mov    %esp,%ebp
  1082e3:	83 ec 10             	sub    $0x10,%esp
  1082e6:	8b 45 08             	mov    0x8(%ebp),%eax
			return;
		}
	}
#endif
#ifdef CONFIG_EXCEPTION_DEBUG
	dump_page_fault(esf);
  1082e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1082ec:	89 0c 24             	mov    %ecx,(%esp)
  1082ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1082f2:	e8 19 00 00 00       	call   108310 <dump_page_fault>
  1082f7:	31 c0                	xor    %eax,%eax
#ifdef CONFIG_THREAD_STACK_INFO
	if (z_x86_check_stack_bounds(esf_get_sp(esf), 0, esf->cs)) {
		z_x86_fatal_error(K_ERR_STACK_CHK_FAIL, esf);
	}
#endif
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
  1082f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1082fc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  108303:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108307:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10830a:	e8 41 fa ff ff       	call   107d50 <z_x86_fatal_error>
  10830f:	90                   	nop

00108310 <dump_page_fault>:
{
  108310:	55                   	push   %ebp
  108311:	89 e5                	mov    %esp,%ebp
  108313:	56                   	push   %esi
  108314:	83 e4 f8             	and    $0xfffffff8,%esp
  108317:	83 ec 60             	sub    $0x60,%esp
  10831a:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ ("mov %%cr2, %0" : "=r" (cr2));
  10831d:	0f 20 d1             	mov    %cr2,%ecx
  108320:	89 4c 24 54          	mov    %ecx,0x54(%esp)
	err = esf_get_code(esf);
  108324:	8b 4d 08             	mov    0x8(%ebp),%ecx
  108327:	89 0c 24             	mov    %ecx,(%esp)
  10832a:	89 44 24 44          	mov    %eax,0x44(%esp)
  10832e:	e8 5d 06 00 00       	call   108990 <esf_get_code>
  108333:	89 44 24 58          	mov    %eax,0x58(%esp)
	LOG_ERR("***** CPU Page Fault (error code " PR_UPTR ")", err);
  108337:	e8 f4 02 00 00       	call   108630 <_is_user_context>
  10833c:	24 01                	and    $0x1,%al
  10833e:	88 44 24 53          	mov    %al,0x53(%esp)
  108342:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  108347:	0f 85 0f 00 00 00    	jne    10835c <dump_page_fault+0x4c>
  10834d:	b0 01                	mov    $0x1,%al
  10834f:	a8 01                	test   $0x1,%al
  108351:	0f 85 05 00 00 00    	jne    10835c <dump_page_fault+0x4c>
  108357:	e9 a5 00 00 00       	jmp    108401 <dump_page_fault+0xf1>
  10835c:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  108361:	66 83 e0 f8          	and    $0xfff8,%ax
  108365:	66 83 c8 01          	or     $0x1,%ax
  108369:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  10836e:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  108373:	66 83 e0 c7          	and    $0xffc7,%ax
  108377:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  10837c:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108382:	89 0c 24             	mov    %ecx,(%esp)
  108385:	e8 b6 02 00 00       	call   108640 <log_const_source_id>
  10838a:	66 8b 54 24 50       	mov    0x50(%esp),%dx
  10838f:	66 25 ff 03          	and    $0x3ff,%ax
  108393:	66 c1 e0 06          	shl    $0x6,%ax
  108397:	66 83 e2 3f          	and    $0x3f,%dx
  10839b:	66 09 c2             	or     %ax,%dx
  10839e:	66 89 54 24 50       	mov    %dx,0x50(%esp)
  1083a3:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  1083a8:	0f 84 27 00 00 00    	je     1083d5 <dump_page_fault+0xc5>
  1083ae:	8b 44 24 58          	mov    0x58(%esp),%eax
  1083b2:	8d 4c 24 50          	lea    0x50(%esp),%ecx
  1083b6:	66 8b 11             	mov    (%ecx),%dx
  1083b9:	66 89 14 24          	mov    %dx,(%esp)
  1083bd:	8d 0d e1 38 12 00    	lea    0x1238e1,%ecx
  1083c3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1083c7:	89 44 24 08          	mov    %eax,0x8(%esp)
  1083cb:	e8 70 bc ff ff       	call   104040 <log_from_user>
  1083d0:	e9 22 00 00 00       	jmp    1083f7 <dump_page_fault+0xe7>
  1083d5:	8b 44 24 58          	mov    0x58(%esp),%eax
  1083d9:	8d 0d e1 38 12 00    	lea    0x1238e1,%ecx
  1083df:	89 0c 24             	mov    %ecx,(%esp)
  1083e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1083e6:	8d 44 24 50          	lea    0x50(%esp),%eax
  1083ea:	66 8b 10             	mov    (%eax),%dx
  1083ed:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  1083f2:	e8 69 af ff ff       	call   103360 <log_1>
  1083f7:	e9 00 00 00 00       	jmp    1083fc <dump_page_fault+0xec>
  1083fc:	e9 00 00 00 00       	jmp    108401 <dump_page_fault+0xf1>
  108401:	e9 00 00 00 00       	jmp    108406 <dump_page_fault+0xf6>
	LOG_ERR("%s thread %s address " PR_UPTR,
  108406:	e9 00 00 00 00       	jmp    10840b <dump_page_fault+0xfb>
  10840b:	e8 20 02 00 00       	call   108630 <_is_user_context>
  108410:	24 01                	and    $0x1,%al
  108412:	88 44 24 4f          	mov    %al,0x4f(%esp)
  108416:	f6 44 24 4f 01       	testb  $0x1,0x4f(%esp)
  10841b:	0f 85 0f 00 00 00    	jne    108430 <dump_page_fault+0x120>
  108421:	b0 01                	mov    $0x1,%al
  108423:	a8 01                	test   $0x1,%al
  108425:	0f 85 05 00 00 00    	jne    108430 <dump_page_fault+0x120>
  10842b:	e9 d3 01 00 00       	jmp    108603 <dump_page_fault+0x2f3>
  108430:	66 8b 44 24 48       	mov    0x48(%esp),%ax
  108435:	66 83 e0 f8          	and    $0xfff8,%ax
  108439:	66 83 c8 01          	or     $0x1,%ax
  10843d:	66 89 44 24 48       	mov    %ax,0x48(%esp)
  108442:	66 8b 44 24 48       	mov    0x48(%esp),%ax
  108447:	66 83 e0 c7          	and    $0xffc7,%ax
  10844b:	66 89 44 24 48       	mov    %ax,0x48(%esp)
  108450:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108456:	89 0c 24             	mov    %ecx,(%esp)
  108459:	e8 e2 01 00 00       	call   108640 <log_const_source_id>
  10845e:	66 8b 54 24 48       	mov    0x48(%esp),%dx
  108463:	66 25 ff 03          	and    $0x3ff,%ax
  108467:	66 c1 e0 06          	shl    $0x6,%ax
  10846b:	66 83 e2 3f          	and    $0x3f,%dx
  10846f:	66 09 c2             	or     %ax,%dx
  108472:	66 89 54 24 48       	mov    %dx,0x48(%esp)
  108477:	f6 44 24 4f 01       	testb  $0x1,0x4f(%esp)
  10847c:	0f 84 be 00 00 00    	je     108540 <dump_page_fault+0x230>
  108482:	8b 44 24 58          	mov    0x58(%esp),%eax
  108486:	83 e0 04             	and    $0x4,%eax
  108489:	83 f8 00             	cmp    $0x0,%eax
  10848c:	8d 05 2d 39 12 00    	lea    0x12392d,%eax
  108492:	8d 0d 28 39 12 00    	lea    0x123928,%ecx
  108498:	89 44 24 40          	mov    %eax,0x40(%esp)
  10849c:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
  1084a0:	0f 85 08 00 00 00    	jne    1084ae <dump_page_fault+0x19e>
  1084a6:	8b 44 24 40          	mov    0x40(%esp),%eax
  1084aa:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1084ae:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1084b2:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  1084b6:	83 e1 10             	and    $0x10,%ecx
  1084b9:	83 f9 00             	cmp    $0x0,%ecx
  1084bc:	89 44 24 38          	mov    %eax,0x38(%esp)
  1084c0:	0f 84 0f 00 00 00    	je     1084d5 <dump_page_fault+0x1c5>
  1084c6:	8d 05 38 39 12 00    	lea    0x123938,%eax
  1084cc:	89 44 24 34          	mov    %eax,0x34(%esp)
  1084d0:	e9 34 00 00 00       	jmp    108509 <dump_page_fault+0x1f9>
  1084d5:	8b 44 24 58          	mov    0x58(%esp),%eax
  1084d9:	83 e0 02             	and    $0x2,%eax
  1084dc:	83 f8 00             	cmp    $0x0,%eax
  1084df:	8d 05 47 39 12 00    	lea    0x123947,%eax
  1084e5:	8d 0d 41 39 12 00    	lea    0x123941,%ecx
  1084eb:	89 44 24 30          	mov    %eax,0x30(%esp)
  1084ef:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
  1084f3:	0f 85 08 00 00 00    	jne    108501 <dump_page_fault+0x1f1>
  1084f9:	8b 44 24 30          	mov    0x30(%esp),%eax
  1084fd:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  108501:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  108505:	89 44 24 34          	mov    %eax,0x34(%esp)
  108509:	8b 44 24 34          	mov    0x34(%esp),%eax
  10850d:	8b 4c 24 54          	mov    0x54(%esp),%ecx
  108511:	8d 54 24 48          	lea    0x48(%esp),%edx
  108515:	66 8b 32             	mov    (%edx),%si
  108518:	66 89 34 24          	mov    %si,(%esp)
  10851c:	8d 15 0b 39 12 00    	lea    0x12390b,%edx
  108522:	89 54 24 04          	mov    %edx,0x4(%esp)
  108526:	8b 54 24 38          	mov    0x38(%esp),%edx
  10852a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10852e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  108532:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  108536:	e8 05 bb ff ff       	call   104040 <log_from_user>
  10853b:	e9 b9 00 00 00       	jmp    1085f9 <dump_page_fault+0x2e9>
  108540:	8b 44 24 58          	mov    0x58(%esp),%eax
  108544:	83 e0 04             	and    $0x4,%eax
  108547:	83 f8 00             	cmp    $0x0,%eax
  10854a:	8d 05 2d 39 12 00    	lea    0x12392d,%eax
  108550:	8d 0d 28 39 12 00    	lea    0x123928,%ecx
  108556:	89 44 24 28          	mov    %eax,0x28(%esp)
  10855a:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  10855e:	0f 85 08 00 00 00    	jne    10856c <dump_page_fault+0x25c>
  108564:	8b 44 24 28          	mov    0x28(%esp),%eax
  108568:	89 44 24 24          	mov    %eax,0x24(%esp)
  10856c:	8b 44 24 24          	mov    0x24(%esp),%eax
  108570:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  108574:	83 e1 10             	and    $0x10,%ecx
  108577:	83 f9 00             	cmp    $0x0,%ecx
  10857a:	89 44 24 20          	mov    %eax,0x20(%esp)
  10857e:	0f 84 0f 00 00 00    	je     108593 <dump_page_fault+0x283>
  108584:	8d 05 38 39 12 00    	lea    0x123938,%eax
  10858a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10858e:	e9 34 00 00 00       	jmp    1085c7 <dump_page_fault+0x2b7>
  108593:	8b 44 24 58          	mov    0x58(%esp),%eax
  108597:	83 e0 02             	and    $0x2,%eax
  10859a:	83 f8 00             	cmp    $0x0,%eax
  10859d:	8d 05 47 39 12 00    	lea    0x123947,%eax
  1085a3:	8d 0d 41 39 12 00    	lea    0x123941,%ecx
  1085a9:	89 44 24 18          	mov    %eax,0x18(%esp)
  1085ad:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  1085b1:	0f 85 08 00 00 00    	jne    1085bf <dump_page_fault+0x2af>
  1085b7:	8b 44 24 18          	mov    0x18(%esp),%eax
  1085bb:	89 44 24 14          	mov    %eax,0x14(%esp)
  1085bf:	8b 44 24 14          	mov    0x14(%esp),%eax
  1085c3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1085c7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1085cb:	8b 4c 24 54          	mov    0x54(%esp),%ecx
  1085cf:	8d 15 0b 39 12 00    	lea    0x12390b,%edx
  1085d5:	89 14 24             	mov    %edx,(%esp)
  1085d8:	8b 54 24 20          	mov    0x20(%esp),%edx
  1085dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1085e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1085e4:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1085e8:	8d 44 24 48          	lea    0x48(%esp),%eax
  1085ec:	66 8b 30             	mov    (%eax),%si
  1085ef:	66 89 74 24 10       	mov    %si,0x10(%esp)
  1085f4:	e8 07 af ff ff       	call   103500 <log_3>
  1085f9:	e9 00 00 00 00       	jmp    1085fe <dump_page_fault+0x2ee>
  1085fe:	e9 00 00 00 00       	jmp    108603 <dump_page_fault+0x2f3>
  108603:	e9 00 00 00 00       	jmp    108608 <dump_page_fault+0x2f8>
		dump_mmu_flags(&z_x86_kernel_ptables, cr2);
  108608:	8b 44 24 54          	mov    0x54(%esp),%eax
  10860c:	8d 0d 00 50 13 00    	lea    0x135000,%ecx
  108612:	89 0c 24             	mov    %ecx,(%esp)
  108615:	89 44 24 04          	mov    %eax,0x4(%esp)
  108619:	e8 92 03 00 00       	call   1089b0 <dump_mmu_flags>
}
  10861e:	8d 65 fc             	lea    -0x4(%ebp),%esp
  108621:	5e                   	pop    %esi
  108622:	5d                   	pop    %ebp
  108623:	c3                   	ret    
  108624:	66 90                	xchg   %ax,%ax
  108626:	66 90                	xchg   %ax,%ax
  108628:	66 90                	xchg   %ax,%ax
  10862a:	66 90                	xchg   %ax,%ax
  10862c:	66 90                	xchg   %ax,%ax
  10862e:	66 90                	xchg   %ax,%ax

00108630 <_is_user_context>:
{
  108630:	55                   	push   %ebp
  108631:	89 e5                	mov    %esp,%ebp
  108633:	31 c0                	xor    %eax,%eax
	return false;
  108635:	24 01                	and    $0x1,%al
  108637:	0f b6 c0             	movzbl %al,%eax
  10863a:	5d                   	pop    %ebp
  10863b:	c3                   	ret    
  10863c:	66 90                	xchg   %ax,%ax
  10863e:	66 90                	xchg   %ax,%ax

00108640 <log_const_source_id>:
{
  108640:	55                   	push   %ebp
  108641:	89 e5                	mov    %esp,%ebp
  108643:	50                   	push   %eax
  108644:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  108647:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10864a:	8d 15 84 30 12 00    	lea    0x123084,%edx
  108650:	29 d1                	sub    %edx,%ecx
  108652:	c1 e9 03             	shr    $0x3,%ecx
  108655:	89 45 fc             	mov    %eax,-0x4(%ebp)
  108658:	89 c8                	mov    %ecx,%eax
  10865a:	83 c4 04             	add    $0x4,%esp
  10865d:	5d                   	pop    %ebp
  10865e:	c3                   	ret    
  10865f:	90                   	nop

00108660 <z_x86_page_tables_get>:
 * @param ptables Top-level pointer to the page tables, as programmed in CR3
 */
void z_x86_dump_page_tables(struct x86_page_tables *ptables);

static inline struct x86_page_tables *z_x86_page_tables_get(void)
{
  108660:	55                   	push   %ebp
  108661:	89 e5                	mov    %esp,%ebp
  108663:	50                   	push   %eax
	struct x86_page_tables *ret;

#ifdef CONFIG_X86_64
	__asm__ volatile("movq %%cr3, %0\n\t" : "=r" (ret));
#else
	__asm__ volatile("movl %%cr3, %0\n\t" : "=r" (ret));
  108664:	0f 20 d8             	mov    %cr3,%eax
  108667:	89 45 fc             	mov    %eax,-0x4(%ebp)
#endif

	return ret;
  10866a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10866d:	83 c4 04             	add    $0x4,%esp
  108670:	5d                   	pop    %ebp
  108671:	c3                   	ret    
  108672:	66 90                	xchg   %ax,%ax
  108674:	66 90                	xchg   %ax,%ax
  108676:	66 90                	xchg   %ax,%ax
  108678:	66 90                	xchg   %ax,%ax
  10867a:	66 90                	xchg   %ax,%ax
  10867c:	66 90                	xchg   %ax,%ax
  10867e:	66 90                	xchg   %ax,%ax

00108680 <unwind_stack>:
{
  108680:	55                   	push   %ebp
  108681:	89 e5                	mov    %esp,%ebp
  108683:	56                   	push   %esi
  108684:	83 e4 f8             	and    $0xfffffff8,%esp
  108687:	83 ec 30             	sub    $0x30,%esp
  10868a:	66 8b 45 0c          	mov    0xc(%ebp),%ax
  10868e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (base_ptr == 0U) {
  108691:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  108695:	0f 85 c9 00 00 00    	jne    108764 <unwind_stack+0xe4>
		LOG_ERR("NULL base ptr");
  10869b:	e9 00 00 00 00       	jmp    1086a0 <unwind_stack+0x20>
  1086a0:	e8 8b ff ff ff       	call   108630 <_is_user_context>
  1086a5:	24 01                	and    $0x1,%al
  1086a7:	88 44 24 23          	mov    %al,0x23(%esp)
  1086ab:	f6 44 24 23 01       	testb  $0x1,0x23(%esp)
  1086b0:	0f 85 0f 00 00 00    	jne    1086c5 <unwind_stack+0x45>
  1086b6:	b0 01                	mov    $0x1,%al
  1086b8:	a8 01                	test   $0x1,%al
  1086ba:	0f 85 05 00 00 00    	jne    1086c5 <unwind_stack+0x45>
  1086c0:	e9 95 00 00 00       	jmp    10875a <unwind_stack+0xda>
  1086c5:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  1086ca:	66 83 e0 f8          	and    $0xfff8,%ax
  1086ce:	66 83 c8 01          	or     $0x1,%ax
  1086d2:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  1086d7:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  1086dc:	66 83 e0 c7          	and    $0xffc7,%ax
  1086e0:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  1086e5:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  1086eb:	89 0c 24             	mov    %ecx,(%esp)
  1086ee:	e8 4d ff ff ff       	call   108640 <log_const_source_id>
  1086f3:	66 8b 54 24 20       	mov    0x20(%esp),%dx
  1086f8:	66 25 ff 03          	and    $0x3ff,%ax
  1086fc:	66 c1 e0 06          	shl    $0x6,%ax
  108700:	66 83 e2 3f          	and    $0x3f,%dx
  108704:	66 09 c2             	or     %ax,%dx
  108707:	66 89 54 24 20       	mov    %dx,0x20(%esp)
  10870c:	f6 44 24 23 01       	testb  $0x1,0x23(%esp)
  108711:	0f 84 1f 00 00 00    	je     108736 <unwind_stack+0xb6>
  108717:	8d 44 24 20          	lea    0x20(%esp),%eax
  10871b:	66 8b 08             	mov    (%eax),%cx
  10871e:	66 89 0c 24          	mov    %cx,(%esp)
  108722:	8d 05 aa 38 12 00    	lea    0x1238aa,%eax
  108728:	89 44 24 04          	mov    %eax,0x4(%esp)
  10872c:	e8 0f b9 ff ff       	call   104040 <log_from_user>
  108731:	e9 1a 00 00 00       	jmp    108750 <unwind_stack+0xd0>
  108736:	8d 05 aa 38 12 00    	lea    0x1238aa,%eax
  10873c:	89 04 24             	mov    %eax,(%esp)
  10873f:	8d 44 24 20          	lea    0x20(%esp),%eax
  108743:	66 8b 08             	mov    (%eax),%cx
  108746:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10874b:	e8 50 aa ff ff       	call   1031a0 <log_0>
  108750:	e9 00 00 00 00       	jmp    108755 <unwind_stack+0xd5>
  108755:	e9 00 00 00 00       	jmp    10875a <unwind_stack+0xda>
  10875a:	e9 00 00 00 00       	jmp    10875f <unwind_stack+0xdf>
		return;
  10875f:	e9 1e 02 00 00       	jmp    108982 <unwind_stack+0x302>
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
  108764:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  10876b:	00 
  10876c:	83 7c 24 24 08       	cmpl   $0x8,0x24(%esp)
  108771:	0f 8d 0b 02 00 00    	jge    108982 <unwind_stack+0x302>
		if (base_ptr % sizeof(base_ptr) != 0U) {
  108777:	8b 45 08             	mov    0x8(%ebp),%eax
  10877a:	83 e0 03             	and    $0x3,%eax
  10877d:	83 f8 00             	cmp    $0x0,%eax
  108780:	0f 84 c9 00 00 00    	je     10884f <unwind_stack+0x1cf>
			LOG_ERR("unaligned frame ptr");
  108786:	e9 00 00 00 00       	jmp    10878b <unwind_stack+0x10b>
  10878b:	e8 a0 fe ff ff       	call   108630 <_is_user_context>
  108790:	24 01                	and    $0x1,%al
  108792:	88 44 24 1f          	mov    %al,0x1f(%esp)
  108796:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  10879b:	0f 85 0f 00 00 00    	jne    1087b0 <unwind_stack+0x130>
  1087a1:	b0 01                	mov    $0x1,%al
  1087a3:	a8 01                	test   $0x1,%al
  1087a5:	0f 85 05 00 00 00    	jne    1087b0 <unwind_stack+0x130>
  1087ab:	e9 95 00 00 00       	jmp    108845 <unwind_stack+0x1c5>
  1087b0:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  1087b5:	66 83 e0 f8          	and    $0xfff8,%ax
  1087b9:	66 83 c8 01          	or     $0x1,%ax
  1087bd:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  1087c2:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  1087c7:	66 83 e0 c7          	and    $0xffc7,%ax
  1087cb:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  1087d0:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  1087d6:	89 0c 24             	mov    %ecx,(%esp)
  1087d9:	e8 62 fe ff ff       	call   108640 <log_const_source_id>
  1087de:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  1087e3:	66 25 ff 03          	and    $0x3ff,%ax
  1087e7:	66 c1 e0 06          	shl    $0x6,%ax
  1087eb:	66 83 e2 3f          	and    $0x3f,%dx
  1087ef:	66 09 c2             	or     %ax,%dx
  1087f2:	66 89 54 24 18       	mov    %dx,0x18(%esp)
  1087f7:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  1087fc:	0f 84 1f 00 00 00    	je     108821 <unwind_stack+0x1a1>
  108802:	8d 44 24 18          	lea    0x18(%esp),%eax
  108806:	66 8b 08             	mov    (%eax),%cx
  108809:	66 89 0c 24          	mov    %cx,(%esp)
  10880d:	8d 05 b8 38 12 00    	lea    0x1238b8,%eax
  108813:	89 44 24 04          	mov    %eax,0x4(%esp)
  108817:	e8 24 b8 ff ff       	call   104040 <log_from_user>
  10881c:	e9 1a 00 00 00       	jmp    10883b <unwind_stack+0x1bb>
  108821:	8d 05 b8 38 12 00    	lea    0x1238b8,%eax
  108827:	89 04 24             	mov    %eax,(%esp)
  10882a:	8d 44 24 18          	lea    0x18(%esp),%eax
  10882e:	66 8b 08             	mov    (%eax),%cx
  108831:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  108836:	e8 65 a9 ff ff       	call   1031a0 <log_0>
  10883b:	e9 00 00 00 00       	jmp    108840 <unwind_stack+0x1c0>
  108840:	e9 00 00 00 00       	jmp    108845 <unwind_stack+0x1c5>
  108845:	e9 00 00 00 00       	jmp    10884a <unwind_stack+0x1ca>
			return;
  10884a:	e9 33 01 00 00       	jmp    108982 <unwind_stack+0x302>
		frame = (struct stack_frame *)base_ptr;
  10884f:	8b 45 08             	mov    0x8(%ebp),%eax
  108852:	89 44 24 28          	mov    %eax,0x28(%esp)
		if (frame == NULL) {
  108856:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  10885b:	0f 85 05 00 00 00    	jne    108866 <unwind_stack+0x1e6>
			break;
  108861:	e9 1c 01 00 00       	jmp    108982 <unwind_stack+0x302>
		if (frame->ret_addr == 0U) {
  108866:	8b 44 24 28          	mov    0x28(%esp),%eax
  10886a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  10886e:	0f 85 05 00 00 00    	jne    108879 <unwind_stack+0x1f9>
			break;
  108874:	e9 09 01 00 00       	jmp    108982 <unwind_stack+0x302>
		LOG_ERR("     0x%08lx (0x%lx)", frame->ret_addr, frame->args);
  108879:	e9 00 00 00 00       	jmp    10887e <unwind_stack+0x1fe>
  10887e:	e8 ad fd ff ff       	call   108630 <_is_user_context>
  108883:	24 01                	and    $0x1,%al
  108885:	88 44 24 17          	mov    %al,0x17(%esp)
  108889:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  10888e:	0f 85 0f 00 00 00    	jne    1088a3 <unwind_stack+0x223>
  108894:	b0 01                	mov    $0x1,%al
  108896:	a8 01                	test   $0x1,%al
  108898:	0f 85 05 00 00 00    	jne    1088a3 <unwind_stack+0x223>
  10889e:	e9 c1 00 00 00       	jmp    108964 <unwind_stack+0x2e4>
  1088a3:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  1088a8:	66 83 e0 f8          	and    $0xfff8,%ax
  1088ac:	66 83 c8 01          	or     $0x1,%ax
  1088b0:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  1088b5:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  1088ba:	66 83 e0 c7          	and    $0xffc7,%ax
  1088be:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  1088c3:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  1088c9:	89 0c 24             	mov    %ecx,(%esp)
  1088cc:	e8 6f fd ff ff       	call   108640 <log_const_source_id>
  1088d1:	66 8b 54 24 10       	mov    0x10(%esp),%dx
  1088d6:	66 25 ff 03          	and    $0x3ff,%ax
  1088da:	66 c1 e0 06          	shl    $0x6,%ax
  1088de:	66 83 e2 3f          	and    $0x3f,%dx
  1088e2:	66 09 c2             	or     %ax,%dx
  1088e5:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  1088ea:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  1088ef:	0f 84 35 00 00 00    	je     10892a <unwind_stack+0x2aa>
  1088f5:	8b 44 24 28          	mov    0x28(%esp),%eax
  1088f9:	8b 40 04             	mov    0x4(%eax),%eax
  1088fc:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  108900:	8b 49 08             	mov    0x8(%ecx),%ecx
  108903:	8d 54 24 10          	lea    0x10(%esp),%edx
  108907:	66 8b 32             	mov    (%edx),%si
  10890a:	66 89 34 24          	mov    %si,(%esp)
  10890e:	8d 15 cc 38 12 00    	lea    0x1238cc,%edx
  108914:	89 54 24 04          	mov    %edx,0x4(%esp)
  108918:	89 44 24 08          	mov    %eax,0x8(%esp)
  10891c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  108920:	e8 1b b7 ff ff       	call   104040 <log_from_user>
  108925:	e9 30 00 00 00       	jmp    10895a <unwind_stack+0x2da>
  10892a:	8b 44 24 28          	mov    0x28(%esp),%eax
  10892e:	8b 40 04             	mov    0x4(%eax),%eax
  108931:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  108935:	8b 49 08             	mov    0x8(%ecx),%ecx
  108938:	8d 15 cc 38 12 00    	lea    0x1238cc,%edx
  10893e:	89 14 24             	mov    %edx,(%esp)
  108941:	89 44 24 04          	mov    %eax,0x4(%esp)
  108945:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  108949:	8d 44 24 10          	lea    0x10(%esp),%eax
  10894d:	66 8b 30             	mov    (%eax),%si
  108950:	66 89 74 24 0c       	mov    %si,0xc(%esp)
  108955:	e8 c6 aa ff ff       	call   103420 <log_2>
  10895a:	e9 00 00 00 00       	jmp    10895f <unwind_stack+0x2df>
  10895f:	e9 00 00 00 00       	jmp    108964 <unwind_stack+0x2e4>
  108964:	e9 00 00 00 00       	jmp    108969 <unwind_stack+0x2e9>
		base_ptr = frame->next;
  108969:	8b 44 24 28          	mov    0x28(%esp),%eax
  10896d:	8b 00                	mov    (%eax),%eax
  10896f:	89 45 08             	mov    %eax,0x8(%ebp)
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
  108972:	8b 44 24 24          	mov    0x24(%esp),%eax
  108976:	83 c0 01             	add    $0x1,%eax
  108979:	89 44 24 24          	mov    %eax,0x24(%esp)
  10897d:	e9 ea fd ff ff       	jmp    10876c <unwind_stack+0xec>
}
  108982:	8d 65 fc             	lea    -0x4(%ebp),%esp
  108985:	5e                   	pop    %esi
  108986:	5d                   	pop    %ebp
  108987:	c3                   	ret    
  108988:	66 90                	xchg   %ax,%ax
  10898a:	66 90                	xchg   %ax,%ax
  10898c:	66 90                	xchg   %ax,%ax
  10898e:	66 90                	xchg   %ax,%ax

00108990 <esf_get_code>:
{
  108990:	55                   	push   %ebp
  108991:	89 e5                	mov    %esp,%ebp
  108993:	50                   	push   %eax
  108994:	8b 45 08             	mov    0x8(%ebp),%eax
	return esf->errorCode;
  108997:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10899a:	8b 49 20             	mov    0x20(%ecx),%ecx
  10899d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1089a0:	89 c8                	mov    %ecx,%eax
  1089a2:	83 c4 04             	add    $0x4,%esp
  1089a5:	5d                   	pop    %ebp
  1089a6:	c3                   	ret    
  1089a7:	66 90                	xchg   %ax,%ax
  1089a9:	66 90                	xchg   %ax,%ax
  1089ab:	66 90                	xchg   %ax,%ax
  1089ad:	66 90                	xchg   %ax,%ax
  1089af:	90                   	nop

001089b0 <dump_mmu_flags>:
{
  1089b0:	55                   	push   %ebp
  1089b1:	89 e5                	mov    %esp,%ebp
  1089b3:	53                   	push   %ebx
  1089b4:	57                   	push   %edi
  1089b5:	56                   	push   %esi
  1089b6:	83 e4 f8             	and    $0xfffffff8,%esp
  1089b9:	83 ec 30             	sub    $0x30,%esp
  1089bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1089bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry = *z_x86_get_pdpte(ptables, addr);
  1089c2:	8b 55 08             	mov    0x8(%ebp),%edx
  1089c5:	8b 75 0c             	mov    0xc(%ebp),%esi
  1089c8:	89 e7                	mov    %esp,%edi
  1089ca:	89 77 04             	mov    %esi,0x4(%edi)
  1089cd:	89 17                	mov    %edx,(%edi)
  1089cf:	89 44 24 14          	mov    %eax,0x14(%esp)
  1089d3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1089d7:	e8 a4 01 00 00       	call   108b80 <z_x86_get_pdpte>
  1089dc:	8b 08                	mov    (%eax),%ecx
  1089de:	8b 40 04             	mov    0x4(%eax),%eax
  1089e1:	89 44 24 24          	mov    %eax,0x24(%esp)
  1089e5:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	if ((entry & Z_X86_MMU_P) == 0) {
  1089e9:	8a 5c 24 20          	mov    0x20(%esp),%bl
  1089ed:	f6 c3 01             	test   $0x1,%bl
  1089f0:	0f 85 ce 00 00 00    	jne    108ac4 <dump_mmu_flags+0x114>
  1089f6:	e9 00 00 00 00       	jmp    1089fb <dump_mmu_flags+0x4b>
		LOG_ERR("PDPTE: Non-present");
  1089fb:	e9 00 00 00 00       	jmp    108a00 <dump_mmu_flags+0x50>
  108a00:	e8 2b fc ff ff       	call   108630 <_is_user_context>
  108a05:	24 01                	and    $0x1,%al
  108a07:	88 44 24 1f          	mov    %al,0x1f(%esp)
  108a0b:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  108a10:	0f 85 0f 00 00 00    	jne    108a25 <dump_mmu_flags+0x75>
  108a16:	b0 01                	mov    $0x1,%al
  108a18:	a8 01                	test   $0x1,%al
  108a1a:	0f 85 05 00 00 00    	jne    108a25 <dump_mmu_flags+0x75>
  108a20:	e9 95 00 00 00       	jmp    108aba <dump_mmu_flags+0x10a>
  108a25:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  108a2a:	66 83 e0 f8          	and    $0xfff8,%ax
  108a2e:	66 83 c8 01          	or     $0x1,%ax
  108a32:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  108a37:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  108a3c:	66 83 e0 c7          	and    $0xffc7,%ax
  108a40:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  108a45:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108a4b:	89 0c 24             	mov    %ecx,(%esp)
  108a4e:	e8 ed fb ff ff       	call   108640 <log_const_source_id>
  108a53:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  108a58:	66 25 ff 03          	and    $0x3ff,%ax
  108a5c:	66 c1 e0 06          	shl    $0x6,%ax
  108a60:	66 83 e2 3f          	and    $0x3f,%dx
  108a64:	66 09 c2             	or     %ax,%dx
  108a67:	66 89 54 24 18       	mov    %dx,0x18(%esp)
  108a6c:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  108a71:	0f 84 1f 00 00 00    	je     108a96 <dump_mmu_flags+0xe6>
  108a77:	8d 44 24 18          	lea    0x18(%esp),%eax
  108a7b:	66 8b 08             	mov    (%eax),%cx
  108a7e:	66 89 0c 24          	mov    %cx,(%esp)
  108a82:	8d 05 4c 39 12 00    	lea    0x12394c,%eax
  108a88:	89 44 24 04          	mov    %eax,0x4(%esp)
  108a8c:	e8 af b5 ff ff       	call   104040 <log_from_user>
  108a91:	e9 1a 00 00 00       	jmp    108ab0 <dump_mmu_flags+0x100>
  108a96:	8d 05 4c 39 12 00    	lea    0x12394c,%eax
  108a9c:	89 04 24             	mov    %eax,(%esp)
  108a9f:	8d 44 24 18          	lea    0x18(%esp),%eax
  108aa3:	66 8b 08             	mov    (%eax),%cx
  108aa6:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  108aab:	e8 f0 a6 ff ff       	call   1031a0 <log_0>
  108ab0:	e9 00 00 00 00       	jmp    108ab5 <dump_mmu_flags+0x105>
  108ab5:	e9 00 00 00 00       	jmp    108aba <dump_mmu_flags+0x10a>
  108aba:	e9 00 00 00 00       	jmp    108abf <dump_mmu_flags+0x10f>
		return;
  108abf:	e9 b0 00 00 00       	jmp    108b74 <dump_mmu_flags+0x1c4>
	entry = *z_x86_pd_get_pde(z_x86_pdpte_get_pd(entry), addr);
  108ac4:	8b 44 24 20          	mov    0x20(%esp),%eax
  108ac8:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  108acc:	89 e2                	mov    %esp,%edx
  108ace:	89 4a 04             	mov    %ecx,0x4(%edx)
  108ad1:	89 02                	mov    %eax,(%edx)
  108ad3:	e8 28 01 00 00       	call   108c00 <z_x86_pdpte_get_pd>
  108ad8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  108adb:	89 e2                	mov    %esp,%edx
  108add:	89 4a 04             	mov    %ecx,0x4(%edx)
  108ae0:	89 02                	mov    %eax,(%edx)
  108ae2:	e8 d9 00 00 00       	call   108bc0 <z_x86_pd_get_pde>
  108ae7:	8b 08                	mov    (%eax),%ecx
  108ae9:	8b 40 04             	mov    0x4(%eax),%eax
  108aec:	89 44 24 24          	mov    %eax,0x24(%esp)
  108af0:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	if (!dump_entry_flags("  PDE", entry)) {
  108af4:	8b 44 24 20          	mov    0x20(%esp),%eax
  108af8:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  108afc:	89 e2                	mov    %esp,%edx
  108afe:	89 4a 08             	mov    %ecx,0x8(%edx)
  108b01:	89 42 04             	mov    %eax,0x4(%edx)
  108b04:	c7 02 5f 39 12 00    	movl   $0x12395f,(%edx)
  108b0a:	e8 21 01 00 00       	call   108c30 <dump_entry_flags>
  108b0f:	a8 01                	test   $0x1,%al
  108b11:	0f 85 05 00 00 00    	jne    108b1c <dump_mmu_flags+0x16c>
		return;
  108b17:	e9 58 00 00 00       	jmp    108b74 <dump_mmu_flags+0x1c4>
	entry = *z_x86_pt_get_pte(z_x86_pde_get_pt(entry), addr);
  108b1c:	8b 44 24 20          	mov    0x20(%esp),%eax
  108b20:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  108b24:	89 e2                	mov    %esp,%edx
  108b26:	89 4a 04             	mov    %ecx,0x4(%edx)
  108b29:	89 02                	mov    %eax,(%edx)
  108b2b:	e8 20 05 00 00       	call   109050 <z_x86_pde_get_pt>
  108b30:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  108b33:	89 e2                	mov    %esp,%edx
  108b35:	89 4a 04             	mov    %ecx,0x4(%edx)
  108b38:	89 02                	mov    %eax,(%edx)
  108b3a:	e8 d1 04 00 00       	call   109010 <z_x86_pt_get_pte>
  108b3f:	8b 08                	mov    (%eax),%ecx
  108b41:	8b 40 04             	mov    0x4(%eax),%eax
  108b44:	89 44 24 24          	mov    %eax,0x24(%esp)
  108b48:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	if (!dump_entry_flags("  PTE", entry)) {
  108b4c:	8b 44 24 20          	mov    0x20(%esp),%eax
  108b50:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  108b54:	89 e2                	mov    %esp,%edx
  108b56:	89 4a 08             	mov    %ecx,0x8(%edx)
  108b59:	89 42 04             	mov    %eax,0x4(%edx)
  108b5c:	c7 02 65 39 12 00    	movl   $0x123965,(%edx)
  108b62:	e8 c9 00 00 00       	call   108c30 <dump_entry_flags>
  108b67:	a8 01                	test   $0x1,%al
  108b69:	0f 85 05 00 00 00    	jne    108b74 <dump_mmu_flags+0x1c4>
		return;
  108b6f:	e9 00 00 00 00       	jmp    108b74 <dump_mmu_flags+0x1c4>
}
  108b74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108b77:	5e                   	pop    %esi
  108b78:	5f                   	pop    %edi
  108b79:	5b                   	pop    %ebx
  108b7a:	5d                   	pop    %ebp
  108b7b:	c3                   	ret    
  108b7c:	66 90                	xchg   %ax,%ax
  108b7e:	66 90                	xchg   %ax,%ax

00108b80 <z_x86_get_pdpte>:
{
  108b80:	55                   	push   %ebp
  108b81:	89 e5                	mov    %esp,%ebp
  108b83:	56                   	push   %esi
  108b84:	83 ec 10             	sub    $0x10,%esp
  108b87:	8b 45 0c             	mov    0xc(%ebp),%eax
  108b8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return z_x86_pdpt_get_pdpte(z_x86_get_pdpt(ptables, addr), addr);
  108b8d:	8b 55 08             	mov    0x8(%ebp),%edx
  108b90:	8b 75 0c             	mov    0xc(%ebp),%esi
  108b93:	89 14 24             	mov    %edx,(%esp)
  108b96:	89 74 24 04          	mov    %esi,0x4(%esp)
  108b9a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  108b9d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  108ba0:	e8 0b 05 00 00       	call   1090b0 <z_x86_get_pdpt>
  108ba5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  108ba8:	89 04 24             	mov    %eax,(%esp)
  108bab:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108baf:	e8 cc 04 00 00       	call   109080 <z_x86_pdpt_get_pdpte>
  108bb4:	83 c4 10             	add    $0x10,%esp
  108bb7:	5e                   	pop    %esi
  108bb8:	5d                   	pop    %ebp
  108bb9:	c3                   	ret    
  108bba:	66 90                	xchg   %ax,%ax
  108bbc:	66 90                	xchg   %ax,%ax
  108bbe:	66 90                	xchg   %ax,%ax

00108bc0 <z_x86_pd_get_pde>:
{
  108bc0:	55                   	push   %ebp
  108bc1:	89 e5                	mov    %esp,%ebp
  108bc3:	56                   	push   %esi
  108bc4:	83 ec 08             	sub    $0x8,%esp
  108bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
  108bca:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 21U) & (Z_X86_NUM_PD_ENTRIES - 1);
  108bcd:	8b 55 0c             	mov    0xc(%ebp),%edx
  108bd0:	c1 ea 15             	shr    $0x15,%edx
  108bd3:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  108bd9:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pd->entry[index];
  108bdc:	8b 55 08             	mov    0x8(%ebp),%edx
  108bdf:	8b 75 f8             	mov    -0x8(%ebp),%esi
  108be2:	c1 e6 03             	shl    $0x3,%esi
  108be5:	01 f2                	add    %esi,%edx
  108be7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  108bea:	89 d0                	mov    %edx,%eax
  108bec:	83 c4 08             	add    $0x8,%esp
  108bef:	5e                   	pop    %esi
  108bf0:	5d                   	pop    %ebp
  108bf1:	c3                   	ret    
  108bf2:	66 90                	xchg   %ax,%ax
  108bf4:	66 90                	xchg   %ax,%ax
  108bf6:	66 90                	xchg   %ax,%ax
  108bf8:	66 90                	xchg   %ax,%ax
  108bfa:	66 90                	xchg   %ax,%ax
  108bfc:	66 90                	xchg   %ax,%ax
  108bfe:	66 90                	xchg   %ax,%ax

00108c00 <z_x86_pdpte_get_pd>:
{
  108c00:	55                   	push   %ebp
  108c01:	89 e5                	mov    %esp,%ebp
  108c03:	83 e4 f8             	and    $0xfffffff8,%esp
  108c06:	83 ec 10             	sub    $0x10,%esp
  108c09:	8b 45 08             	mov    0x8(%ebp),%eax
  108c0c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  108c0f:	89 44 24 08          	mov    %eax,0x8(%esp)
  108c13:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	uintptr_t addr = pdpte & Z_X86_MMU_PDPTE_PD_MASK;
  108c17:	8b 44 24 08          	mov    0x8(%esp),%eax
  108c1b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  108c20:	89 44 24 04          	mov    %eax,0x4(%esp)
	return (struct x86_mmu_pd *)addr;
  108c24:	8b 44 24 04          	mov    0x4(%esp),%eax
  108c28:	89 ec                	mov    %ebp,%esp
  108c2a:	5d                   	pop    %ebp
  108c2b:	c3                   	ret    
  108c2c:	66 90                	xchg   %ax,%ax
  108c2e:	66 90                	xchg   %ax,%ax

00108c30 <dump_entry_flags>:
{
  108c30:	55                   	push   %ebp
  108c31:	89 e5                	mov    %esp,%ebp
  108c33:	53                   	push   %ebx
  108c34:	57                   	push   %edi
  108c35:	56                   	push   %esi
  108c36:	83 e4 f8             	and    $0xfffffff8,%esp
  108c39:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  108c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
  108c42:	8b 4d 10             	mov    0x10(%ebp),%ecx
  108c45:	8b 55 08             	mov    0x8(%ebp),%edx
  108c48:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
  108c4f:	89 8c 24 94 00 00 00 	mov    %ecx,0x94(%esp)
	if ((flags & Z_X86_MMU_P) == 0) {
  108c56:	8a 9c 24 90 00 00 00 	mov    0x90(%esp),%bl
  108c5d:	f6 c3 01             	test   $0x1,%bl
  108c60:	0f 85 05 01 00 00    	jne    108d6b <dump_entry_flags+0x13b>
  108c66:	e9 00 00 00 00       	jmp    108c6b <dump_entry_flags+0x3b>
		LOG_ERR("%s: Non-present", name);
  108c6b:	e9 00 00 00 00       	jmp    108c70 <dump_entry_flags+0x40>
  108c70:	e8 bb f9 ff ff       	call   108630 <_is_user_context>
  108c75:	24 01                	and    $0x1,%al
  108c77:	88 84 24 8f 00 00 00 	mov    %al,0x8f(%esp)
  108c7e:	f6 84 24 8f 00 00 00 	testb  $0x1,0x8f(%esp)
  108c85:	01 
  108c86:	0f 85 0f 00 00 00    	jne    108c9b <dump_entry_flags+0x6b>
  108c8c:	b0 01                	mov    $0x1,%al
  108c8e:	a8 01                	test   $0x1,%al
  108c90:	0f 85 05 00 00 00    	jne    108c9b <dump_entry_flags+0x6b>
  108c96:	e9 be 00 00 00       	jmp    108d59 <dump_entry_flags+0x129>
  108c9b:	66 8b 84 24 88 00 00 	mov    0x88(%esp),%ax
  108ca2:	00 
  108ca3:	66 83 e0 f8          	and    $0xfff8,%ax
  108ca7:	66 83 c8 01          	or     $0x1,%ax
  108cab:	66 89 84 24 88 00 00 	mov    %ax,0x88(%esp)
  108cb2:	00 
  108cb3:	66 8b 84 24 88 00 00 	mov    0x88(%esp),%ax
  108cba:	00 
  108cbb:	66 83 e0 c7          	and    $0xffc7,%ax
  108cbf:	66 89 84 24 88 00 00 	mov    %ax,0x88(%esp)
  108cc6:	00 
  108cc7:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108ccd:	89 0c 24             	mov    %ecx,(%esp)
  108cd0:	e8 6b f9 ff ff       	call   108640 <log_const_source_id>
  108cd5:	66 8b 94 24 88 00 00 	mov    0x88(%esp),%dx
  108cdc:	00 
  108cdd:	66 25 ff 03          	and    $0x3ff,%ax
  108ce1:	66 c1 e0 06          	shl    $0x6,%ax
  108ce5:	66 83 e2 3f          	and    $0x3f,%dx
  108ce9:	66 09 c2             	or     %ax,%dx
  108cec:	66 89 94 24 88 00 00 	mov    %dx,0x88(%esp)
  108cf3:	00 
  108cf4:	f6 84 24 8f 00 00 00 	testb  $0x1,0x8f(%esp)
  108cfb:	01 
  108cfc:	0f 84 29 00 00 00    	je     108d2b <dump_entry_flags+0xfb>
  108d02:	8b 45 08             	mov    0x8(%ebp),%eax
  108d05:	8d 8c 24 88 00 00 00 	lea    0x88(%esp),%ecx
  108d0c:	66 8b 11             	mov    (%ecx),%dx
  108d0f:	66 89 14 24          	mov    %dx,(%esp)
  108d13:	8d 0d 6b 39 12 00    	lea    0x12396b,%ecx
  108d19:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108d1d:	89 44 24 08          	mov    %eax,0x8(%esp)
  108d21:	e8 1a b3 ff ff       	call   104040 <log_from_user>
  108d26:	e9 24 00 00 00       	jmp    108d4f <dump_entry_flags+0x11f>
  108d2b:	8b 45 08             	mov    0x8(%ebp),%eax
  108d2e:	8d 0d 6b 39 12 00    	lea    0x12396b,%ecx
  108d34:	89 0c 24             	mov    %ecx,(%esp)
  108d37:	89 44 24 04          	mov    %eax,0x4(%esp)
  108d3b:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
  108d42:	66 8b 10             	mov    (%eax),%dx
  108d45:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  108d4a:	e8 11 a6 ff ff       	call   103360 <log_1>
  108d4f:	e9 00 00 00 00       	jmp    108d54 <dump_entry_flags+0x124>
  108d54:	e9 00 00 00 00       	jmp    108d59 <dump_entry_flags+0x129>
  108d59:	e9 00 00 00 00       	jmp    108d5e <dump_entry_flags+0x12e>
		return false;
  108d5e:	c6 84 24 9b 00 00 00 	movb   $0x0,0x9b(%esp)
  108d65:	00 
  108d66:	e9 83 02 00 00       	jmp    108fee <dump_entry_flags+0x3be>
		LOG_ERR("%s: 0x%016llx %s, %s, %s", name, flags,
  108d6b:	e9 00 00 00 00       	jmp    108d70 <dump_entry_flags+0x140>
  108d70:	e8 bb f8 ff ff       	call   108630 <_is_user_context>
  108d75:	24 01                	and    $0x1,%al
  108d77:	88 84 24 87 00 00 00 	mov    %al,0x87(%esp)
  108d7e:	f6 84 24 87 00 00 00 	testb  $0x1,0x87(%esp)
  108d85:	01 
  108d86:	0f 85 0f 00 00 00    	jne    108d9b <dump_entry_flags+0x16b>
  108d8c:	b0 01                	mov    $0x1,%al
  108d8e:	a8 01                	test   $0x1,%al
  108d90:	0f 85 05 00 00 00    	jne    108d9b <dump_entry_flags+0x16b>
  108d96:	e9 46 02 00 00       	jmp    108fe1 <dump_entry_flags+0x3b1>
  108d9b:	66 8b 84 24 80 00 00 	mov    0x80(%esp),%ax
  108da2:	00 
  108da3:	66 83 e0 f8          	and    $0xfff8,%ax
  108da7:	66 83 c8 01          	or     $0x1,%ax
  108dab:	66 89 84 24 80 00 00 	mov    %ax,0x80(%esp)
  108db2:	00 
  108db3:	66 8b 84 24 80 00 00 	mov    0x80(%esp),%ax
  108dba:	00 
  108dbb:	66 83 e0 c7          	and    $0xffc7,%ax
  108dbf:	66 89 84 24 80 00 00 	mov    %ax,0x80(%esp)
  108dc6:	00 
  108dc7:	8b 0d 14 30 14 00    	mov    0x143014,%ecx
  108dcd:	89 0c 24             	mov    %ecx,(%esp)
  108dd0:	e8 6b f8 ff ff       	call   108640 <log_const_source_id>
  108dd5:	66 8b 94 24 80 00 00 	mov    0x80(%esp),%dx
  108ddc:	00 
  108ddd:	66 25 ff 03          	and    $0x3ff,%ax
  108de1:	66 c1 e0 06          	shl    $0x6,%ax
  108de5:	66 83 e2 3f          	and    $0x3f,%dx
  108de9:	66 09 c2             	or     %ax,%dx
  108dec:	66 89 94 24 80 00 00 	mov    %dx,0x80(%esp)
  108df3:	00 
  108df4:	f6 84 24 87 00 00 00 	testb  $0x1,0x87(%esp)
  108dfb:	01 
  108dfc:	0f 84 ef 00 00 00    	je     108ef1 <dump_entry_flags+0x2c1>
  108e02:	8b 45 08             	mov    0x8(%ebp),%eax
  108e05:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
  108e0c:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
  108e13:	88 cb                	mov    %cl,%bl
  108e15:	be 94 39 12 00       	mov    $0x123994,%esi
  108e1a:	bf 9d 39 12 00       	mov    $0x12399d,%edi
  108e1f:	f6 c3 02             	test   $0x2,%bl
  108e22:	89 44 24 68          	mov    %eax,0x68(%esp)
  108e26:	89 4c 24 64          	mov    %ecx,0x64(%esp)
  108e2a:	89 54 24 60          	mov    %edx,0x60(%esp)
  108e2e:	88 5c 24 5f          	mov    %bl,0x5f(%esp)
  108e32:	89 7c 24 58          	mov    %edi,0x58(%esp)
  108e36:	89 74 24 54          	mov    %esi,0x54(%esp)
  108e3a:	0f 85 08 00 00 00    	jne    108e48 <dump_entry_flags+0x218>
  108e40:	8b 44 24 58          	mov    0x58(%esp),%eax
  108e44:	89 44 24 54          	mov    %eax,0x54(%esp)
  108e48:	8b 44 24 54          	mov    0x54(%esp),%eax
  108e4c:	b9 28 39 12 00       	mov    $0x123928,%ecx
  108e51:	ba 2d 39 12 00       	mov    $0x12392d,%edx
  108e56:	8a 5c 24 5f          	mov    0x5f(%esp),%bl
  108e5a:	f6 c3 04             	test   $0x4,%bl
  108e5d:	89 44 24 50          	mov    %eax,0x50(%esp)
  108e61:	89 54 24 4c          	mov    %edx,0x4c(%esp)
  108e65:	89 4c 24 48          	mov    %ecx,0x48(%esp)
  108e69:	0f 85 08 00 00 00    	jne    108e77 <dump_entry_flags+0x247>
  108e6f:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  108e73:	89 44 24 48          	mov    %eax,0x48(%esp)
  108e77:	8b 44 24 48          	mov    0x48(%esp),%eax
  108e7b:	b9 a7 39 12 00       	mov    $0x1239a7,%ecx
  108e80:	ba b7 39 12 00       	mov    $0x1239b7,%edx
  108e85:	8b 74 24 60          	mov    0x60(%esp),%esi
  108e89:	f7 c6 00 00 00 80    	test   $0x80000000,%esi
  108e8f:	89 44 24 44          	mov    %eax,0x44(%esp)
  108e93:	89 54 24 40          	mov    %edx,0x40(%esp)
  108e97:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
  108e9b:	0f 85 08 00 00 00    	jne    108ea9 <dump_entry_flags+0x279>
  108ea1:	8b 44 24 40          	mov    0x40(%esp),%eax
  108ea5:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  108ea9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  108ead:	66 8b 8c 24 80 00 00 	mov    0x80(%esp),%cx
  108eb4:	00 
  108eb5:	89 e2                	mov    %esp,%edx
  108eb7:	66 89 0a             	mov    %cx,(%edx)
  108eba:	89 42 1c             	mov    %eax,0x1c(%edx)
  108ebd:	8b 44 24 44          	mov    0x44(%esp),%eax
  108ec1:	89 42 18             	mov    %eax,0x18(%edx)
  108ec4:	8b 74 24 50          	mov    0x50(%esp),%esi
  108ec8:	89 72 14             	mov    %esi,0x14(%edx)
  108ecb:	8b 7c 24 60          	mov    0x60(%esp),%edi
  108ecf:	89 7a 10             	mov    %edi,0x10(%edx)
  108ed2:	8b 5c 24 64          	mov    0x64(%esp),%ebx
  108ed6:	89 5a 0c             	mov    %ebx,0xc(%edx)
  108ed9:	8b 4c 24 68          	mov    0x68(%esp),%ecx
  108edd:	89 4a 08             	mov    %ecx,0x8(%edx)
  108ee0:	c7 42 04 7b 39 12 00 	movl   $0x12397b,0x4(%edx)
  108ee7:	e8 54 b1 ff ff       	call   104040 <log_from_user>
  108eec:	e9 e6 00 00 00       	jmp    108fd7 <dump_entry_flags+0x3a7>
  108ef1:	e9 00 00 00 00       	jmp    108ef6 <dump_entry_flags+0x2c6>
  108ef6:	8d 44 24 6c          	lea    0x6c(%esp),%eax
  108efa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  108efd:	89 4c 24 6c          	mov    %ecx,0x6c(%esp)
  108f01:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
  108f08:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  108f0c:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
  108f13:	ba 94 39 12 00       	mov    $0x123994,%edx
  108f18:	be 9d 39 12 00       	mov    $0x12399d,%esi
  108f1d:	f6 c1 02             	test   $0x2,%cl
  108f20:	89 44 24 38          	mov    %eax,0x38(%esp)
  108f24:	89 74 24 34          	mov    %esi,0x34(%esp)
  108f28:	89 54 24 30          	mov    %edx,0x30(%esp)
  108f2c:	0f 85 08 00 00 00    	jne    108f3a <dump_entry_flags+0x30a>
  108f32:	8b 44 24 34          	mov    0x34(%esp),%eax
  108f36:	89 44 24 30          	mov    %eax,0x30(%esp)
  108f3a:	8b 44 24 30          	mov    0x30(%esp),%eax
  108f3e:	89 44 24 74          	mov    %eax,0x74(%esp)
  108f42:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  108f49:	b9 28 39 12 00       	mov    $0x123928,%ecx
  108f4e:	ba 2d 39 12 00       	mov    $0x12392d,%edx
  108f53:	a8 04                	test   $0x4,%al
  108f55:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  108f59:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  108f5d:	0f 85 08 00 00 00    	jne    108f6b <dump_entry_flags+0x33b>
  108f63:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  108f67:	89 44 24 28          	mov    %eax,0x28(%esp)
  108f6b:	8b 44 24 28          	mov    0x28(%esp),%eax
  108f6f:	89 44 24 78          	mov    %eax,0x78(%esp)
  108f73:	8a 8c 24 97 00 00 00 	mov    0x97(%esp),%cl
  108f7a:	b8 a7 39 12 00       	mov    $0x1239a7,%eax
  108f7f:	ba b7 39 12 00       	mov    $0x1239b7,%edx
  108f84:	f6 c1 80             	test   $0x80,%cl
  108f87:	89 54 24 24          	mov    %edx,0x24(%esp)
  108f8b:	89 44 24 20          	mov    %eax,0x20(%esp)
  108f8f:	0f 85 08 00 00 00    	jne    108f9d <dump_entry_flags+0x36d>
  108f95:	8b 44 24 24          	mov    0x24(%esp),%eax
  108f99:	89 44 24 20          	mov    %eax,0x20(%esp)
  108f9d:	8b 44 24 20          	mov    0x20(%esp),%eax
  108fa1:	89 44 24 7c          	mov    %eax,0x7c(%esp)
  108fa5:	8d 05 7b 39 12 00    	lea    0x12397b,%eax
  108fab:	89 04 24             	mov    %eax,(%esp)
  108fae:	8b 44 24 38          	mov    0x38(%esp),%eax
  108fb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  108fb6:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
  108fbd:	00 
  108fbe:	8d 8c 24 80 00 00 00 	lea    0x80(%esp),%ecx
  108fc5:	66 8b 11             	mov    (%ecx),%dx
  108fc8:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
  108fcd:	e8 3e a6 ff ff       	call   103610 <log_n>
  108fd2:	e9 00 00 00 00       	jmp    108fd7 <dump_entry_flags+0x3a7>
  108fd7:	e9 00 00 00 00       	jmp    108fdc <dump_entry_flags+0x3ac>
  108fdc:	e9 00 00 00 00       	jmp    108fe1 <dump_entry_flags+0x3b1>
  108fe1:	e9 00 00 00 00       	jmp    108fe6 <dump_entry_flags+0x3b6>
		return true;
  108fe6:	c6 84 24 9b 00 00 00 	movb   $0x1,0x9b(%esp)
  108fed:	01 
}
  108fee:	8a 84 24 9b 00 00 00 	mov    0x9b(%esp),%al
  108ff5:	24 01                	and    $0x1,%al
  108ff7:	0f b6 c0             	movzbl %al,%eax
  108ffa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108ffd:	5e                   	pop    %esi
  108ffe:	5f                   	pop    %edi
  108fff:	5b                   	pop    %ebx
  109000:	5d                   	pop    %ebp
  109001:	c3                   	ret    
  109002:	66 90                	xchg   %ax,%ax
  109004:	66 90                	xchg   %ax,%ax
  109006:	66 90                	xchg   %ax,%ax
  109008:	66 90                	xchg   %ax,%ax
  10900a:	66 90                	xchg   %ax,%ax
  10900c:	66 90                	xchg   %ax,%ax
  10900e:	66 90                	xchg   %ax,%ax

00109010 <z_x86_pt_get_pte>:
{
  109010:	55                   	push   %ebp
  109011:	89 e5                	mov    %esp,%ebp
  109013:	56                   	push   %esi
  109014:	83 ec 08             	sub    $0x8,%esp
  109017:	8b 45 0c             	mov    0xc(%ebp),%eax
  10901a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 12U) & (Z_X86_NUM_PT_ENTRIES - 1);
  10901d:	8b 55 0c             	mov    0xc(%ebp),%edx
  109020:	c1 ea 0c             	shr    $0xc,%edx
  109023:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  109029:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pt->entry[index];
  10902c:	8b 55 08             	mov    0x8(%ebp),%edx
  10902f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  109032:	c1 e6 03             	shl    $0x3,%esi
  109035:	01 f2                	add    %esi,%edx
  109037:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10903a:	89 d0                	mov    %edx,%eax
  10903c:	83 c4 08             	add    $0x8,%esp
  10903f:	5e                   	pop    %esi
  109040:	5d                   	pop    %ebp
  109041:	c3                   	ret    
  109042:	66 90                	xchg   %ax,%ax
  109044:	66 90                	xchg   %ax,%ax
  109046:	66 90                	xchg   %ax,%ax
  109048:	66 90                	xchg   %ax,%ax
  10904a:	66 90                	xchg   %ax,%ax
  10904c:	66 90                	xchg   %ax,%ax
  10904e:	66 90                	xchg   %ax,%ax

00109050 <z_x86_pde_get_pt>:
{
  109050:	55                   	push   %ebp
  109051:	89 e5                	mov    %esp,%ebp
  109053:	83 e4 f8             	and    $0xfffffff8,%esp
  109056:	83 ec 10             	sub    $0x10,%esp
  109059:	8b 45 08             	mov    0x8(%ebp),%eax
  10905c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10905f:	89 44 24 08          	mov    %eax,0x8(%esp)
  109063:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	uintptr_t addr = pde & Z_X86_MMU_PDE_PT_MASK;
  109067:	8b 44 24 08          	mov    0x8(%esp),%eax
  10906b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  109070:	89 44 24 04          	mov    %eax,0x4(%esp)
	return (struct x86_mmu_pt *)addr;
  109074:	8b 44 24 04          	mov    0x4(%esp),%eax
  109078:	89 ec                	mov    %ebp,%esp
  10907a:	5d                   	pop    %ebp
  10907b:	c3                   	ret    
  10907c:	66 90                	xchg   %ax,%ax
  10907e:	66 90                	xchg   %ax,%ax

00109080 <z_x86_pdpt_get_pdpte>:
{
  109080:	55                   	push   %ebp
  109081:	89 e5                	mov    %esp,%ebp
  109083:	56                   	push   %esi
  109084:	83 ec 08             	sub    $0x8,%esp
  109087:	8b 45 0c             	mov    0xc(%ebp),%eax
  10908a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 30U) & (Z_X86_NUM_PDPT_ENTRIES - 1);
  10908d:	8b 55 0c             	mov    0xc(%ebp),%edx
  109090:	c1 ea 1e             	shr    $0x1e,%edx
  109093:	83 e2 03             	and    $0x3,%edx
  109096:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pdpt->entry[index];
  109099:	8b 55 08             	mov    0x8(%ebp),%edx
  10909c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10909f:	c1 e6 03             	shl    $0x3,%esi
  1090a2:	01 f2                	add    %esi,%edx
  1090a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1090a7:	89 d0                	mov    %edx,%eax
  1090a9:	83 c4 08             	add    $0x8,%esp
  1090ac:	5e                   	pop    %esi
  1090ad:	5d                   	pop    %ebp
  1090ae:	c3                   	ret    
  1090af:	90                   	nop

001090b0 <z_x86_get_pdpt>:
{
  1090b0:	55                   	push   %ebp
  1090b1:	89 e5                	mov    %esp,%ebp
  1090b3:	50                   	push   %eax
  1090b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1090b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return &ptables->pdpt;
  1090ba:	8b 55 08             	mov    0x8(%ebp),%edx
  1090bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1090c0:	89 d0                	mov    %edx,%eax
  1090c2:	83 c4 04             	add    $0x4,%esp
  1090c5:	5d                   	pop    %ebp
  1090c6:	c3                   	ret    
  1090c7:	66 90                	xchg   %ax,%ax
  1090c9:	66 90                	xchg   %ax,%ax
  1090cb:	66 90                	xchg   %ax,%ax
  1090cd:	66 90                	xchg   %ax,%ax
  1090cf:	90                   	nop

001090d0 <z_x86_get_pdpt>:
{
  1090d0:	55                   	push   %ebp
  1090d1:	89 e5                	mov    %esp,%ebp
  1090d3:	50                   	push   %eax
  1090d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1090d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return &ptables->pdpt;
  1090da:	8b 55 08             	mov    0x8(%ebp),%edx
  1090dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1090e0:	89 d0                	mov    %edx,%eax
  1090e2:	83 c4 04             	add    $0x4,%esp
  1090e5:	5d                   	pop    %ebp
  1090e6:	c3                   	ret    
  1090e7:	66 90                	xchg   %ax,%ax
  1090e9:	66 90                	xchg   %ax,%ax
  1090eb:	66 90                	xchg   %ax,%ax
  1090ed:	66 90                	xchg   %ax,%ax
  1090ef:	90                   	nop

001090f0 <z_x86_pdpt_get_pdpte>:
{
  1090f0:	55                   	push   %ebp
  1090f1:	89 e5                	mov    %esp,%ebp
  1090f3:	56                   	push   %esi
  1090f4:	83 ec 08             	sub    $0x8,%esp
  1090f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1090fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 30U) & (Z_X86_NUM_PDPT_ENTRIES - 1);
  1090fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  109100:	c1 ea 1e             	shr    $0x1e,%edx
  109103:	83 e2 03             	and    $0x3,%edx
  109106:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pdpt->entry[index];
  109109:	8b 55 08             	mov    0x8(%ebp),%edx
  10910c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10910f:	c1 e6 03             	shl    $0x3,%esi
  109112:	01 f2                	add    %esi,%edx
  109114:	89 45 f4             	mov    %eax,-0xc(%ebp)
  109117:	89 d0                	mov    %edx,%eax
  109119:	83 c4 08             	add    $0x8,%esp
  10911c:	5e                   	pop    %esi
  10911d:	5d                   	pop    %ebp
  10911e:	c3                   	ret    
  10911f:	90                   	nop

00109120 <z_x86_pd_get_pde>:
{
  109120:	55                   	push   %ebp
  109121:	89 e5                	mov    %esp,%ebp
  109123:	56                   	push   %esi
  109124:	83 ec 08             	sub    $0x8,%esp
  109127:	8b 45 0c             	mov    0xc(%ebp),%eax
  10912a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 21U) & (Z_X86_NUM_PD_ENTRIES - 1);
  10912d:	8b 55 0c             	mov    0xc(%ebp),%edx
  109130:	c1 ea 15             	shr    $0x15,%edx
  109133:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  109139:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pd->entry[index];
  10913c:	8b 55 08             	mov    0x8(%ebp),%edx
  10913f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  109142:	c1 e6 03             	shl    $0x3,%esi
  109145:	01 f2                	add    %esi,%edx
  109147:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10914a:	89 d0                	mov    %edx,%eax
  10914c:	83 c4 08             	add    $0x8,%esp
  10914f:	5e                   	pop    %esi
  109150:	5d                   	pop    %ebp
  109151:	c3                   	ret    
  109152:	66 90                	xchg   %ax,%ax
  109154:	66 90                	xchg   %ax,%ax
  109156:	66 90                	xchg   %ax,%ax
  109158:	66 90                	xchg   %ax,%ax
  10915a:	66 90                	xchg   %ax,%ax
  10915c:	66 90                	xchg   %ax,%ax
  10915e:	66 90                	xchg   %ax,%ax

00109160 <z_x86_pdpte_get_pd>:
{
  109160:	55                   	push   %ebp
  109161:	89 e5                	mov    %esp,%ebp
  109163:	83 e4 f8             	and    $0xfffffff8,%esp
  109166:	83 ec 10             	sub    $0x10,%esp
  109169:	8b 45 08             	mov    0x8(%ebp),%eax
  10916c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10916f:	89 44 24 08          	mov    %eax,0x8(%esp)
  109173:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	uintptr_t addr = pdpte & Z_X86_MMU_PDPTE_PD_MASK;
  109177:	8b 44 24 08          	mov    0x8(%esp),%eax
  10917b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  109180:	89 44 24 04          	mov    %eax,0x4(%esp)
	return (struct x86_mmu_pd *)addr;
  109184:	8b 44 24 04          	mov    0x4(%esp),%eax
  109188:	89 ec                	mov    %ebp,%esp
  10918a:	5d                   	pop    %ebp
  10918b:	c3                   	ret    
  10918c:	66 90                	xchg   %ax,%ax
  10918e:	66 90                	xchg   %ax,%ax

00109190 <z_x86_pt_get_pte>:
{
  109190:	55                   	push   %ebp
  109191:	89 e5                	mov    %esp,%ebp
  109193:	56                   	push   %esi
  109194:	83 ec 08             	sub    $0x8,%esp
  109197:	8b 45 0c             	mov    0xc(%ebp),%eax
  10919a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int index = (addr >> 12U) & (Z_X86_NUM_PT_ENTRIES - 1);
  10919d:	8b 55 0c             	mov    0xc(%ebp),%edx
  1091a0:	c1 ea 0c             	shr    $0xc,%edx
  1091a3:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  1091a9:	89 55 f8             	mov    %edx,-0x8(%ebp)
	return &pt->entry[index];
  1091ac:	8b 55 08             	mov    0x8(%ebp),%edx
  1091af:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1091b2:	c1 e6 03             	shl    $0x3,%esi
  1091b5:	01 f2                	add    %esi,%edx
  1091b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1091ba:	89 d0                	mov    %edx,%eax
  1091bc:	83 c4 08             	add    $0x8,%esp
  1091bf:	5e                   	pop    %esi
  1091c0:	5d                   	pop    %ebp
  1091c1:	c3                   	ret    
  1091c2:	66 90                	xchg   %ax,%ax
  1091c4:	66 90                	xchg   %ax,%ax
  1091c6:	66 90                	xchg   %ax,%ax
  1091c8:	66 90                	xchg   %ax,%ax
  1091ca:	66 90                	xchg   %ax,%ax
  1091cc:	66 90                	xchg   %ax,%ax
  1091ce:	66 90                	xchg   %ax,%ax

001091d0 <z_x86_pde_get_pt>:
{
  1091d0:	55                   	push   %ebp
  1091d1:	89 e5                	mov    %esp,%ebp
  1091d3:	83 e4 f8             	and    $0xfffffff8,%esp
  1091d6:	83 ec 10             	sub    $0x10,%esp
  1091d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1091dc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1091df:	89 44 24 08          	mov    %eax,0x8(%esp)
  1091e3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	uintptr_t addr = pde & Z_X86_MMU_PDE_PT_MASK;
  1091e7:	8b 44 24 08          	mov    0x8(%esp),%eax
  1091eb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1091f0:	89 44 24 04          	mov    %eax,0x4(%esp)
	return (struct x86_mmu_pt *)addr;
  1091f4:	8b 44 24 04          	mov    0x4(%esp),%eax
  1091f8:	89 ec                	mov    %ebp,%esp
  1091fa:	5d                   	pop    %ebp
  1091fb:	c3                   	ret    
  1091fc:	66 90                	xchg   %ax,%ax
  1091fe:	66 90                	xchg   %ax,%ax

00109200 <z_x86_paging_init>:
	}
}

/* Called from x86's arch_kernel_init() */
void z_x86_paging_init(void)
{
  109200:	55                   	push   %ebp
  109201:	89 e5                	mov    %esp,%ebp
  109203:	83 ec 1c             	sub    $0x1c,%esp
	size_t pages_free;

	Z_STRUCT_SECTION_FOREACH(mmu_region, rgn) {
  109206:	8d 05 70 49 12 00    	lea    0x124970,%eax
  10920c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10920f:	8d 05 d0 49 12 00    	lea    0x1249d0,%eax
  109215:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  109218:	0f 92 c1             	setb   %cl
  10921b:	80 e1 01             	and    $0x1,%cl
  10921e:	0f b6 c1             	movzbl %cl,%eax
  109221:	89 45 f4             	mov    %eax,-0xc(%ebp)
  109224:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  109228:	0f 84 30 00 00 00    	je     10925e <z_x86_paging_init+0x5e>
  10922e:	31 c0                	xor    %eax,%eax
		add_mmu_region(&z_x86_kernel_ptables, rgn, false);
  109230:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  109233:	8d 15 00 50 13 00    	lea    0x135000,%edx
  109239:	89 14 24             	mov    %edx,(%esp)
  10923c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109240:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  109247:	00 
  109248:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10924b:	e8 50 00 00 00       	call   1092a0 <add_mmu_region>
	Z_STRUCT_SECTION_FOREACH(mmu_region, rgn) {
  109250:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109253:	83 c0 10             	add    $0x10,%eax
  109256:	89 45 f8             	mov    %eax,-0x8(%ebp)
  109259:	e9 b1 ff ff ff       	jmp    10920f <z_x86_paging_init+0xf>
#ifdef CONFIG_X86_KPTI
		add_mmu_region(&z_x86_user_ptables, rgn, true);
#endif
	}

	pages_free = (page_pos - page_pool) / MMU_PAGE_SIZE;
  10925e:	a1 18 30 14 00       	mov    0x143018,%eax
  109263:	8d 0d 00 60 12 00    	lea    0x126000,%ecx
  109269:	29 c8                	sub    %ecx,%eax
  10926b:	c1 e8 0c             	shr    $0xc,%eax
  10926e:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (pages_free != 0) {
  109271:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  109275:	0f 84 1a 00 00 00    	je     109295 <z_x86_paging_init+0x95>
		printk("Optimal CONFIG_X86_MMU_PAGE_POOL_PAGES %zu\n",
		       CONFIG_X86_MMU_PAGE_POOL_PAGES - pages_free);
  10927b:	b8 0f 00 00 00       	mov    $0xf,%eax
  109280:	2b 45 fc             	sub    -0x4(%ebp),%eax
		printk("Optimal CONFIG_X86_MMU_PAGE_POOL_PAGES %zu\n",
  109283:	8d 0d c7 39 12 00    	lea    0x1239c7,%ecx
  109289:	89 0c 24             	mov    %ecx,(%esp)
  10928c:	89 44 24 04          	mov    %eax,0x4(%esp)
  109290:	e8 fb 9d ff ff       	call   103090 <printk>
	 * program CR3 with our newly generated page tables.
	 */
	__asm__ volatile("movq %0, %%cr3\n\t"
			 : : "r" (&z_x86_kernel_ptables) : "memory");
#else
	z_x86_enable_paging();
  109295:	e8 e1 6d ff ff       	call   10007b <z_x86_enable_paging>
#endif
}
  10929a:	83 c4 1c             	add    $0x1c,%esp
  10929d:	5d                   	pop    %ebp
  10929e:	c3                   	ret    
  10929f:	90                   	nop

001092a0 <add_mmu_region>:
{
  1092a0:	55                   	push   %ebp
  1092a1:	89 e5                	mov    %esp,%ebp
  1092a3:	53                   	push   %ebx
  1092a4:	57                   	push   %edi
  1092a5:	56                   	push   %esi
  1092a6:	83 e4 f8             	and    $0xfffffff8,%esp
  1092a9:	83 ec 30             	sub    $0x30,%esp
  1092ac:	8a 45 10             	mov    0x10(%ebp),%al
  1092af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1092b2:	8b 55 08             	mov    0x8(%ebp),%edx
  1092b5:	24 01                	and    $0x1,%al
  1092b7:	88 44 24 2b          	mov    %al,0x2b(%esp)
	addr = rgn->address;
  1092bb:	8b 75 0c             	mov    0xc(%ebp),%esi
  1092be:	8b 36                	mov    (%esi),%esi
  1092c0:	89 74 24 14          	mov    %esi,0x14(%esp)
	flags = rgn->flags | Z_X86_MMU_P;
  1092c4:	8b 75 0c             	mov    0xc(%ebp),%esi
  1092c7:	8b 7e 08             	mov    0x8(%esi),%edi
  1092ca:	8b 76 0c             	mov    0xc(%esi),%esi
  1092cd:	83 cf 01             	or     $0x1,%edi
  1092d0:	89 74 24 1c          	mov    %esi,0x1c(%esp)
  1092d4:	89 7c 24 18          	mov    %edi,0x18(%esp)
	size = rgn->size;
  1092d8:	8b 75 0c             	mov    0xc(%ebp),%esi
  1092db:	8b 76 04             	mov    0x4(%esi),%esi
  1092de:	89 74 24 24          	mov    %esi,0x24(%esp)
	while (size > 0) {
  1092e2:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  1092e7:	0f 86 4d 00 00 00    	jbe    10933a <add_mmu_region+0x9a>
		add_mmu_region_page(ptables, addr, flags, user_table);
  1092ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1092f0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  1092f4:	8b 54 24 18          	mov    0x18(%esp),%edx
  1092f8:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  1092fc:	8a 5c 24 2b          	mov    0x2b(%esp),%bl
  109300:	89 e7                	mov    %esp,%edi
  109302:	89 77 0c             	mov    %esi,0xc(%edi)
  109305:	89 57 08             	mov    %edx,0x8(%edi)
  109308:	89 4f 04             	mov    %ecx,0x4(%edi)
  10930b:	89 07                	mov    %eax,(%edi)
  10930d:	0f b6 c3             	movzbl %bl,%eax
  109310:	83 e0 01             	and    $0x1,%eax
  109313:	89 47 10             	mov    %eax,0x10(%edi)
  109316:	e8 35 00 00 00       	call   109350 <add_mmu_region_page>
		size -= MMU_PAGE_SIZE;
  10931b:	8b 44 24 24          	mov    0x24(%esp),%eax
  10931f:	2d 00 10 00 00       	sub    $0x1000,%eax
  109324:	89 44 24 24          	mov    %eax,0x24(%esp)
		addr += MMU_PAGE_SIZE;
  109328:	8b 44 24 14          	mov    0x14(%esp),%eax
  10932c:	05 00 10 00 00       	add    $0x1000,%eax
  109331:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (size > 0) {
  109335:	e9 a8 ff ff ff       	jmp    1092e2 <add_mmu_region+0x42>
}
  10933a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10933d:	5e                   	pop    %esi
  10933e:	5f                   	pop    %edi
  10933f:	5b                   	pop    %ebx
  109340:	5d                   	pop    %ebp
  109341:	c3                   	ret    
  109342:	66 90                	xchg   %ax,%ax
  109344:	66 90                	xchg   %ax,%ax
  109346:	66 90                	xchg   %ax,%ax
  109348:	66 90                	xchg   %ax,%ax
  10934a:	66 90                	xchg   %ax,%ax
  10934c:	66 90                	xchg   %ax,%ax
  10934e:	66 90                	xchg   %ax,%ax

00109350 <add_mmu_region_page>:
{
  109350:	55                   	push   %ebp
  109351:	89 e5                	mov    %esp,%ebp
  109353:	53                   	push   %ebx
  109354:	57                   	push   %edi
  109355:	56                   	push   %esi
  109356:	83 e4 f8             	and    $0xfffffff8,%esp
  109359:	83 ec 40             	sub    $0x40,%esp
  10935c:	8b 45 10             	mov    0x10(%ebp),%eax
  10935f:	8b 4d 14             	mov    0x14(%ebp),%ecx
  109362:	8a 55 18             	mov    0x18(%ebp),%dl
  109365:	8b 75 0c             	mov    0xc(%ebp),%esi
  109368:	8b 7d 08             	mov    0x8(%ebp),%edi
  10936b:	89 44 24 30          	mov    %eax,0x30(%esp)
  10936f:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  109373:	80 e2 01             	and    $0x1,%dl
  109376:	88 54 24 2f          	mov    %dl,0x2f(%esp)
	bool exec = (flags & Z_X86_MMU_XD) == 0;
  10937a:	8b 44 24 34          	mov    0x34(%esp),%eax
  10937e:	a9 00 00 00 80       	test   $0x80000000,%eax
  109383:	0f 94 44 24 13       	sete   0x13(%esp)
	pdpt = z_x86_get_pdpt(ptables, addr);
  109388:	8b 45 08             	mov    0x8(%ebp),%eax
  10938b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10938e:	89 e3                	mov    %esp,%ebx
  109390:	89 4b 04             	mov    %ecx,0x4(%ebx)
  109393:	89 03                	mov    %eax,(%ebx)
  109395:	89 74 24 0c          	mov    %esi,0xc(%esp)
  109399:	89 7c 24 08          	mov    %edi,0x8(%esp)
  10939d:	e8 2e fd ff ff       	call   1090d0 <z_x86_get_pdpt>
  1093a2:	89 44 24 28          	mov    %eax,0x28(%esp)
	pdpte = z_x86_pdpt_get_pdpte(pdpt, addr);
  1093a6:	8b 44 24 28          	mov    0x28(%esp),%eax
  1093aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1093ad:	89 e6                	mov    %esp,%esi
  1093af:	89 4e 04             	mov    %ecx,0x4(%esi)
  1093b2:	89 06                	mov    %eax,(%esi)
  1093b4:	e8 37 fd ff ff       	call   1090f0 <z_x86_pdpt_get_pdpte>
  1093b9:	89 44 24 24          	mov    %eax,0x24(%esp)
	if ((*pdpte & Z_X86_MMU_P) == 0) {
  1093bd:	8b 44 24 24          	mov    0x24(%esp),%eax
  1093c1:	8a 10                	mov    (%eax),%dl
  1093c3:	f6 c2 01             	test   $0x1,%dl
  1093c6:	0f 85 27 00 00 00    	jne    1093f3 <add_mmu_region_page+0xa3>
  1093cc:	e9 00 00 00 00       	jmp    1093d1 <add_mmu_region_page+0x81>
		pd = get_page();
  1093d1:	e8 3a 01 00 00       	call   109510 <get_page>
  1093d6:	89 44 24 20          	mov    %eax,0x20(%esp)
		pdpte_update_pd(pdpte, pd);
  1093da:	8b 44 24 24          	mov    0x24(%esp),%eax
  1093de:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1093e2:	89 04 24             	mov    %eax,(%esp)
  1093e5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1093e9:	e8 42 01 00 00       	call   109530 <pdpte_update_pd>
	} else {
  1093ee:	e9 19 00 00 00       	jmp    10940c <add_mmu_region_page+0xbc>
		pd = z_x86_pdpte_get_pd(*pdpte);
  1093f3:	8b 44 24 24          	mov    0x24(%esp),%eax
  1093f7:	8b 08                	mov    (%eax),%ecx
  1093f9:	8b 40 04             	mov    0x4(%eax),%eax
  1093fc:	89 e2                	mov    %esp,%edx
  1093fe:	89 42 04             	mov    %eax,0x4(%edx)
  109401:	89 0a                	mov    %ecx,(%edx)
  109403:	e8 58 fd ff ff       	call   109160 <z_x86_pdpte_get_pd>
  109408:	89 44 24 20          	mov    %eax,0x20(%esp)
	*pdpte |= (flags & PDPTE_FLAGS_MASK);
  10940c:	8b 44 24 30          	mov    0x30(%esp),%eax
  109410:	83 e0 01             	and    $0x1,%eax
  109413:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  109417:	8b 11                	mov    (%ecx),%edx
  109419:	8b 71 04             	mov    0x4(%ecx),%esi
  10941c:	09 c2                	or     %eax,%edx
  10941e:	89 71 04             	mov    %esi,0x4(%ecx)
  109421:	89 11                	mov    %edx,(%ecx)
	pde = z_x86_pd_get_pde(pd, addr);
  109423:	8b 44 24 20          	mov    0x20(%esp),%eax
  109427:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10942a:	89 e2                	mov    %esp,%edx
  10942c:	89 4a 04             	mov    %ecx,0x4(%edx)
  10942f:	89 02                	mov    %eax,(%edx)
  109431:	e8 ea fc ff ff       	call   109120 <z_x86_pd_get_pde>
  109436:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if ((*pde & Z_X86_MMU_P) == 0) {
  10943a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10943e:	8a 18                	mov    (%eax),%bl
  109440:	f6 c3 01             	test   $0x1,%bl
  109443:	0f 85 27 00 00 00    	jne    109470 <add_mmu_region_page+0x120>
  109449:	e9 00 00 00 00       	jmp    10944e <add_mmu_region_page+0xfe>
		pt = get_page();
  10944e:	e8 bd 00 00 00       	call   109510 <get_page>
  109453:	89 44 24 18          	mov    %eax,0x18(%esp)
		pde_update_pt(pde, pt);
  109457:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10945b:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10945f:	89 04 24             	mov    %eax,(%esp)
  109462:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109466:	e8 05 01 00 00       	call   109570 <pde_update_pt>
	} else {
  10946b:	e9 19 00 00 00       	jmp    109489 <add_mmu_region_page+0x139>
		pt = z_x86_pde_get_pt(*pde);
  109470:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  109474:	8b 08                	mov    (%eax),%ecx
  109476:	8b 40 04             	mov    0x4(%eax),%eax
  109479:	89 e2                	mov    %esp,%edx
  10947b:	89 42 04             	mov    %eax,0x4(%edx)
  10947e:	89 0a                	mov    %ecx,(%edx)
  109480:	e8 4b fd ff ff       	call   1091d0 <z_x86_pde_get_pt>
  109485:	89 44 24 18          	mov    %eax,0x18(%esp)
	*pde |= (flags & PDE_FLAGS_MASK);
  109489:	8b 44 24 30          	mov    0x30(%esp),%eax
  10948d:	83 e0 07             	and    $0x7,%eax
  109490:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  109494:	8b 11                	mov    (%ecx),%edx
  109496:	8b 71 04             	mov    0x4(%ecx),%esi
  109499:	09 c2                	or     %eax,%edx
  10949b:	89 71 04             	mov    %esi,0x4(%ecx)
  10949e:	89 11                	mov    %edx,(%ecx)
	maybe_clear_xd(pde, exec);
  1094a0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1094a4:	0f b6 4c 24 13       	movzbl 0x13(%esp),%ecx
  1094a9:	83 e1 01             	and    $0x1,%ecx
  1094ac:	89 e2                	mov    %esp,%edx
  1094ae:	89 4a 04             	mov    %ecx,0x4(%edx)
  1094b1:	89 02                	mov    %eax,(%edx)
  1094b3:	e8 f8 00 00 00       	call   1095b0 <maybe_clear_xd>
	pte = z_x86_pt_get_pte(pt, addr);
  1094b8:	8b 44 24 18          	mov    0x18(%esp),%eax
  1094bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1094bf:	89 e2                	mov    %esp,%edx
  1094c1:	89 4a 04             	mov    %ecx,0x4(%edx)
  1094c4:	89 02                	mov    %eax,(%edx)
  1094c6:	e8 c5 fc ff ff       	call   109190 <z_x86_pt_get_pte>
  1094cb:	89 44 24 14          	mov    %eax,0x14(%esp)
	pte_update_addr(pte, addr);
  1094cf:	8b 44 24 14          	mov    0x14(%esp),%eax
  1094d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1094d6:	89 e2                	mov    %esp,%edx
  1094d8:	89 4a 04             	mov    %ecx,0x4(%edx)
  1094db:	89 02                	mov    %eax,(%edx)
  1094dd:	e8 4e 01 00 00       	call   109630 <pte_update_addr>
	*pte |= (flags & PTE_FLAGS_MASK);
  1094e2:	8b 44 24 30          	mov    0x30(%esp),%eax
  1094e6:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  1094ea:	81 e1 00 00 00 80    	and    $0x80000000,%ecx
  1094f0:	83 e0 1f             	and    $0x1f,%eax
  1094f3:	8b 54 24 14          	mov    0x14(%esp),%edx
  1094f7:	8b 32                	mov    (%edx),%esi
  1094f9:	8b 7a 04             	mov    0x4(%edx),%edi
  1094fc:	09 c6                	or     %eax,%esi
  1094fe:	09 cf                	or     %ecx,%edi
  109500:	89 7a 04             	mov    %edi,0x4(%edx)
  109503:	89 32                	mov    %esi,(%edx)
}
  109505:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109508:	5e                   	pop    %esi
  109509:	5f                   	pop    %edi
  10950a:	5b                   	pop    %ebx
  10950b:	5d                   	pop    %ebp
  10950c:	c3                   	ret    
  10950d:	66 90                	xchg   %ax,%ax
  10950f:	90                   	nop

00109510 <get_page>:
{
  109510:	55                   	push   %ebp
  109511:	89 e5                	mov    %esp,%ebp
	page_pos -= MMU_PAGE_SIZE;
  109513:	a1 18 30 14 00       	mov    0x143018,%eax
  109518:	05 00 f0 ff ff       	add    $0xfffff000,%eax
  10951d:	a3 18 30 14 00       	mov    %eax,0x143018
	return page_pos;
  109522:	a1 18 30 14 00       	mov    0x143018,%eax
  109527:	5d                   	pop    %ebp
  109528:	c3                   	ret    
  109529:	66 90                	xchg   %ax,%ax
  10952b:	66 90                	xchg   %ax,%ax
  10952d:	66 90                	xchg   %ax,%ax
  10952f:	90                   	nop

00109530 <pdpte_update_pd>:
{
  109530:	55                   	push   %ebp
  109531:	89 e5                	mov    %esp,%ebp
  109533:	53                   	push   %ebx
  109534:	57                   	push   %edi
  109535:	56                   	push   %esi
  109536:	50                   	push   %eax
  109537:	8b 45 0c             	mov    0xc(%ebp),%eax
  10953a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	uintptr_t pd_addr = (uintptr_t)pd;
  10953d:	8b 55 0c             	mov    0xc(%ebp),%edx
  109540:	89 55 f0             	mov    %edx,-0x10(%ebp)
	*pdpte = ((*pdpte & ~Z_X86_MMU_PDPTE_PD_MASK) |
  109543:	8b 55 08             	mov    0x8(%ebp),%edx
  109546:	8b 32                	mov    (%edx),%esi
  109548:	8b 7a 04             	mov    0x4(%edx),%edi
  10954b:	81 e7 00 00 00 80    	and    $0x80000000,%edi
  109551:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
		  (pd_addr & Z_X86_MMU_PDPTE_PD_MASK));
  109557:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10955a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	*pdpte = ((*pdpte & ~Z_X86_MMU_PDPTE_PD_MASK) |
  109560:	09 de                	or     %ebx,%esi
  109562:	89 7a 04             	mov    %edi,0x4(%edx)
  109565:	89 32                	mov    %esi,(%edx)
}
  109567:	83 c4 04             	add    $0x4,%esp
  10956a:	5e                   	pop    %esi
  10956b:	5f                   	pop    %edi
  10956c:	5b                   	pop    %ebx
  10956d:	5d                   	pop    %ebp
  10956e:	c3                   	ret    
  10956f:	90                   	nop

00109570 <pde_update_pt>:
{
  109570:	55                   	push   %ebp
  109571:	89 e5                	mov    %esp,%ebp
  109573:	53                   	push   %ebx
  109574:	57                   	push   %edi
  109575:	56                   	push   %esi
  109576:	50                   	push   %eax
  109577:	8b 45 0c             	mov    0xc(%ebp),%eax
  10957a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	uintptr_t pt_addr = (uintptr_t)pt;
  10957d:	8b 55 0c             	mov    0xc(%ebp),%edx
  109580:	89 55 f0             	mov    %edx,-0x10(%ebp)
	*pde = ((*pde & ~Z_X86_MMU_PDE_PT_MASK) |
  109583:	8b 55 08             	mov    0x8(%ebp),%edx
  109586:	8b 32                	mov    (%edx),%esi
  109588:	8b 7a 04             	mov    0x4(%edx),%edi
  10958b:	81 e7 00 00 00 80    	and    $0x80000000,%edi
  109591:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
		(pt_addr & Z_X86_MMU_PDE_PT_MASK));
  109597:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10959a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	*pde = ((*pde & ~Z_X86_MMU_PDE_PT_MASK) |
  1095a0:	09 de                	or     %ebx,%esi
  1095a2:	89 7a 04             	mov    %edi,0x4(%edx)
  1095a5:	89 32                	mov    %esi,(%edx)
}
  1095a7:	83 c4 04             	add    $0x4,%esp
  1095aa:	5e                   	pop    %esi
  1095ab:	5f                   	pop    %edi
  1095ac:	5b                   	pop    %ebx
  1095ad:	5d                   	pop    %ebp
  1095ae:	c3                   	ret    
  1095af:	90                   	nop

001095b0 <maybe_clear_xd>:
{
  1095b0:	55                   	push   %ebp
  1095b1:	89 e5                	mov    %esp,%ebp
  1095b3:	50                   	push   %eax
  1095b4:	8a 45 0c             	mov    0xc(%ebp),%al
  1095b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1095ba:	24 01                	and    $0x1,%al
  1095bc:	88 45 ff             	mov    %al,-0x1(%ebp)
	if (exec) {
  1095bf:	f6 45 ff 01          	testb  $0x1,-0x1(%ebp)
  1095c3:	0f 84 2b 00 00 00    	je     1095f4 <maybe_clear_xd+0x44>
		*entry |= IGNORED;
  1095c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1095cc:	8b 08                	mov    (%eax),%ecx
  1095ce:	8b 50 04             	mov    0x4(%eax),%edx
  1095d1:	81 c9 00 08 00 00    	or     $0x800,%ecx
  1095d7:	89 50 04             	mov    %edx,0x4(%eax)
  1095da:	89 08                	mov    %ecx,(%eax)
		*entry &= ~Z_X86_MMU_XD;
  1095dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1095df:	8b 08                	mov    (%eax),%ecx
  1095e1:	8b 50 04             	mov    0x4(%eax),%edx
  1095e4:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
  1095ea:	89 08                	mov    %ecx,(%eax)
  1095ec:	89 50 04             	mov    %edx,0x4(%eax)
	} else if ((*entry & IGNORED) == 0) {
  1095ef:	e9 2c 00 00 00       	jmp    109620 <maybe_clear_xd+0x70>
  1095f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1095f7:	8a 48 01             	mov    0x1(%eax),%cl
  1095fa:	f6 c1 08             	test   $0x8,%cl
  1095fd:	0f 85 18 00 00 00    	jne    10961b <maybe_clear_xd+0x6b>
  109603:	e9 00 00 00 00       	jmp    109608 <maybe_clear_xd+0x58>
		*entry |= Z_X86_MMU_XD;
  109608:	8b 45 08             	mov    0x8(%ebp),%eax
  10960b:	8b 08                	mov    (%eax),%ecx
  10960d:	8b 50 04             	mov    0x4(%eax),%edx
  109610:	81 ca 00 00 00 80    	or     $0x80000000,%edx
  109616:	89 08                	mov    %ecx,(%eax)
  109618:	89 50 04             	mov    %edx,0x4(%eax)
  10961b:	e9 00 00 00 00       	jmp    109620 <maybe_clear_xd+0x70>
}
  109620:	83 c4 04             	add    $0x4,%esp
  109623:	5d                   	pop    %ebp
  109624:	c3                   	ret    
  109625:	66 90                	xchg   %ax,%ax
  109627:	66 90                	xchg   %ax,%ax
  109629:	66 90                	xchg   %ax,%ax
  10962b:	66 90                	xchg   %ax,%ax
  10962d:	66 90                	xchg   %ax,%ax
  10962f:	90                   	nop

00109630 <pte_update_addr>:
{
  109630:	55                   	push   %ebp
  109631:	89 e5                	mov    %esp,%ebp
  109633:	53                   	push   %ebx
  109634:	57                   	push   %edi
  109635:	56                   	push   %esi
  109636:	8b 45 0c             	mov    0xc(%ebp),%eax
  109639:	8b 4d 08             	mov    0x8(%ebp),%ecx
	*pte = ((*pte & ~Z_X86_MMU_PTE_ADDR_MASK) |
  10963c:	8b 55 08             	mov    0x8(%ebp),%edx
  10963f:	8b 32                	mov    (%edx),%esi
  109641:	8b 7a 04             	mov    0x4(%edx),%edi
  109644:	81 e7 00 00 00 f8    	and    $0xf8000000,%edi
  10964a:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
		(addr & Z_X86_MMU_PTE_ADDR_MASK));
  109650:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  109653:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	*pte = ((*pte & ~Z_X86_MMU_PTE_ADDR_MASK) |
  109659:	09 de                	or     %ebx,%esi
  10965b:	89 7a 04             	mov    %edi,0x4(%edx)
  10965e:	89 32                	mov    %esi,(%edx)
}
  109660:	5e                   	pop    %esi
  109661:	5f                   	pop    %edi
  109662:	5b                   	pop    %ebx
  109663:	5d                   	pop    %ebp
  109664:	c3                   	ret    
  109665:	66 90                	xchg   %ax,%ax
  109667:	66 90                	xchg   %ax,%ax
  109669:	66 90                	xchg   %ax,%ax
  10966b:	66 90                	xchg   %ax,%ax
  10966d:	66 90                	xchg   %ax,%ax
  10966f:	90                   	nop

00109670 <z_x86_early_serial_init>:
}

extern void __printk_hook_install(int (*fn)(int));

void z_x86_early_serial_init(void)
{
  109670:	55                   	push   %ebp
  109671:	89 e5                	mov    %esp,%ebp
  109673:	83 ec 34             	sub    $0x34,%esp
  109676:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  10967a:	c7 45 d0 f9 03 00 00 	movl   $0x3f9,-0x30(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  109681:	8a 45 d7             	mov    -0x29(%ebp),%al
  109684:	8b 55 d0             	mov    -0x30(%ebp),%edx
  109687:	ee                   	out    %al,(%dx)
  109688:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
  10968c:	c7 45 d8 fb 03 00 00 	movl   $0x3fb,-0x28(%ebp)
  109693:	8a 45 df             	mov    -0x21(%ebp),%al
  109696:	8b 55 d8             	mov    -0x28(%ebp),%edx
  109699:	ee                   	out    %al,(%dx)
  10969a:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  10969e:	c7 45 e0 f8 03 00 00 	movl   $0x3f8,-0x20(%ebp)
  1096a5:	8a 45 e7             	mov    -0x19(%ebp),%al
  1096a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1096ab:	ee                   	out    %al,(%dx)
  1096ac:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  1096b0:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
  1096b7:	8a 45 ef             	mov    -0x11(%ebp),%al
  1096ba:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1096bd:	ee                   	out    %al,(%dx)
  1096be:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
  1096c2:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
  1096c9:	8a 45 f7             	mov    -0x9(%ebp),%al
  1096cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1096cf:	ee                   	out    %al,(%dx)
  1096d0:	c6 45 ff 03          	movb   $0x3,-0x1(%ebp)
  1096d4:	c7 45 f8 fc 03 00 00 	movl   $0x3fc,-0x8(%ebp)
  1096db:	8a 45 ff             	mov    -0x1(%ebp),%al
  1096de:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1096e1:	ee                   	out    %al,(%dx)
	sys_out8(0, PORT + REG_DL_HI);
	sys_out8(LCR_8N1, PORT + REG_LCR);	/* LCR = 8n1 + DLAB off */
	sys_out8(MCR_DTR | MCR_RTS, PORT + REG_MCR);

	/* Will be replaced later when a real serial driver comes up */
	__printk_hook_install(console_out);
  1096e2:	8d 0d 00 97 10 00    	lea    0x109700,%ecx
  1096e8:	89 0c 24             	mov    %ecx,(%esp)
  1096eb:	e8 80 8e ff ff       	call   102570 <__printk_hook_install>
}
  1096f0:	83 c4 34             	add    $0x34,%esp
  1096f3:	5d                   	pop    %ebp
  1096f4:	c3                   	ret    
  1096f5:	66 90                	xchg   %ax,%ax
  1096f7:	66 90                	xchg   %ax,%ax
  1096f9:	66 90                	xchg   %ax,%ax
  1096fb:	66 90                	xchg   %ax,%ax
  1096fd:	66 90                	xchg   %ax,%ax
  1096ff:	90                   	nop

00109700 <console_out>:
{
  109700:	55                   	push   %ebp
  109701:	89 e5                	mov    %esp,%ebp
  109703:	50                   	push   %eax
  109704:	8b 45 08             	mov    0x8(%ebp),%eax
	if (c == '\n') {
  109707:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  10970b:	0f 85 0c 00 00 00    	jne    10971d <console_out+0x1d>
		serout('\r');
  109711:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  109718:	e8 13 00 00 00       	call   109730 <serout>
	serout(c);
  10971d:	8b 45 08             	mov    0x8(%ebp),%eax
  109720:	89 04 24             	mov    %eax,(%esp)
  109723:	e8 08 00 00 00       	call   109730 <serout>
	return c;
  109728:	8b 45 08             	mov    0x8(%ebp),%eax
  10972b:	83 c4 04             	add    $0x4,%esp
  10972e:	5d                   	pop    %ebp
  10972f:	c3                   	ret    

00109730 <serout>:
{
  109730:	55                   	push   %ebp
  109731:	89 e5                	mov    %esp,%ebp
  109733:	83 ec 10             	sub    $0x10,%esp
  109736:	8b 45 08             	mov    0x8(%ebp),%eax
  109739:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  109740:	8b 55 f4             	mov    -0xc(%ebp),%edx
  109743:	ec                   	in     (%dx),%al
  109744:	88 45 f3             	mov    %al,-0xd(%ebp)
	while (!(sys_in8(PORT + REG_LSR) & LCR_THRE)) {
  109747:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
  10974b:	83 e1 20             	and    $0x20,%ecx
  10974e:	83 f9 00             	cmp    $0x0,%ecx
  109751:	0f 95 c0             	setne  %al
  109754:	34 ff                	xor    $0xff,%al
  109756:	a8 01                	test   $0x1,%al
  109758:	0f 85 05 00 00 00    	jne    109763 <serout+0x33>
  10975e:	e9 05 00 00 00       	jmp    109768 <serout+0x38>
  109763:	e9 d1 ff ff ff       	jmp    109739 <serout+0x9>
	sys_out8(c, PORT);
  109768:	8b 45 08             	mov    0x8(%ebp),%eax
  10976b:	88 45 ff             	mov    %al,-0x1(%ebp)
  10976e:	c7 45 f8 f8 03 00 00 	movl   $0x3f8,-0x8(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  109775:	8a 45 ff             	mov    -0x1(%ebp),%al
  109778:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10977b:	ee                   	out    %al,(%dx)
}
  10977c:	83 c4 10             	add    $0x10,%esp
  10977f:	5d                   	pop    %ebp
  109780:	c3                   	ret    
  109781:	66 90                	xchg   %ax,%ax
  109783:	66 90                	xchg   %ax,%ax
  109785:	66 90                	xchg   %ax,%ax
  109787:	66 90                	xchg   %ax,%ax
  109789:	66 90                	xchg   %ax,%ax
  10978b:	66 90                	xchg   %ax,%ax
  10978d:	66 90                	xchg   %ax,%ax
  10978f:	90                   	nop

00109790 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  109790:	55                   	push   %ebp
  109791:	89 e5                	mov    %esp,%ebp
  109793:	8b 45 08             	mov    0x8(%ebp),%eax
	ARG_UNUSED(unused);

	init_cache_flush();
  109796:	e9 00 00 00 00       	jmp    10979b <init_cache+0xb>
	init_cache_line_size();
  10979b:	e8 10 00 00 00       	call   1097b0 <init_cache_line_size>
  1097a0:	31 c0                	xor    %eax,%eax

	return 0;
  1097a2:	5d                   	pop    %ebp
  1097a3:	c3                   	ret    
  1097a4:	66 90                	xchg   %ax,%ax
  1097a6:	66 90                	xchg   %ax,%ax
  1097a8:	66 90                	xchg   %ax,%ax
  1097aa:	66 90                	xchg   %ax,%ax
  1097ac:	66 90                	xchg   %ax,%ax
  1097ae:	66 90                	xchg   %ax,%ax

001097b0 <init_cache_line_size>:
{
  1097b0:	55                   	push   %ebp
  1097b1:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = z_cache_line_size_get();
  1097b3:	e8 08 00 00 00       	call   1097c0 <z_cache_line_size_get>
  1097b8:	a3 28 51 13 00       	mov    %eax,0x135128
}
  1097bd:	5d                   	pop    %ebp
  1097be:	c3                   	ret    
  1097bf:	90                   	nop

001097c0 <z_cache_line_size_get>:
  1097c0:	53                   	push   %ebx
  1097c1:	b8 01 00 00 00       	mov    $0x1,%eax
  1097c6:	0f a2                	cpuid  
  1097c8:	89 d8                	mov    %ebx,%eax
  1097ca:	25 00 ff 00 00       	and    $0xff00,%eax
  1097cf:	c1 e8 05             	shr    $0x5,%eax
  1097d2:	5b                   	pop    %ebx
  1097d3:	c3                   	ret    
  1097d4:	66 90                	xchg   %ax,%ax
  1097d6:	66 90                	xchg   %ax,%ax
  1097d8:	66 90                	xchg   %ax,%ax
  1097da:	66 90                	xchg   %ax,%ax
  1097dc:	66 90                	xchg   %ax,%ax
  1097de:	66 90                	xchg   %ax,%ax

001097e0 <_exception_enter>:
  1097e0:	fc                   	cld    
  1097e1:	87 0c 24             	xchg   %ecx,(%esp)
  1097e4:	50                   	push   %eax
  1097e5:	52                   	push   %edx
  1097e6:	57                   	push   %edi
  1097e7:	56                   	push   %esi
  1097e8:	53                   	push   %ebx
  1097e9:	55                   	push   %ebp
  1097ea:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  1097ee:	50                   	push   %eax
  1097ef:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  1097f6:	00 
  1097f7:	74 01                	je     1097fa <allDone>
  1097f9:	fb                   	sti    

001097fa <allDone>:
  1097fa:	54                   	push   %esp
  1097fb:	ff d1                	call   *%ecx
  1097fd:	83 c4 04             	add    $0x4,%esp
  109800:	5d                   	pop    %ebp
  109801:	5d                   	pop    %ebp
  109802:	5b                   	pop    %ebx
  109803:	5e                   	pop    %esi
  109804:	5f                   	pop    %edi
  109805:	5a                   	pop    %edx
  109806:	58                   	pop    %eax
  109807:	59                   	pop    %ecx
  109808:	83 c4 04             	add    $0x4,%esp
  10980b:	cf                   	iret   
  10980c:	66 90                	xchg   %ax,%ax
  10980e:	66 90                	xchg   %ax,%ax

00109810 <_kernel_oops_handler>:
  109810:	6a 00                	push   $0x0
  109812:	68 60 9b 10 00       	push   $0x109b60
  109817:	e9 c4 ff ff ff       	jmp    1097e0 <_exception_enter>
  10981c:	66 90                	xchg   %ax,%ax
  10981e:	66 90                	xchg   %ax,%ax

00109820 <_interrupt_enter>:
  109820:	fc                   	cld    
  109821:	87 44 24 04          	xchg   %eax,0x4(%esp)
  109825:	87 14 24             	xchg   %edx,(%esp)
  109828:	51                   	push   %ecx
  109829:	57                   	push   %edi
  10982a:	b9 a8 96 13 00       	mov    $0x1396a8,%ecx
  10982f:	ff 01                	incl   (%ecx)
  109831:	83 39 01             	cmpl   $0x1,(%ecx)
  109834:	75 06                	jne    10983c <alreadyOnIntStack>
  109836:	89 e7                	mov    %esp,%edi
  109838:	8b 61 04             	mov    0x4(%ecx),%esp
  10983b:	57                   	push   %edi

0010983c <alreadyOnIntStack>:
  10983c:	50                   	push   %eax
  10983d:	fb                   	sti    
  10983e:	ff d2                	call   *%edx
  109840:	83 c4 04             	add    $0x4,%esp
  109843:	fa                   	cli    
  109844:	31 c0                	xor    %eax,%eax
  109846:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
  10984b:	b9 a8 96 13 00       	mov    $0x1396a8,%ecx
  109850:	ff 09                	decl   (%ecx)
  109852:	75 18                	jne    10986c <nestedInterrupt>
  109854:	8b 51 08             	mov    0x8(%ecx),%edx
  109857:	39 51 20             	cmp    %edx,0x20(%ecx)
  10985a:	74 0f                	je     10986b <noReschedule>
  10985c:	5c                   	pop    %esp
  10985d:	9c                   	pushf  
  10985e:	e8 4d 00 00 00       	call   1098b0 <arch_swap>
  109863:	83 c4 04             	add    $0x4,%esp
  109866:	5f                   	pop    %edi
  109867:	59                   	pop    %ecx
  109868:	5a                   	pop    %edx
  109869:	58                   	pop    %eax
  10986a:	cf                   	iret   

0010986b <noReschedule>:
  10986b:	5c                   	pop    %esp

0010986c <nestedInterrupt>:
  10986c:	5f                   	pop    %edi
  10986d:	59                   	pop    %ecx
  10986e:	5a                   	pop    %edx
  10986f:	58                   	pop    %eax
  109870:	cf                   	iret   
  109871:	66 90                	xchg   %ax,%ax
  109873:	66 90                	xchg   %ax,%ax
  109875:	66 90                	xchg   %ax,%ax
  109877:	66 90                	xchg   %ax,%ax
  109879:	66 90                	xchg   %ax,%ax
  10987b:	66 90                	xchg   %ax,%ax
  10987d:	66 90                	xchg   %ax,%ax
  10987f:	90                   	nop

00109880 <z_SpuriousIntNoErrCodeHandler>:
  109880:	6a 00                	push   $0x0
  109882:	66 90                	xchg   %ax,%ax
  109884:	66 90                	xchg   %ax,%ax
  109886:	66 90                	xchg   %ax,%ax
  109888:	66 90                	xchg   %ax,%ax
  10988a:	66 90                	xchg   %ax,%ax
  10988c:	66 90                	xchg   %ax,%ax
  10988e:	66 90                	xchg   %ax,%ax

00109890 <z_SpuriousIntHandler>:
  109890:	fc                   	cld    
  109891:	50                   	push   %eax
  109892:	51                   	push   %ecx
  109893:	52                   	push   %edx
  109894:	57                   	push   %edi
  109895:	56                   	push   %esi
  109896:	53                   	push   %ebx
  109897:	55                   	push   %ebp
  109898:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
  10989c:	51                   	push   %ecx
  10989d:	54                   	push   %esp
  10989e:	fb                   	sti    
  10989f:	e8 7c 01 00 00       	call   109a20 <z_x86_spurious_irq>
  1098a4:	66 90                	xchg   %ax,%ax
  1098a6:	66 90                	xchg   %ax,%ax
  1098a8:	66 90                	xchg   %ax,%ax
  1098aa:	66 90                	xchg   %ax,%ax
  1098ac:	66 90                	xchg   %ax,%ax
  1098ae:	66 90                	xchg   %ax,%ax

001098b0 <arch_swap>:
  1098b0:	57                   	push   %edi
  1098b1:	bf a8 96 13 00       	mov    $0x1396a8,%edi
  1098b6:	56                   	push   %esi
  1098b7:	53                   	push   %ebx
  1098b8:	55                   	push   %ebp
  1098b9:	ff 35 a4 36 12 00    	pushl  0x1236a4
  1098bf:	8b 57 08             	mov    0x8(%edi),%edx
  1098c2:	89 62 28             	mov    %esp,0x28(%edx)
  1098c5:	8b 47 20             	mov    0x20(%edi),%eax
  1098c8:	89 47 08             	mov    %eax,0x8(%edi)
  1098cb:	8b 60 28             	mov    0x28(%eax),%esp
  1098ce:	58                   	pop    %eax
  1098cf:	5d                   	pop    %ebp
  1098d0:	5b                   	pop    %ebx
  1098d1:	5e                   	pop    %esi
  1098d2:	5f                   	pop    %edi
  1098d3:	ff 74 24 04          	pushl  0x4(%esp)
  1098d7:	9d                   	popf   
  1098d8:	c3                   	ret    
  1098d9:	66 90                	xchg   %ax,%ax
  1098db:	66 90                	xchg   %ax,%ax
  1098dd:	66 90                	xchg   %ax,%ax
  1098df:	90                   	nop

001098e0 <z_x86_thread_entry_wrapper>:
  1098e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1098e7:	ff e7                	jmp    *%edi
  1098e9:	66 90                	xchg   %ax,%ax
  1098eb:	66 90                	xchg   %ax,%ax
  1098ed:	66 90                	xchg   %ax,%ax
  1098ef:	90                   	nop

001098f0 <arch_new_thread>:

void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stack_size, k_thread_entry_t entry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
  1098f0:	55                   	push   %ebp
  1098f1:	89 e5                	mov    %esp,%ebp
  1098f3:	53                   	push   %ebx
  1098f4:	57                   	push   %edi
  1098f5:	56                   	push   %esi
  1098f6:	83 ec 2c             	sub    $0x2c,%esp
  1098f9:	8b 45 28             	mov    0x28(%ebp),%eax
  1098fc:	8b 4d 24             	mov    0x24(%ebp),%ecx
  1098ff:	8b 55 20             	mov    0x20(%ebp),%edx
  109902:	8b 75 1c             	mov    0x1c(%ebp),%esi
  109905:	8b 7d 18             	mov    0x18(%ebp),%edi
  109908:	8b 5d 14             	mov    0x14(%ebp),%ebx
  10990b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10990e:	8b 45 10             	mov    0x10(%ebp),%eax
  109911:	89 45 e0             	mov    %eax,-0x20(%ebp)
  109914:	8b 45 0c             	mov    0xc(%ebp),%eax
  109917:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10991a:	8b 45 08             	mov    0x8(%ebp),%eax
#if defined(CONFIG_X86_USERSPACE) || defined(CONFIG_X86_STACK_PROTECTION)
	struct z_x86_thread_stack_header *header =
		(struct z_x86_thread_stack_header *)stack;
#endif

	Z_ASSERT_VALID_PRIO(priority, entry);
  10991d:	e9 00 00 00 00       	jmp    109922 <arch_new_thread+0x32>
	stack_buf = Z_THREAD_STACK_BUFFER(stack);
  109922:	8b 45 0c             	mov    0xc(%ebp),%eax
  109925:	89 04 24             	mov    %eax,(%esp)
  109928:	e8 a3 00 00 00       	call   1099d0 <Z_THREAD_STACK_BUFFER>
  10992d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	z_new_thread_init(thread, stack_buf, stack_size, priority, options);
  109930:	8b 45 08             	mov    0x8(%ebp),%eax
  109933:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  109936:	8b 55 10             	mov    0x10(%ebp),%edx
  109939:	8b 75 24             	mov    0x24(%ebp),%esi
  10993c:	8b 7d 28             	mov    0x28(%ebp),%edi
  10993f:	89 04 24             	mov    %eax,(%esp)
  109942:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109946:	89 54 24 08          	mov    %edx,0x8(%esp)
  10994a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10994e:	89 7c 24 10          	mov    %edi,0x10(%esp)
  109952:	e8 b9 6a 01 00       	call   120410 <z_new_thread_init>
  109957:	8d 05 e0 98 10 00    	lea    0x1098e0,%eax
	z_x86_mmu_set_flags(&z_x86_kernel_ptables, &header->guard_page,
			    MMU_PAGE_SIZE, MMU_ENTRY_READ, Z_X86_MMU_RW,
			    true);
#endif

	stack_high = (char *)STACK_ROUND_DOWN(stack_buf + stack_size);
  10995d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  109960:	03 4d 10             	add    0x10(%ebp),%ecx
  109963:	83 e1 fc             	and    $0xfffffffc,%ecx
  109966:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	/* Create an initial context on the stack expected by z_swap() */
	initial_frame = (struct _x86_initial_frame *)
		(stack_high - sizeof(struct _x86_initial_frame));
  109969:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10996c:	83 c1 d4             	add    $0xffffffd4,%ecx
	initial_frame = (struct _x86_initial_frame *)
  10996f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	/* z_thread_entry() arguments */
	initial_frame->entry = entry;
  109972:	8b 4d 14             	mov    0x14(%ebp),%ecx
  109975:	8b 55 e8             	mov    -0x18(%ebp),%edx
  109978:	89 4a 1c             	mov    %ecx,0x1c(%edx)
	initial_frame->p1 = parameter1;
  10997b:	8b 4d 18             	mov    0x18(%ebp),%ecx
  10997e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  109981:	89 4a 20             	mov    %ecx,0x20(%edx)
	initial_frame->p2 = parameter2;
  109984:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  109987:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10998a:	89 4a 24             	mov    %ecx,0x24(%edx)
	initial_frame->p3 = parameter3;
  10998d:	8b 4d 20             	mov    0x20(%ebp),%ecx
  109990:	8b 55 e8             	mov    -0x18(%ebp),%edx
  109993:	89 4a 28             	mov    %ecx,0x28(%edx)
	initial_frame->eflags = EFLAGS_INITIAL;
  109996:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  109999:	c7 41 18 00 02 00 00 	movl   $0x200,0x18(%ecx)
#endif /* _THREAD_WRAPPER_REQUIRED */
	} else
#endif /* CONFIG_X86_USERSPACE */
	{
#ifdef _THREAD_WRAPPER_REQUIRED
		initial_frame->edi = (u32_t)z_thread_entry;
  1099a0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1099a3:	8d 15 d0 24 10 00    	lea    0x1024d0,%edx
  1099a9:	89 51 10             	mov    %edx,0x10(%ecx)
		initial_frame->thread_entry = z_x86_thread_entry_wrapper;
  1099ac:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1099af:	89 41 14             	mov    %eax,0x14(%ecx)
#endif
	}
	/* Remaining _x86_initial_frame members can be garbage, z_thread_entry()
	 * doesn't care about their state when execution begins
	 */
	thread->callee_saved.esp = (unsigned long)initial_frame;
  1099b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1099b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1099b8:	89 41 28             	mov    %eax,0x28(%ecx)

#if defined(CONFIG_LAZY_FP_SHARING)
	thread->arch.excNestCount = 0;
#endif /* CONFIG_LAZY_FP_SHARING */

	thread->arch.flags = 0;
  1099bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1099be:	c6 40 3c 00          	movb   $0x0,0x3c(%eax)
}
  1099c2:	83 c4 2c             	add    $0x2c,%esp
  1099c5:	5e                   	pop    %esi
  1099c6:	5f                   	pop    %edi
  1099c7:	5b                   	pop    %ebx
  1099c8:	5d                   	pop    %ebp
  1099c9:	c3                   	ret    
  1099ca:	66 90                	xchg   %ax,%ax
  1099cc:	66 90                	xchg   %ax,%ax
  1099ce:	66 90                	xchg   %ax,%ax

001099d0 <Z_THREAD_STACK_BUFFER>:
{
  1099d0:	55                   	push   %ebp
  1099d1:	89 e5                	mov    %esp,%ebp
  1099d3:	50                   	push   %eax
  1099d4:	8b 45 08             	mov    0x8(%ebp),%eax
	return ARCH_THREAD_STACK_BUFFER(sym);
  1099d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1099da:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1099dd:	89 c8                	mov    %ecx,%eax
  1099df:	83 c4 04             	add    $0x4,%esp
  1099e2:	5d                   	pop    %ebp
  1099e3:	c3                   	ret    
  1099e4:	66 90                	xchg   %ax,%ax
  1099e6:	66 90                	xchg   %ax,%ax
  1099e8:	66 90                	xchg   %ax,%ax
  1099ea:	66 90                	xchg   %ax,%ax
  1099ec:	66 90                	xchg   %ax,%ax
  1099ee:	66 90                	xchg   %ax,%ax

001099f0 <arch_system_halt>:
__weak void z_debug_fatal_hook(const z_arch_esf_t *esf) { ARG_UNUSED(esf); }


#ifdef CONFIG_BOARD_QEMU_X86
FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  1099f0:	55                   	push   %ebp
  1099f1:	89 e5                	mov    %esp,%ebp
  1099f3:	83 ec 0c             	sub    $0xc,%esp
  1099f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1099f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  109a00:	c7 45 f8 f4 00 00 00 	movl   $0xf4,-0x8(%ebp)
	__asm__ volatile("outl %0, %w1" :: "a"(data), "Nd"(port));
  109a07:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  109a0a:	8b 55 f8             	mov    -0x8(%ebp),%edx
  109a0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  109a10:	89 c8                	mov    %ecx,%eax
  109a12:	ef                   	out    %eax,(%dx)
  109a13:	66 90                	xchg   %ax,%ax
  109a15:	66 90                	xchg   %ax,%ax
  109a17:	66 90                	xchg   %ax,%ax
  109a19:	66 90                	xchg   %ax,%ax
  109a1b:	66 90                	xchg   %ax,%ax
  109a1d:	66 90                	xchg   %ax,%ax
  109a1f:	90                   	nop

00109a20 <z_x86_spurious_irq>:
	CODE_UNREACHABLE;
}
#endif

void z_x86_spurious_irq(const z_arch_esf_t *esf)
{
  109a20:	55                   	push   %ebp
  109a21:	89 e5                	mov    %esp,%ebp
  109a23:	83 e4 f8             	and    $0xfffffff8,%esp
  109a26:	83 ec 18             	sub    $0x18,%esp
  109a29:	8b 45 08             	mov    0x8(%ebp),%eax
  109a2c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	int vector = z_irq_controller_isr_vector_get();
  109a30:	e8 db dc ff ff       	call   107710 <z_irq_controller_isr_vector_get>
  109a35:	89 44 24 14          	mov    %eax,0x14(%esp)

	if (vector >= 0) {
  109a39:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
  109a3e:	0f 8c d9 00 00 00    	jl     109b1d <z_x86_spurious_irq+0xfd>
		LOG_ERR("IRQ vector: %d", vector);
  109a44:	e9 00 00 00 00       	jmp    109a49 <z_x86_spurious_irq+0x29>
  109a49:	e8 e2 00 00 00       	call   109b30 <_is_user_context>
  109a4e:	24 01                	and    $0x1,%al
  109a50:	88 44 24 13          	mov    %al,0x13(%esp)
  109a54:	f6 44 24 13 01       	testb  $0x1,0x13(%esp)
  109a59:	0f 85 0f 00 00 00    	jne    109a6e <z_x86_spurious_irq+0x4e>
  109a5f:	b0 01                	mov    $0x1,%al
  109a61:	a8 01                	test   $0x1,%al
  109a63:	0f 85 05 00 00 00    	jne    109a6e <z_x86_spurious_irq+0x4e>
  109a69:	e9 a5 00 00 00       	jmp    109b13 <z_x86_spurious_irq+0xf3>
  109a6e:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  109a73:	66 83 e0 f8          	and    $0xfff8,%ax
  109a77:	66 83 c8 01          	or     $0x1,%ax
  109a7b:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  109a80:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  109a85:	66 83 e0 c7          	and    $0xffc7,%ax
  109a89:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  109a8e:	8b 0d 1c 30 14 00    	mov    0x14301c,%ecx
  109a94:	89 0c 24             	mov    %ecx,(%esp)
  109a97:	e8 a4 00 00 00       	call   109b40 <log_const_source_id>
  109a9c:	66 8b 54 24 10       	mov    0x10(%esp),%dx
  109aa1:	66 25 ff 03          	and    $0x3ff,%ax
  109aa5:	66 c1 e0 06          	shl    $0x6,%ax
  109aa9:	66 83 e2 3f          	and    $0x3f,%dx
  109aad:	66 09 c2             	or     %ax,%dx
  109ab0:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  109ab5:	f6 44 24 13 01       	testb  $0x1,0x13(%esp)
  109aba:	0f 84 27 00 00 00    	je     109ae7 <z_x86_spurious_irq+0xc7>
  109ac0:	8b 44 24 14          	mov    0x14(%esp),%eax
  109ac4:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  109ac8:	66 8b 11             	mov    (%ecx),%dx
  109acb:	66 89 14 24          	mov    %dx,(%esp)
  109acf:	8d 0d 91 3a 12 00    	lea    0x123a91,%ecx
  109ad5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109ad9:	89 44 24 08          	mov    %eax,0x8(%esp)
  109add:	e8 5e a5 ff ff       	call   104040 <log_from_user>
  109ae2:	e9 22 00 00 00       	jmp    109b09 <z_x86_spurious_irq+0xe9>
  109ae7:	8b 44 24 14          	mov    0x14(%esp),%eax
  109aeb:	8d 0d 91 3a 12 00    	lea    0x123a91,%ecx
  109af1:	89 0c 24             	mov    %ecx,(%esp)
  109af4:	89 44 24 04          	mov    %eax,0x4(%esp)
  109af8:	8d 44 24 10          	lea    0x10(%esp),%eax
  109afc:	66 8b 10             	mov    (%eax),%dx
  109aff:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  109b04:	e8 57 98 ff ff       	call   103360 <log_1>
  109b09:	e9 00 00 00 00       	jmp    109b0e <z_x86_spurious_irq+0xee>
  109b0e:	e9 00 00 00 00       	jmp    109b13 <z_x86_spurious_irq+0xf3>
  109b13:	e9 00 00 00 00       	jmp    109b18 <z_x86_spurious_irq+0xf8>
	}
  109b18:	e9 00 00 00 00       	jmp    109b1d <z_x86_spurious_irq+0xfd>

	z_x86_fatal_error(K_ERR_SPURIOUS_IRQ, esf);
  109b1d:	8b 45 08             	mov    0x8(%ebp),%eax
  109b20:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  109b27:	89 44 24 04          	mov    %eax,0x4(%esp)
  109b2b:	e8 20 e2 ff ff       	call   107d50 <z_x86_fatal_error>

00109b30 <_is_user_context>:
{
  109b30:	55                   	push   %ebp
  109b31:	89 e5                	mov    %esp,%ebp
  109b33:	31 c0                	xor    %eax,%eax
	return false;
  109b35:	24 01                	and    $0x1,%al
  109b37:	0f b6 c0             	movzbl %al,%eax
  109b3a:	5d                   	pop    %ebp
  109b3b:	c3                   	ret    
  109b3c:	66 90                	xchg   %ax,%ax
  109b3e:	66 90                	xchg   %ax,%ax

00109b40 <log_const_source_id>:
{
  109b40:	55                   	push   %ebp
  109b41:	89 e5                	mov    %esp,%ebp
  109b43:	50                   	push   %eax
  109b44:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  109b47:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109b4a:	8d 15 84 30 12 00    	lea    0x123084,%edx
  109b50:	29 d1                	sub    %edx,%ecx
  109b52:	c1 e9 03             	shr    $0x3,%ecx
  109b55:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109b58:	89 c8                	mov    %ecx,%eax
  109b5a:	83 c4 04             	add    $0x4,%esp
  109b5d:	5d                   	pop    %ebp
  109b5e:	c3                   	ret    
  109b5f:	90                   	nop

00109b60 <z_do_kernel_oops>:
	z_x86_fatal_error(K_ERR_KERNEL_OOPS, &oops);
}

#ifdef CONFIG_X86_KERNEL_OOPS
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
  109b60:	55                   	push   %ebp
  109b61:	89 e5                	mov    %esp,%ebp
  109b63:	83 ec 14             	sub    $0x14,%esp
  109b66:	8b 45 08             	mov    0x8(%ebp),%eax
	u32_t *stack_ptr = (u32_t *)esf->esp;
  109b69:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109b6c:	8b 09                	mov    (%ecx),%ecx
  109b6e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	u32_t reason = *stack_ptr;
  109b71:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  109b74:	8b 09                	mov    (%ecx),%ecx
  109b76:	89 4d f8             	mov    %ecx,-0x8(%ebp)
					  reason == K_ERR_STACK_CHK_FAIL)) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_x86_fatal_error(reason, esf);
  109b79:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  109b7c:	8b 55 08             	mov    0x8(%ebp),%edx
  109b7f:	89 0c 24             	mov    %ecx,(%esp)
  109b82:	89 54 24 04          	mov    %edx,0x4(%esp)
  109b86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  109b89:	e8 c2 e1 ff ff       	call   107d50 <z_x86_fatal_error>
  109b8e:	66 90                	xchg   %ax,%ax

00109b90 <handle_exc_0>:
	Z_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	Z_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  109b90:	55                   	push   %ebp
  109b91:	89 e5                	mov    %esp,%ebp
  109b93:	83 ec 10             	sub    $0x10,%esp
  109b96:	8b 45 08             	mov    0x8(%ebp),%eax
  109b99:	31 c9                	xor    %ecx,%ecx
  109b9b:	8b 55 08             	mov    0x8(%ebp),%edx
  109b9e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  109ba5:	89 54 24 04          	mov    %edx,0x4(%esp)
  109ba9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109bac:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  109baf:	e8 0c 00 00 00       	call   109bc0 <generic_exc_handle>
  109bb4:	66 90                	xchg   %ax,%ax
  109bb6:	66 90                	xchg   %ax,%ax
  109bb8:	66 90                	xchg   %ax,%ax
  109bba:	66 90                	xchg   %ax,%ax
  109bbc:	66 90                	xchg   %ax,%ax
  109bbe:	66 90                	xchg   %ax,%ax

00109bc0 <generic_exc_handle>:
{
  109bc0:	55                   	push   %ebp
  109bc1:	89 e5                	mov    %esp,%ebp
  109bc3:	56                   	push   %esi
  109bc4:	83 e4 f8             	and    $0xfffffff8,%esp
  109bc7:	83 ec 38             	sub    $0x38,%esp
  109bca:	8b 45 0c             	mov    0xc(%ebp),%eax
  109bcd:	8b 4d 08             	mov    0x8(%ebp),%ecx
	switch (vector) {
  109bd0:	8b 55 08             	mov    0x8(%ebp),%edx
  109bd3:	89 d6                	mov    %edx,%esi
  109bd5:	83 ee 07             	sub    $0x7,%esi
  109bd8:	89 54 24 14          	mov    %edx,0x14(%esp)
  109bdc:	0f 84 e0 00 00 00    	je     109cc2 <generic_exc_handle+0x102>
  109be2:	e9 00 00 00 00       	jmp    109be7 <generic_exc_handle+0x27>
  109be7:	8b 44 24 14          	mov    0x14(%esp),%eax
  109beb:	83 e8 0d             	sub    $0xd,%eax
  109bee:	0f 85 97 01 00 00    	jne    109d8b <generic_exc_handle+0x1cb>
  109bf4:	e9 00 00 00 00       	jmp    109bf9 <generic_exc_handle+0x39>
		LOG_ERR("General Protection Fault");
  109bf9:	e9 00 00 00 00       	jmp    109bfe <generic_exc_handle+0x3e>
  109bfe:	e8 2d ff ff ff       	call   109b30 <_is_user_context>
  109c03:	24 01                	and    $0x1,%al
  109c05:	88 44 24 33          	mov    %al,0x33(%esp)
  109c09:	f6 44 24 33 01       	testb  $0x1,0x33(%esp)
  109c0e:	0f 85 0f 00 00 00    	jne    109c23 <generic_exc_handle+0x63>
  109c14:	b0 01                	mov    $0x1,%al
  109c16:	a8 01                	test   $0x1,%al
  109c18:	0f 85 05 00 00 00    	jne    109c23 <generic_exc_handle+0x63>
  109c1e:	e9 95 00 00 00       	jmp    109cb8 <generic_exc_handle+0xf8>
  109c23:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  109c28:	66 83 e0 f8          	and    $0xfff8,%ax
  109c2c:	66 83 c8 01          	or     $0x1,%ax
  109c30:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  109c35:	66 8b 44 24 30       	mov    0x30(%esp),%ax
  109c3a:	66 83 e0 c7          	and    $0xffc7,%ax
  109c3e:	66 89 44 24 30       	mov    %ax,0x30(%esp)
  109c43:	8b 0d 1c 30 14 00    	mov    0x14301c,%ecx
  109c49:	89 0c 24             	mov    %ecx,(%esp)
  109c4c:	e8 ef fe ff ff       	call   109b40 <log_const_source_id>
  109c51:	66 8b 54 24 30       	mov    0x30(%esp),%dx
  109c56:	66 25 ff 03          	and    $0x3ff,%ax
  109c5a:	66 c1 e0 06          	shl    $0x6,%ax
  109c5e:	66 83 e2 3f          	and    $0x3f,%dx
  109c62:	66 09 c2             	or     %ax,%dx
  109c65:	66 89 54 24 30       	mov    %dx,0x30(%esp)
  109c6a:	f6 44 24 33 01       	testb  $0x1,0x33(%esp)
  109c6f:	0f 84 1f 00 00 00    	je     109c94 <generic_exc_handle+0xd4>
  109c75:	8d 44 24 30          	lea    0x30(%esp),%eax
  109c79:	66 8b 08             	mov    (%eax),%cx
  109c7c:	66 89 0c 24          	mov    %cx,(%esp)
  109c80:	8d 05 a0 3a 12 00    	lea    0x123aa0,%eax
  109c86:	89 44 24 04          	mov    %eax,0x4(%esp)
  109c8a:	e8 b1 a3 ff ff       	call   104040 <log_from_user>
  109c8f:	e9 1a 00 00 00       	jmp    109cae <generic_exc_handle+0xee>
  109c94:	8d 05 a0 3a 12 00    	lea    0x123aa0,%eax
  109c9a:	89 04 24             	mov    %eax,(%esp)
  109c9d:	8d 44 24 30          	lea    0x30(%esp),%eax
  109ca1:	66 8b 08             	mov    (%eax),%cx
  109ca4:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  109ca9:	e8 f2 94 ff ff       	call   1031a0 <log_0>
  109cae:	e9 00 00 00 00       	jmp    109cb3 <generic_exc_handle+0xf3>
  109cb3:	e9 00 00 00 00       	jmp    109cb8 <generic_exc_handle+0xf8>
  109cb8:	e9 00 00 00 00       	jmp    109cbd <generic_exc_handle+0xfd>
		break;
  109cbd:	e9 a0 01 00 00       	jmp    109e62 <generic_exc_handle+0x2a2>
		LOG_ERR("Floating point unit not enabled");
  109cc2:	e9 00 00 00 00       	jmp    109cc7 <generic_exc_handle+0x107>
  109cc7:	e8 64 fe ff ff       	call   109b30 <_is_user_context>
  109ccc:	24 01                	and    $0x1,%al
  109cce:	88 44 24 2f          	mov    %al,0x2f(%esp)
  109cd2:	f6 44 24 2f 01       	testb  $0x1,0x2f(%esp)
  109cd7:	0f 85 0f 00 00 00    	jne    109cec <generic_exc_handle+0x12c>
  109cdd:	b0 01                	mov    $0x1,%al
  109cdf:	a8 01                	test   $0x1,%al
  109ce1:	0f 85 05 00 00 00    	jne    109cec <generic_exc_handle+0x12c>
  109ce7:	e9 95 00 00 00       	jmp    109d81 <generic_exc_handle+0x1c1>
  109cec:	66 8b 44 24 28       	mov    0x28(%esp),%ax
  109cf1:	66 83 e0 f8          	and    $0xfff8,%ax
  109cf5:	66 83 c8 01          	or     $0x1,%ax
  109cf9:	66 89 44 24 28       	mov    %ax,0x28(%esp)
  109cfe:	66 8b 44 24 28       	mov    0x28(%esp),%ax
  109d03:	66 83 e0 c7          	and    $0xffc7,%ax
  109d07:	66 89 44 24 28       	mov    %ax,0x28(%esp)
  109d0c:	8b 0d 1c 30 14 00    	mov    0x14301c,%ecx
  109d12:	89 0c 24             	mov    %ecx,(%esp)
  109d15:	e8 26 fe ff ff       	call   109b40 <log_const_source_id>
  109d1a:	66 8b 54 24 28       	mov    0x28(%esp),%dx
  109d1f:	66 25 ff 03          	and    $0x3ff,%ax
  109d23:	66 c1 e0 06          	shl    $0x6,%ax
  109d27:	66 83 e2 3f          	and    $0x3f,%dx
  109d2b:	66 09 c2             	or     %ax,%dx
  109d2e:	66 89 54 24 28       	mov    %dx,0x28(%esp)
  109d33:	f6 44 24 2f 01       	testb  $0x1,0x2f(%esp)
  109d38:	0f 84 1f 00 00 00    	je     109d5d <generic_exc_handle+0x19d>
  109d3e:	8d 44 24 28          	lea    0x28(%esp),%eax
  109d42:	66 8b 08             	mov    (%eax),%cx
  109d45:	66 89 0c 24          	mov    %cx,(%esp)
  109d49:	8d 05 b9 3a 12 00    	lea    0x123ab9,%eax
  109d4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  109d53:	e8 e8 a2 ff ff       	call   104040 <log_from_user>
  109d58:	e9 1a 00 00 00       	jmp    109d77 <generic_exc_handle+0x1b7>
  109d5d:	8d 05 b9 3a 12 00    	lea    0x123ab9,%eax
  109d63:	89 04 24             	mov    %eax,(%esp)
  109d66:	8d 44 24 28          	lea    0x28(%esp),%eax
  109d6a:	66 8b 08             	mov    (%eax),%cx
  109d6d:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  109d72:	e8 29 94 ff ff       	call   1031a0 <log_0>
  109d77:	e9 00 00 00 00       	jmp    109d7c <generic_exc_handle+0x1bc>
  109d7c:	e9 00 00 00 00       	jmp    109d81 <generic_exc_handle+0x1c1>
  109d81:	e9 00 00 00 00       	jmp    109d86 <generic_exc_handle+0x1c6>
		break;
  109d86:	e9 d7 00 00 00       	jmp    109e62 <generic_exc_handle+0x2a2>
		LOG_ERR("CPU exception %d", vector);
  109d8b:	e9 00 00 00 00       	jmp    109d90 <generic_exc_handle+0x1d0>
  109d90:	e8 9b fd ff ff       	call   109b30 <_is_user_context>
  109d95:	24 01                	and    $0x1,%al
  109d97:	88 44 24 27          	mov    %al,0x27(%esp)
  109d9b:	f6 44 24 27 01       	testb  $0x1,0x27(%esp)
  109da0:	0f 85 0f 00 00 00    	jne    109db5 <generic_exc_handle+0x1f5>
  109da6:	b0 01                	mov    $0x1,%al
  109da8:	a8 01                	test   $0x1,%al
  109daa:	0f 85 05 00 00 00    	jne    109db5 <generic_exc_handle+0x1f5>
  109db0:	e9 a3 00 00 00       	jmp    109e58 <generic_exc_handle+0x298>
  109db5:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  109dba:	66 83 e0 f8          	and    $0xfff8,%ax
  109dbe:	66 83 c8 01          	or     $0x1,%ax
  109dc2:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  109dc7:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  109dcc:	66 83 e0 c7          	and    $0xffc7,%ax
  109dd0:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  109dd5:	8b 0d 1c 30 14 00    	mov    0x14301c,%ecx
  109ddb:	89 0c 24             	mov    %ecx,(%esp)
  109dde:	e8 5d fd ff ff       	call   109b40 <log_const_source_id>
  109de3:	66 8b 54 24 20       	mov    0x20(%esp),%dx
  109de8:	66 25 ff 03          	and    $0x3ff,%ax
  109dec:	66 c1 e0 06          	shl    $0x6,%ax
  109df0:	66 83 e2 3f          	and    $0x3f,%dx
  109df4:	66 09 c2             	or     %ax,%dx
  109df7:	66 89 54 24 20       	mov    %dx,0x20(%esp)
  109dfc:	f6 44 24 27 01       	testb  $0x1,0x27(%esp)
  109e01:	0f 84 26 00 00 00    	je     109e2d <generic_exc_handle+0x26d>
  109e07:	8b 45 08             	mov    0x8(%ebp),%eax
  109e0a:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  109e0e:	66 8b 11             	mov    (%ecx),%dx
  109e11:	66 89 14 24          	mov    %dx,(%esp)
  109e15:	8d 0d d9 3a 12 00    	lea    0x123ad9,%ecx
  109e1b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109e1f:	89 44 24 08          	mov    %eax,0x8(%esp)
  109e23:	e8 18 a2 ff ff       	call   104040 <log_from_user>
  109e28:	e9 21 00 00 00       	jmp    109e4e <generic_exc_handle+0x28e>
  109e2d:	8b 45 08             	mov    0x8(%ebp),%eax
  109e30:	8d 0d d9 3a 12 00    	lea    0x123ad9,%ecx
  109e36:	89 0c 24             	mov    %ecx,(%esp)
  109e39:	89 44 24 04          	mov    %eax,0x4(%esp)
  109e3d:	8d 44 24 20          	lea    0x20(%esp),%eax
  109e41:	66 8b 10             	mov    (%eax),%dx
  109e44:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  109e49:	e8 12 95 ff ff       	call   103360 <log_1>
  109e4e:	e9 00 00 00 00       	jmp    109e53 <generic_exc_handle+0x293>
  109e53:	e9 00 00 00 00       	jmp    109e58 <generic_exc_handle+0x298>
  109e58:	e9 00 00 00 00       	jmp    109e5d <generic_exc_handle+0x29d>
		break;
  109e5d:	e9 00 00 00 00       	jmp    109e62 <generic_exc_handle+0x2a2>
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
  109e62:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109e65:	b8 01 00 00 00       	mov    $0x1,%eax
  109e6a:	d3 e0                	shl    %cl,%eax
  109e6c:	25 00 7d 02 00       	and    $0x27d00,%eax
  109e71:	83 f8 00             	cmp    $0x0,%eax
  109e74:	0f 84 dd 00 00 00    	je     109f57 <generic_exc_handle+0x397>
		LOG_ERR("Exception code: 0x%x", pEsf->errorCode);
  109e7a:	e9 00 00 00 00       	jmp    109e7f <generic_exc_handle+0x2bf>
  109e7f:	e8 ac fc ff ff       	call   109b30 <_is_user_context>
  109e84:	24 01                	and    $0x1,%al
  109e86:	88 44 24 1f          	mov    %al,0x1f(%esp)
  109e8a:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  109e8f:	0f 85 0f 00 00 00    	jne    109ea4 <generic_exc_handle+0x2e4>
  109e95:	b0 01                	mov    $0x1,%al
  109e97:	a8 01                	test   $0x1,%al
  109e99:	0f 85 05 00 00 00    	jne    109ea4 <generic_exc_handle+0x2e4>
  109e9f:	e9 a9 00 00 00       	jmp    109f4d <generic_exc_handle+0x38d>
  109ea4:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  109ea9:	66 83 e0 f8          	and    $0xfff8,%ax
  109ead:	66 83 c8 01          	or     $0x1,%ax
  109eb1:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  109eb6:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  109ebb:	66 83 e0 c7          	and    $0xffc7,%ax
  109ebf:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  109ec4:	8b 0d 1c 30 14 00    	mov    0x14301c,%ecx
  109eca:	89 0c 24             	mov    %ecx,(%esp)
  109ecd:	e8 6e fc ff ff       	call   109b40 <log_const_source_id>
  109ed2:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  109ed7:	66 25 ff 03          	and    $0x3ff,%ax
  109edb:	66 c1 e0 06          	shl    $0x6,%ax
  109edf:	66 83 e2 3f          	and    $0x3f,%dx
  109ee3:	66 09 c2             	or     %ax,%dx
  109ee6:	66 89 54 24 18       	mov    %dx,0x18(%esp)
  109eeb:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  109ef0:	0f 84 29 00 00 00    	je     109f1f <generic_exc_handle+0x35f>
  109ef6:	8b 45 0c             	mov    0xc(%ebp),%eax
  109ef9:	8b 40 20             	mov    0x20(%eax),%eax
  109efc:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  109f00:	66 8b 11             	mov    (%ecx),%dx
  109f03:	66 89 14 24          	mov    %dx,(%esp)
  109f07:	8d 0d ea 3a 12 00    	lea    0x123aea,%ecx
  109f0d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109f11:	89 44 24 08          	mov    %eax,0x8(%esp)
  109f15:	e8 26 a1 ff ff       	call   104040 <log_from_user>
  109f1a:	e9 24 00 00 00       	jmp    109f43 <generic_exc_handle+0x383>
  109f1f:	8b 45 0c             	mov    0xc(%ebp),%eax
  109f22:	8b 40 20             	mov    0x20(%eax),%eax
  109f25:	8d 0d ea 3a 12 00    	lea    0x123aea,%ecx
  109f2b:	89 0c 24             	mov    %ecx,(%esp)
  109f2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  109f32:	8d 44 24 18          	lea    0x18(%esp),%eax
  109f36:	66 8b 10             	mov    (%eax),%dx
  109f39:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  109f3e:	e8 1d 94 ff ff       	call   103360 <log_1>
  109f43:	e9 00 00 00 00       	jmp    109f48 <generic_exc_handle+0x388>
  109f48:	e9 00 00 00 00       	jmp    109f4d <generic_exc_handle+0x38d>
  109f4d:	e9 00 00 00 00       	jmp    109f52 <generic_exc_handle+0x392>
	}
  109f52:	e9 00 00 00 00       	jmp    109f57 <generic_exc_handle+0x397>
  109f57:	31 c0                	xor    %eax,%eax
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, pEsf);
  109f59:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  109f5c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  109f63:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109f67:	89 44 24 10          	mov    %eax,0x10(%esp)
  109f6b:	e8 e0 dd ff ff       	call   107d50 <z_x86_fatal_error>

00109f70 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  109f70:	55                   	push   %ebp
  109f71:	89 e5                	mov    %esp,%ebp
  109f73:	83 ec 0c             	sub    $0xc,%esp
  109f76:	8b 45 08             	mov    0x8(%ebp),%eax
  109f79:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109f7c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  109f83:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109f87:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109f8a:	e8 31 fc ff ff       	call   109bc0 <generic_exc_handle>
  109f8f:	90                   	nop

00109f90 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  109f90:	55                   	push   %ebp
  109f91:	89 e5                	mov    %esp,%ebp
  109f93:	83 ec 0c             	sub    $0xc,%esp
  109f96:	8b 45 08             	mov    0x8(%ebp),%eax
  109f99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109f9c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  109fa3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109fa7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109faa:	e8 11 fc ff ff       	call   109bc0 <generic_exc_handle>
  109faf:	90                   	nop

00109fb0 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  109fb0:	55                   	push   %ebp
  109fb1:	89 e5                	mov    %esp,%ebp
  109fb3:	83 ec 0c             	sub    $0xc,%esp
  109fb6:	8b 45 08             	mov    0x8(%ebp),%eax
  109fb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109fbc:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  109fc3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109fc7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109fca:	e8 f1 fb ff ff       	call   109bc0 <generic_exc_handle>
  109fcf:	90                   	nop

00109fd0 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  109fd0:	55                   	push   %ebp
  109fd1:	89 e5                	mov    %esp,%ebp
  109fd3:	83 ec 0c             	sub    $0xc,%esp
  109fd6:	8b 45 08             	mov    0x8(%ebp),%eax
  109fd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109fdc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  109fe3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  109fe7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109fea:	e8 d1 fb ff ff       	call   109bc0 <generic_exc_handle>
  109fef:	90                   	nop

00109ff0 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  109ff0:	55                   	push   %ebp
  109ff1:	89 e5                	mov    %esp,%ebp
  109ff3:	83 ec 0c             	sub    $0xc,%esp
  109ff6:	8b 45 08             	mov    0x8(%ebp),%eax
  109ff9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  109ffc:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  10a003:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a007:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a00a:	e8 b1 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a00f:	90                   	nop

0010a010 <handle_exc_8>:
#ifndef CONFIG_X86_ENABLE_TSS
EXC_FUNC_NOCODE(IV_DOUBLE_FAULT);
  10a010:	55                   	push   %ebp
  10a011:	89 e5                	mov    %esp,%ebp
  10a013:	83 ec 0c             	sub    $0xc,%esp
  10a016:	8b 45 08             	mov    0x8(%ebp),%eax
  10a019:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a01c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10a023:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a027:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a02a:	e8 91 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a02f:	90                   	nop

0010a030 <handle_exc_10>:
#endif
EXC_FUNC_CODE(IV_INVALID_TSS);
  10a030:	55                   	push   %ebp
  10a031:	89 e5                	mov    %esp,%ebp
  10a033:	83 ec 0c             	sub    $0xc,%esp
  10a036:	8b 45 08             	mov    0x8(%ebp),%eax
  10a039:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a03c:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  10a043:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a047:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a04a:	e8 71 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a04f:	90                   	nop

0010a050 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  10a050:	55                   	push   %ebp
  10a051:	89 e5                	mov    %esp,%ebp
  10a053:	83 ec 0c             	sub    $0xc,%esp
  10a056:	8b 45 08             	mov    0x8(%ebp),%eax
  10a059:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a05c:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  10a063:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a067:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a06a:	e8 51 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a06f:	90                   	nop

0010a070 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  10a070:	55                   	push   %ebp
  10a071:	89 e5                	mov    %esp,%ebp
  10a073:	83 ec 0c             	sub    $0xc,%esp
  10a076:	8b 45 08             	mov    0x8(%ebp),%eax
  10a079:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a07c:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10a083:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a087:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a08a:	e8 31 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a08f:	90                   	nop

0010a090 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  10a090:	55                   	push   %ebp
  10a091:	89 e5                	mov    %esp,%ebp
  10a093:	83 ec 0c             	sub    $0xc,%esp
  10a096:	8b 45 08             	mov    0x8(%ebp),%eax
  10a099:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a09c:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  10a0a3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a0a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a0aa:	e8 11 fb ff ff       	call   109bc0 <generic_exc_handle>
  10a0af:	90                   	nop

0010a0b0 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  10a0b0:	55                   	push   %ebp
  10a0b1:	89 e5                	mov    %esp,%ebp
  10a0b3:	83 ec 0c             	sub    $0xc,%esp
  10a0b6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a0bc:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10a0c3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a0c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a0ca:	e8 f1 fa ff ff       	call   109bc0 <generic_exc_handle>
  10a0cf:	90                   	nop

0010a0d0 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  10a0d0:	55                   	push   %ebp
  10a0d1:	89 e5                	mov    %esp,%ebp
  10a0d3:	83 ec 0c             	sub    $0xc,%esp
  10a0d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a0dc:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  10a0e3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a0e7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a0ea:	e8 d1 fa ff ff       	call   109bc0 <generic_exc_handle>
  10a0ef:	90                   	nop

0010a0f0 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  10a0f0:	55                   	push   %ebp
  10a0f1:	89 e5                	mov    %esp,%ebp
  10a0f3:	83 ec 0c             	sub    $0xc,%esp
  10a0f6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a0fc:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  10a103:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a107:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a10a:	e8 b1 fa ff ff       	call   109bc0 <generic_exc_handle>
  10a10f:	90                   	nop

0010a110 <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
  10a110:	55                   	push   %ebp
  10a111:	89 e5                	mov    %esp,%ebp
  10a113:	50                   	push   %eax
  10a114:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a117:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char *dest = d;
  10a11a:	8b 55 08             	mov    0x8(%ebp),%edx
  10a11d:	89 55 fc             	mov    %edx,-0x4(%ebp)

	while (*s != '\0') {
  10a120:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a123:	0f be 00             	movsbl (%eax),%eax
  10a126:	83 f8 00             	cmp    $0x0,%eax
  10a129:	0f 84 21 00 00 00    	je     10a150 <strcpy+0x40>
		*d = *s;
  10a12f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a132:	8a 08                	mov    (%eax),%cl
  10a134:	8b 45 08             	mov    0x8(%ebp),%eax
  10a137:	88 08                	mov    %cl,(%eax)
		d++;
  10a139:	8b 45 08             	mov    0x8(%ebp),%eax
  10a13c:	83 c0 01             	add    $0x1,%eax
  10a13f:	89 45 08             	mov    %eax,0x8(%ebp)
		s++;
  10a142:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a145:	83 c0 01             	add    $0x1,%eax
  10a148:	89 45 0c             	mov    %eax,0xc(%ebp)
	while (*s != '\0') {
  10a14b:	e9 d0 ff ff ff       	jmp    10a120 <strcpy+0x10>
	}

	*d = '\0';
  10a150:	8b 45 08             	mov    0x8(%ebp),%eax
  10a153:	c6 00 00             	movb   $0x0,(%eax)

	return dest;
  10a156:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a159:	83 c4 04             	add    $0x4,%esp
  10a15c:	5d                   	pop    %ebp
  10a15d:	c3                   	ret    
  10a15e:	66 90                	xchg   %ax,%ax

0010a160 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
  10a160:	55                   	push   %ebp
  10a161:	89 e5                	mov    %esp,%ebp
  10a163:	56                   	push   %esi
  10a164:	83 ec 08             	sub    $0x8,%esp
  10a167:	8b 45 10             	mov    0x10(%ebp),%eax
  10a16a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a16d:	8b 55 08             	mov    0x8(%ebp),%edx
	char *dest = d;
  10a170:	8b 75 08             	mov    0x8(%ebp),%esi
  10a173:	89 75 f8             	mov    %esi,-0x8(%ebp)
  10a176:	31 c0                	xor    %eax,%eax

	while ((n > 0) && *s != '\0') {
  10a178:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a17c:	88 45 f7             	mov    %al,-0x9(%ebp)
  10a17f:	0f 86 0f 00 00 00    	jbe    10a194 <strncpy+0x34>
  10a185:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a188:	0f be 00             	movsbl (%eax),%eax
  10a18b:	83 f8 00             	cmp    $0x0,%eax
  10a18e:	0f 95 c1             	setne  %cl
  10a191:	88 4d f7             	mov    %cl,-0x9(%ebp)
  10a194:	8a 45 f7             	mov    -0x9(%ebp),%al
  10a197:	a8 01                	test   $0x1,%al
  10a199:	0f 85 05 00 00 00    	jne    10a1a4 <strncpy+0x44>
  10a19f:	e9 2a 00 00 00       	jmp    10a1ce <strncpy+0x6e>
		*d = *s;
  10a1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a1a7:	8a 08                	mov    (%eax),%cl
  10a1a9:	8b 45 08             	mov    0x8(%ebp),%eax
  10a1ac:	88 08                	mov    %cl,(%eax)
		s++;
  10a1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a1b1:	83 c0 01             	add    $0x1,%eax
  10a1b4:	89 45 0c             	mov    %eax,0xc(%ebp)
		d++;
  10a1b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10a1ba:	83 c0 01             	add    $0x1,%eax
  10a1bd:	89 45 08             	mov    %eax,0x8(%ebp)
		n--;
  10a1c0:	8b 45 10             	mov    0x10(%ebp),%eax
  10a1c3:	83 c0 ff             	add    $0xffffffff,%eax
  10a1c6:	89 45 10             	mov    %eax,0x10(%ebp)
	while ((n > 0) && *s != '\0') {
  10a1c9:	e9 a8 ff ff ff       	jmp    10a176 <strncpy+0x16>
	}

	while (n > 0) {
  10a1ce:	e9 00 00 00 00       	jmp    10a1d3 <strncpy+0x73>
  10a1d3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a1d7:	0f 86 1d 00 00 00    	jbe    10a1fa <strncpy+0x9a>
		*d = '\0';
  10a1dd:	8b 45 08             	mov    0x8(%ebp),%eax
  10a1e0:	c6 00 00             	movb   $0x0,(%eax)
		d++;
  10a1e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10a1e6:	83 c0 01             	add    $0x1,%eax
  10a1e9:	89 45 08             	mov    %eax,0x8(%ebp)
		n--;
  10a1ec:	8b 45 10             	mov    0x10(%ebp),%eax
  10a1ef:	83 c0 ff             	add    $0xffffffff,%eax
  10a1f2:	89 45 10             	mov    %eax,0x10(%ebp)
	while (n > 0) {
  10a1f5:	e9 d9 ff ff ff       	jmp    10a1d3 <strncpy+0x73>
	}

	return dest;
  10a1fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10a1fd:	83 c4 08             	add    $0x8,%esp
  10a200:	5e                   	pop    %esi
  10a201:	5d                   	pop    %ebp
  10a202:	c3                   	ret    
  10a203:	66 90                	xchg   %ax,%ax
  10a205:	66 90                	xchg   %ax,%ax
  10a207:	66 90                	xchg   %ax,%ax
  10a209:	66 90                	xchg   %ax,%ax
  10a20b:	66 90                	xchg   %ax,%ax
  10a20d:	66 90                	xchg   %ax,%ax
  10a20f:	90                   	nop

0010a210 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  10a210:	55                   	push   %ebp
  10a211:	89 e5                	mov    %esp,%ebp
  10a213:	83 ec 08             	sub    $0x8,%esp
  10a216:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a219:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char tmp = (char) c;
  10a21c:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a21f:	88 55 ff             	mov    %dl,-0x1(%ebp)
  10a222:	31 c0                	xor    %eax,%eax

	while ((*s != tmp) && (*s != '\0')) {
  10a224:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a227:	0f be 09             	movsbl (%ecx),%ecx
  10a22a:	0f be 55 ff          	movsbl -0x1(%ebp),%edx
  10a22e:	39 d1                	cmp    %edx,%ecx
  10a230:	88 45 fe             	mov    %al,-0x2(%ebp)
  10a233:	0f 84 0f 00 00 00    	je     10a248 <strchr+0x38>
  10a239:	8b 45 08             	mov    0x8(%ebp),%eax
  10a23c:	0f be 00             	movsbl (%eax),%eax
  10a23f:	83 f8 00             	cmp    $0x0,%eax
  10a242:	0f 95 c1             	setne  %cl
  10a245:	88 4d fe             	mov    %cl,-0x2(%ebp)
  10a248:	8a 45 fe             	mov    -0x2(%ebp),%al
  10a24b:	a8 01                	test   $0x1,%al
  10a24d:	0f 85 05 00 00 00    	jne    10a258 <strchr+0x48>
  10a253:	e9 0e 00 00 00       	jmp    10a266 <strchr+0x56>
		s++;
  10a258:	8b 45 08             	mov    0x8(%ebp),%eax
  10a25b:	83 c0 01             	add    $0x1,%eax
  10a25e:	89 45 08             	mov    %eax,0x8(%ebp)
	while ((*s != tmp) && (*s != '\0')) {
  10a261:	e9 bc ff ff ff       	jmp    10a222 <strchr+0x12>
	}

	return (*s == tmp) ? (char *) s : NULL;
  10a266:	8b 45 08             	mov    0x8(%ebp),%eax
  10a269:	0f be 00             	movsbl (%eax),%eax
  10a26c:	0f be 4d ff          	movsbl -0x1(%ebp),%ecx
  10a270:	39 c8                	cmp    %ecx,%eax
  10a272:	0f 85 0b 00 00 00    	jne    10a283 <strchr+0x73>
  10a278:	8b 45 08             	mov    0x8(%ebp),%eax
  10a27b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10a27e:	e9 0a 00 00 00       	jmp    10a28d <strchr+0x7d>
  10a283:	31 c0                	xor    %eax,%eax
  10a285:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10a288:	e9 00 00 00 00       	jmp    10a28d <strchr+0x7d>
  10a28d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10a290:	83 c4 08             	add    $0x8,%esp
  10a293:	5d                   	pop    %ebp
  10a294:	c3                   	ret    
  10a295:	66 90                	xchg   %ax,%ax
  10a297:	66 90                	xchg   %ax,%ax
  10a299:	66 90                	xchg   %ax,%ax
  10a29b:	66 90                	xchg   %ax,%ax
  10a29d:	66 90                	xchg   %ax,%ax
  10a29f:	90                   	nop

0010a2a0 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
  10a2a0:	55                   	push   %ebp
  10a2a1:	89 e5                	mov    %esp,%ebp
  10a2a3:	50                   	push   %eax
  10a2a4:	8b 45 08             	mov    0x8(%ebp),%eax
	size_t n = 0;
  10a2a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

	while (*s != '\0') {
  10a2ae:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2b1:	0f be 00             	movsbl (%eax),%eax
  10a2b4:	83 f8 00             	cmp    $0x0,%eax
  10a2b7:	0f 84 17 00 00 00    	je     10a2d4 <strlen+0x34>
		s++;
  10a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2c0:	83 c0 01             	add    $0x1,%eax
  10a2c3:	89 45 08             	mov    %eax,0x8(%ebp)
		n++;
  10a2c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a2c9:	83 c0 01             	add    $0x1,%eax
  10a2cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while (*s != '\0') {
  10a2cf:	e9 da ff ff ff       	jmp    10a2ae <strlen+0xe>
	}

	return n;
  10a2d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a2d7:	83 c4 04             	add    $0x4,%esp
  10a2da:	5d                   	pop    %ebp
  10a2db:	c3                   	ret    
  10a2dc:	66 90                	xchg   %ax,%ax
  10a2de:	66 90                	xchg   %ax,%ax

0010a2e0 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  10a2e0:	55                   	push   %ebp
  10a2e1:	89 e5                	mov    %esp,%ebp
  10a2e3:	50                   	push   %eax
  10a2e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a2e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a2ea:	31 c0                	xor    %eax,%eax
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10a2ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10a2ef:	0f be 09             	movsbl (%ecx),%ecx
  10a2f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a2f5:	0f be 12             	movsbl (%edx),%edx
  10a2f8:	39 d1                	cmp    %edx,%ecx
  10a2fa:	88 45 ff             	mov    %al,-0x1(%ebp)
  10a2fd:	0f 85 0f 00 00 00    	jne    10a312 <strcmp+0x32>
  10a303:	8b 45 08             	mov    0x8(%ebp),%eax
  10a306:	0f be 00             	movsbl (%eax),%eax
  10a309:	83 f8 00             	cmp    $0x0,%eax
  10a30c:	0f 95 c1             	setne  %cl
  10a30f:	88 4d ff             	mov    %cl,-0x1(%ebp)
  10a312:	8a 45 ff             	mov    -0x1(%ebp),%al
  10a315:	a8 01                	test   $0x1,%al
  10a317:	0f 85 05 00 00 00    	jne    10a322 <strcmp+0x42>
  10a31d:	e9 17 00 00 00       	jmp    10a339 <strcmp+0x59>
		s1++;
  10a322:	8b 45 08             	mov    0x8(%ebp),%eax
  10a325:	83 c0 01             	add    $0x1,%eax
  10a328:	89 45 08             	mov    %eax,0x8(%ebp)
		s2++;
  10a32b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a32e:	83 c0 01             	add    $0x1,%eax
  10a331:	89 45 0c             	mov    %eax,0xc(%ebp)
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10a334:	e9 b1 ff ff ff       	jmp    10a2ea <strcmp+0xa>
	}

	return *s1 - *s2;
  10a339:	8b 45 08             	mov    0x8(%ebp),%eax
  10a33c:	0f be 00             	movsbl (%eax),%eax
  10a33f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a342:	0f be 09             	movsbl (%ecx),%ecx
  10a345:	29 c8                	sub    %ecx,%eax
  10a347:	83 c4 04             	add    $0x4,%esp
  10a34a:	5d                   	pop    %ebp
  10a34b:	c3                   	ret    
  10a34c:	66 90                	xchg   %ax,%ax
  10a34e:	66 90                	xchg   %ax,%ax

0010a350 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  10a350:	55                   	push   %ebp
  10a351:	89 e5                	mov    %esp,%ebp
  10a353:	57                   	push   %edi
  10a354:	56                   	push   %esi
  10a355:	83 ec 18             	sub    $0x18,%esp
  10a358:	8b 45 10             	mov    0x10(%ebp),%eax
  10a35b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a35e:	8b 55 08             	mov    0x8(%ebp),%edx
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
  10a361:	8b 75 08             	mov    0x8(%ebp),%esi
  10a364:	89 75 f0             	mov    %esi,-0x10(%ebp)
	const unsigned char *s_byte = (const unsigned char *)s;
  10a367:	8b 75 0c             	mov    0xc(%ebp),%esi
  10a36a:	89 75 ec             	mov    %esi,-0x14(%ebp)
	const uintptr_t mask = sizeof(mem_word_t) - 1;
  10a36d:	c7 45 e8 03 00 00 00 	movl   $0x3,-0x18(%ebp)

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
  10a374:	8b 75 08             	mov    0x8(%ebp),%esi
  10a377:	8b 7d ec             	mov    -0x14(%ebp),%edi
  10a37a:	31 fe                	xor    %edi,%esi
  10a37c:	83 e6 03             	and    $0x3,%esi
  10a37f:	83 fe 00             	cmp    $0x0,%esi
  10a382:	0f 85 9b 00 00 00    	jne    10a423 <memcpy+0xd3>

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
  10a388:	e9 00 00 00 00       	jmp    10a38d <memcpy+0x3d>
  10a38d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a390:	83 e0 03             	and    $0x3,%eax
  10a393:	83 f8 00             	cmp    $0x0,%eax
  10a396:	0f 84 3d 00 00 00    	je     10a3d9 <memcpy+0x89>
			if (n == 0) {
  10a39c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a3a0:	0f 85 0b 00 00 00    	jne    10a3b1 <memcpy+0x61>
				return d;
  10a3a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a3a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10a3ac:	e9 af 00 00 00       	jmp    10a460 <memcpy+0x110>
			}
			*(d_byte++) = *(s_byte++);
  10a3b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a3b4:	89 c1                	mov    %eax,%ecx
  10a3b6:	83 c1 01             	add    $0x1,%ecx
  10a3b9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10a3bc:	8a 10                	mov    (%eax),%dl
  10a3be:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a3c1:	89 c1                	mov    %eax,%ecx
  10a3c3:	83 c1 01             	add    $0x1,%ecx
  10a3c6:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10a3c9:	88 10                	mov    %dl,(%eax)
			n--;
  10a3cb:	8b 45 10             	mov    0x10(%ebp),%eax
  10a3ce:	83 c0 ff             	add    $0xffffffff,%eax
  10a3d1:	89 45 10             	mov    %eax,0x10(%ebp)
		while (((uintptr_t)d_byte) & mask) {
  10a3d4:	e9 b4 ff ff ff       	jmp    10a38d <memcpy+0x3d>
		};

		/* do word-sized copying as long as possible */

		mem_word_t *d_word = (mem_word_t *)d_byte;
  10a3d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a3dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		const mem_word_t *s_word = (const mem_word_t *)s_byte;
  10a3df:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a3e2:	89 45 e0             	mov    %eax,-0x20(%ebp)

		while (n >= sizeof(mem_word_t)) {
  10a3e5:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
  10a3e9:	0f 82 28 00 00 00    	jb     10a417 <memcpy+0xc7>
			*(d_word++) = *(s_word++);
  10a3ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10a3f2:	89 c1                	mov    %eax,%ecx
  10a3f4:	83 c1 04             	add    $0x4,%ecx
  10a3f7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10a3fa:	8b 00                	mov    (%eax),%eax
  10a3fc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10a3ff:	89 ca                	mov    %ecx,%edx
  10a401:	83 c2 04             	add    $0x4,%edx
  10a404:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10a407:	89 01                	mov    %eax,(%ecx)
			n -= sizeof(mem_word_t);
  10a409:	8b 45 10             	mov    0x10(%ebp),%eax
  10a40c:	83 e8 04             	sub    $0x4,%eax
  10a40f:	89 45 10             	mov    %eax,0x10(%ebp)
		while (n >= sizeof(mem_word_t)) {
  10a412:	e9 ce ff ff ff       	jmp    10a3e5 <memcpy+0x95>
		}

		d_byte = (unsigned char *)d_word;
  10a417:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a41a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		s_byte = (unsigned char *)s_word;
  10a41d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10a420:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  10a423:	e9 00 00 00 00       	jmp    10a428 <memcpy+0xd8>
  10a428:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a42c:	0f 86 28 00 00 00    	jbe    10a45a <memcpy+0x10a>
		*(d_byte++) = *(s_byte++);
  10a432:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a435:	89 c1                	mov    %eax,%ecx
  10a437:	83 c1 01             	add    $0x1,%ecx
  10a43a:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10a43d:	8a 10                	mov    (%eax),%dl
  10a43f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a442:	89 c1                	mov    %eax,%ecx
  10a444:	83 c1 01             	add    $0x1,%ecx
  10a447:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10a44a:	88 10                	mov    %dl,(%eax)
		n--;
  10a44c:	8b 45 10             	mov    0x10(%ebp),%eax
  10a44f:	83 c0 ff             	add    $0xffffffff,%eax
  10a452:	89 45 10             	mov    %eax,0x10(%ebp)
	while (n > 0) {
  10a455:	e9 ce ff ff ff       	jmp    10a428 <memcpy+0xd8>
	}

	return d;
  10a45a:	8b 45 08             	mov    0x8(%ebp),%eax
  10a45d:	89 45 f4             	mov    %eax,-0xc(%ebp)
}
  10a460:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10a463:	83 c4 18             	add    $0x18,%esp
  10a466:	5e                   	pop    %esi
  10a467:	5f                   	pop    %edi
  10a468:	5d                   	pop    %ebp
  10a469:	c3                   	ret    
  10a46a:	66 90                	xchg   %ax,%ax
  10a46c:	66 90                	xchg   %ax,%ax
  10a46e:	66 90                	xchg   %ax,%ax

0010a470 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  10a470:	55                   	push   %ebp
  10a471:	89 e5                	mov    %esp,%ebp
  10a473:	53                   	push   %ebx
  10a474:	56                   	push   %esi
  10a475:	83 ec 14             	sub    $0x14,%esp
  10a478:	8b 45 10             	mov    0x10(%ebp),%eax
  10a47b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10a47e:	8b 55 08             	mov    0x8(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
  10a481:	8b 75 08             	mov    0x8(%ebp),%esi
  10a484:	89 75 f0             	mov    %esi,-0x10(%ebp)
	unsigned char c_byte = (unsigned char)c;
  10a487:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10a48a:	88 5d ef             	mov    %bl,-0x11(%ebp)

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
  10a48d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a490:	83 e0 03             	and    $0x3,%eax
  10a493:	83 f8 00             	cmp    $0x0,%eax
  10a496:	0f 84 33 00 00 00    	je     10a4cf <memset+0x5f>
		if (n == 0) {
  10a49c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a4a0:	0f 85 0b 00 00 00    	jne    10a4b1 <memset+0x41>
			return buf;
  10a4a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a4a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10a4ac:	e9 9f 00 00 00       	jmp    10a550 <memset+0xe0>
		}
		*(d_byte++) = c_byte;
  10a4b1:	8a 45 ef             	mov    -0x11(%ebp),%al
  10a4b4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10a4b7:	89 ca                	mov    %ecx,%edx
  10a4b9:	83 c2 01             	add    $0x1,%edx
  10a4bc:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10a4bf:	88 01                	mov    %al,(%ecx)
		n--;
  10a4c1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10a4c4:	83 c1 ff             	add    $0xffffffff,%ecx
  10a4c7:	89 4d 10             	mov    %ecx,0x10(%ebp)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
  10a4ca:	e9 be ff ff ff       	jmp    10a48d <memset+0x1d>
	};

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
  10a4cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a4d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	mem_word_t c_word = (mem_word_t)c_byte;
  10a4d5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  10a4d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	c_word |= c_word << 8;
  10a4dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a4df:	c1 e0 08             	shl    $0x8,%eax
  10a4e2:	0b 45 e4             	or     -0x1c(%ebp),%eax
  10a4e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	c_word |= c_word << 16;
  10a4e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a4eb:	c1 e0 10             	shl    $0x10,%eax
  10a4ee:	0b 45 e4             	or     -0x1c(%ebp),%eax
  10a4f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
  10a4f4:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
  10a4f8:	0f 82 1e 00 00 00    	jb     10a51c <memset+0xac>
		*(d_word++) = c_word;
  10a4fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a501:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10a504:	89 ca                	mov    %ecx,%edx
  10a506:	83 c2 04             	add    $0x4,%edx
  10a509:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10a50c:	89 01                	mov    %eax,(%ecx)
		n -= sizeof(mem_word_t);
  10a50e:	8b 45 10             	mov    0x10(%ebp),%eax
  10a511:	83 e8 04             	sub    $0x4,%eax
  10a514:	89 45 10             	mov    %eax,0x10(%ebp)
	while (n >= sizeof(mem_word_t)) {
  10a517:	e9 d8 ff ff ff       	jmp    10a4f4 <memset+0x84>
	}

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
  10a51c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a51f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (n > 0) {
  10a522:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a526:	0f 86 1e 00 00 00    	jbe    10a54a <memset+0xda>
		*(d_byte++) = c_byte;
  10a52c:	8a 45 ef             	mov    -0x11(%ebp),%al
  10a52f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10a532:	89 ca                	mov    %ecx,%edx
  10a534:	83 c2 01             	add    $0x1,%edx
  10a537:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10a53a:	88 01                	mov    %al,(%ecx)
		n--;
  10a53c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10a53f:	83 c1 ff             	add    $0xffffffff,%ecx
  10a542:	89 4d 10             	mov    %ecx,0x10(%ebp)
	while (n > 0) {
  10a545:	e9 d8 ff ff ff       	jmp    10a522 <memset+0xb2>
	}

	return buf;
  10a54a:	8b 45 08             	mov    0x8(%ebp),%eax
  10a54d:	89 45 f4             	mov    %eax,-0xc(%ebp)
}
  10a550:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10a553:	83 c4 14             	add    $0x14,%esp
  10a556:	5e                   	pop    %esi
  10a557:	5b                   	pop    %ebx
  10a558:	5d                   	pop    %ebp
  10a559:	c3                   	ret    
  10a55a:	66 90                	xchg   %ax,%ax
  10a55c:	66 90                	xchg   %ax,%ax
  10a55e:	66 90                	xchg   %ax,%ax

0010a560 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
  10a560:	55                   	push   %ebp
  10a561:	89 e5                	mov    %esp,%ebp
  10a563:	53                   	push   %ebx
  10a564:	57                   	push   %edi
  10a565:	56                   	push   %esi
  10a566:	83 e4 f8             	and    $0xfffffff8,%esp
  10a569:	81 ec b8 00 00 00    	sub    $0xb8,%esp
  10a56f:	8b 45 14             	mov    0x14(%ebp),%eax
  10a572:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10a575:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a578:	8b 75 08             	mov    0x8(%ebp),%esi
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
  10a57b:	c7 84 24 90 00 00 00 	movl   $0x0,0x90(%esp)
  10a582:	00 00 00 00 

	while ((c = *format++)) {
  10a586:	8b 45 10             	mov    0x10(%ebp),%eax
  10a589:	89 c1                	mov    %eax,%ecx
  10a58b:	83 c1 01             	add    $0x1,%ecx
  10a58e:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a591:	8a 10                	mov    (%eax),%dl
  10a593:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
  10a59a:	80 fa 00             	cmp    $0x0,%dl
  10a59d:	0f 84 3e 0f 00 00    	je     10b4e1 <z_prf+0xf81>
		if (c != '%') {
  10a5a3:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a5aa:	00 
  10a5ab:	83 f8 25             	cmp    $0x25,%eax
  10a5ae:	0f 84 50 00 00 00    	je     10a604 <z_prf+0xa4>
			PUTC(c);
  10a5b4:	e9 00 00 00 00       	jmp    10a5b9 <z_prf+0x59>
  10a5b9:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5bc:	0f be 8c 24 96 00 00 	movsbl 0x96(%esp),%ecx
  10a5c3:	00 
  10a5c4:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a5c7:	89 0c 24             	mov    %ecx,(%esp)
  10a5ca:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a5ce:	ff d0                	call   *%eax
  10a5d0:	83 f8 ff             	cmp    $0xffffffff,%eax
  10a5d3:	0f 85 10 00 00 00    	jne    10a5e9 <z_prf+0x89>
  10a5d9:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10a5e0:	ff ff ff ff 
  10a5e4:	e9 06 0f 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10a5e9:	e9 00 00 00 00       	jmp    10a5ee <z_prf+0x8e>
			count++;
  10a5ee:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10a5f5:	83 c0 01             	add    $0x1,%eax
  10a5f8:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
		} else {
  10a5ff:	e9 d8 0e 00 00       	jmp    10b4dc <z_prf+0xf7c>
			fminus = fplus = fspace = falt = fzero = false;
  10a604:	c6 84 24 87 00 00 00 	movb   $0x0,0x87(%esp)
  10a60b:	00 
  10a60c:	c6 84 24 8b 00 00 00 	movb   $0x0,0x8b(%esp)
  10a613:	00 
  10a614:	c6 84 24 88 00 00 00 	movb   $0x0,0x88(%esp)
  10a61b:	00 
  10a61c:	c6 84 24 89 00 00 00 	movb   $0x0,0x89(%esp)
  10a623:	00 
  10a624:	c6 84 24 8a 00 00 00 	movb   $0x0,0x8a(%esp)
  10a62b:	00 
			while (strchr("-+ #0", (c = *format++)) != NULL) {
  10a62c:	8b 45 10             	mov    0x10(%ebp),%eax
  10a62f:	89 c1                	mov    %eax,%ecx
  10a631:	83 c1 01             	add    $0x1,%ecx
  10a634:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a637:	8a 10                	mov    (%eax),%dl
  10a639:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
  10a640:	0f be c2             	movsbl %dl,%eax
  10a643:	8d 0d ff 3a 12 00    	lea    0x123aff,%ecx
  10a649:	89 0c 24             	mov    %ecx,(%esp)
  10a64c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a650:	e8 bb fb ff ff       	call   10a210 <strchr>
  10a655:	83 f8 00             	cmp    $0x0,%eax
  10a658:	0f 84 7d 00 00 00    	je     10a6db <z_prf+0x17b>
				switch (c) {
  10a65e:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a665:	00 
  10a666:	89 c1                	mov    %eax,%ecx
  10a668:	83 e9 30             	sub    $0x30,%ecx
  10a66b:	89 44 24 44          	mov    %eax,0x44(%esp)
  10a66f:	0f 87 61 00 00 00    	ja     10a6d6 <z_prf+0x176>
  10a675:	8b 44 24 44          	mov    0x44(%esp),%eax
  10a679:	8b 0c 85 80 34 12 00 	mov    0x123480(,%eax,4),%ecx
  10a680:	ff e1                	jmp    *%ecx
				case '-':
					fminus = true;
  10a682:	c6 84 24 8a 00 00 00 	movb   $0x1,0x8a(%esp)
  10a689:	01 
					break;
  10a68a:	e9 47 00 00 00       	jmp    10a6d6 <z_prf+0x176>

				case '+':
					fplus = true;
  10a68f:	c6 84 24 89 00 00 00 	movb   $0x1,0x89(%esp)
  10a696:	01 
					break;
  10a697:	e9 3a 00 00 00       	jmp    10a6d6 <z_prf+0x176>

				case ' ':
					fspace = true;
  10a69c:	c6 84 24 88 00 00 00 	movb   $0x1,0x88(%esp)
  10a6a3:	01 
					break;
  10a6a4:	e9 2d 00 00 00       	jmp    10a6d6 <z_prf+0x176>

				case '#':
					falt = true;
  10a6a9:	c6 84 24 8b 00 00 00 	movb   $0x1,0x8b(%esp)
  10a6b0:	01 
					break;
  10a6b1:	e9 20 00 00 00       	jmp    10a6d6 <z_prf+0x176>

				case '0':
					fzero = true;
  10a6b6:	c6 84 24 87 00 00 00 	movb   $0x1,0x87(%esp)
  10a6bd:	01 
					break;
  10a6be:	e9 13 00 00 00       	jmp    10a6d6 <z_prf+0x176>

				case '\0':
					return count;
  10a6c3:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10a6ca:	89 84 24 b0 00 00 00 	mov    %eax,0xb0(%esp)
  10a6d1:	e9 19 0e 00 00       	jmp    10b4ef <z_prf+0xf8f>
			while (strchr("-+ #0", (c = *format++)) != NULL) {
  10a6d6:	e9 51 ff ff ff       	jmp    10a62c <z_prf+0xcc>
				}
			}

			if (c == '*') {
  10a6db:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a6e2:	00 
  10a6e3:	83 f8 2a             	cmp    $0x2a,%eax
  10a6e6:	0f 85 47 00 00 00    	jne    10a733 <z_prf+0x1d3>
				/* Is the width a parameter? */
				width = va_arg(vargs, int);
  10a6ec:	8b 45 14             	mov    0x14(%ebp),%eax
  10a6ef:	89 c1                	mov    %eax,%ecx
  10a6f1:	83 c1 04             	add    $0x4,%ecx
  10a6f4:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a6f7:	8b 00                	mov    (%eax),%eax
  10a6f9:	89 44 24 7c          	mov    %eax,0x7c(%esp)
				if (width < 0) {
  10a6fd:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
  10a702:	0f 8d 12 00 00 00    	jge    10a71a <z_prf+0x1ba>
  10a708:	31 c0                	xor    %eax,%eax
					fminus = true;
  10a70a:	c6 84 24 8a 00 00 00 	movb   $0x1,0x8a(%esp)
  10a711:	01 
					width = -width;
  10a712:	2b 44 24 7c          	sub    0x7c(%esp),%eax
  10a716:	89 44 24 7c          	mov    %eax,0x7c(%esp)
				}
				c = *format++;
  10a71a:	8b 45 10             	mov    0x10(%ebp),%eax
  10a71d:	89 c1                	mov    %eax,%ecx
  10a71f:	83 c1 01             	add    $0x1,%ecx
  10a722:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a725:	8a 10                	mov    (%eax),%dl
  10a727:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
			} else if (!isdigit(c)) {
  10a72e:	e9 4e 00 00 00       	jmp    10a781 <z_prf+0x221>
  10a733:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a73a:	00 
  10a73b:	89 04 24             	mov    %eax,(%esp)
  10a73e:	e8 bd 0d 00 00       	call   10b500 <isdigit>
  10a743:	83 f8 00             	cmp    $0x0,%eax
  10a746:	0f 85 0d 00 00 00    	jne    10a759 <z_prf+0x1f9>
				width = 0;
  10a74c:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
  10a753:	00 
			} else {
  10a754:	e9 23 00 00 00       	jmp    10a77c <z_prf+0x21c>
				width = _atoi(&format);	/* Find width */
  10a759:	8d 45 10             	lea    0x10(%ebp),%eax
  10a75c:	89 04 24             	mov    %eax,(%esp)
  10a75f:	e8 cc 0d 00 00       	call   10b530 <_atoi>
  10a764:	89 44 24 7c          	mov    %eax,0x7c(%esp)
				c = *format++;
  10a768:	8b 45 10             	mov    0x10(%ebp),%eax
  10a76b:	89 c1                	mov    %eax,%ecx
  10a76d:	83 c1 01             	add    $0x1,%ecx
  10a770:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a773:	8a 10                	mov    (%eax),%dl
  10a775:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
  10a77c:	e9 00 00 00 00       	jmp    10a781 <z_prf+0x221>
			}

			precision = -1;
  10a781:	c7 44 24 78 ff ff ff 	movl   $0xffffffff,0x78(%esp)
  10a788:	ff 
			if (c == '.') {
  10a789:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a790:	00 
  10a791:	83 f8 2e             	cmp    $0x2e,%eax
  10a794:	0f 85 5e 00 00 00    	jne    10a7f8 <z_prf+0x298>
				c = *format++;
  10a79a:	8b 45 10             	mov    0x10(%ebp),%eax
  10a79d:	89 c1                	mov    %eax,%ecx
  10a79f:	83 c1 01             	add    $0x1,%ecx
  10a7a2:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a7a5:	8a 10                	mov    (%eax),%dl
  10a7a7:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
				if (c == '*') {
  10a7ae:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a7b5:	00 
  10a7b6:	83 f8 2a             	cmp    $0x2a,%eax
  10a7b9:	0f 85 16 00 00 00    	jne    10a7d5 <z_prf+0x275>
					precision = va_arg(vargs, int);
  10a7bf:	8b 45 14             	mov    0x14(%ebp),%eax
  10a7c2:	89 c1                	mov    %eax,%ecx
  10a7c4:	83 c1 04             	add    $0x4,%ecx
  10a7c7:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a7ca:	8b 00                	mov    (%eax),%eax
  10a7cc:	89 44 24 78          	mov    %eax,0x78(%esp)
				} else {
  10a7d0:	e9 0f 00 00 00       	jmp    10a7e4 <z_prf+0x284>
					precision = _atoi(&format);
  10a7d5:	8d 45 10             	lea    0x10(%ebp),%eax
  10a7d8:	89 04 24             	mov    %eax,(%esp)
  10a7db:	e8 50 0d 00 00       	call   10b530 <_atoi>
  10a7e0:	89 44 24 78          	mov    %eax,0x78(%esp)
				}

				c = *format++;
  10a7e4:	8b 45 10             	mov    0x10(%ebp),%eax
  10a7e7:	89 c1                	mov    %eax,%ecx
  10a7e9:	83 c1 01             	add    $0x1,%ecx
  10a7ec:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a7ef:	8a 10                	mov    (%eax),%dl
  10a7f1:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
			 *   hh: char
			 *    l: long
			 *   ll: long long
			 *    z: size_t or ssize_t
			 */
			i = 0;
  10a7f8:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
  10a7ff:	00 00 00 00 
			if (strchr("hlz", c) != NULL) {
  10a803:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a80a:	00 
  10a80b:	8d 0d 05 3b 12 00    	lea    0x123b05,%ecx
  10a811:	89 0c 24             	mov    %ecx,(%esp)
  10a814:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a818:	e8 f3 f9 ff ff       	call   10a210 <strchr>
  10a81d:	83 f8 00             	cmp    $0x0,%eax
  10a820:	0f 84 66 00 00 00    	je     10a88c <z_prf+0x32c>
				i = c;
  10a826:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a82d:	00 
  10a82e:	89 84 24 80 00 00 00 	mov    %eax,0x80(%esp)
				c = *format++;
  10a835:	8b 45 10             	mov    0x10(%ebp),%eax
  10a838:	89 c1                	mov    %eax,%ecx
  10a83a:	83 c1 01             	add    $0x1,%ecx
  10a83d:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a840:	8a 10                	mov    (%eax),%dl
  10a842:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
				if (IS_ENABLED(CONFIG_MINIMAL_LIBC_LL_PRINTF) &&
				    i == 'l' && c == 'l') {
					i = 'L';
					c = *format++;
				} else if (i == 'h' && c == 'h') {
  10a849:	83 bc 24 80 00 00 00 	cmpl   $0x68,0x80(%esp)
  10a850:	68 
  10a851:	0f 85 30 00 00 00    	jne    10a887 <z_prf+0x327>
  10a857:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a85e:	00 
  10a85f:	83 f8 68             	cmp    $0x68,%eax
  10a862:	0f 85 1f 00 00 00    	jne    10a887 <z_prf+0x327>
					i = 'H';
  10a868:	c7 84 24 80 00 00 00 	movl   $0x48,0x80(%esp)
  10a86f:	48 00 00 00 
					c = *format++;
  10a873:	8b 45 10             	mov    0x10(%ebp),%eax
  10a876:	89 c1                	mov    %eax,%ecx
  10a878:	83 c1 01             	add    $0x1,%ecx
  10a87b:	89 4d 10             	mov    %ecx,0x10(%ebp)
  10a87e:	8a 10                	mov    (%eax),%dl
  10a880:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
				}
			}
  10a887:	e9 00 00 00 00       	jmp    10a88c <z_prf+0x32c>
  10a88c:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax

			cptr = buf;
  10a893:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
			prefix = 0;
  10a89a:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%esp)
  10a8a1:	00 
			zero.predot = zero.postdot = zero.trail = 0;
  10a8a2:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%esp)
  10a8a9:	00 
  10a8aa:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  10a8b1:	00 
  10a8b2:	c7 44 24 60 00 00 00 	movl   $0x0,0x60(%esp)
  10a8b9:	00 

			switch (c) {
  10a8ba:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10a8c1:	00 
  10a8c2:	89 c1                	mov    %eax,%ecx
  10a8c4:	83 e9 78             	sub    $0x78,%ecx
  10a8c7:	89 44 24 40          	mov    %eax,0x40(%esp)
  10a8cb:	0f 87 a0 05 00 00    	ja     10ae71 <z_prf+0x911>
  10a8d1:	8b 44 24 40          	mov    0x40(%esp),%eax
  10a8d5:	8b 0c 85 9c 32 12 00 	mov    0x12329c(,%eax,4),%ecx
  10a8dc:	ff e1                	jmp    *%ecx
			case 'c':
				buf[0] = va_arg(vargs, int);
  10a8de:	8b 45 14             	mov    0x14(%ebp),%eax
  10a8e1:	89 c1                	mov    %eax,%ecx
  10a8e3:	83 c1 04             	add    $0x4,%ecx
  10a8e6:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a8e9:	8b 00                	mov    (%eax),%eax
  10a8eb:	88 84 24 97 00 00 00 	mov    %al,0x97(%esp)
				clen = 1;
  10a8f2:	c7 44 24 74 01 00 00 	movl   $0x1,0x74(%esp)
  10a8f9:	00 
				precision = 0;
  10a8fa:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
  10a901:	00 
				break;
  10a902:	e9 03 06 00 00       	jmp    10af0a <z_prf+0x9aa>

			case 'd':
			case 'i':
				switch (i) {
  10a907:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  10a90e:	89 c1                	mov    %eax,%ecx
  10a910:	83 e9 48             	sub    $0x48,%ecx
  10a913:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  10a917:	0f 84 67 00 00 00    	je     10a984 <z_prf+0x424>
  10a91d:	e9 00 00 00 00       	jmp    10a922 <z_prf+0x3c2>
  10a922:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10a926:	83 e8 68             	sub    $0x68,%eax
  10a929:	0f 84 55 00 00 00    	je     10a984 <z_prf+0x424>
  10a92f:	e9 00 00 00 00       	jmp    10a934 <z_prf+0x3d4>
  10a934:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10a938:	83 e8 6c             	sub    $0x6c,%eax
  10a93b:	0f 84 17 00 00 00    	je     10a958 <z_prf+0x3f8>
  10a941:	e9 00 00 00 00       	jmp    10a946 <z_prf+0x3e6>
  10a946:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  10a94a:	83 e8 7a             	sub    $0x7a,%eax
  10a94d:	0f 84 1b 00 00 00    	je     10a96e <z_prf+0x40e>
  10a953:	e9 31 00 00 00       	jmp    10a989 <z_prf+0x429>
				case 'l':
					val = va_arg(vargs, long);
  10a958:	8b 45 14             	mov    0x14(%ebp),%eax
  10a95b:	89 c1                	mov    %eax,%ecx
  10a95d:	83 c1 04             	add    $0x4,%ecx
  10a960:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a963:	8b 00                	mov    (%eax),%eax
  10a965:	89 44 24 5c          	mov    %eax,0x5c(%esp)
					break;
  10a969:	e9 2c 00 00 00       	jmp    10a99a <z_prf+0x43a>
				case 'L':
					val = va_arg(vargs, long long);
					break;
#endif
				case 'z':
					val = va_arg(vargs, ssize_t);
  10a96e:	8b 45 14             	mov    0x14(%ebp),%eax
  10a971:	89 c1                	mov    %eax,%ecx
  10a973:	83 c1 04             	add    $0x4,%ecx
  10a976:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a979:	8b 00                	mov    (%eax),%eax
  10a97b:	89 44 24 5c          	mov    %eax,0x5c(%esp)
					break;
  10a97f:	e9 16 00 00 00       	jmp    10a99a <z_prf+0x43a>
  10a984:	e9 00 00 00 00       	jmp    10a989 <z_prf+0x429>
				case 'h':
				case 'H':
				default:
					val = va_arg(vargs, int);
  10a989:	8b 45 14             	mov    0x14(%ebp),%eax
  10a98c:	89 c1                	mov    %eax,%ecx
  10a98e:	83 c1 04             	add    $0x4,%ecx
  10a991:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10a994:	8b 00                	mov    (%eax),%eax
  10a996:	89 44 24 5c          	mov    %eax,0x5c(%esp)
  10a99a:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax
					break;
				}
				clen = _to_dec(buf, val, fplus, fspace);
  10a9a1:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  10a9a5:	8a 94 24 89 00 00 00 	mov    0x89(%esp),%dl
  10a9ac:	8a b4 24 88 00 00 00 	mov    0x88(%esp),%dh
  10a9b3:	80 e2 01             	and    $0x1,%dl
  10a9b6:	80 e6 01             	and    $0x1,%dh
  10a9b9:	89 04 24             	mov    %eax,(%esp)
  10a9bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10a9c0:	0f b6 c2             	movzbl %dl,%eax
  10a9c3:	89 44 24 08          	mov    %eax,0x8(%esp)
  10a9c7:	0f b6 c6             	movzbl %dh,%eax
  10a9ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10a9ce:	e8 cd 0b 00 00       	call   10b5a0 <_to_dec>
  10a9d3:	89 44 24 74          	mov    %eax,0x74(%esp)
				if (fplus || fspace || val < 0) {
  10a9d7:	f6 84 24 89 00 00 00 	testb  $0x1,0x89(%esp)
  10a9de:	01 
  10a9df:	0f 85 19 00 00 00    	jne    10a9fe <z_prf+0x49e>
  10a9e5:	f6 84 24 88 00 00 00 	testb  $0x1,0x88(%esp)
  10a9ec:	01 
  10a9ed:	0f 85 0b 00 00 00    	jne    10a9fe <z_prf+0x49e>
  10a9f3:	83 7c 24 5c 00       	cmpl   $0x0,0x5c(%esp)
  10a9f8:	0f 8d 08 00 00 00    	jge    10aa06 <z_prf+0x4a6>
					prefix = 1;
  10a9fe:	c7 44 24 70 01 00 00 	movl   $0x1,0x70(%esp)
  10aa05:	00 
				}
				break;
  10aa06:	e9 ff 04 00 00       	jmp    10af0a <z_prf+0x9aa>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = va_arg(vargs, double);
  10aa0b:	8b 45 14             	mov    0x14(%ebp),%eax
  10aa0e:	89 c1                	mov    %eax,%ecx
  10aa10:	83 c1 08             	add    $0x8,%ecx
  10aa13:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10aa16:	dd 00                	fldl   (%eax)
  10aa18:	dd 5c 24 48          	fstpl  0x48(%esp)
				double_val = u.i;
  10aa1c:	8b 44 24 48          	mov    0x48(%esp),%eax
  10aa20:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  10aa24:	89 4c 24 54          	mov    %ecx,0x54(%esp)
  10aa28:	89 44 24 50          	mov    %eax,0x50(%esp)
  10aa2c:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax

				clen = _to_float(buf, double_val, c, falt,
  10aa33:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  10aa37:	8b 54 24 54          	mov    0x54(%esp),%edx
  10aa3b:	8a 9c 24 96 00 00 00 	mov    0x96(%esp),%bl
  10aa42:	8a bc 24 8b 00 00 00 	mov    0x8b(%esp),%bh
  10aa49:	89 44 24 38          	mov    %eax,0x38(%esp)
						 fplus, fspace, precision,
  10aa4d:	8a 84 24 89 00 00 00 	mov    0x89(%esp),%al
  10aa54:	8a a4 24 88 00 00 00 	mov    0x88(%esp),%ah
  10aa5b:	8b 74 24 78          	mov    0x78(%esp),%esi
				clen = _to_float(buf, double_val, c, falt,
  10aa5f:	89 e7                	mov    %esp,%edi
  10aa61:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  10aa65:	8d 4c 24 60          	lea    0x60(%esp),%ecx
  10aa69:	89 4f 20             	mov    %ecx,0x20(%edi)
  10aa6c:	89 77 1c             	mov    %esi,0x1c(%edi)
  10aa6f:	0f be cb             	movsbl %bl,%ecx
  10aa72:	89 4f 0c             	mov    %ecx,0xc(%edi)
  10aa75:	89 57 08             	mov    %edx,0x8(%edi)
  10aa78:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10aa7c:	89 4f 04             	mov    %ecx,0x4(%edi)
  10aa7f:	8b 54 24 38          	mov    0x38(%esp),%edx
  10aa83:	89 17                	mov    %edx,(%edi)
  10aa85:	0f b6 f4             	movzbl %ah,%esi
  10aa88:	83 e6 01             	and    $0x1,%esi
  10aa8b:	89 77 18             	mov    %esi,0x18(%edi)
  10aa8e:	0f b6 f0             	movzbl %al,%esi
  10aa91:	83 e6 01             	and    $0x1,%esi
  10aa94:	89 77 14             	mov    %esi,0x14(%edi)
  10aa97:	0f b6 f7             	movzbl %bh,%esi
  10aa9a:	83 e6 01             	and    $0x1,%esi
  10aa9d:	89 77 10             	mov    %esi,0x10(%edi)
  10aaa0:	e8 bb 0b 00 00       	call   10b660 <_to_float>
  10aaa5:	89 44 24 74          	mov    %eax,0x74(%esp)
						 &zero);
				if (fplus || fspace || (buf[0] == '-')) {
  10aaa9:	f6 84 24 89 00 00 00 	testb  $0x1,0x89(%esp)
  10aab0:	01 
  10aab1:	0f 85 1f 00 00 00    	jne    10aad6 <z_prf+0x576>
  10aab7:	f6 84 24 88 00 00 00 	testb  $0x1,0x88(%esp)
  10aabe:	01 
  10aabf:	0f 85 11 00 00 00    	jne    10aad6 <z_prf+0x576>
  10aac5:	0f be 84 24 97 00 00 	movsbl 0x97(%esp),%eax
  10aacc:	00 
  10aacd:	83 f8 2d             	cmp    $0x2d,%eax
  10aad0:	0f 85 08 00 00 00    	jne    10aade <z_prf+0x57e>
					prefix = 1;
  10aad6:	c7 44 24 70 01 00 00 	movl   $0x1,0x70(%esp)
  10aadd:	00 
				}
				clen += zero.predot + zero.postdot + zero.trail;
  10aade:	8b 44 24 60          	mov    0x60(%esp),%eax
  10aae2:	03 44 24 64          	add    0x64(%esp),%eax
  10aae6:	03 44 24 68          	add    0x68(%esp),%eax
  10aaea:	03 44 24 74          	add    0x74(%esp),%eax
  10aaee:	89 44 24 74          	mov    %eax,0x74(%esp)
				if (!isdigit(buf[prefix])) {
  10aaf2:	8b 44 24 70          	mov    0x70(%esp),%eax
  10aaf6:	0f be 84 04 97 00 00 	movsbl 0x97(%esp,%eax,1),%eax
  10aafd:	00 
  10aafe:	89 04 24             	mov    %eax,(%esp)
  10ab01:	e8 fa 09 00 00       	call   10b500 <isdigit>
  10ab06:	83 f8 00             	cmp    $0x0,%eax
  10ab09:	0f 85 08 00 00 00    	jne    10ab17 <z_prf+0x5b7>
					/* inf or nan: no zero padding */
					fzero = false;
  10ab0f:	c6 84 24 87 00 00 00 	movb   $0x0,0x87(%esp)
  10ab16:	00 
				}
				precision = -1;
  10ab17:	c7 44 24 78 ff ff ff 	movl   $0xffffffff,0x78(%esp)
  10ab1e:	ff 
				break;
  10ab1f:	e9 e6 03 00 00       	jmp    10af0a <z_prf+0x9aa>
			}

			case 'n':
				switch (i) {
  10ab24:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  10ab2b:	89 c1                	mov    %eax,%ecx
  10ab2d:	83 e9 48             	sub    $0x48,%ecx
  10ab30:	89 44 24 30          	mov    %eax,0x30(%esp)
  10ab34:	0f 84 57 00 00 00    	je     10ab91 <z_prf+0x631>
  10ab3a:	e9 00 00 00 00       	jmp    10ab3f <z_prf+0x5df>
  10ab3f:	8b 44 24 30          	mov    0x30(%esp),%eax
  10ab43:	83 e8 68             	sub    $0x68,%eax
  10ab46:	0f 84 29 00 00 00    	je     10ab75 <z_prf+0x615>
  10ab4c:	e9 00 00 00 00       	jmp    10ab51 <z_prf+0x5f1>
  10ab51:	8b 44 24 30          	mov    0x30(%esp),%eax
  10ab55:	83 e8 6c             	sub    $0x6c,%eax
  10ab58:	0f 84 4e 00 00 00    	je     10abac <z_prf+0x64c>
  10ab5e:	e9 00 00 00 00       	jmp    10ab63 <z_prf+0x603>
  10ab63:	8b 44 24 30          	mov    0x30(%esp),%eax
  10ab67:	83 e8 7a             	sub    $0x7a,%eax
  10ab6a:	0f 84 57 00 00 00    	je     10abc7 <z_prf+0x667>
  10ab70:	e9 6d 00 00 00       	jmp    10abe2 <z_prf+0x682>
				case 'h':
					*va_arg(vargs, short *) = count;
  10ab75:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10ab7c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10ab7f:	89 ca                	mov    %ecx,%edx
  10ab81:	83 c2 04             	add    $0x4,%edx
  10ab84:	89 55 14             	mov    %edx,0x14(%ebp)
  10ab87:	8b 09                	mov    (%ecx),%ecx
  10ab89:	66 89 01             	mov    %ax,(%ecx)
					break;
  10ab8c:	e9 67 00 00 00       	jmp    10abf8 <z_prf+0x698>
				case 'H':
					*va_arg(vargs, char *) = count;
  10ab91:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10ab98:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10ab9b:	89 ca                	mov    %ecx,%edx
  10ab9d:	83 c2 04             	add    $0x4,%edx
  10aba0:	89 55 14             	mov    %edx,0x14(%ebp)
  10aba3:	8b 09                	mov    (%ecx),%ecx
  10aba5:	88 01                	mov    %al,(%ecx)
					break;
  10aba7:	e9 4c 00 00 00       	jmp    10abf8 <z_prf+0x698>
				case 'l':
					*va_arg(vargs, long *) = count;
  10abac:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10abb3:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10abb6:	89 ca                	mov    %ecx,%edx
  10abb8:	83 c2 04             	add    $0x4,%edx
  10abbb:	89 55 14             	mov    %edx,0x14(%ebp)
  10abbe:	8b 09                	mov    (%ecx),%ecx
  10abc0:	89 01                	mov    %eax,(%ecx)
					break;
  10abc2:	e9 31 00 00 00       	jmp    10abf8 <z_prf+0x698>
				case 'L':
					*va_arg(vargs, long long *) = count;
					break;
#endif
				case 'z':
					*va_arg(vargs, ssize_t *) = count;
  10abc7:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10abce:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10abd1:	89 ca                	mov    %ecx,%edx
  10abd3:	83 c2 04             	add    $0x4,%edx
  10abd6:	89 55 14             	mov    %edx,0x14(%ebp)
  10abd9:	8b 09                	mov    (%ecx),%ecx
  10abdb:	89 01                	mov    %eax,(%ecx)
					break;
  10abdd:	e9 16 00 00 00       	jmp    10abf8 <z_prf+0x698>
				default:
					*va_arg(vargs, int *) = count;
  10abe2:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10abe9:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10abec:	89 ca                	mov    %ecx,%edx
  10abee:	83 c2 04             	add    $0x4,%edx
  10abf1:	89 55 14             	mov    %edx,0x14(%ebp)
  10abf4:	8b 09                	mov    (%ecx),%ecx
  10abf6:	89 01                	mov    %eax,(%ecx)
					break;
				}
				continue;
  10abf8:	e9 89 f9 ff ff       	jmp    10a586 <z_prf+0x26>
  10abfd:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax

			case 'p':
				val = (uintptr_t) va_arg(vargs, void *);
  10ac04:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10ac07:	89 ca                	mov    %ecx,%edx
  10ac09:	83 c2 04             	add    $0x4,%edx
  10ac0c:	89 55 14             	mov    %edx,0x14(%ebp)
  10ac0f:	8b 09                	mov    (%ecx),%ecx
  10ac11:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
				clen = _to_hex(buf, val, true, 'x');
  10ac15:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  10ac19:	89 04 24             	mov    %eax,(%esp)
  10ac1c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ac20:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10ac27:	00 
  10ac28:	c7 44 24 0c 78 00 00 	movl   $0x78,0xc(%esp)
  10ac2f:	00 
  10ac30:	e8 4b 13 00 00       	call   10bf80 <_to_hex>
  10ac35:	89 44 24 74          	mov    %eax,0x74(%esp)
				prefix = 2;
  10ac39:	c7 44 24 70 02 00 00 	movl   $0x2,0x70(%esp)
  10ac40:	00 
				break;
  10ac41:	e9 c4 02 00 00       	jmp    10af0a <z_prf+0x9aa>

			case 's':
				cptr = va_arg(vargs, char *);
  10ac46:	8b 45 14             	mov    0x14(%ebp),%eax
  10ac49:	89 c1                	mov    %eax,%ecx
  10ac4b:	83 c1 04             	add    $0x4,%ecx
  10ac4e:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10ac51:	8b 00                	mov    (%eax),%eax
  10ac53:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
				/* Get the string length */
				if (precision < 0) {
  10ac5a:	83 7c 24 78 00       	cmpl   $0x0,0x78(%esp)
  10ac5f:	0f 8d 08 00 00 00    	jge    10ac6d <z_prf+0x70d>
					precision = INT_MAX;
  10ac65:	c7 44 24 78 ff ff ff 	movl   $0x7fffffff,0x78(%esp)
  10ac6c:	7f 
				}
				for (clen = 0; clen < precision; clen++) {
  10ac6d:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  10ac74:	00 
  10ac75:	8b 44 24 74          	mov    0x74(%esp),%eax
  10ac79:	3b 44 24 78          	cmp    0x78(%esp),%eax
  10ac7d:	0f 8d 32 00 00 00    	jge    10acb5 <z_prf+0x755>
					if (cptr[clen] == '\0') {
  10ac83:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10ac8a:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  10ac8e:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  10ac92:	83 f8 00             	cmp    $0x0,%eax
  10ac95:	0f 85 05 00 00 00    	jne    10aca0 <z_prf+0x740>
						break;
  10ac9b:	e9 15 00 00 00       	jmp    10acb5 <z_prf+0x755>
					}
				}
  10aca0:	e9 00 00 00 00       	jmp    10aca5 <z_prf+0x745>
				for (clen = 0; clen < precision; clen++) {
  10aca5:	8b 44 24 74          	mov    0x74(%esp),%eax
  10aca9:	83 c0 01             	add    $0x1,%eax
  10acac:	89 44 24 74          	mov    %eax,0x74(%esp)
  10acb0:	e9 c0 ff ff ff       	jmp    10ac75 <z_prf+0x715>
				precision = 0;
  10acb5:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
  10acbc:	00 
				break;
  10acbd:	e9 48 02 00 00       	jmp    10af0a <z_prf+0x9aa>

			case 'o':
			case 'u':
			case 'x':
			case 'X':
				switch (i) {
  10acc2:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  10acc9:	89 c1                	mov    %eax,%ecx
  10accb:	83 e9 48             	sub    $0x48,%ecx
  10acce:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10acd2:	0f 84 67 00 00 00    	je     10ad3f <z_prf+0x7df>
  10acd8:	e9 00 00 00 00       	jmp    10acdd <z_prf+0x77d>
  10acdd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10ace1:	83 e8 68             	sub    $0x68,%eax
  10ace4:	0f 84 55 00 00 00    	je     10ad3f <z_prf+0x7df>
  10acea:	e9 00 00 00 00       	jmp    10acef <z_prf+0x78f>
  10acef:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10acf3:	83 e8 6c             	sub    $0x6c,%eax
  10acf6:	0f 84 17 00 00 00    	je     10ad13 <z_prf+0x7b3>
  10acfc:	e9 00 00 00 00       	jmp    10ad01 <z_prf+0x7a1>
  10ad01:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10ad05:	83 e8 7a             	sub    $0x7a,%eax
  10ad08:	0f 84 1b 00 00 00    	je     10ad29 <z_prf+0x7c9>
  10ad0e:	e9 31 00 00 00       	jmp    10ad44 <z_prf+0x7e4>
				case 'l':
					val = va_arg(vargs, unsigned long);
  10ad13:	8b 45 14             	mov    0x14(%ebp),%eax
  10ad16:	89 c1                	mov    %eax,%ecx
  10ad18:	83 c1 04             	add    $0x4,%ecx
  10ad1b:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10ad1e:	8b 00                	mov    (%eax),%eax
  10ad20:	89 44 24 5c          	mov    %eax,0x5c(%esp)
					break;
  10ad24:	e9 2c 00 00 00       	jmp    10ad55 <z_prf+0x7f5>
				case 'L':
					val = va_arg(vargs, unsigned long long);
					break;
#endif
				case 'z':
					val = va_arg(vargs, size_t);
  10ad29:	8b 45 14             	mov    0x14(%ebp),%eax
  10ad2c:	89 c1                	mov    %eax,%ecx
  10ad2e:	83 c1 04             	add    $0x4,%ecx
  10ad31:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10ad34:	8b 00                	mov    (%eax),%eax
  10ad36:	89 44 24 5c          	mov    %eax,0x5c(%esp)
					break;
  10ad3a:	e9 16 00 00 00       	jmp    10ad55 <z_prf+0x7f5>
  10ad3f:	e9 00 00 00 00       	jmp    10ad44 <z_prf+0x7e4>
				case 'h':
				case 'H':
				default:
					val = va_arg(vargs, unsigned int);
  10ad44:	8b 45 14             	mov    0x14(%ebp),%eax
  10ad47:	89 c1                	mov    %eax,%ecx
  10ad49:	83 c1 04             	add    $0x4,%ecx
  10ad4c:	89 4d 14             	mov    %ecx,0x14(%ebp)
  10ad4f:	8b 00                	mov    (%eax),%eax
  10ad51:	89 44 24 5c          	mov    %eax,0x5c(%esp)
					break;
				}
				if (c == 'o') {
  10ad55:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10ad5c:	00 
  10ad5d:	83 f8 6f             	cmp    $0x6f,%eax
  10ad60:	0f 85 31 00 00 00    	jne    10ad97 <z_prf+0x837>
  10ad66:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax
					clen = _to_octal(buf, val, falt);
  10ad6d:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  10ad71:	8a 94 24 8b 00 00 00 	mov    0x8b(%esp),%dl
  10ad78:	80 e2 01             	and    $0x1,%dl
  10ad7b:	89 04 24             	mov    %eax,(%esp)
  10ad7e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ad82:	0f b6 c2             	movzbl %dl,%eax
  10ad85:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad89:	e8 82 12 00 00       	call   10c010 <_to_octal>
  10ad8e:	89 44 24 74          	mov    %eax,0x74(%esp)
				} else if (c == 'u') {
  10ad92:	e9 89 00 00 00       	jmp    10ae20 <z_prf+0x8c0>
  10ad97:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10ad9e:	00 
  10ad9f:	83 f8 75             	cmp    $0x75,%eax
  10ada2:	0f 85 20 00 00 00    	jne    10adc8 <z_prf+0x868>
  10ada8:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax
					clen = _to_udec(buf, val);
  10adaf:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  10adb3:	89 04 24             	mov    %eax,(%esp)
  10adb6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10adba:	e8 f1 12 00 00       	call   10c0b0 <_to_udec>
  10adbf:	89 44 24 74          	mov    %eax,0x74(%esp)
				} else {
  10adc3:	e9 53 00 00 00       	jmp    10ae1b <z_prf+0x8bb>
  10adc8:	8d 84 24 97 00 00 00 	lea    0x97(%esp),%eax
					clen = _to_hex(buf, val, falt, c);
  10adcf:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  10add3:	8a 94 24 8b 00 00 00 	mov    0x8b(%esp),%dl
  10adda:	80 e2 01             	and    $0x1,%dl
  10addd:	89 04 24             	mov    %eax,(%esp)
  10ade0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ade4:	0f b6 c2             	movzbl %dl,%eax
  10ade7:	89 44 24 08          	mov    %eax,0x8(%esp)
  10adeb:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10adf2:	00 
  10adf3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10adf7:	e8 84 11 00 00       	call   10bf80 <_to_hex>
  10adfc:	89 44 24 74          	mov    %eax,0x74(%esp)
					if (falt) {
  10ae00:	f6 84 24 8b 00 00 00 	testb  $0x1,0x8b(%esp)
  10ae07:	01 
  10ae08:	0f 84 08 00 00 00    	je     10ae16 <z_prf+0x8b6>
						prefix = 2;
  10ae0e:	c7 44 24 70 02 00 00 	movl   $0x2,0x70(%esp)
  10ae15:	00 
  10ae16:	e9 00 00 00 00       	jmp    10ae1b <z_prf+0x8bb>
  10ae1b:	e9 00 00 00 00       	jmp    10ae20 <z_prf+0x8c0>
					}
				}
				break;
  10ae20:	e9 e5 00 00 00       	jmp    10af0a <z_prf+0x9aa>

			case '%':
				PUTC('%');
  10ae25:	e9 00 00 00 00       	jmp    10ae2a <z_prf+0x8ca>
  10ae2a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae2d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10ae30:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10ae37:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ae3b:	ff d0                	call   *%eax
  10ae3d:	83 f8 ff             	cmp    $0xffffffff,%eax
  10ae40:	0f 85 10 00 00 00    	jne    10ae56 <z_prf+0x8f6>
  10ae46:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10ae4d:	ff ff ff ff 
  10ae51:	e9 99 06 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10ae56:	e9 00 00 00 00       	jmp    10ae5b <z_prf+0x8fb>
				count++;
  10ae5b:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10ae62:	83 c0 01             	add    $0x1,%eax
  10ae65:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
				continue;
  10ae6c:	e9 15 f7 ff ff       	jmp    10a586 <z_prf+0x26>

			default:
				PUTC('%');
  10ae71:	e9 00 00 00 00       	jmp    10ae76 <z_prf+0x916>
  10ae76:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae79:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10ae7c:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10ae83:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ae87:	ff d0                	call   *%eax
  10ae89:	83 f8 ff             	cmp    $0xffffffff,%eax
  10ae8c:	0f 85 10 00 00 00    	jne    10aea2 <z_prf+0x942>
  10ae92:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10ae99:	ff ff ff ff 
  10ae9d:	e9 4d 06 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10aea2:	e9 00 00 00 00       	jmp    10aea7 <z_prf+0x947>
				PUTC(c);
  10aea7:	e9 00 00 00 00       	jmp    10aeac <z_prf+0x94c>
  10aeac:	8b 45 08             	mov    0x8(%ebp),%eax
  10aeaf:	0f be 8c 24 96 00 00 	movsbl 0x96(%esp),%ecx
  10aeb6:	00 
  10aeb7:	8b 55 0c             	mov    0xc(%ebp),%edx
  10aeba:	89 0c 24             	mov    %ecx,(%esp)
  10aebd:	89 54 24 04          	mov    %edx,0x4(%esp)
  10aec1:	ff d0                	call   *%eax
  10aec3:	83 f8 ff             	cmp    $0xffffffff,%eax
  10aec6:	0f 85 10 00 00 00    	jne    10aedc <z_prf+0x97c>
  10aecc:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10aed3:	ff ff ff ff 
  10aed7:	e9 13 06 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10aedc:	e9 00 00 00 00       	jmp    10aee1 <z_prf+0x981>
				count += 2;
  10aee1:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10aee8:	83 c0 02             	add    $0x2,%eax
  10aeeb:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
				continue;
  10aef2:	e9 8f f6 ff ff       	jmp    10a586 <z_prf+0x26>

			case 0:
				return count;
  10aef7:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10aefe:	89 84 24 b0 00 00 00 	mov    %eax,0xb0(%esp)
  10af05:	e9 e5 05 00 00       	jmp    10b4ef <z_prf+0xf8f>
			}

			if (precision >= 0) {
  10af0a:	83 7c 24 78 00       	cmpl   $0x0,0x78(%esp)
  10af0f:	0f 8c 15 00 00 00    	jl     10af2a <z_prf+0x9ca>
				zero_head = precision - clen + prefix;
  10af15:	8b 44 24 78          	mov    0x78(%esp),%eax
  10af19:	2b 44 24 74          	sub    0x74(%esp),%eax
  10af1d:	03 44 24 70          	add    0x70(%esp),%eax
  10af21:	89 44 24 6c          	mov    %eax,0x6c(%esp)
			} else if (fzero) {
  10af25:	e9 2c 00 00 00       	jmp    10af56 <z_prf+0x9f6>
  10af2a:	f6 84 24 87 00 00 00 	testb  $0x1,0x87(%esp)
  10af31:	01 
  10af32:	0f 84 11 00 00 00    	je     10af49 <z_prf+0x9e9>
				zero_head = width - clen;
  10af38:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  10af3c:	2b 44 24 74          	sub    0x74(%esp),%eax
  10af40:	89 44 24 6c          	mov    %eax,0x6c(%esp)
			} else {
  10af44:	e9 08 00 00 00       	jmp    10af51 <z_prf+0x9f1>
				zero_head = 0;
  10af49:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  10af50:	00 
  10af51:	e9 00 00 00 00       	jmp    10af56 <z_prf+0x9f6>
			}
			if (zero_head < 0) {
  10af56:	83 7c 24 6c 00       	cmpl   $0x0,0x6c(%esp)
  10af5b:	0f 8d 08 00 00 00    	jge    10af69 <z_prf+0xa09>
				zero_head = 0;
  10af61:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  10af68:	00 
			}
			width -= clen + zero_head;
  10af69:	8b 44 24 74          	mov    0x74(%esp),%eax
  10af6d:	03 44 24 6c          	add    0x6c(%esp),%eax
  10af71:	8b 4c 24 7c          	mov    0x7c(%esp),%ecx
  10af75:	29 c1                	sub    %eax,%ecx
  10af77:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)

			/* padding for right justification */
			if (!fminus && width > 0) {
  10af7b:	f6 84 24 8a 00 00 00 	testb  $0x1,0x8a(%esp)
  10af82:	01 
  10af83:	0f 85 73 00 00 00    	jne    10affc <z_prf+0xa9c>
  10af89:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
  10af8e:	0f 8e 68 00 00 00    	jle    10affc <z_prf+0xa9c>
				count += width;
  10af94:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  10af98:	03 84 24 90 00 00 00 	add    0x90(%esp),%eax
  10af9f:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
				while (width-- > 0) {
  10afa6:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  10afaa:	89 c1                	mov    %eax,%ecx
  10afac:	83 c1 ff             	add    $0xffffffff,%ecx
  10afaf:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
  10afb3:	83 f8 00             	cmp    $0x0,%eax
  10afb6:	0f 8e 3b 00 00 00    	jle    10aff7 <z_prf+0xa97>
					PUTC(' ');
  10afbc:	e9 00 00 00 00       	jmp    10afc1 <z_prf+0xa61>
  10afc1:	8b 45 08             	mov    0x8(%ebp),%eax
  10afc4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10afc7:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10afce:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10afd2:	ff d0                	call   *%eax
  10afd4:	83 f8 ff             	cmp    $0xffffffff,%eax
  10afd7:	0f 85 10 00 00 00    	jne    10afed <z_prf+0xa8d>
  10afdd:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10afe4:	ff ff ff ff 
  10afe8:	e9 02 05 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10afed:	e9 00 00 00 00       	jmp    10aff2 <z_prf+0xa92>
				while (width-- > 0) {
  10aff2:	e9 af ff ff ff       	jmp    10afa6 <z_prf+0xa46>
				}
			}
  10aff7:	e9 00 00 00 00       	jmp    10affc <z_prf+0xa9c>

			/* data prefix */
			clen -= prefix;
  10affc:	8b 44 24 70          	mov    0x70(%esp),%eax
  10b000:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  10b004:	29 c1                	sub    %eax,%ecx
  10b006:	89 4c 24 74          	mov    %ecx,0x74(%esp)
			count += prefix;
  10b00a:	8b 44 24 70          	mov    0x70(%esp),%eax
  10b00e:	03 84 24 90 00 00 00 	add    0x90(%esp),%eax
  10b015:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
			while (prefix-- > 0) {
  10b01c:	8b 44 24 70          	mov    0x70(%esp),%eax
  10b020:	89 c1                	mov    %eax,%ecx
  10b022:	83 c1 ff             	add    $0xffffffff,%ecx
  10b025:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  10b029:	83 f8 00             	cmp    $0x0,%eax
  10b02c:	0f 8e 4d 00 00 00    	jle    10b07f <z_prf+0xb1f>
				PUTC(*cptr++);
  10b032:	e9 00 00 00 00       	jmp    10b037 <z_prf+0xad7>
  10b037:	8b 45 08             	mov    0x8(%ebp),%eax
  10b03a:	8b 8c 24 8c 00 00 00 	mov    0x8c(%esp),%ecx
  10b041:	89 ca                	mov    %ecx,%edx
  10b043:	83 c2 01             	add    $0x1,%edx
  10b046:	89 94 24 8c 00 00 00 	mov    %edx,0x8c(%esp)
  10b04d:	0f be 09             	movsbl (%ecx),%ecx
  10b050:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b053:	89 0c 24             	mov    %ecx,(%esp)
  10b056:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b05a:	ff d0                	call   *%eax
  10b05c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b05f:	0f 85 10 00 00 00    	jne    10b075 <z_prf+0xb15>
  10b065:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b06c:	ff ff ff ff 
  10b070:	e9 7a 04 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b075:	e9 00 00 00 00       	jmp    10b07a <z_prf+0xb1a>
			while (prefix-- > 0) {
  10b07a:	e9 9d ff ff ff       	jmp    10b01c <z_prf+0xabc>
			}

			/* zero-padded head */
			count += zero_head;
  10b07f:	8b 44 24 6c          	mov    0x6c(%esp),%eax
  10b083:	03 84 24 90 00 00 00 	add    0x90(%esp),%eax
  10b08a:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
			while (zero_head-- > 0) {
  10b091:	8b 44 24 6c          	mov    0x6c(%esp),%eax
  10b095:	89 c1                	mov    %eax,%ecx
  10b097:	83 c1 ff             	add    $0xffffffff,%ecx
  10b09a:	89 4c 24 6c          	mov    %ecx,0x6c(%esp)
  10b09e:	83 f8 00             	cmp    $0x0,%eax
  10b0a1:	0f 8e 3b 00 00 00    	jle    10b0e2 <z_prf+0xb82>
				PUTC('0');
  10b0a7:	e9 00 00 00 00       	jmp    10b0ac <z_prf+0xb4c>
  10b0ac:	8b 45 08             	mov    0x8(%ebp),%eax
  10b0af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10b0b2:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10b0b9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10b0bd:	ff d0                	call   *%eax
  10b0bf:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b0c2:	0f 85 10 00 00 00    	jne    10b0d8 <z_prf+0xb78>
  10b0c8:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b0cf:	ff ff ff ff 
  10b0d3:	e9 17 04 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b0d8:	e9 00 00 00 00       	jmp    10b0dd <z_prf+0xb7d>
			while (zero_head-- > 0) {
  10b0dd:	e9 af ff ff ff       	jmp    10b091 <z_prf+0xb31>
			 * or with
			 *	x.<zero.postdot>xxxxxx<zero.trail>[e+xx]
			 * In the non-float cases, those predot, postdot and
			 * tail params are equal to 0.
			 */
			count += clen;
  10b0e2:	8b 44 24 74          	mov    0x74(%esp),%eax
  10b0e6:	03 84 24 90 00 00 00 	add    0x90(%esp),%eax
  10b0ed:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
			if (zero.predot) {
  10b0f4:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
  10b0f9:	0f 84 f4 00 00 00    	je     10b1f3 <z_prf+0xc93>
				c = *cptr;
  10b0ff:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10b106:	8a 08                	mov    (%eax),%cl
  10b108:	88 8c 24 96 00 00 00 	mov    %cl,0x96(%esp)
				while (isdigit(c)) {
  10b10f:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10b116:	00 
  10b117:	89 04 24             	mov    %eax,(%esp)
  10b11a:	e8 e1 03 00 00       	call   10b500 <isdigit>
  10b11f:	83 f8 00             	cmp    $0x0,%eax
  10b122:	0f 84 67 00 00 00    	je     10b18f <z_prf+0xc2f>
					PUTC(c);
  10b128:	e9 00 00 00 00       	jmp    10b12d <z_prf+0xbcd>
  10b12d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b130:	0f be 8c 24 96 00 00 	movsbl 0x96(%esp),%ecx
  10b137:	00 
  10b138:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b13b:	89 0c 24             	mov    %ecx,(%esp)
  10b13e:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b142:	ff d0                	call   *%eax
  10b144:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b147:	0f 85 10 00 00 00    	jne    10b15d <z_prf+0xbfd>
  10b14d:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b154:	ff ff ff ff 
  10b158:	e9 92 03 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b15d:	e9 00 00 00 00       	jmp    10b162 <z_prf+0xc02>
					clen--;
  10b162:	8b 44 24 74          	mov    0x74(%esp),%eax
  10b166:	83 c0 ff             	add    $0xffffffff,%eax
  10b169:	89 44 24 74          	mov    %eax,0x74(%esp)
					c = *++cptr;
  10b16d:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10b174:	89 c1                	mov    %eax,%ecx
  10b176:	83 c1 01             	add    $0x1,%ecx
  10b179:	89 8c 24 8c 00 00 00 	mov    %ecx,0x8c(%esp)
  10b180:	8a 50 01             	mov    0x1(%eax),%dl
  10b183:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
				while (isdigit(c)) {
  10b18a:	e9 80 ff ff ff       	jmp    10b10f <z_prf+0xbaf>
				}
				clen -= zero.predot;
  10b18f:	8b 44 24 60          	mov    0x60(%esp),%eax
  10b193:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  10b197:	29 c1                	sub    %eax,%ecx
  10b199:	89 4c 24 74          	mov    %ecx,0x74(%esp)
				while (zero.predot-- > 0) {
  10b19d:	8b 44 24 60          	mov    0x60(%esp),%eax
  10b1a1:	89 c1                	mov    %eax,%ecx
  10b1a3:	83 c1 ff             	add    $0xffffffff,%ecx
  10b1a6:	89 4c 24 60          	mov    %ecx,0x60(%esp)
  10b1aa:	83 f8 00             	cmp    $0x0,%eax
  10b1ad:	0f 8e 3b 00 00 00    	jle    10b1ee <z_prf+0xc8e>
					PUTC('0');
  10b1b3:	e9 00 00 00 00       	jmp    10b1b8 <z_prf+0xc58>
  10b1b8:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1bb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10b1be:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10b1c5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10b1c9:	ff d0                	call   *%eax
  10b1cb:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b1ce:	0f 85 10 00 00 00    	jne    10b1e4 <z_prf+0xc84>
  10b1d4:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b1db:	ff ff ff ff 
  10b1df:	e9 0b 03 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b1e4:	e9 00 00 00 00       	jmp    10b1e9 <z_prf+0xc89>
				while (zero.predot-- > 0) {
  10b1e9:	e9 af ff ff ff       	jmp    10b19d <z_prf+0xc3d>
				}
			}
  10b1ee:	e9 00 00 00 00       	jmp    10b1f3 <z_prf+0xc93>
			if (zero.postdot) {
  10b1f3:	83 7c 24 64 00       	cmpl   $0x0,0x64(%esp)
  10b1f8:	0f 84 d6 00 00 00    	je     10b2d4 <z_prf+0xd74>
				do {
  10b1fe:	e9 00 00 00 00       	jmp    10b203 <z_prf+0xca3>
					c = *cptr++;
  10b203:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10b20a:	89 c1                	mov    %eax,%ecx
  10b20c:	83 c1 01             	add    $0x1,%ecx
  10b20f:	89 8c 24 8c 00 00 00 	mov    %ecx,0x8c(%esp)
  10b216:	8a 10                	mov    (%eax),%dl
  10b218:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
					PUTC(c);
  10b21f:	8b 45 08             	mov    0x8(%ebp),%eax
  10b222:	0f be 8c 24 96 00 00 	movsbl 0x96(%esp),%ecx
  10b229:	00 
  10b22a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b22d:	89 0c 24             	mov    %ecx,(%esp)
  10b230:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b234:	ff d0                	call   *%eax
  10b236:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b239:	0f 85 10 00 00 00    	jne    10b24f <z_prf+0xcef>
  10b23f:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b246:	ff ff ff ff 
  10b24a:	e9 a0 02 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b24f:	e9 00 00 00 00       	jmp    10b254 <z_prf+0xcf4>
					clen--;
  10b254:	8b 44 24 74          	mov    0x74(%esp),%eax
  10b258:	83 c0 ff             	add    $0xffffffff,%eax
  10b25b:	89 44 24 74          	mov    %eax,0x74(%esp)
				} while (c != '.');
  10b25f:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10b266:	00 
  10b267:	83 f8 2e             	cmp    $0x2e,%eax
  10b26a:	0f 85 93 ff ff ff    	jne    10b203 <z_prf+0xca3>
				clen -= zero.postdot;
  10b270:	8b 44 24 64          	mov    0x64(%esp),%eax
  10b274:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  10b278:	29 c1                	sub    %eax,%ecx
  10b27a:	89 4c 24 74          	mov    %ecx,0x74(%esp)
				while (zero.postdot-- > 0) {
  10b27e:	8b 44 24 64          	mov    0x64(%esp),%eax
  10b282:	89 c1                	mov    %eax,%ecx
  10b284:	83 c1 ff             	add    $0xffffffff,%ecx
  10b287:	89 4c 24 64          	mov    %ecx,0x64(%esp)
  10b28b:	83 f8 00             	cmp    $0x0,%eax
  10b28e:	0f 8e 3b 00 00 00    	jle    10b2cf <z_prf+0xd6f>
					PUTC('0');
  10b294:	e9 00 00 00 00       	jmp    10b299 <z_prf+0xd39>
  10b299:	8b 45 08             	mov    0x8(%ebp),%eax
  10b29c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10b29f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10b2a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10b2aa:	ff d0                	call   *%eax
  10b2ac:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b2af:	0f 85 10 00 00 00    	jne    10b2c5 <z_prf+0xd65>
  10b2b5:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b2bc:	ff ff ff ff 
  10b2c0:	e9 2a 02 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b2c5:	e9 00 00 00 00       	jmp    10b2ca <z_prf+0xd6a>
				while (zero.postdot-- > 0) {
  10b2ca:	e9 af ff ff ff       	jmp    10b27e <z_prf+0xd1e>
				}
			}
  10b2cf:	e9 00 00 00 00       	jmp    10b2d4 <z_prf+0xd74>
			if (zero.trail) {
  10b2d4:	83 7c 24 68 00       	cmpl   $0x0,0x68(%esp)
  10b2d9:	0f 84 1d 01 00 00    	je     10b3fc <z_prf+0xe9c>
				c = *cptr;
  10b2df:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10b2e6:	8a 08                	mov    (%eax),%cl
  10b2e8:	88 8c 24 96 00 00 00 	mov    %cl,0x96(%esp)
				while (isdigit(c) || c == '.') {
  10b2ef:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10b2f6:	00 
  10b2f7:	89 04 24             	mov    %eax,(%esp)
  10b2fa:	e8 01 02 00 00       	call   10b500 <isdigit>
  10b2ff:	83 f8 00             	cmp    $0x0,%eax
  10b302:	b1 01                	mov    $0x1,%cl
  10b304:	88 4c 24 2b          	mov    %cl,0x2b(%esp)
  10b308:	0f 85 12 00 00 00    	jne    10b320 <z_prf+0xdc0>
  10b30e:	0f be 84 24 96 00 00 	movsbl 0x96(%esp),%eax
  10b315:	00 
  10b316:	83 f8 2e             	cmp    $0x2e,%eax
  10b319:	0f 94 c1             	sete   %cl
  10b31c:	88 4c 24 2b          	mov    %cl,0x2b(%esp)
  10b320:	8a 44 24 2b          	mov    0x2b(%esp),%al
  10b324:	a8 01                	test   $0x1,%al
  10b326:	0f 85 05 00 00 00    	jne    10b331 <z_prf+0xdd1>
  10b32c:	e9 67 00 00 00       	jmp    10b398 <z_prf+0xe38>
					PUTC(c);
  10b331:	e9 00 00 00 00       	jmp    10b336 <z_prf+0xdd6>
  10b336:	8b 45 08             	mov    0x8(%ebp),%eax
  10b339:	0f be 8c 24 96 00 00 	movsbl 0x96(%esp),%ecx
  10b340:	00 
  10b341:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b344:	89 0c 24             	mov    %ecx,(%esp)
  10b347:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b34b:	ff d0                	call   *%eax
  10b34d:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b350:	0f 85 10 00 00 00    	jne    10b366 <z_prf+0xe06>
  10b356:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b35d:	ff ff ff ff 
  10b361:	e9 89 01 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b366:	e9 00 00 00 00       	jmp    10b36b <z_prf+0xe0b>
					clen--;
  10b36b:	8b 44 24 74          	mov    0x74(%esp),%eax
  10b36f:	83 c0 ff             	add    $0xffffffff,%eax
  10b372:	89 44 24 74          	mov    %eax,0x74(%esp)
					c = *++cptr;
  10b376:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  10b37d:	89 c1                	mov    %eax,%ecx
  10b37f:	83 c1 01             	add    $0x1,%ecx
  10b382:	89 8c 24 8c 00 00 00 	mov    %ecx,0x8c(%esp)
  10b389:	8a 50 01             	mov    0x1(%eax),%dl
  10b38c:	88 94 24 96 00 00 00 	mov    %dl,0x96(%esp)
				while (isdigit(c) || c == '.') {
  10b393:	e9 57 ff ff ff       	jmp    10b2ef <z_prf+0xd8f>
				}
				clen -= zero.trail;
  10b398:	8b 44 24 68          	mov    0x68(%esp),%eax
  10b39c:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  10b3a0:	29 c1                	sub    %eax,%ecx
  10b3a2:	89 4c 24 74          	mov    %ecx,0x74(%esp)
				while (zero.trail-- > 0) {
  10b3a6:	8b 44 24 68          	mov    0x68(%esp),%eax
  10b3aa:	89 c1                	mov    %eax,%ecx
  10b3ac:	83 c1 ff             	add    $0xffffffff,%ecx
  10b3af:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  10b3b3:	83 f8 00             	cmp    $0x0,%eax
  10b3b6:	0f 8e 3b 00 00 00    	jle    10b3f7 <z_prf+0xe97>
					PUTC('0');
  10b3bc:	e9 00 00 00 00       	jmp    10b3c1 <z_prf+0xe61>
  10b3c1:	8b 45 08             	mov    0x8(%ebp),%eax
  10b3c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10b3c7:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10b3ce:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10b3d2:	ff d0                	call   *%eax
  10b3d4:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b3d7:	0f 85 10 00 00 00    	jne    10b3ed <z_prf+0xe8d>
  10b3dd:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b3e4:	ff ff ff ff 
  10b3e8:	e9 02 01 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b3ed:	e9 00 00 00 00       	jmp    10b3f2 <z_prf+0xe92>
				while (zero.trail-- > 0) {
  10b3f2:	e9 af ff ff ff       	jmp    10b3a6 <z_prf+0xe46>
				}
			}
  10b3f7:	e9 00 00 00 00       	jmp    10b3fc <z_prf+0xe9c>
			while (clen-- > 0) {
  10b3fc:	e9 00 00 00 00       	jmp    10b401 <z_prf+0xea1>
  10b401:	8b 44 24 74          	mov    0x74(%esp),%eax
  10b405:	89 c1                	mov    %eax,%ecx
  10b407:	83 c1 ff             	add    $0xffffffff,%ecx
  10b40a:	89 4c 24 74          	mov    %ecx,0x74(%esp)
  10b40e:	83 f8 00             	cmp    $0x0,%eax
  10b411:	0f 8e 4d 00 00 00    	jle    10b464 <z_prf+0xf04>
				PUTC(*cptr++);
  10b417:	e9 00 00 00 00       	jmp    10b41c <z_prf+0xebc>
  10b41c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b41f:	8b 8c 24 8c 00 00 00 	mov    0x8c(%esp),%ecx
  10b426:	89 ca                	mov    %ecx,%edx
  10b428:	83 c2 01             	add    $0x1,%edx
  10b42b:	89 94 24 8c 00 00 00 	mov    %edx,0x8c(%esp)
  10b432:	0f be 09             	movsbl (%ecx),%ecx
  10b435:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b438:	89 0c 24             	mov    %ecx,(%esp)
  10b43b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b43f:	ff d0                	call   *%eax
  10b441:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b444:	0f 85 10 00 00 00    	jne    10b45a <z_prf+0xefa>
  10b44a:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b451:	ff ff ff ff 
  10b455:	e9 95 00 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b45a:	e9 00 00 00 00       	jmp    10b45f <z_prf+0xeff>
			while (clen-- > 0) {
  10b45f:	e9 9d ff ff ff       	jmp    10b401 <z_prf+0xea1>
			}

			/* padding for left justification */
			if (width > 0) {
  10b464:	83 7c 24 7c 00       	cmpl   $0x0,0x7c(%esp)
  10b469:	0f 8e 68 00 00 00    	jle    10b4d7 <z_prf+0xf77>
				count += width;
  10b46f:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  10b473:	03 84 24 90 00 00 00 	add    0x90(%esp),%eax
  10b47a:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
				while (width-- > 0) {
  10b481:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  10b485:	89 c1                	mov    %eax,%ecx
  10b487:	83 c1 ff             	add    $0xffffffff,%ecx
  10b48a:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
  10b48e:	83 f8 00             	cmp    $0x0,%eax
  10b491:	0f 8e 3b 00 00 00    	jle    10b4d2 <z_prf+0xf72>
					PUTC(' ');
  10b497:	e9 00 00 00 00       	jmp    10b49c <z_prf+0xf3c>
  10b49c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b49f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10b4a2:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10b4a9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10b4ad:	ff d0                	call   *%eax
  10b4af:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b4b2:	0f 85 10 00 00 00    	jne    10b4c8 <z_prf+0xf68>
  10b4b8:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
  10b4bf:	ff ff ff ff 
  10b4c3:	e9 27 00 00 00       	jmp    10b4ef <z_prf+0xf8f>
  10b4c8:	e9 00 00 00 00       	jmp    10b4cd <z_prf+0xf6d>
				while (width-- > 0) {
  10b4cd:	e9 af ff ff ff       	jmp    10b481 <z_prf+0xf21>
				}
			}
  10b4d2:	e9 00 00 00 00       	jmp    10b4d7 <z_prf+0xf77>
  10b4d7:	e9 00 00 00 00       	jmp    10b4dc <z_prf+0xf7c>
	while ((c = *format++)) {
  10b4dc:	e9 a5 f0 ff ff       	jmp    10a586 <z_prf+0x26>
		}
	}
	return count;
  10b4e1:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  10b4e8:	89 84 24 b0 00 00 00 	mov    %eax,0xb0(%esp)

#undef PUTC
}
  10b4ef:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
  10b4f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b4f9:	5e                   	pop    %esi
  10b4fa:	5f                   	pop    %edi
  10b4fb:	5b                   	pop    %ebx
  10b4fc:	5d                   	pop    %ebp
  10b4fd:	c3                   	ret    
  10b4fe:	66 90                	xchg   %ax,%ax

0010b500 <isdigit>:
}

static inline int isdigit(int a)
{
  10b500:	55                   	push   %ebp
  10b501:	89 e5                	mov    %esp,%ebp
  10b503:	50                   	push   %eax
  10b504:	8b 45 08             	mov    0x8(%ebp),%eax
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  10b507:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b50a:	83 e9 30             	sub    $0x30,%ecx
  10b50d:	83 f9 0a             	cmp    $0xa,%ecx
  10b510:	0f 92 c2             	setb   %dl
  10b513:	80 e2 01             	and    $0x1,%dl
  10b516:	0f b6 ca             	movzbl %dl,%ecx
  10b519:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b51c:	89 c8                	mov    %ecx,%eax
  10b51e:	83 c4 04             	add    $0x4,%esp
  10b521:	5d                   	pop    %ebp
  10b522:	c3                   	ret    
  10b523:	66 90                	xchg   %ax,%ax
  10b525:	66 90                	xchg   %ax,%ax
  10b527:	66 90                	xchg   %ax,%ax
  10b529:	66 90                	xchg   %ax,%ax
  10b52b:	66 90                	xchg   %ax,%ax
  10b52d:	66 90                	xchg   %ax,%ax
  10b52f:	90                   	nop

0010b530 <_atoi>:
{
  10b530:	55                   	push   %ebp
  10b531:	89 e5                	mov    %esp,%ebp
  10b533:	83 ec 0c             	sub    $0xc,%esp
  10b536:	8b 45 08             	mov    0x8(%ebp),%eax
	const char *p = *sptr - 1;
  10b539:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b53c:	8b 09                	mov    (%ecx),%ecx
  10b53e:	83 c1 ff             	add    $0xffffffff,%ecx
  10b541:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	int i = 0;
  10b544:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	while (isdigit(*p)) {
  10b54b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b54e:	0f be 00             	movsbl (%eax),%eax
  10b551:	89 04 24             	mov    %eax,(%esp)
  10b554:	e8 a7 ff ff ff       	call   10b500 <isdigit>
  10b559:	83 f8 00             	cmp    $0x0,%eax
  10b55c:	0f 84 1f 00 00 00    	je     10b581 <_atoi+0x51>
		i = 10 * i + *p++ - '0';
  10b562:	6b 45 f8 0a          	imul   $0xa,-0x8(%ebp),%eax
  10b566:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10b569:	89 ca                	mov    %ecx,%edx
  10b56b:	83 c2 01             	add    $0x1,%edx
  10b56e:	89 55 fc             	mov    %edx,-0x4(%ebp)
  10b571:	0f be 09             	movsbl (%ecx),%ecx
  10b574:	01 c8                	add    %ecx,%eax
  10b576:	83 e8 30             	sub    $0x30,%eax
  10b579:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (isdigit(*p)) {
  10b57c:	e9 ca ff ff ff       	jmp    10b54b <_atoi+0x1b>
	*sptr = p;
  10b581:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b584:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b587:	89 01                	mov    %eax,(%ecx)
	return i;
  10b589:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b58c:	83 c4 0c             	add    $0xc,%esp
  10b58f:	5d                   	pop    %ebp
  10b590:	c3                   	ret    
  10b591:	66 90                	xchg   %ax,%ax
  10b593:	66 90                	xchg   %ax,%ax
  10b595:	66 90                	xchg   %ax,%ax
  10b597:	66 90                	xchg   %ax,%ax
  10b599:	66 90                	xchg   %ax,%ax
  10b59b:	66 90                	xchg   %ax,%ax
  10b59d:	66 90                	xchg   %ax,%ax
  10b59f:	90                   	nop

0010b5a0 <_to_dec>:
{
  10b5a0:	55                   	push   %ebp
  10b5a1:	89 e5                	mov    %esp,%ebp
  10b5a3:	57                   	push   %edi
  10b5a4:	56                   	push   %esi
  10b5a5:	83 ec 14             	sub    $0x14,%esp
  10b5a8:	8a 45 14             	mov    0x14(%ebp),%al
  10b5ab:	8a 4d 10             	mov    0x10(%ebp),%cl
  10b5ae:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b5b1:	8b 75 08             	mov    0x8(%ebp),%esi
  10b5b4:	80 e1 01             	and    $0x1,%cl
  10b5b7:	88 4d f7             	mov    %cl,-0x9(%ebp)
  10b5ba:	24 01                	and    $0x1,%al
  10b5bc:	88 45 f6             	mov    %al,-0xa(%ebp)
	char *start = buf;
  10b5bf:	8b 7d 08             	mov    0x8(%ebp),%edi
  10b5c2:	89 7d f0             	mov    %edi,-0x10(%ebp)
	if (value < 0) {
  10b5c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b5c9:	0f 8d 1b 00 00 00    	jge    10b5ea <_to_dec+0x4a>
  10b5cf:	31 c0                	xor    %eax,%eax
		*buf++ = '-';
  10b5d1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b5d4:	89 ca                	mov    %ecx,%edx
  10b5d6:	83 c2 01             	add    $0x1,%edx
  10b5d9:	89 55 08             	mov    %edx,0x8(%ebp)
  10b5dc:	c6 01 2d             	movb   $0x2d,(%ecx)
		value = -value;
  10b5df:	2b 45 0c             	sub    0xc(%ebp),%eax
  10b5e2:	89 45 0c             	mov    %eax,0xc(%ebp)
	} else if (fplus) {
  10b5e5:	e9 3f 00 00 00       	jmp    10b629 <_to_dec+0x89>
  10b5ea:	f6 45 f7 01          	testb  $0x1,-0x9(%ebp)
  10b5ee:	0f 84 13 00 00 00    	je     10b607 <_to_dec+0x67>
		*buf++ = '+';
  10b5f4:	8b 45 08             	mov    0x8(%ebp),%eax
  10b5f7:	89 c1                	mov    %eax,%ecx
  10b5f9:	83 c1 01             	add    $0x1,%ecx
  10b5fc:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b5ff:	c6 00 2b             	movb   $0x2b,(%eax)
	} else if (fspace) {
  10b602:	e9 1d 00 00 00       	jmp    10b624 <_to_dec+0x84>
  10b607:	f6 45 f6 01          	testb  $0x1,-0xa(%ebp)
  10b60b:	0f 84 0e 00 00 00    	je     10b61f <_to_dec+0x7f>
		*buf++ = ' ';
  10b611:	8b 45 08             	mov    0x8(%ebp),%eax
  10b614:	89 c1                	mov    %eax,%ecx
  10b616:	83 c1 01             	add    $0x1,%ecx
  10b619:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b61c:	c6 00 20             	movb   $0x20,(%eax)
  10b61f:	e9 00 00 00 00       	jmp    10b624 <_to_dec+0x84>
  10b624:	e9 00 00 00 00       	jmp    10b629 <_to_dec+0x89>
	return (buf + _to_udec(buf, value)) - start;
  10b629:	8b 45 08             	mov    0x8(%ebp),%eax
  10b62c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10b62f:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b632:	89 0c 24             	mov    %ecx,(%esp)
  10b635:	89 54 24 04          	mov    %edx,0x4(%esp)
  10b639:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b63c:	e8 6f 0a 00 00       	call   10c0b0 <_to_udec>
  10b641:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10b644:	01 c1                	add    %eax,%ecx
  10b646:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b649:	29 c1                	sub    %eax,%ecx
  10b64b:	89 c8                	mov    %ecx,%eax
  10b64d:	83 c4 14             	add    $0x14,%esp
  10b650:	5e                   	pop    %esi
  10b651:	5f                   	pop    %edi
  10b652:	5d                   	pop    %ebp
  10b653:	c3                   	ret    
  10b654:	66 90                	xchg   %ax,%ax
  10b656:	66 90                	xchg   %ax,%ax
  10b658:	66 90                	xchg   %ax,%ax
  10b65a:	66 90                	xchg   %ax,%ax
  10b65c:	66 90                	xchg   %ax,%ax
  10b65e:	66 90                	xchg   %ax,%ax

0010b660 <_to_float>:
{
  10b660:	55                   	push   %ebp
  10b661:	89 e5                	mov    %esp,%ebp
  10b663:	53                   	push   %ebx
  10b664:	57                   	push   %edi
  10b665:	56                   	push   %esi
  10b666:	83 e4 f8             	and    $0xfffffff8,%esp
  10b669:	83 ec 60             	sub    $0x60,%esp
  10b66c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b66f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10b672:	8b 55 28             	mov    0x28(%ebp),%edx
  10b675:	8b 75 24             	mov    0x24(%ebp),%esi
  10b678:	8a 5d 20             	mov    0x20(%ebp),%bl
  10b67b:	8a 7d 1c             	mov    0x1c(%ebp),%bh
  10b67e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10b682:	8a 45 18             	mov    0x18(%ebp),%al
  10b685:	8a 65 14             	mov    0x14(%ebp),%ah
  10b688:	8b 7d 08             	mov    0x8(%ebp),%edi
  10b68b:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  10b68f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  10b693:	89 4c 24 50          	mov    %ecx,0x50(%esp)
  10b697:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10b69b:	89 4c 24 54          	mov    %ecx,0x54(%esp)
  10b69f:	24 01                	and    $0x1,%al
  10b6a1:	88 44 24 4f          	mov    %al,0x4f(%esp)
  10b6a5:	80 e7 01             	and    $0x1,%bh
  10b6a8:	88 7c 24 4e          	mov    %bh,0x4e(%esp)
  10b6ac:	80 e3 01             	and    $0x1,%bl
  10b6af:	88 5c 24 4d          	mov    %bl,0x4d(%esp)
	char *start = buf;
  10b6b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10b6b6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
	exp = double_temp >> 52 & 0x7ff;
  10b6ba:	8b 5c 24 54          	mov    0x54(%esp),%ebx
  10b6be:	c1 eb 14             	shr    $0x14,%ebx
  10b6c1:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  10b6c7:	89 5c 24 44          	mov    %ebx,0x44(%esp)
	fract = (double_temp << 11) & ~HIGHBIT64;
  10b6cb:	8b 5c 24 50          	mov    0x50(%esp),%ebx
  10b6cf:	8b 4c 24 54          	mov    0x54(%esp),%ecx
  10b6d3:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  10b6d7:	c1 e3 0b             	shl    $0xb,%ebx
  10b6da:	89 54 24 10          	mov    %edx,0x10(%esp)
  10b6de:	8b 54 24 14          	mov    0x14(%esp),%edx
  10b6e2:	0f a4 d1 0b          	shld   $0xb,%edx,%ecx
  10b6e6:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  10b6ec:	89 5c 24 30          	mov    %ebx,0x30(%esp)
  10b6f0:	89 4c 24 34          	mov    %ecx,0x34(%esp)
	sign = !!(double_temp & HIGHBIT64);
  10b6f4:	8a 44 24 57          	mov    0x57(%esp),%al
  10b6f8:	c0 e8 07             	shr    $0x7,%al
  10b6fb:	34 ff                	xor    $0xff,%al
  10b6fd:	34 ff                	xor    $0xff,%al
  10b6ff:	24 01                	and    $0x1,%al
  10b701:	88 44 24 43          	mov    %al,0x43(%esp)
	if (sign) {
  10b705:	f6 44 24 43 01       	testb  $0x1,0x43(%esp)
  10b70a:	0f 84 13 00 00 00    	je     10b723 <_to_float+0xc3>
		*buf++ = '-';
  10b710:	8b 45 08             	mov    0x8(%ebp),%eax
  10b713:	89 c1                	mov    %eax,%ecx
  10b715:	83 c1 01             	add    $0x1,%ecx
  10b718:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b71b:	c6 00 2d             	movb   $0x2d,(%eax)
	} else if (fplus) {
  10b71e:	e9 41 00 00 00       	jmp    10b764 <_to_float+0x104>
  10b723:	f6 44 24 4e 01       	testb  $0x1,0x4e(%esp)
  10b728:	0f 84 13 00 00 00    	je     10b741 <_to_float+0xe1>
		*buf++ = '+';
  10b72e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b731:	89 c1                	mov    %eax,%ecx
  10b733:	83 c1 01             	add    $0x1,%ecx
  10b736:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b739:	c6 00 2b             	movb   $0x2b,(%eax)
	} else if (fspace) {
  10b73c:	e9 1e 00 00 00       	jmp    10b75f <_to_float+0xff>
  10b741:	f6 44 24 4d 01       	testb  $0x1,0x4d(%esp)
  10b746:	0f 84 0e 00 00 00    	je     10b75a <_to_float+0xfa>
		*buf++ = ' ';
  10b74c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b74f:	89 c1                	mov    %eax,%ecx
  10b751:	83 c1 01             	add    $0x1,%ecx
  10b754:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b757:	c6 00 20             	movb   $0x20,(%eax)
  10b75a:	e9 00 00 00 00       	jmp    10b75f <_to_float+0xff>
  10b75f:	e9 00 00 00 00       	jmp    10b764 <_to_float+0x104>
	if (exp == 0x7ff) {
  10b764:	81 7c 24 44 ff 07 00 	cmpl   $0x7ff,0x44(%esp)
  10b76b:	00 
  10b76c:	0f 85 13 01 00 00    	jne    10b885 <_to_float+0x225>
		if (!fract) {
  10b772:	8b 44 24 30          	mov    0x30(%esp),%eax
  10b776:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10b77a:	09 c8                	or     %ecx,%eax
  10b77c:	0f 85 78 00 00 00    	jne    10b7fa <_to_float+0x19a>
  10b782:	e9 00 00 00 00       	jmp    10b787 <_to_float+0x127>
			if (isupper(c)) {
  10b787:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10b78b:	89 04 24             	mov    %eax,(%esp)
  10b78e:	e8 5d 09 00 00       	call   10c0f0 <isupper>
  10b793:	83 f8 00             	cmp    $0x0,%eax
  10b796:	0f 84 2f 00 00 00    	je     10b7cb <_to_float+0x16b>
				*buf++ = 'I';
  10b79c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b79f:	89 c1                	mov    %eax,%ecx
  10b7a1:	83 c1 01             	add    $0x1,%ecx
  10b7a4:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7a7:	c6 00 49             	movb   $0x49,(%eax)
				*buf++ = 'N';
  10b7aa:	8b 45 08             	mov    0x8(%ebp),%eax
  10b7ad:	89 c1                	mov    %eax,%ecx
  10b7af:	83 c1 01             	add    $0x1,%ecx
  10b7b2:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7b5:	c6 00 4e             	movb   $0x4e,(%eax)
				*buf++ = 'F';
  10b7b8:	8b 45 08             	mov    0x8(%ebp),%eax
  10b7bb:	89 c1                	mov    %eax,%ecx
  10b7bd:	83 c1 01             	add    $0x1,%ecx
  10b7c0:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7c3:	c6 00 46             	movb   $0x46,(%eax)
			} else {
  10b7c6:	e9 2a 00 00 00       	jmp    10b7f5 <_to_float+0x195>
				*buf++ = 'i';
  10b7cb:	8b 45 08             	mov    0x8(%ebp),%eax
  10b7ce:	89 c1                	mov    %eax,%ecx
  10b7d0:	83 c1 01             	add    $0x1,%ecx
  10b7d3:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7d6:	c6 00 69             	movb   $0x69,(%eax)
				*buf++ = 'n';
  10b7d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10b7dc:	89 c1                	mov    %eax,%ecx
  10b7de:	83 c1 01             	add    $0x1,%ecx
  10b7e1:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7e4:	c6 00 6e             	movb   $0x6e,(%eax)
				*buf++ = 'f';
  10b7e7:	8b 45 08             	mov    0x8(%ebp),%eax
  10b7ea:	89 c1                	mov    %eax,%ecx
  10b7ec:	83 c1 01             	add    $0x1,%ecx
  10b7ef:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b7f2:	c6 00 66             	movb   $0x66,(%eax)
		} else {
  10b7f5:	e9 73 00 00 00       	jmp    10b86d <_to_float+0x20d>
			if (isupper(c)) {
  10b7fa:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10b7fe:	89 04 24             	mov    %eax,(%esp)
  10b801:	e8 ea 08 00 00       	call   10c0f0 <isupper>
  10b806:	83 f8 00             	cmp    $0x0,%eax
  10b809:	0f 84 2f 00 00 00    	je     10b83e <_to_float+0x1de>
				*buf++ = 'N';
  10b80f:	8b 45 08             	mov    0x8(%ebp),%eax
  10b812:	89 c1                	mov    %eax,%ecx
  10b814:	83 c1 01             	add    $0x1,%ecx
  10b817:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b81a:	c6 00 4e             	movb   $0x4e,(%eax)
				*buf++ = 'A';
  10b81d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b820:	89 c1                	mov    %eax,%ecx
  10b822:	83 c1 01             	add    $0x1,%ecx
  10b825:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b828:	c6 00 41             	movb   $0x41,(%eax)
				*buf++ = 'N';
  10b82b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b82e:	89 c1                	mov    %eax,%ecx
  10b830:	83 c1 01             	add    $0x1,%ecx
  10b833:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b836:	c6 00 4e             	movb   $0x4e,(%eax)
			} else {
  10b839:	e9 2a 00 00 00       	jmp    10b868 <_to_float+0x208>
				*buf++ = 'n';
  10b83e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b841:	89 c1                	mov    %eax,%ecx
  10b843:	83 c1 01             	add    $0x1,%ecx
  10b846:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b849:	c6 00 6e             	movb   $0x6e,(%eax)
				*buf++ = 'a';
  10b84c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b84f:	89 c1                	mov    %eax,%ecx
  10b851:	83 c1 01             	add    $0x1,%ecx
  10b854:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b857:	c6 00 61             	movb   $0x61,(%eax)
				*buf++ = 'n';
  10b85a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b85d:	89 c1                	mov    %eax,%ecx
  10b85f:	83 c1 01             	add    $0x1,%ecx
  10b862:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10b865:	c6 00 6e             	movb   $0x6e,(%eax)
  10b868:	e9 00 00 00 00       	jmp    10b86d <_to_float+0x20d>
		*buf = 0;
  10b86d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b870:	c6 00 00             	movb   $0x0,(%eax)
		return buf - start;
  10b873:	8b 45 08             	mov    0x8(%ebp),%eax
  10b876:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10b87a:	29 c8                	sub    %ecx,%eax
  10b87c:	89 44 24 58          	mov    %eax,0x58(%esp)
  10b880:	e9 e1 06 00 00       	jmp    10bf66 <_to_float+0x906>
	if (c == 'F') {
  10b885:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10b889:	83 f8 46             	cmp    $0x46,%eax
  10b88c:	0f 85 04 00 00 00    	jne    10b896 <_to_float+0x236>
		c = 'f';
  10b892:	c6 45 14 66          	movb   $0x66,0x14(%ebp)
	if ((exp | fract) != 0) {
  10b896:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b89a:	89 c1                	mov    %eax,%ecx
  10b89c:	c1 f9 1f             	sar    $0x1f,%ecx
  10b89f:	8b 54 24 30          	mov    0x30(%esp),%edx
  10b8a3:	8b 74 24 34          	mov    0x34(%esp),%esi
  10b8a7:	09 d0                	or     %edx,%eax
  10b8a9:	09 f1                	or     %esi,%ecx
  10b8ab:	09 c8                	or     %ecx,%eax
  10b8ad:	0f 84 6b 00 00 00    	je     10b91e <_to_float+0x2be>
  10b8b3:	e9 00 00 00 00       	jmp    10b8b8 <_to_float+0x258>
		if (exp == 0) {
  10b8b8:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  10b8bd:	0f 85 43 00 00 00    	jne    10b906 <_to_float+0x2a6>
			while (((fract <<= 1) & HIGHBIT64) == 0) {
  10b8c3:	e9 00 00 00 00       	jmp    10b8c8 <_to_float+0x268>
  10b8c8:	8b 44 24 30          	mov    0x30(%esp),%eax
  10b8cc:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10b8d0:	89 c2                	mov    %eax,%edx
  10b8d2:	01 d2                	add    %edx,%edx
  10b8d4:	0f a4 c1 01          	shld   $0x1,%eax,%ecx
  10b8d8:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  10b8dc:	89 54 24 30          	mov    %edx,0x30(%esp)
  10b8e0:	f7 c1 00 00 00 80    	test   $0x80000000,%ecx
  10b8e6:	0f 85 15 00 00 00    	jne    10b901 <_to_float+0x2a1>
  10b8ec:	e9 00 00 00 00       	jmp    10b8f1 <_to_float+0x291>
				exp--;
  10b8f1:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b8f5:	83 c0 ff             	add    $0xffffffff,%eax
  10b8f8:	89 44 24 44          	mov    %eax,0x44(%esp)
			while (((fract <<= 1) & HIGHBIT64) == 0) {
  10b8fc:	e9 c7 ff ff ff       	jmp    10b8c8 <_to_float+0x268>
		}
  10b901:	e9 00 00 00 00       	jmp    10b906 <_to_float+0x2a6>
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  10b906:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b90a:	05 02 fc ff ff       	add    $0xfffffc02,%eax
  10b90f:	89 44 24 44          	mov    %eax,0x44(%esp)
		fract |= HIGHBIT64;
  10b913:	8a 4c 24 37          	mov    0x37(%esp),%cl
  10b917:	80 c9 80             	or     $0x80,%cl
  10b91a:	88 4c 24 37          	mov    %cl,0x37(%esp)
	decexp = 0;
  10b91e:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
  10b925:	00 
	while (exp <= -3) {
  10b926:	83 7c 24 44 fd       	cmpl   $0xfffffffd,0x44(%esp)
  10b92b:	0f 8f a5 00 00 00    	jg     10b9d6 <_to_float+0x376>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  10b931:	e9 00 00 00 00       	jmp    10b936 <_to_float+0x2d6>
  10b936:	8b 44 24 34          	mov    0x34(%esp),%eax
  10b93a:	2d 33 33 33 33       	sub    $0x33333333,%eax
  10b93f:	0f 82 21 00 00 00    	jb     10b966 <_to_float+0x306>
  10b945:	e9 00 00 00 00       	jmp    10b94a <_to_float+0x2ea>
			_rlrshift(&fract);
  10b94a:	8d 44 24 30          	lea    0x30(%esp),%eax
  10b94e:	89 04 24             	mov    %eax,(%esp)
  10b951:	e8 ca 07 00 00       	call   10c120 <_rlrshift>
			exp++;
  10b956:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b95a:	83 c0 01             	add    $0x1,%eax
  10b95d:	89 44 24 44          	mov    %eax,0x44(%esp)
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  10b961:	e9 d0 ff ff ff       	jmp    10b936 <_to_float+0x2d6>
		fract *= 5U;
  10b966:	8b 44 24 30          	mov    0x30(%esp),%eax
  10b96a:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10b96e:	ba 05 00 00 00       	mov    $0x5,%edx
  10b973:	f7 e2                	mul    %edx
  10b975:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  10b978:	01 ca                	add    %ecx,%edx
  10b97a:	89 44 24 30          	mov    %eax,0x30(%esp)
  10b97e:	89 54 24 34          	mov    %edx,0x34(%esp)
		exp++;
  10b982:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b986:	83 c0 01             	add    $0x1,%eax
  10b989:	89 44 24 44          	mov    %eax,0x44(%esp)
		decexp--;
  10b98d:	8b 44 24 48          	mov    0x48(%esp),%eax
  10b991:	83 c0 ff             	add    $0xffffffff,%eax
  10b994:	89 44 24 48          	mov    %eax,0x48(%esp)
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  10b998:	8b 44 24 34          	mov    0x34(%esp),%eax
  10b99c:	85 c0                	test   %eax,%eax
  10b99e:	0f 88 2d 00 00 00    	js     10b9d1 <_to_float+0x371>
  10b9a4:	e9 00 00 00 00       	jmp    10b9a9 <_to_float+0x349>
			fract <<= 1;
  10b9a9:	8b 44 24 30          	mov    0x30(%esp),%eax
  10b9ad:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10b9b1:	89 c2                	mov    %eax,%edx
  10b9b3:	01 d2                	add    %edx,%edx
  10b9b5:	0f a4 c1 01          	shld   $0x1,%eax,%ecx
  10b9b9:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  10b9bd:	89 54 24 30          	mov    %edx,0x30(%esp)
			exp--;
  10b9c1:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b9c5:	83 c0 ff             	add    $0xffffffff,%eax
  10b9c8:	89 44 24 44          	mov    %eax,0x44(%esp)
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  10b9cc:	e9 c7 ff ff ff       	jmp    10b998 <_to_float+0x338>
	while (exp <= -3) {
  10b9d1:	e9 50 ff ff ff       	jmp    10b926 <_to_float+0x2c6>
	while (exp > 0) {
  10b9d6:	e9 00 00 00 00       	jmp    10b9db <_to_float+0x37b>
  10b9db:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  10b9e0:	0f 8e 60 00 00 00    	jle    10ba46 <_to_float+0x3e6>
		_ldiv5(&fract);
  10b9e6:	8d 44 24 30          	lea    0x30(%esp),%eax
  10b9ea:	89 04 24             	mov    %eax,(%esp)
  10b9ed:	e8 5e 07 00 00       	call   10c150 <_ldiv5>
		exp--;
  10b9f2:	8b 44 24 44          	mov    0x44(%esp),%eax
  10b9f6:	83 c0 ff             	add    $0xffffffff,%eax
  10b9f9:	89 44 24 44          	mov    %eax,0x44(%esp)
		decexp++;
  10b9fd:	8b 44 24 48          	mov    0x48(%esp),%eax
  10ba01:	83 c0 01             	add    $0x1,%eax
  10ba04:	89 44 24 48          	mov    %eax,0x48(%esp)
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  10ba08:	8b 44 24 34          	mov    0x34(%esp),%eax
  10ba0c:	85 c0                	test   %eax,%eax
  10ba0e:	0f 88 2d 00 00 00    	js     10ba41 <_to_float+0x3e1>
  10ba14:	e9 00 00 00 00       	jmp    10ba19 <_to_float+0x3b9>
			fract <<= 1;
  10ba19:	8b 44 24 30          	mov    0x30(%esp),%eax
  10ba1d:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10ba21:	89 c2                	mov    %eax,%edx
  10ba23:	01 d2                	add    %edx,%edx
  10ba25:	0f a4 c1 01          	shld   $0x1,%eax,%ecx
  10ba29:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  10ba2d:	89 54 24 30          	mov    %edx,0x30(%esp)
			exp--;
  10ba31:	8b 44 24 44          	mov    0x44(%esp),%eax
  10ba35:	83 c0 ff             	add    $0xffffffff,%eax
  10ba38:	89 44 24 44          	mov    %eax,0x44(%esp)
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  10ba3c:	e9 c7 ff ff ff       	jmp    10ba08 <_to_float+0x3a8>
	while (exp > 0) {
  10ba41:	e9 95 ff ff ff       	jmp    10b9db <_to_float+0x37b>
	while (exp < (0 + 4)) {
  10ba46:	e9 00 00 00 00       	jmp    10ba4b <_to_float+0x3eb>
  10ba4b:	83 7c 24 44 04       	cmpl   $0x4,0x44(%esp)
  10ba50:	0f 8d 1c 00 00 00    	jge    10ba72 <_to_float+0x412>
		_rlrshift(&fract);
  10ba56:	8d 44 24 30          	lea    0x30(%esp),%eax
  10ba5a:	89 04 24             	mov    %eax,(%esp)
  10ba5d:	e8 be 06 00 00       	call   10c120 <_rlrshift>
		exp++;
  10ba62:	8b 44 24 44          	mov    0x44(%esp),%eax
  10ba66:	83 c0 01             	add    $0x1,%eax
  10ba69:	89 44 24 44          	mov    %eax,0x44(%esp)
	while (exp < (0 + 4)) {
  10ba6d:	e9 d9 ff ff ff       	jmp    10ba4b <_to_float+0x3eb>
	if (precision < 0) {
  10ba72:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10ba76:	0f 8d 07 00 00 00    	jge    10ba83 <_to_float+0x423>
		precision = 6;		/* Default precision if none given */
  10ba7c:	c7 45 24 06 00 00 00 	movl   $0x6,0x24(%ebp)
	prune_zero = false;		/* Assume trailing 0's allowed     */
  10ba83:	c6 44 24 27 00       	movb   $0x0,0x27(%esp)
	if ((c == 'g') || (c == 'G')) {
  10ba88:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10ba8c:	83 f8 67             	cmp    $0x67,%eax
  10ba8f:	0f 84 0d 00 00 00    	je     10baa2 <_to_float+0x442>
  10ba95:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10ba99:	83 f8 47             	cmp    $0x47,%eax
  10ba9c:	0f 85 69 00 00 00    	jne    10bb0b <_to_float+0x4ab>
		if (decexp < (-4 + 1) || decexp > precision) {
  10baa2:	83 7c 24 48 fd       	cmpl   $0xfffffffd,0x48(%esp)
  10baa7:	0f 8c 0d 00 00 00    	jl     10baba <_to_float+0x45a>
  10baad:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bab1:	3b 45 24             	cmp    0x24(%ebp),%eax
  10bab4:	0f 8e 22 00 00 00    	jle    10badc <_to_float+0x47c>
			c += 'e' - 'g';
  10baba:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10babe:	83 c0 fe             	add    $0xfffffffe,%eax
  10bac1:	88 45 14             	mov    %al,0x14(%ebp)
			if (precision > 0) {
  10bac4:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bac8:	0f 8e 09 00 00 00    	jle    10bad7 <_to_float+0x477>
				precision--;
  10bace:	8b 45 24             	mov    0x24(%ebp),%eax
  10bad1:	83 c0 ff             	add    $0xffffffff,%eax
  10bad4:	89 45 24             	mov    %eax,0x24(%ebp)
		} else {
  10bad7:	e9 10 00 00 00       	jmp    10baec <_to_float+0x48c>
			c = 'f';
  10badc:	c6 45 14 66          	movb   $0x66,0x14(%ebp)
			precision -= decexp;
  10bae0:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bae4:	8b 4d 24             	mov    0x24(%ebp),%ecx
  10bae7:	29 c1                	sub    %eax,%ecx
  10bae9:	89 4d 24             	mov    %ecx,0x24(%ebp)
		if (!falt && (precision > 0)) {
  10baec:	f6 44 24 4f 01       	testb  $0x1,0x4f(%esp)
  10baf1:	0f 85 0f 00 00 00    	jne    10bb06 <_to_float+0x4a6>
  10baf7:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bafb:	0f 8e 05 00 00 00    	jle    10bb06 <_to_float+0x4a6>
			prune_zero = true;
  10bb01:	c6 44 24 27 01       	movb   $0x1,0x27(%esp)
	}
  10bb06:	e9 00 00 00 00       	jmp    10bb0b <_to_float+0x4ab>
	if (c == 'f') {
  10bb0b:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10bb0f:	83 f8 66             	cmp    $0x66,%eax
  10bb12:	0f 85 23 00 00 00    	jne    10bb3b <_to_float+0x4db>
		exp = precision + decexp;
  10bb18:	8b 45 24             	mov    0x24(%ebp),%eax
  10bb1b:	03 44 24 48          	add    0x48(%esp),%eax
  10bb1f:	89 44 24 44          	mov    %eax,0x44(%esp)
		if (exp < 0) {
  10bb23:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  10bb28:	0f 8d 08 00 00 00    	jge    10bb36 <_to_float+0x4d6>
			exp = 0;
  10bb2e:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
  10bb35:	00 
	} else {
  10bb36:	e9 0a 00 00 00       	jmp    10bb45 <_to_float+0x4e5>
		exp = precision + 1;
  10bb3b:	8b 45 24             	mov    0x24(%ebp),%eax
  10bb3e:	83 c0 01             	add    $0x1,%eax
  10bb41:	89 44 24 44          	mov    %eax,0x44(%esp)
	digit_count = 16;
  10bb45:	c7 44 24 3c 10 00 00 	movl   $0x10,0x3c(%esp)
  10bb4c:	00 
	if (exp > 16) {
  10bb4d:	83 7c 24 44 10       	cmpl   $0x10,0x44(%esp)
  10bb52:	0f 8e 08 00 00 00    	jle    10bb60 <_to_float+0x500>
		exp = 16;
  10bb58:	c7 44 24 44 10 00 00 	movl   $0x10,0x44(%esp)
  10bb5f:	00 
	ltemp = 0x0800000000000000;
  10bb60:	c7 44 24 2c 00 00 00 	movl   $0x8000000,0x2c(%esp)
  10bb67:	08 
  10bb68:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  10bb6f:	00 
	while (exp--) {
  10bb70:	8b 44 24 44          	mov    0x44(%esp),%eax
  10bb74:	89 c1                	mov    %eax,%ecx
  10bb76:	83 c1 ff             	add    $0xffffffff,%ecx
  10bb79:	89 4c 24 44          	mov    %ecx,0x44(%esp)
  10bb7d:	83 f8 00             	cmp    $0x0,%eax
  10bb80:	0f 84 1d 00 00 00    	je     10bba3 <_to_float+0x543>
		_ldiv5(&ltemp);
  10bb86:	8d 44 24 28          	lea    0x28(%esp),%eax
  10bb8a:	89 04 24             	mov    %eax,(%esp)
  10bb8d:	e8 be 05 00 00       	call   10c150 <_ldiv5>
		_rlrshift(&ltemp);
  10bb92:	8d 44 24 28          	lea    0x28(%esp),%eax
  10bb96:	89 04 24             	mov    %eax,(%esp)
  10bb99:	e8 82 05 00 00       	call   10c120 <_rlrshift>
	while (exp--) {
  10bb9e:	e9 cd ff ff ff       	jmp    10bb70 <_to_float+0x510>
	fract += ltemp;
  10bba3:	8b 44 24 28          	mov    0x28(%esp),%eax
  10bba7:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  10bbab:	8b 54 24 30          	mov    0x30(%esp),%edx
  10bbaf:	8b 74 24 34          	mov    0x34(%esp),%esi
  10bbb3:	01 c2                	add    %eax,%edx
  10bbb5:	11 ce                	adc    %ecx,%esi
  10bbb7:	89 54 24 30          	mov    %edx,0x30(%esp)
  10bbbb:	89 74 24 34          	mov    %esi,0x34(%esp)
	if ((fract >> 32) & 0xF0000000) {
  10bbbf:	8b 44 24 34          	mov    0x34(%esp),%eax
  10bbc3:	a9 00 00 00 f0       	test   $0xf0000000,%eax
  10bbc8:	0f 84 28 00 00 00    	je     10bbf6 <_to_float+0x596>
  10bbce:	e9 00 00 00 00       	jmp    10bbd3 <_to_float+0x573>
		_ldiv5(&fract);
  10bbd3:	8d 44 24 30          	lea    0x30(%esp),%eax
  10bbd7:	89 04 24             	mov    %eax,(%esp)
  10bbda:	e8 71 05 00 00       	call   10c150 <_ldiv5>
		_rlrshift(&fract);
  10bbdf:	8d 44 24 30          	lea    0x30(%esp),%eax
  10bbe3:	89 04 24             	mov    %eax,(%esp)
  10bbe6:	e8 35 05 00 00       	call   10c120 <_rlrshift>
		decexp++;
  10bbeb:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bbef:	83 c0 01             	add    $0x1,%eax
  10bbf2:	89 44 24 48          	mov    %eax,0x48(%esp)
	if (c == 'f') {
  10bbf6:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10bbfa:	83 f8 66             	cmp    $0x66,%eax
  10bbfd:	0f 85 6c 01 00 00    	jne    10bd6f <_to_float+0x70f>
		if (decexp > 0) {
  10bc03:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  10bc08:	0f 8e 7a 00 00 00    	jle    10bc88 <_to_float+0x628>
			while (decexp > 0 && digit_count > 0) {
  10bc0e:	e9 00 00 00 00       	jmp    10bc13 <_to_float+0x5b3>
  10bc13:	31 c0                	xor    %eax,%eax
  10bc15:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  10bc1a:	88 44 24 0f          	mov    %al,0xf(%esp)
  10bc1e:	0f 8e 0c 00 00 00    	jle    10bc30 <_to_float+0x5d0>
  10bc24:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  10bc29:	0f 9f c0             	setg   %al
  10bc2c:	88 44 24 0f          	mov    %al,0xf(%esp)
  10bc30:	8a 44 24 0f          	mov    0xf(%esp),%al
  10bc34:	a8 01                	test   $0x1,%al
  10bc36:	0f 85 05 00 00 00    	jne    10bc41 <_to_float+0x5e1>
  10bc3c:	e9 31 00 00 00       	jmp    10bc72 <_to_float+0x612>
				*buf++ = _get_digit(&fract, &digit_count);
  10bc41:	8d 44 24 30          	lea    0x30(%esp),%eax
  10bc45:	89 04 24             	mov    %eax,(%esp)
  10bc48:	8d 44 24 3c          	lea    0x3c(%esp),%eax
  10bc4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bc50:	e8 6b 06 00 00       	call   10c2c0 <_get_digit>
  10bc55:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bc58:	89 ca                	mov    %ecx,%edx
  10bc5a:	83 c2 01             	add    $0x1,%edx
  10bc5d:	89 55 08             	mov    %edx,0x8(%ebp)
  10bc60:	88 01                	mov    %al,(%ecx)
				decexp--;
  10bc62:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  10bc66:	83 c1 ff             	add    $0xffffffff,%ecx
  10bc69:	89 4c 24 48          	mov    %ecx,0x48(%esp)
			while (decexp > 0 && digit_count > 0) {
  10bc6d:	e9 a1 ff ff ff       	jmp    10bc13 <_to_float+0x5b3>
			zp->predot = decexp;
  10bc72:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bc76:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10bc79:	89 01                	mov    %eax,(%ecx)
			decexp = 0;
  10bc7b:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
  10bc82:	00 
		} else {
  10bc83:	e9 0e 00 00 00       	jmp    10bc96 <_to_float+0x636>
			*buf++ = '0';
  10bc88:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc8b:	89 c1                	mov    %eax,%ecx
  10bc8d:	83 c1 01             	add    $0x1,%ecx
  10bc90:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bc93:	c6 00 30             	movb   $0x30,(%eax)
		if (falt || (precision > 0)) {
  10bc96:	f6 44 24 4f 01       	testb  $0x1,0x4f(%esp)
  10bc9b:	0f 85 0a 00 00 00    	jne    10bcab <_to_float+0x64b>
  10bca1:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bca5:	0f 8e 0e 00 00 00    	jle    10bcb9 <_to_float+0x659>
			*buf++ = '.';
  10bcab:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcae:	89 c1                	mov    %eax,%ecx
  10bcb0:	83 c1 01             	add    $0x1,%ecx
  10bcb3:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bcb6:	c6 00 2e             	movb   $0x2e,(%eax)
		if (decexp < 0 && precision > 0) {
  10bcb9:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  10bcbe:	0f 8d 3c 00 00 00    	jge    10bd00 <_to_float+0x6a0>
  10bcc4:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bcc8:	0f 8e 32 00 00 00    	jle    10bd00 <_to_float+0x6a0>
  10bcce:	31 c0                	xor    %eax,%eax
			zp->postdot = -decexp;
  10bcd0:	2b 44 24 48          	sub    0x48(%esp),%eax
  10bcd4:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10bcd7:	89 41 04             	mov    %eax,0x4(%ecx)
			if (zp->postdot > precision) {
  10bcda:	8b 45 28             	mov    0x28(%ebp),%eax
  10bcdd:	8b 40 04             	mov    0x4(%eax),%eax
  10bce0:	3b 45 24             	cmp    0x24(%ebp),%eax
  10bce3:	0f 8e 09 00 00 00    	jle    10bcf2 <_to_float+0x692>
				zp->postdot = precision;
  10bce9:	8b 45 24             	mov    0x24(%ebp),%eax
  10bcec:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10bcef:	89 41 04             	mov    %eax,0x4(%ecx)
			precision -= zp->postdot;
  10bcf2:	8b 45 28             	mov    0x28(%ebp),%eax
  10bcf5:	8b 40 04             	mov    0x4(%eax),%eax
  10bcf8:	8b 4d 24             	mov    0x24(%ebp),%ecx
  10bcfb:	29 c1                	sub    %eax,%ecx
  10bcfd:	89 4d 24             	mov    %ecx,0x24(%ebp)
		while (precision > 0 && digit_count > 0) {
  10bd00:	e9 00 00 00 00       	jmp    10bd05 <_to_float+0x6a5>
  10bd05:	31 c0                	xor    %eax,%eax
  10bd07:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bd0b:	88 44 24 0e          	mov    %al,0xe(%esp)
  10bd0f:	0f 8e 0c 00 00 00    	jle    10bd21 <_to_float+0x6c1>
  10bd15:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  10bd1a:	0f 9f c0             	setg   %al
  10bd1d:	88 44 24 0e          	mov    %al,0xe(%esp)
  10bd21:	8a 44 24 0e          	mov    0xe(%esp),%al
  10bd25:	a8 01                	test   $0x1,%al
  10bd27:	0f 85 05 00 00 00    	jne    10bd32 <_to_float+0x6d2>
  10bd2d:	e9 2f 00 00 00       	jmp    10bd61 <_to_float+0x701>
			*buf++ = _get_digit(&fract, &digit_count);
  10bd32:	8d 44 24 30          	lea    0x30(%esp),%eax
  10bd36:	89 04 24             	mov    %eax,(%esp)
  10bd39:	8d 44 24 3c          	lea    0x3c(%esp),%eax
  10bd3d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bd41:	e8 7a 05 00 00       	call   10c2c0 <_get_digit>
  10bd46:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bd49:	89 ca                	mov    %ecx,%edx
  10bd4b:	83 c2 01             	add    $0x1,%edx
  10bd4e:	89 55 08             	mov    %edx,0x8(%ebp)
  10bd51:	88 01                	mov    %al,(%ecx)
			precision--;
  10bd53:	8b 4d 24             	mov    0x24(%ebp),%ecx
  10bd56:	83 c1 ff             	add    $0xffffffff,%ecx
  10bd59:	89 4d 24             	mov    %ecx,0x24(%ebp)
		while (precision > 0 && digit_count > 0) {
  10bd5c:	e9 a4 ff ff ff       	jmp    10bd05 <_to_float+0x6a5>
		zp->trail = precision;
  10bd61:	8b 45 24             	mov    0x24(%ebp),%eax
  10bd64:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10bd67:	89 41 08             	mov    %eax,0x8(%ecx)
	} else {
  10bd6a:	e9 c8 00 00 00       	jmp    10be37 <_to_float+0x7d7>
		*buf = _get_digit(&fract, &digit_count);
  10bd6f:	8d 44 24 30          	lea    0x30(%esp),%eax
  10bd73:	89 04 24             	mov    %eax,(%esp)
  10bd76:	8d 44 24 3c          	lea    0x3c(%esp),%eax
  10bd7a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bd7e:	e8 3d 05 00 00       	call   10c2c0 <_get_digit>
  10bd83:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bd86:	88 01                	mov    %al,(%ecx)
		if (*buf++ != '0') {
  10bd88:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bd8b:	89 ca                	mov    %ecx,%edx
  10bd8d:	83 c2 01             	add    $0x1,%edx
  10bd90:	89 55 08             	mov    %edx,0x8(%ebp)
  10bd93:	0f be 09             	movsbl (%ecx),%ecx
  10bd96:	83 f9 30             	cmp    $0x30,%ecx
  10bd99:	0f 84 0b 00 00 00    	je     10bdaa <_to_float+0x74a>
			decexp--;
  10bd9f:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bda3:	83 c0 ff             	add    $0xffffffff,%eax
  10bda6:	89 44 24 48          	mov    %eax,0x48(%esp)
		if (falt || (precision > 0)) {
  10bdaa:	f6 44 24 4f 01       	testb  $0x1,0x4f(%esp)
  10bdaf:	0f 85 0a 00 00 00    	jne    10bdbf <_to_float+0x75f>
  10bdb5:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bdb9:	0f 8e 0e 00 00 00    	jle    10bdcd <_to_float+0x76d>
			*buf++ = '.';
  10bdbf:	8b 45 08             	mov    0x8(%ebp),%eax
  10bdc2:	89 c1                	mov    %eax,%ecx
  10bdc4:	83 c1 01             	add    $0x1,%ecx
  10bdc7:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bdca:	c6 00 2e             	movb   $0x2e,(%eax)
		while (precision > 0 && digit_count > 0) {
  10bdcd:	e9 00 00 00 00       	jmp    10bdd2 <_to_float+0x772>
  10bdd2:	31 c0                	xor    %eax,%eax
  10bdd4:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  10bdd8:	88 44 24 0d          	mov    %al,0xd(%esp)
  10bddc:	0f 8e 0c 00 00 00    	jle    10bdee <_to_float+0x78e>
  10bde2:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  10bde7:	0f 9f c0             	setg   %al
  10bdea:	88 44 24 0d          	mov    %al,0xd(%esp)
  10bdee:	8a 44 24 0d          	mov    0xd(%esp),%al
  10bdf2:	a8 01                	test   $0x1,%al
  10bdf4:	0f 85 05 00 00 00    	jne    10bdff <_to_float+0x79f>
  10bdfa:	e9 2f 00 00 00       	jmp    10be2e <_to_float+0x7ce>
			*buf++ = _get_digit(&fract, &digit_count);
  10bdff:	8d 44 24 30          	lea    0x30(%esp),%eax
  10be03:	89 04 24             	mov    %eax,(%esp)
  10be06:	8d 44 24 3c          	lea    0x3c(%esp),%eax
  10be0a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10be0e:	e8 ad 04 00 00       	call   10c2c0 <_get_digit>
  10be13:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10be16:	89 ca                	mov    %ecx,%edx
  10be18:	83 c2 01             	add    $0x1,%edx
  10be1b:	89 55 08             	mov    %edx,0x8(%ebp)
  10be1e:	88 01                	mov    %al,(%ecx)
			precision--;
  10be20:	8b 4d 24             	mov    0x24(%ebp),%ecx
  10be23:	83 c1 ff             	add    $0xffffffff,%ecx
  10be26:	89 4d 24             	mov    %ecx,0x24(%ebp)
		while (precision > 0 && digit_count > 0) {
  10be29:	e9 a4 ff ff ff       	jmp    10bdd2 <_to_float+0x772>
		zp->trail = precision;
  10be2e:	8b 45 24             	mov    0x24(%ebp),%eax
  10be31:	8b 4d 28             	mov    0x28(%ebp),%ecx
  10be34:	89 41 08             	mov    %eax,0x8(%ecx)
	if (prune_zero) {
  10be37:	f6 44 24 27 01       	testb  $0x1,0x27(%esp)
  10be3c:	0f 84 44 00 00 00    	je     10be86 <_to_float+0x826>
		zp->trail = 0;
  10be42:	8b 45 28             	mov    0x28(%ebp),%eax
  10be45:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		while (*--buf == '0')
  10be4c:	8b 45 08             	mov    0x8(%ebp),%eax
  10be4f:	89 c1                	mov    %eax,%ecx
  10be51:	83 c1 ff             	add    $0xffffffff,%ecx
  10be54:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10be57:	0f be 40 ff          	movsbl -0x1(%eax),%eax
  10be5b:	83 f8 30             	cmp    $0x30,%eax
  10be5e:	0f 85 05 00 00 00    	jne    10be69 <_to_float+0x809>
  10be64:	e9 e3 ff ff ff       	jmp    10be4c <_to_float+0x7ec>
		if (*buf != '.') {
  10be69:	8b 45 08             	mov    0x8(%ebp),%eax
  10be6c:	0f be 00             	movsbl (%eax),%eax
  10be6f:	83 f8 2e             	cmp    $0x2e,%eax
  10be72:	0f 84 09 00 00 00    	je     10be81 <_to_float+0x821>
			buf++;
  10be78:	8b 45 08             	mov    0x8(%ebp),%eax
  10be7b:	83 c0 01             	add    $0x1,%eax
  10be7e:	89 45 08             	mov    %eax,0x8(%ebp)
	}
  10be81:	e9 00 00 00 00       	jmp    10be86 <_to_float+0x826>
	if ((c == 'e') || (c == 'E')) {
  10be86:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10be8a:	83 f8 65             	cmp    $0x65,%eax
  10be8d:	0f 84 0d 00 00 00    	je     10bea0 <_to_float+0x840>
  10be93:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10be97:	83 f8 45             	cmp    $0x45,%eax
  10be9a:	0f 85 b3 00 00 00    	jne    10bf53 <_to_float+0x8f3>
		*buf++ = c;
  10bea0:	8a 45 14             	mov    0x14(%ebp),%al
  10bea3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bea6:	89 ca                	mov    %ecx,%edx
  10bea8:	83 c2 01             	add    $0x1,%edx
  10beab:	89 55 08             	mov    %edx,0x8(%ebp)
  10beae:	88 01                	mov    %al,(%ecx)
		if (decexp < 0) {
  10beb0:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  10beb5:	0f 8d 1d 00 00 00    	jge    10bed8 <_to_float+0x878>
  10bebb:	31 c0                	xor    %eax,%eax
			decexp = -decexp;
  10bebd:	2b 44 24 48          	sub    0x48(%esp),%eax
  10bec1:	89 44 24 48          	mov    %eax,0x48(%esp)
			*buf++ = '-';
  10bec5:	8b 45 08             	mov    0x8(%ebp),%eax
  10bec8:	89 c1                	mov    %eax,%ecx
  10beca:	83 c1 01             	add    $0x1,%ecx
  10becd:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bed0:	c6 00 2d             	movb   $0x2d,(%eax)
		} else {
  10bed3:	e9 0e 00 00 00       	jmp    10bee6 <_to_float+0x886>
			*buf++ = '+';
  10bed8:	8b 45 08             	mov    0x8(%ebp),%eax
  10bedb:	89 c1                	mov    %eax,%ecx
  10bedd:	83 c1 01             	add    $0x1,%ecx
  10bee0:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bee3:	c6 00 2b             	movb   $0x2b,(%eax)
		if (decexp >= 100) {
  10bee6:	83 7c 24 48 64       	cmpl   $0x64,0x48(%esp)
  10beeb:	0f 8c 27 00 00 00    	jl     10bf18 <_to_float+0x8b8>
			*buf++ = (decexp / 100) + '0';
  10bef1:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bef5:	99                   	cltd   
  10bef6:	b9 64 00 00 00       	mov    $0x64,%ecx
  10befb:	f7 f9                	idiv   %ecx
  10befd:	83 c0 30             	add    $0x30,%eax
  10bf00:	8b 75 08             	mov    0x8(%ebp),%esi
  10bf03:	89 f7                	mov    %esi,%edi
  10bf05:	83 c7 01             	add    $0x1,%edi
  10bf08:	89 7d 08             	mov    %edi,0x8(%ebp)
  10bf0b:	88 06                	mov    %al,(%esi)
			decexp %= 100;
  10bf0d:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bf11:	99                   	cltd   
  10bf12:	f7 f9                	idiv   %ecx
  10bf14:	89 54 24 48          	mov    %edx,0x48(%esp)
		*buf++ = (decexp / 10) + '0';
  10bf18:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bf1c:	99                   	cltd   
  10bf1d:	b9 0a 00 00 00       	mov    $0xa,%ecx
  10bf22:	f7 f9                	idiv   %ecx
  10bf24:	83 c0 30             	add    $0x30,%eax
  10bf27:	8b 75 08             	mov    0x8(%ebp),%esi
  10bf2a:	89 f7                	mov    %esi,%edi
  10bf2c:	83 c7 01             	add    $0x1,%edi
  10bf2f:	89 7d 08             	mov    %edi,0x8(%ebp)
  10bf32:	88 06                	mov    %al,(%esi)
		decexp %= 10;
  10bf34:	8b 44 24 48          	mov    0x48(%esp),%eax
  10bf38:	99                   	cltd   
  10bf39:	f7 f9                	idiv   %ecx
  10bf3b:	89 54 24 48          	mov    %edx,0x48(%esp)
		*buf++ = decexp + '0';
  10bf3f:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  10bf43:	83 c1 30             	add    $0x30,%ecx
  10bf46:	8b 55 08             	mov    0x8(%ebp),%edx
  10bf49:	89 d6                	mov    %edx,%esi
  10bf4b:	83 c6 01             	add    $0x1,%esi
  10bf4e:	89 75 08             	mov    %esi,0x8(%ebp)
  10bf51:	88 0a                	mov    %cl,(%edx)
	*buf = 0;
  10bf53:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf56:	c6 00 00             	movb   $0x0,(%eax)
	return buf - start;
  10bf59:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf5c:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10bf60:	29 c8                	sub    %ecx,%eax
  10bf62:	89 44 24 58          	mov    %eax,0x58(%esp)
}
  10bf66:	8b 44 24 58          	mov    0x58(%esp),%eax
  10bf6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10bf6d:	5e                   	pop    %esi
  10bf6e:	5f                   	pop    %edi
  10bf6f:	5b                   	pop    %ebx
  10bf70:	5d                   	pop    %ebp
  10bf71:	c3                   	ret    
  10bf72:	66 90                	xchg   %ax,%ax
  10bf74:	66 90                	xchg   %ax,%ax
  10bf76:	66 90                	xchg   %ax,%ax
  10bf78:	66 90                	xchg   %ax,%ax
  10bf7a:	66 90                	xchg   %ax,%ax
  10bf7c:	66 90                	xchg   %ax,%ax
  10bf7e:	66 90                	xchg   %ax,%ax

0010bf80 <_to_hex>:
{
  10bf80:	55                   	push   %ebp
  10bf81:	89 e5                	mov    %esp,%ebp
  10bf83:	57                   	push   %edi
  10bf84:	56                   	push   %esi
  10bf85:	83 ec 18             	sub    $0x18,%esp
  10bf88:	8a 45 14             	mov    0x14(%ebp),%al
  10bf8b:	8a 4d 10             	mov    0x10(%ebp),%cl
  10bf8e:	8b 55 0c             	mov    0xc(%ebp),%edx
  10bf91:	8b 75 08             	mov    0x8(%ebp),%esi
  10bf94:	80 e1 01             	and    $0x1,%cl
  10bf97:	88 4d f7             	mov    %cl,-0x9(%ebp)
	char *buf0 = buf;
  10bf9a:	8b 7d 08             	mov    0x8(%ebp),%edi
  10bf9d:	89 7d ec             	mov    %edi,-0x14(%ebp)
	if (alt_form) {
  10bfa0:	f6 45 f7 01          	testb  $0x1,-0x9(%ebp)
  10bfa4:	0f 84 1c 00 00 00    	je     10bfc6 <_to_hex+0x46>
		*buf++ = '0';
  10bfaa:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfad:	89 c1                	mov    %eax,%ecx
  10bfaf:	83 c1 01             	add    $0x1,%ecx
  10bfb2:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bfb5:	c6 00 30             	movb   $0x30,(%eax)
		*buf++ = 'x';
  10bfb8:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfbb:	89 c1                	mov    %eax,%ecx
  10bfbd:	83 c1 01             	add    $0x1,%ecx
  10bfc0:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bfc3:	c6 00 78             	movb   $0x78,(%eax)
	len = _to_x(buf, value, 16);
  10bfc6:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10bfcc:	89 04 24             	mov    %eax,(%esp)
  10bfcf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10bfd3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  10bfda:	00 
  10bfdb:	e8 70 03 00 00       	call   10c350 <_to_x>
  10bfe0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (prefix == 'X') {
  10bfe3:	0f be 45 14          	movsbl 0x14(%ebp),%eax
  10bfe7:	83 f8 58             	cmp    $0x58,%eax
  10bfea:	0f 85 0b 00 00 00    	jne    10bffb <_to_hex+0x7b>
		_uc(buf0);
  10bff0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10bff3:	89 04 24             	mov    %eax,(%esp)
  10bff6:	e8 35 04 00 00       	call   10c430 <_uc>
	return len + (buf - buf0);
  10bffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10bffe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c001:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10c004:	29 d1                	sub    %edx,%ecx
  10c006:	01 c8                	add    %ecx,%eax
  10c008:	83 c4 18             	add    $0x18,%esp
  10c00b:	5e                   	pop    %esi
  10c00c:	5f                   	pop    %edi
  10c00d:	5d                   	pop    %ebp
  10c00e:	c3                   	ret    
  10c00f:	90                   	nop

0010c010 <_to_octal>:
{
  10c010:	55                   	push   %ebp
  10c011:	89 e5                	mov    %esp,%ebp
  10c013:	56                   	push   %esi
  10c014:	83 ec 1c             	sub    $0x1c,%esp
  10c017:	8a 45 10             	mov    0x10(%ebp),%al
  10c01a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c01d:	8b 55 08             	mov    0x8(%ebp),%edx
  10c020:	24 01                	and    $0x1,%al
  10c022:	88 45 f7             	mov    %al,-0x9(%ebp)
	char *buf0 = buf;
  10c025:	8b 75 08             	mov    0x8(%ebp),%esi
  10c028:	89 75 f0             	mov    %esi,-0x10(%ebp)
	if (alt_form) {
  10c02b:	f6 45 f7 01          	testb  $0x1,-0x9(%ebp)
  10c02f:	0f 84 37 00 00 00    	je     10c06c <_to_octal+0x5c>
		*buf++ = '0';
  10c035:	8b 45 08             	mov    0x8(%ebp),%eax
  10c038:	89 c1                	mov    %eax,%ecx
  10c03a:	83 c1 01             	add    $0x1,%ecx
  10c03d:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10c040:	c6 00 30             	movb   $0x30,(%eax)
		if (!value) {
  10c043:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c047:	0f 85 1a 00 00 00    	jne    10c067 <_to_octal+0x57>
			*buf++ = 0;
  10c04d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c050:	89 c1                	mov    %eax,%ecx
  10c052:	83 c1 01             	add    $0x1,%ecx
  10c055:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10c058:	c6 00 00             	movb   $0x0,(%eax)
			return 1;
  10c05b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  10c062:	e9 32 00 00 00       	jmp    10c099 <_to_octal+0x89>
	}
  10c067:	e9 00 00 00 00       	jmp    10c06c <_to_octal+0x5c>
	return (buf - buf0) + _to_x(buf, value, 8);
  10c06c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c06f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10c072:	29 c8                	sub    %ecx,%eax
  10c074:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c077:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c07a:	89 0c 24             	mov    %ecx,(%esp)
  10c07d:	89 54 24 04          	mov    %edx,0x4(%esp)
  10c081:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10c088:	00 
  10c089:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c08c:	e8 bf 02 00 00       	call   10c350 <_to_x>
  10c091:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10c094:	01 c1                	add    %eax,%ecx
  10c096:	89 4d f8             	mov    %ecx,-0x8(%ebp)
}
  10c099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c09c:	83 c4 1c             	add    $0x1c,%esp
  10c09f:	5e                   	pop    %esi
  10c0a0:	5d                   	pop    %ebp
  10c0a1:	c3                   	ret    
  10c0a2:	66 90                	xchg   %ax,%ax
  10c0a4:	66 90                	xchg   %ax,%ax
  10c0a6:	66 90                	xchg   %ax,%ax
  10c0a8:	66 90                	xchg   %ax,%ax
  10c0aa:	66 90                	xchg   %ax,%ax
  10c0ac:	66 90                	xchg   %ax,%ax
  10c0ae:	66 90                	xchg   %ax,%ax

0010c0b0 <_to_udec>:
{
  10c0b0:	55                   	push   %ebp
  10c0b1:	89 e5                	mov    %esp,%ebp
  10c0b3:	56                   	push   %esi
  10c0b4:	83 ec 14             	sub    $0x14,%esp
  10c0b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c0ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return _to_x(buf, value, 10);
  10c0bd:	8b 55 08             	mov    0x8(%ebp),%edx
  10c0c0:	8b 75 0c             	mov    0xc(%ebp),%esi
  10c0c3:	89 14 24             	mov    %edx,(%esp)
  10c0c6:	89 74 24 04          	mov    %esi,0x4(%esp)
  10c0ca:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  10c0d1:	00 
  10c0d2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10c0d5:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10c0d8:	e8 73 02 00 00       	call   10c350 <_to_x>
  10c0dd:	83 c4 14             	add    $0x14,%esp
  10c0e0:	5e                   	pop    %esi
  10c0e1:	5d                   	pop    %ebp
  10c0e2:	c3                   	ret    
  10c0e3:	66 90                	xchg   %ax,%ax
  10c0e5:	66 90                	xchg   %ax,%ax
  10c0e7:	66 90                	xchg   %ax,%ax
  10c0e9:	66 90                	xchg   %ax,%ax
  10c0eb:	66 90                	xchg   %ax,%ax
  10c0ed:	66 90                	xchg   %ax,%ax
  10c0ef:	90                   	nop

0010c0f0 <isupper>:
{
  10c0f0:	55                   	push   %ebp
  10c0f1:	89 e5                	mov    %esp,%ebp
  10c0f3:	50                   	push   %eax
  10c0f4:	8b 45 08             	mov    0x8(%ebp),%eax
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  10c0f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c0fa:	83 e9 41             	sub    $0x41,%ecx
  10c0fd:	83 f9 1a             	cmp    $0x1a,%ecx
  10c100:	0f 92 c2             	setb   %dl
  10c103:	80 e2 01             	and    $0x1,%dl
  10c106:	0f b6 ca             	movzbl %dl,%ecx
  10c109:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c10c:	89 c8                	mov    %ecx,%eax
  10c10e:	83 c4 04             	add    $0x4,%esp
  10c111:	5d                   	pop    %ebp
  10c112:	c3                   	ret    
  10c113:	66 90                	xchg   %ax,%ax
  10c115:	66 90                	xchg   %ax,%ax
  10c117:	66 90                	xchg   %ax,%ax
  10c119:	66 90                	xchg   %ax,%ax
  10c11b:	66 90                	xchg   %ax,%ax
  10c11d:	66 90                	xchg   %ax,%ax
  10c11f:	90                   	nop

0010c120 <_rlrshift>:
{
  10c120:	55                   	push   %ebp
  10c121:	89 e5                	mov    %esp,%ebp
  10c123:	53                   	push   %ebx
  10c124:	57                   	push   %edi
  10c125:	56                   	push   %esi
  10c126:	8b 45 08             	mov    0x8(%ebp),%eax
	*v = (*v & 1) + (*v >> 1);
  10c129:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c12c:	8b 11                	mov    (%ecx),%edx
  10c12e:	8b 71 04             	mov    0x4(%ecx),%esi
  10c131:	89 d7                	mov    %edx,%edi
  10c133:	83 e7 01             	and    $0x1,%edi
  10c136:	89 f3                	mov    %esi,%ebx
  10c138:	d1 eb                	shr    %ebx
  10c13a:	0f a4 d6 1f          	shld   $0x1f,%edx,%esi
  10c13e:	01 f7                	add    %esi,%edi
  10c140:	83 d3 00             	adc    $0x0,%ebx
  10c143:	89 39                	mov    %edi,(%ecx)
  10c145:	89 59 04             	mov    %ebx,0x4(%ecx)
}
  10c148:	5e                   	pop    %esi
  10c149:	5f                   	pop    %edi
  10c14a:	5b                   	pop    %ebx
  10c14b:	5d                   	pop    %ebp
  10c14c:	c3                   	ret    
  10c14d:	66 90                	xchg   %ax,%ax
  10c14f:	90                   	nop

0010c150 <_ldiv5>:
{
  10c150:	55                   	push   %ebp
  10c151:	89 e5                	mov    %esp,%ebp
  10c153:	53                   	push   %ebx
  10c154:	57                   	push   %edi
  10c155:	56                   	push   %esi
  10c156:	83 e4 f8             	and    $0xfffffff8,%esp
  10c159:	83 ec 40             	sub    $0x40,%esp
  10c15c:	8b 45 08             	mov    0x8(%ebp),%eax
	uint64_t rem = *v, quot = 0U, q;
  10c15f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c162:	8b 11                	mov    (%ecx),%edx
  10c164:	8b 49 04             	mov    0x4(%ecx),%ecx
  10c167:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  10c16b:	89 54 24 30          	mov    %edx,0x30(%esp)
  10c16f:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  10c176:	00 
  10c177:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  10c17e:	00 
	rem += 2U;
  10c17f:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  10c183:	83 c1 02             	add    $0x2,%ecx
  10c186:	83 54 24 34 00       	adcl   $0x0,0x34(%esp)
  10c18b:	89 4c 24 30          	mov    %ecx,0x30(%esp)
	for (i = 0; i < 3; i++) {
  10c18f:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  10c196:	00 
  10c197:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
  10c19c:	0f 8d f9 00 00 00    	jge    10c29b <_ldiv5+0x14b>
		hi = rem >> shifts[i];
  10c1a2:	8b 44 24 30          	mov    0x30(%esp),%eax
  10c1a6:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10c1aa:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  10c1ae:	8a 9a 09 3b 12 00    	mov    0x123b09(%edx),%bl
  10c1b4:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  10c1b8:	88 d9                	mov    %bl,%cl
  10c1ba:	8b 54 24 18          	mov    0x18(%esp),%edx
  10c1be:	d3 ea                	shr    %cl,%edx
  10c1c0:	88 d9                	mov    %bl,%cl
  10c1c2:	8b 74 24 18          	mov    0x18(%esp),%esi
  10c1c6:	0f ad f0             	shrd   %cl,%esi,%eax
  10c1c9:	f6 c3 20             	test   $0x20,%bl
  10c1cc:	89 44 24 14          	mov    %eax,0x14(%esp)
  10c1d0:	89 54 24 10          	mov    %edx,0x10(%esp)
  10c1d4:	0f 85 08 00 00 00    	jne    10c1e2 <_ldiv5+0x92>
  10c1da:	8b 44 24 14          	mov    0x14(%esp),%eax
  10c1de:	89 44 24 10          	mov    %eax,0x10(%esp)
  10c1e2:	8b 44 24 10          	mov    0x10(%esp),%eax
  10c1e6:	89 44 24 38          	mov    %eax,0x38(%esp)
		q = (uint64_t)(hi / 5U) << shifts[i];
  10c1ea:	8b 44 24 38          	mov    0x38(%esp),%eax
  10c1ee:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  10c1f3:	f7 e1                	mul    %ecx
  10c1f5:	c1 ea 02             	shr    $0x2,%edx
  10c1f8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10c1fc:	8a 98 09 3b 12 00    	mov    0x123b09(%eax),%bl
  10c202:	31 c0                	xor    %eax,%eax
  10c204:	88 d9                	mov    %bl,%cl
  10c206:	89 c6                	mov    %eax,%esi
  10c208:	0f a5 d6             	shld   %cl,%edx,%esi
  10c20b:	88 d9                	mov    %bl,%cl
  10c20d:	d3 e2                	shl    %cl,%edx
  10c20f:	f6 c3 20             	test   $0x20,%bl
  10c212:	89 d7                	mov    %edx,%edi
  10c214:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10c218:	89 54 24 08          	mov    %edx,0x8(%esp)
  10c21c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  10c220:	89 04 24             	mov    %eax,(%esp)
  10c223:	0f 85 0f 00 00 00    	jne    10c238 <_ldiv5+0xe8>
  10c229:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10c22d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  10c231:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c235:	89 0c 24             	mov    %ecx,(%esp)
  10c238:	8b 04 24             	mov    (%esp),%eax
  10c23b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  10c23f:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  10c243:	89 44 24 20          	mov    %eax,0x20(%esp)
		rem -= q * 5U;
  10c247:	8b 44 24 20          	mov    0x20(%esp),%eax
  10c24b:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10c24f:	ba 05 00 00 00       	mov    $0x5,%edx
  10c254:	f7 e2                	mul    %edx
  10c256:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  10c259:	01 ca                	add    %ecx,%edx
  10c25b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  10c25f:	8b 74 24 34          	mov    0x34(%esp),%esi
  10c263:	29 c1                	sub    %eax,%ecx
  10c265:	19 d6                	sbb    %edx,%esi
  10c267:	89 4c 24 30          	mov    %ecx,0x30(%esp)
  10c26b:	89 74 24 34          	mov    %esi,0x34(%esp)
		quot += q;
  10c26f:	8b 44 24 20          	mov    0x20(%esp),%eax
  10c273:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10c277:	8b 54 24 28          	mov    0x28(%esp),%edx
  10c27b:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  10c27f:	01 c2                	add    %eax,%edx
  10c281:	11 ce                	adc    %ecx,%esi
  10c283:	89 54 24 28          	mov    %edx,0x28(%esp)
  10c287:	89 74 24 2c          	mov    %esi,0x2c(%esp)
	for (i = 0; i < 3; i++) {
  10c28b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10c28f:	83 c0 01             	add    $0x1,%eax
  10c292:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10c296:	e9 fc fe ff ff       	jmp    10c197 <_ldiv5+0x47>
	*v = quot;
  10c29b:	8b 44 24 28          	mov    0x28(%esp),%eax
  10c29f:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  10c2a3:	8b 55 08             	mov    0x8(%ebp),%edx
  10c2a6:	89 4a 04             	mov    %ecx,0x4(%edx)
  10c2a9:	89 02                	mov    %eax,(%edx)
}
  10c2ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c2ae:	5e                   	pop    %esi
  10c2af:	5f                   	pop    %edi
  10c2b0:	5b                   	pop    %ebx
  10c2b1:	5d                   	pop    %ebp
  10c2b2:	c3                   	ret    
  10c2b3:	66 90                	xchg   %ax,%ax
  10c2b5:	66 90                	xchg   %ax,%ax
  10c2b7:	66 90                	xchg   %ax,%ax
  10c2b9:	66 90                	xchg   %ax,%ax
  10c2bb:	66 90                	xchg   %ax,%ax
  10c2bd:	66 90                	xchg   %ax,%ax
  10c2bf:	90                   	nop

0010c2c0 <_get_digit>:
{
  10c2c0:	55                   	push   %ebp
  10c2c1:	89 e5                	mov    %esp,%ebp
  10c2c3:	53                   	push   %ebx
  10c2c4:	57                   	push   %edi
  10c2c5:	56                   	push   %esi
  10c2c6:	83 ec 0c             	sub    $0xc,%esp
  10c2c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c2cc:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (*digit_count > 0) {
  10c2cf:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c2d2:	83 3a 00             	cmpl   $0x0,(%edx)
  10c2d5:	0f 8e 56 00 00 00    	jle    10c331 <_get_digit+0x71>
		*digit_count -= 1;
  10c2db:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c2de:	8b 08                	mov    (%eax),%ecx
  10c2e0:	49                   	dec    %ecx
  10c2e1:	89 08                	mov    %ecx,(%eax)
		*fr = *fr * 10U;
  10c2e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c2e6:	8b 08                	mov    (%eax),%ecx
  10c2e8:	8b 50 04             	mov    0x4(%eax),%edx
  10c2eb:	be 0a 00 00 00       	mov    $0xa,%esi
  10c2f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c2f3:	89 c8                	mov    %ecx,%eax
  10c2f5:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10c2f8:	f7 e6                	mul    %esi
  10c2fa:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10c2fd:	8d 34 89             	lea    (%ecx,%ecx,4),%esi
  10c300:	8d 14 72             	lea    (%edx,%esi,2),%edx
  10c303:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10c306:	89 06                	mov    %eax,(%esi)
  10c308:	89 56 04             	mov    %edx,0x4(%esi)
		rval = ((*fr >> 60) & 0xF) + '0';
  10c30b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c30e:	8b 40 04             	mov    0x4(%eax),%eax
  10c311:	c1 e8 1c             	shr    $0x1c,%eax
  10c314:	0c 30                	or     $0x30,%al
  10c316:	88 45 f3             	mov    %al,-0xd(%ebp)
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  10c319:	8b 55 08             	mov    0x8(%ebp),%edx
  10c31c:	8b 3a                	mov    (%edx),%edi
  10c31e:	8b 5a 04             	mov    0x4(%edx),%ebx
  10c321:	81 e3 ff ff ff 0f    	and    $0xfffffff,%ebx
  10c327:	89 3a                	mov    %edi,(%edx)
  10c329:	89 5a 04             	mov    %ebx,0x4(%edx)
	} else {
  10c32c:	e9 04 00 00 00       	jmp    10c335 <_get_digit+0x75>
		rval = '0';
  10c331:	c6 45 f3 30          	movb   $0x30,-0xd(%ebp)
	return rval;
  10c335:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
  10c339:	83 c4 0c             	add    $0xc,%esp
  10c33c:	5e                   	pop    %esi
  10c33d:	5f                   	pop    %edi
  10c33e:	5b                   	pop    %ebx
  10c33f:	5d                   	pop    %ebp
  10c340:	c3                   	ret    
  10c341:	66 90                	xchg   %ax,%ax
  10c343:	66 90                	xchg   %ax,%ax
  10c345:	66 90                	xchg   %ax,%ax
  10c347:	66 90                	xchg   %ax,%ax
  10c349:	66 90                	xchg   %ax,%ax
  10c34b:	66 90                	xchg   %ax,%ax
  10c34d:	66 90                	xchg   %ax,%ax
  10c34f:	90                   	nop

0010c350 <_to_x>:
{
  10c350:	55                   	push   %ebp
  10c351:	89 e5                	mov    %esp,%ebp
  10c353:	56                   	push   %esi
  10c354:	83 ec 1c             	sub    $0x1c,%esp
  10c357:	8b 45 10             	mov    0x10(%ebp),%eax
  10c35a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c35d:	8b 55 08             	mov    0x8(%ebp),%edx
	char *start = buf;
  10c360:	8b 75 08             	mov    0x8(%ebp),%esi
  10c363:	89 75 f8             	mov    %esi,-0x8(%ebp)
  10c366:	31 c0                	xor    %eax,%eax
		unsigned int d = n % base;
  10c368:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c36b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10c36e:	89 c8                	mov    %ecx,%eax
  10c370:	31 d2                	xor    %edx,%edx
  10c372:	f7 75 10             	divl   0x10(%ebp)
  10c375:	89 55 f0             	mov    %edx,-0x10(%ebp)
		n /= base;
  10c378:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10c37b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c37e:	89 d0                	mov    %edx,%eax
  10c380:	31 d2                	xor    %edx,%edx
  10c382:	f7 f1                	div    %ecx
  10c384:	89 45 0c             	mov    %eax,0xc(%ebp)
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  10c387:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10c38a:	83 c0 30             	add    $0x30,%eax
  10c38d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10c390:	83 f9 09             	cmp    $0x9,%ecx
  10c393:	b9 27 00 00 00       	mov    $0x27,%ecx
  10c398:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10c39b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10c39e:	0f 87 06 00 00 00    	ja     10c3aa <_to_x+0x5a>
  10c3a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10c3a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10c3aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10c3ad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10c3b0:	01 c1                	add    %eax,%ecx
  10c3b2:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3b5:	89 c2                	mov    %eax,%edx
  10c3b7:	83 c2 01             	add    $0x1,%edx
  10c3ba:	89 55 08             	mov    %edx,0x8(%ebp)
  10c3bd:	88 08                	mov    %cl,(%eax)
	} while (n);
  10c3bf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c3c3:	0f 85 9d ff ff ff    	jne    10c366 <_to_x+0x16>
	*buf = 0;
  10c3c9:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3cc:	c6 00 00             	movb   $0x0,(%eax)
	len = buf - start;
  10c3cf:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3d2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10c3d5:	29 c8                	sub    %ecx,%eax
  10c3d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for (buf--; buf > start; buf--, start++) {
  10c3da:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3dd:	83 c0 ff             	add    $0xffffffff,%eax
  10c3e0:	89 45 08             	mov    %eax,0x8(%ebp)
  10c3e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3e6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10c3e9:	0f 86 31 00 00 00    	jbe    10c420 <_to_x+0xd0>
		char tmp = *buf;
  10c3ef:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3f2:	8a 08                	mov    (%eax),%cl
  10c3f4:	88 4d ef             	mov    %cl,-0x11(%ebp)
		*buf = *start;
  10c3f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c3fa:	8a 08                	mov    (%eax),%cl
  10c3fc:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3ff:	88 08                	mov    %cl,(%eax)
		*start = tmp;
  10c401:	8a 4d ef             	mov    -0x11(%ebp),%cl
  10c404:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c407:	88 08                	mov    %cl,(%eax)
	for (buf--; buf > start; buf--, start++) {
  10c409:	8b 45 08             	mov    0x8(%ebp),%eax
  10c40c:	83 c0 ff             	add    $0xffffffff,%eax
  10c40f:	89 45 08             	mov    %eax,0x8(%ebp)
  10c412:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c415:	83 c0 01             	add    $0x1,%eax
  10c418:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10c41b:	e9 c3 ff ff ff       	jmp    10c3e3 <_to_x+0x93>
	return len;
  10c420:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10c423:	83 c4 1c             	add    $0x1c,%esp
  10c426:	5e                   	pop    %esi
  10c427:	5d                   	pop    %ebp
  10c428:	c3                   	ret    
  10c429:	66 90                	xchg   %ax,%ax
  10c42b:	66 90                	xchg   %ax,%ax
  10c42d:	66 90                	xchg   %ax,%ax
  10c42f:	90                   	nop

0010c430 <_uc>:
{
  10c430:	55                   	push   %ebp
  10c431:	89 e5                	mov    %esp,%ebp
  10c433:	8b 45 08             	mov    0x8(%ebp),%eax
		if (*buf >= 'a' && *buf <= 'z') {
  10c436:	8b 45 08             	mov    0x8(%ebp),%eax
  10c439:	0f be 00             	movsbl (%eax),%eax
  10c43c:	83 f8 61             	cmp    $0x61,%eax
  10c43f:	0f 8c 1a 00 00 00    	jl     10c45f <_uc+0x2f>
  10c445:	8b 45 08             	mov    0x8(%ebp),%eax
  10c448:	0f be 00             	movsbl (%eax),%eax
  10c44b:	83 f8 7a             	cmp    $0x7a,%eax
  10c44e:	0f 8f 0b 00 00 00    	jg     10c45f <_uc+0x2f>
			*buf += 'A' - 'a';
  10c454:	8b 45 08             	mov    0x8(%ebp),%eax
  10c457:	0f be 08             	movsbl (%eax),%ecx
  10c45a:	83 c1 e0             	add    $0xffffffe0,%ecx
  10c45d:	88 08                	mov    %cl,(%eax)
	} while (*buf++);
  10c45f:	e9 00 00 00 00       	jmp    10c464 <_uc+0x34>
  10c464:	8b 45 08             	mov    0x8(%ebp),%eax
  10c467:	89 c1                	mov    %eax,%ecx
  10c469:	83 c1 01             	add    $0x1,%ecx
  10c46c:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10c46f:	80 38 00             	cmpb   $0x0,(%eax)
  10c472:	0f 85 be ff ff ff    	jne    10c436 <_uc+0x6>
}
  10c478:	5d                   	pop    %ebp
  10c479:	c3                   	ret    
  10c47a:	66 90                	xchg   %ax,%ax
  10c47c:	66 90                	xchg   %ax,%ax
  10c47e:	66 90                	xchg   %ax,%ax

0010c480 <__stdout_hook_install>:
}

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
  10c480:	55                   	push   %ebp
  10c481:	89 e5                	mov    %esp,%ebp
  10c483:	8b 45 08             	mov    0x8(%ebp),%eax
	_stdout_hook = hook;
  10c486:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c489:	89 0d 20 30 14 00    	mov    %ecx,0x143020
}
  10c48f:	5d                   	pop    %ebp
  10c490:	c3                   	ret    
  10c491:	66 90                	xchg   %ax,%ax
  10c493:	66 90                	xchg   %ax,%ax
  10c495:	66 90                	xchg   %ax,%ax
  10c497:	66 90                	xchg   %ax,%ax
  10c499:	66 90                	xchg   %ax,%ax
  10c49b:	66 90                	xchg   %ax,%ax
  10c49d:	66 90                	xchg   %ax,%ax
  10c49f:	90                   	nop

0010c4a0 <_stdout_hook_default>:
{
  10c4a0:	55                   	push   %ebp
  10c4a1:	89 e5                	mov    %esp,%ebp
  10c4a3:	50                   	push   %eax
  10c4a4:	8b 45 08             	mov    0x8(%ebp),%eax
	return EOF;
  10c4a7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  10c4ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c4af:	89 c8                	mov    %ecx,%eax
  10c4b1:	83 c4 04             	add    $0x4,%esp
  10c4b4:	5d                   	pop    %ebp
  10c4b5:	c3                   	ret    
  10c4b6:	66 90                	xchg   %ax,%ax
  10c4b8:	66 90                	xchg   %ax,%ax
  10c4ba:	66 90                	xchg   %ax,%ax
  10c4bc:	66 90                	xchg   %ax,%ax
  10c4be:	66 90                	xchg   %ax,%ax

0010c4c0 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
  10c4c0:	55                   	push   %ebp
  10c4c1:	89 e5                	mov    %esp,%ebp
  10c4c3:	83 e4 f8             	and    $0xfffffff8,%esp
  10c4c6:	83 ec 28             	sub    $0x28,%esp
  10c4c9:	8b 45 10             	mov    0x10(%ebp),%eax
  10c4cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c4cf:	8b 55 08             	mov    0x8(%ebp),%edx

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
  10c4d2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c4d6:	0f 85 07 00 00 00    	jne    10c4e3 <snprintf+0x23>
		s = &dummy; /* write final NUL to dummy, can't change *s */
  10c4dc:	8d 44 24 13          	lea    0x13(%esp),%eax
  10c4e0:	89 45 08             	mov    %eax,0x8(%ebp)
	}

	p.ptr = s;
  10c4e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c4e6:	89 44 24 18          	mov    %eax,0x18(%esp)
	p.len = (int) len;
  10c4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c4ed:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10c4f1:	8d 45 14             	lea    0x14(%ebp),%eax

	va_start(vargs, format);
  10c4f4:	89 44 24 24          	mov    %eax,0x24(%esp)
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  10c4f8:	8b 45 10             	mov    0x10(%ebp),%eax
  10c4fb:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10c4ff:	89 e2                	mov    %esp,%edx
  10c501:	89 4a 0c             	mov    %ecx,0xc(%edx)
  10c504:	89 42 08             	mov    %eax,0x8(%edx)
  10c507:	8d 44 24 18          	lea    0x18(%esp),%eax
  10c50b:	89 42 04             	mov    %eax,0x4(%edx)
  10c50e:	c7 02 30 c5 10 00    	movl   $0x10c530,(%edx)
  10c514:	e8 47 e0 ff ff       	call   10a560 <z_prf>
  10c519:	89 44 24 14          	mov    %eax,0x14(%esp)
	va_end(vargs);

	*(p.ptr) = 0;
  10c51d:	8b 44 24 18          	mov    0x18(%esp),%eax
  10c521:	c6 00 00             	movb   $0x0,(%eax)
	return r;
  10c524:	8b 44 24 14          	mov    0x14(%esp),%eax
  10c528:	89 ec                	mov    %ebp,%esp
  10c52a:	5d                   	pop    %ebp
  10c52b:	c3                   	ret    
  10c52c:	66 90                	xchg   %ax,%ax
  10c52e:	66 90                	xchg   %ax,%ax

0010c530 <sprintf_out>:
{
  10c530:	55                   	push   %ebp
  10c531:	89 e5                	mov    %esp,%ebp
  10c533:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c536:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (p->len > 1) { /* need to reserve a byte for EOS */
  10c539:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c53c:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
  10c540:	0f 8e 20 00 00 00    	jle    10c566 <sprintf_out+0x36>
		*(p->ptr) = c;
  10c546:	8b 45 08             	mov    0x8(%ebp),%eax
  10c549:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c54c:	8b 09                	mov    (%ecx),%ecx
  10c54e:	88 01                	mov    %al,(%ecx)
		p->ptr += 1;
  10c550:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c553:	8b 11                	mov    (%ecx),%edx
  10c555:	83 c2 01             	add    $0x1,%edx
  10c558:	89 11                	mov    %edx,(%ecx)
		p->len -= 1;
  10c55a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c55d:	8b 51 04             	mov    0x4(%ecx),%edx
  10c560:	83 ea 01             	sub    $0x1,%edx
  10c563:	89 51 04             	mov    %edx,0x4(%ecx)
  10c566:	31 c0                	xor    %eax,%eax
	return 0; /* indicate keep going so we get the total count */
  10c568:	5d                   	pop    %ebp
  10c569:	c3                   	ret    
  10c56a:	66 90                	xchg   %ax,%ax
  10c56c:	66 90                	xchg   %ax,%ax
  10c56e:	66 90                	xchg   %ax,%ax

0010c570 <sprintf>:
}

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
  10c570:	55                   	push   %ebp
  10c571:	89 e5                	mov    %esp,%ebp
  10c573:	57                   	push   %edi
  10c574:	56                   	push   %esi
  10c575:	83 e4 f8             	and    $0xfffffff8,%esp
  10c578:	83 ec 30             	sub    $0x30,%esp
  10c57b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c57e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	va_list vargs;

	struct emitter p;
	int     r;

	p.ptr = s;
  10c581:	8b 55 08             	mov    0x8(%ebp),%edx
  10c584:	89 54 24 20          	mov    %edx,0x20(%esp)
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
  10c588:	c7 44 24 24 ff ff ff 	movl   $0x7fffffff,0x24(%esp)
  10c58f:	7f 
  10c590:	8d 55 10             	lea    0x10(%ebp),%edx

	va_start(vargs, format);
  10c593:	89 54 24 2c          	mov    %edx,0x2c(%esp)
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  10c597:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c59a:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  10c59e:	89 e7                	mov    %esp,%edi
  10c5a0:	89 77 0c             	mov    %esi,0xc(%edi)
  10c5a3:	89 57 08             	mov    %edx,0x8(%edi)
  10c5a6:	8d 54 24 20          	lea    0x20(%esp),%edx
  10c5aa:	89 57 04             	mov    %edx,0x4(%edi)
  10c5ad:	c7 07 30 c5 10 00    	movl   $0x10c530,(%edi)
  10c5b3:	89 44 24 18          	mov    %eax,0x18(%esp)
  10c5b7:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10c5bb:	e8 a0 df ff ff       	call   10a560 <z_prf>
  10c5c0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	va_end(vargs);

	*(p.ptr) = 0;
  10c5c4:	8b 44 24 20          	mov    0x20(%esp),%eax
  10c5c8:	c6 00 00             	movb   $0x0,(%eax)
	return r;
  10c5cb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10c5cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10c5d2:	5e                   	pop    %esi
  10c5d3:	5f                   	pop    %edi
  10c5d4:	5d                   	pop    %ebp
  10c5d5:	c3                   	ret    
  10c5d6:	66 90                	xchg   %ax,%ax
  10c5d8:	66 90                	xchg   %ax,%ax
  10c5da:	66 90                	xchg   %ax,%ax
  10c5dc:	66 90                	xchg   %ax,%ax
  10c5de:	66 90                	xchg   %ax,%ax

0010c5e0 <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
  10c5e0:	55                   	push   %ebp
  10c5e1:	89 e5                	mov    %esp,%ebp
  10c5e3:	56                   	push   %esi
  10c5e4:	83 e4 f8             	and    $0xfffffff8,%esp
  10c5e7:	83 ec 30             	sub    $0x30,%esp
  10c5ea:	8b 45 08             	mov    0x8(%ebp),%eax
	int err = 0;
  10c5ed:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  10c5f4:	00 
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10c5f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c5f8:	8b 49 20             	mov    0x20(%ecx),%ecx
  10c5fb:	89 4c 24 24          	mov    %ecx,0x24(%esp)
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
  10c5ff:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10c603:	89 e2                	mov    %esp,%edx
  10c605:	8d 74 24 10          	lea    0x10(%esp),%esi
  10c609:	89 72 04             	mov    %esi,0x4(%edx)
  10c60c:	89 0a                	mov    %ecx,(%edx)
  10c60e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10c612:	e8 f9 00 00 00       	call   10c710 <display_get_capabilities>

	switch (cap.current_pixel_format) {
  10c617:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10c61b:	48                   	dec    %eax
  10c61c:	89 c1                	mov    %eax,%ecx
  10c61e:	83 e9 0f             	sub    $0xf,%ecx
  10c621:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c625:	0f 87 a9 00 00 00    	ja     10c6d4 <set_lvgl_rendering_cb+0xf4>
  10c62b:	8b 44 24 08          	mov    0x8(%esp),%eax
  10c62f:	8b 0c 85 44 35 12 00 	mov    0x123544(,%eax,4),%ecx
  10c636:	ff e1                	jmp    *%ecx
	case PIXEL_FORMAT_ARGB_8888:
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
  10c638:	8b 45 08             	mov    0x8(%ebp),%eax
  10c63b:	8d 0d b0 d1 10 00    	lea    0x10d1b0,%ecx
  10c641:	89 48 0c             	mov    %ecx,0xc(%eax)
		disp_drv->rounder_cb = NULL;
  10c644:	8b 45 08             	mov    0x8(%ebp),%eax
  10c647:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
#ifdef CONFIG_LVGL_COLOR_DEPTH_32
		disp_drv->set_px_cb = NULL;
  10c64e:	8b 45 08             	mov    0x8(%ebp),%eax
  10c651:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
#else
		disp_drv->set_px_cb = lvgl_set_px_cb_32bit;
#endif
		break;
  10c658:	e9 9d 00 00 00       	jmp    10c6fa <set_lvgl_rendering_cb+0x11a>
	case PIXEL_FORMAT_RGB_888:
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
  10c65d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c660:	8d 0d 50 ce 10 00    	lea    0x10ce50,%ecx
  10c666:	89 48 0c             	mov    %ecx,0xc(%eax)
		disp_drv->rounder_cb = NULL;
  10c669:	8b 45 08             	mov    0x8(%ebp),%eax
  10c66c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
  10c673:	8b 45 08             	mov    0x8(%ebp),%eax
  10c676:	8d 0d c0 cf 10 00    	lea    0x10cfc0,%ecx
  10c67c:	89 48 14             	mov    %ecx,0x14(%eax)
		break;
  10c67f:	e9 76 00 00 00       	jmp    10c6fa <set_lvgl_rendering_cb+0x11a>
	case PIXEL_FORMAT_RGB_565:
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
  10c684:	8b 45 08             	mov    0x8(%ebp),%eax
  10c687:	8d 0d e0 cb 10 00    	lea    0x10cbe0,%ecx
  10c68d:	89 48 0c             	mov    %ecx,0xc(%eax)
		disp_drv->rounder_cb = NULL;
  10c690:	8b 45 08             	mov    0x8(%ebp),%eax
  10c693:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
#ifdef CONFIG_LVGL_COLOR_DEPTH_16
		disp_drv->set_px_cb = NULL;
#else
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
  10c69a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c69d:	8d 0d 50 cd 10 00    	lea    0x10cd50,%ecx
  10c6a3:	89 48 14             	mov    %ecx,0x14(%eax)
#endif
		break;
  10c6a6:	e9 4f 00 00 00       	jmp    10c6fa <set_lvgl_rendering_cb+0x11a>
	case PIXEL_FORMAT_MONO01:
	case PIXEL_FORMAT_MONO10:
		disp_drv->flush_cb = lvgl_flush_cb_mono;
  10c6ab:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6ae:	8d 0d 50 c7 10 00    	lea    0x10c750,%ecx
  10c6b4:	89 48 0c             	mov    %ecx,0xc(%eax)
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
  10c6b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6ba:	8d 0d 50 cb 10 00    	lea    0x10cb50,%ecx
  10c6c0:	89 48 10             	mov    %ecx,0x10(%eax)
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
  10c6c3:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6c6:	8d 0d 50 c9 10 00    	lea    0x10c950,%ecx
  10c6cc:	89 48 14             	mov    %ecx,0x14(%eax)
		break;
  10c6cf:	e9 26 00 00 00       	jmp    10c6fa <set_lvgl_rendering_cb+0x11a>
	default:
		disp_drv->flush_cb = NULL;
  10c6d4:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6d7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
		disp_drv->rounder_cb = NULL;
  10c6de:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6e1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		disp_drv->set_px_cb = NULL;
  10c6e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c6eb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
		err = -ENOTSUP;
  10c6f2:	c7 44 24 28 dd ff ff 	movl   $0xffffffdd,0x28(%esp)
  10c6f9:	ff 
		break;

	}

	return err;
  10c6fa:	8b 44 24 28          	mov    0x28(%esp),%eax
  10c6fe:	8d 65 fc             	lea    -0x4(%ebp),%esp
  10c701:	5e                   	pop    %esi
  10c702:	5d                   	pop    %ebp
  10c703:	c3                   	ret    
  10c704:	66 90                	xchg   %ax,%ax
  10c706:	66 90                	xchg   %ax,%ax
  10c708:	66 90                	xchg   %ax,%ax
  10c70a:	66 90                	xchg   %ax,%ax
  10c70c:	66 90                	xchg   %ax,%ax
  10c70e:	66 90                	xchg   %ax,%ax

0010c710 <display_get_capabilities>:
 * @param capabilities Pointer to capabilities structure to populate
 */
static inline void display_get_capabilities(const struct device *dev,
					    struct display_capabilities *
					    capabilities)
{
  10c710:	55                   	push   %ebp
  10c711:	89 e5                	mov    %esp,%ebp
  10c713:	57                   	push   %edi
  10c714:	56                   	push   %esi
  10c715:	83 ec 14             	sub    $0x14,%esp
  10c718:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c71b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct display_driver_api *api =
		(struct display_driver_api *)dev->driver_api;
  10c71e:	8b 55 08             	mov    0x8(%ebp),%edx
  10c721:	8b 52 04             	mov    0x4(%edx),%edx
	struct display_driver_api *api =
  10c724:	89 55 f4             	mov    %edx,-0xc(%ebp)

	api->get_capabilities(dev, capabilities);
  10c727:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10c72a:	8b 52 1c             	mov    0x1c(%edx),%edx
  10c72d:	8b 75 08             	mov    0x8(%ebp),%esi
  10c730:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10c733:	89 34 24             	mov    %esi,(%esp)
  10c736:	89 7c 24 04          	mov    %edi,0x4(%esp)
  10c73a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10c73d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10c740:	ff d2                	call   *%edx
}
  10c742:	83 c4 14             	add    $0x14,%esp
  10c745:	5e                   	pop    %esi
  10c746:	5f                   	pop    %edi
  10c747:	5d                   	pop    %ebp
  10c748:	c3                   	ret    
  10c749:	66 90                	xchg   %ax,%ax
  10c74b:	66 90                	xchg   %ax,%ax
  10c74d:	66 90                	xchg   %ax,%ax
  10c74f:	90                   	nop

0010c750 <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
  10c750:	55                   	push   %ebp
  10c751:	89 e5                	mov    %esp,%ebp
  10c753:	53                   	push   %ebx
  10c754:	57                   	push   %edi
  10c755:	56                   	push   %esi
  10c756:	83 e4 f8             	and    $0xfffffff8,%esp
  10c759:	83 ec 50             	sub    $0x50,%esp
  10c75c:	8b 45 10             	mov    0x10(%ebp),%eax
  10c75f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c762:	8b 55 08             	mov    0x8(%ebp),%edx
	u16_t w = area->x2 - area->x1 + 1;
  10c765:	8b 75 0c             	mov    0xc(%ebp),%esi
  10c768:	0f bf 76 04          	movswl 0x4(%esi),%esi
  10c76c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10c76f:	0f bf 3f             	movswl (%edi),%edi
  10c772:	29 fe                	sub    %edi,%esi
  10c774:	83 c6 01             	add    $0x1,%esi
  10c777:	66 89 74 24 4a       	mov    %si,0x4a(%esp)
	u16_t h = area->y2 - area->y1 + 1;
  10c77c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10c77f:	0f bf 7f 06          	movswl 0x6(%edi),%edi
  10c783:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10c786:	0f bf 5b 02          	movswl 0x2(%ebx),%ebx
  10c78a:	29 df                	sub    %ebx,%edi
  10c78c:	83 c7 01             	add    $0x1,%edi
  10c78f:	66 89 7c 24 48       	mov    %di,0x48(%esp)
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10c794:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10c797:	8b 5b 20             	mov    0x20(%ebx),%ebx
  10c79a:	89 5c 24 44          	mov    %ebx,0x44(%esp)
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
  10c79e:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  10c7a2:	89 1c 24             	mov    %ebx,(%esp)
  10c7a5:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  10c7a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10c7ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10c7b1:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  10c7b5:	89 54 24 14          	mov    %edx,0x14(%esp)
  10c7b9:	e8 c2 00 00 00       	call   10c880 <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
  10c7be:	0f b7 44 24 4a       	movzwl 0x4a(%esp),%eax
  10c7c3:	0f b7 4c 24 48       	movzwl 0x48(%esp),%ecx
  10c7c8:	0f af c1             	imul   %ecx,%eax
  10c7cb:	c1 e8 03             	shr    $0x3,%eax
  10c7ce:	89 44 24 20          	mov    %eax,0x20(%esp)
	desc.width = w;
  10c7d2:	66 8b 74 24 4a       	mov    0x4a(%esp),%si
  10c7d7:	66 89 74 24 24       	mov    %si,0x24(%esp)
	desc.pitch = w;
  10c7dc:	66 8b 74 24 4a       	mov    0x4a(%esp),%si
  10c7e1:	66 89 74 24 28       	mov    %si,0x28(%esp)
	desc.height = h;
  10c7e6:	66 8b 74 24 48       	mov    0x48(%esp),%si
  10c7eb:	66 89 74 24 26       	mov    %si,0x26(%esp)
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
  10c7f0:	8b 44 24 44          	mov    0x44(%esp),%eax
  10c7f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c7f7:	66 8b 31             	mov    (%ecx),%si
  10c7fa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c7fd:	66 8b 79 02          	mov    0x2(%ecx),%di
  10c801:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10c804:	89 04 24             	mov    %eax,(%esp)
  10c807:	0f b7 c6             	movzwl %si,%eax
  10c80a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c80e:	0f b7 c7             	movzwl %di,%eax
  10c811:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c815:	8d 44 24 20          	lea    0x20(%esp),%eax
  10c819:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10c81d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10c821:	e8 9a 00 00 00       	call   10c8c0 <display_write>
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
  10c826:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  10c82a:	83 e1 08             	and    $0x8,%ecx
  10c82d:	83 f9 00             	cmp    $0x0,%ecx
  10c830:	0f 84 36 00 00 00    	je     10c86c <lvgl_flush_cb_mono+0x11c>
		display_write(display_dev, area->x1, area->y1, &desc,
  10c836:	8b 44 24 44          	mov    0x44(%esp),%eax
  10c83a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c83d:	66 8b 11             	mov    (%ecx),%dx
  10c840:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10c843:	66 8b 71 02          	mov    0x2(%ecx),%si
				(void *) color_p);
  10c847:	8b 4d 10             	mov    0x10(%ebp),%ecx
		display_write(display_dev, area->x1, area->y1, &desc,
  10c84a:	89 04 24             	mov    %eax,(%esp)
  10c84d:	0f b7 c2             	movzwl %dx,%eax
  10c850:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c854:	0f b7 c6             	movzwl %si,%eax
  10c857:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c85b:	8d 44 24 20          	lea    0x20(%esp),%eax
  10c85f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10c863:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10c867:	e8 54 00 00 00       	call   10c8c0 <display_write>
	}

	lv_disp_flush_ready(disp_drv);
  10c86c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c86f:	89 04 24             	mov    %eax,(%esp)
  10c872:	e8 19 b0 00 00       	call   117890 <lv_disp_flush_ready>
}
  10c877:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c87a:	5e                   	pop    %esi
  10c87b:	5f                   	pop    %edi
  10c87c:	5b                   	pop    %ebx
  10c87d:	5d                   	pop    %ebp
  10c87e:	c3                   	ret    
  10c87f:	90                   	nop

0010c880 <display_get_capabilities>:
{
  10c880:	55                   	push   %ebp
  10c881:	89 e5                	mov    %esp,%ebp
  10c883:	57                   	push   %edi
  10c884:	56                   	push   %esi
  10c885:	83 ec 14             	sub    $0x14,%esp
  10c888:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c88b:	8b 4d 08             	mov    0x8(%ebp),%ecx
		(struct display_driver_api *)dev->driver_api;
  10c88e:	8b 55 08             	mov    0x8(%ebp),%edx
  10c891:	8b 52 04             	mov    0x4(%edx),%edx
	struct display_driver_api *api =
  10c894:	89 55 f4             	mov    %edx,-0xc(%ebp)
	api->get_capabilities(dev, capabilities);
  10c897:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10c89a:	8b 52 1c             	mov    0x1c(%edx),%edx
  10c89d:	8b 75 08             	mov    0x8(%ebp),%esi
  10c8a0:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10c8a3:	89 34 24             	mov    %esi,(%esp)
  10c8a6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  10c8aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10c8ad:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10c8b0:	ff d2                	call   *%edx
}
  10c8b2:	83 c4 14             	add    $0x14,%esp
  10c8b5:	5e                   	pop    %esi
  10c8b6:	5f                   	pop    %edi
  10c8b7:	5d                   	pop    %ebp
  10c8b8:	c3                   	ret    
  10c8b9:	66 90                	xchg   %ax,%ax
  10c8bb:	66 90                	xchg   %ax,%ax
  10c8bd:	66 90                	xchg   %ax,%ax
  10c8bf:	90                   	nop

0010c8c0 <display_write>:
{
  10c8c0:	55                   	push   %ebp
  10c8c1:	89 e5                	mov    %esp,%ebp
  10c8c3:	53                   	push   %ebx
  10c8c4:	57                   	push   %edi
  10c8c5:	56                   	push   %esi
  10c8c6:	83 ec 38             	sub    $0x38,%esp
  10c8c9:	8b 45 18             	mov    0x18(%ebp),%eax
  10c8cc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10c8cf:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10c8d3:	66 8b 75 0c          	mov    0xc(%ebp),%si
  10c8d7:	8b 7d 08             	mov    0x8(%ebp),%edi
		(struct display_driver_api *)dev->driver_api;
  10c8da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10c8dd:	8b 5b 04             	mov    0x4(%ebx),%ebx
	struct display_driver_api *api =
  10c8e0:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	return api->write(dev, x, y, desc, buf);
  10c8e3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10c8e6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10c8e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c8ec:	8b 45 08             	mov    0x8(%ebp),%eax
  10c8ef:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
  10c8f3:	66 8b 55 0c          	mov    0xc(%ebp),%dx
  10c8f7:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  10c8fb:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10c8ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10c902:	8b 45 14             	mov    0x14(%ebp),%eax
  10c905:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10c908:	8b 45 18             	mov    0x18(%ebp),%eax
  10c90b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10c90e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10c911:	89 04 24             	mov    %eax,(%esp)
  10c914:	66 8b 45 e8          	mov    -0x18(%ebp),%ax
  10c918:	0f b7 c0             	movzwl %ax,%eax
  10c91b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c91f:	0f b7 c2             	movzwl %dx,%eax
  10c922:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c926:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10c929:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10c92d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10c930:	89 44 24 10          	mov    %eax,0x10(%esp)
  10c934:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10c937:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  10c93b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  10c93e:	ff d3                	call   *%ebx
  10c940:	83 c4 38             	add    $0x38,%esp
  10c943:	5e                   	pop    %esi
  10c944:	5f                   	pop    %edi
  10c945:	5b                   	pop    %ebx
  10c946:	5d                   	pop    %ebp
  10c947:	c3                   	ret    
  10c948:	66 90                	xchg   %ax,%ax
  10c94a:	66 90                	xchg   %ax,%ax
  10c94c:	66 90                	xchg   %ax,%ax
  10c94e:	66 90                	xchg   %ax,%ax

0010c950 <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
  10c950:	55                   	push   %ebp
  10c951:	89 e5                	mov    %esp,%ebp
  10c953:	53                   	push   %ebx
  10c954:	57                   	push   %edi
  10c955:	56                   	push   %esi
  10c956:	83 e4 f8             	and    $0xfffffff8,%esp
  10c959:	83 ec 50             	sub    $0x50,%esp
  10c95c:	8a 45 20             	mov    0x20(%ebp),%al
  10c95f:	8d 4d 1c             	lea    0x1c(%ebp),%ecx
  10c962:	66 8b 55 18          	mov    0x18(%ebp),%dx
  10c966:	66 8b 75 14          	mov    0x14(%ebp),%si
  10c96a:	66 8b 7d 10          	mov    0x10(%ebp),%di
  10c96e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10c971:	88 44 24 27          	mov    %al,0x27(%esp)
  10c975:	8b 45 08             	mov    0x8(%ebp),%eax
  10c978:	89 44 24 20          	mov    %eax,0x20(%esp)
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10c97c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c97f:	8b 40 20             	mov    0x20(%eax),%eax
  10c982:	89 44 24 48          	mov    %eax,0x48(%esp)
	u8_t *buf_xy;
	u8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
  10c986:	8b 44 24 48          	mov    0x48(%esp),%eax
  10c98a:	89 04 24             	mov    %eax,(%esp)
  10c98d:	8d 44 24 28          	lea    0x28(%esp),%eax
  10c991:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c995:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  10c999:	66 89 54 24 1a       	mov    %dx,0x1a(%esp)
  10c99e:	66 89 74 24 18       	mov    %si,0x18(%esp)
  10c9a3:	66 89 7c 24 16       	mov    %di,0x16(%esp)
  10c9a8:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10c9ac:	e8 cf fe ff ff       	call   10c880 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
  10c9b1:	8b 44 24 30          	mov    0x30(%esp),%eax
  10c9b5:	83 e0 01             	and    $0x1,%eax
  10c9b8:	83 f8 00             	cmp    $0x0,%eax
  10c9bb:	0f 84 6d 00 00 00    	je     10ca2e <lvgl_set_px_cb_mono+0xde>
		buf_xy = buf + x + y/8 * buf_w;
  10c9c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c9c4:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx
  10c9c8:	01 c8                	add    %ecx,%eax
  10c9ca:	0f bf 4d 18          	movswl 0x18(%ebp),%ecx
  10c9ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10c9d2:	89 c8                	mov    %ecx,%eax
  10c9d4:	99                   	cltd   
  10c9d5:	b9 08 00 00 00       	mov    $0x8,%ecx
  10c9da:	f7 f9                	idiv   %ecx
  10c9dc:	0f bf 4d 10          	movswl 0x10(%ebp),%ecx
  10c9e0:	0f af c1             	imul   %ecx,%eax
  10c9e3:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  10c9e7:	01 c1                	add    %eax,%ecx
  10c9e9:	89 4c 24 44          	mov    %ecx,0x44(%esp)

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
  10c9ed:	8b 44 24 30          	mov    0x30(%esp),%eax
  10c9f1:	83 e0 02             	and    $0x2,%eax
  10c9f4:	83 f8 00             	cmp    $0x0,%eax
  10c9f7:	0f 84 1c 00 00 00    	je     10ca19 <lvgl_set_px_cb_mono+0xc9>
			bit = 7 - y%8;
  10c9fd:	0f bf 45 18          	movswl 0x18(%ebp),%eax
  10ca01:	99                   	cltd   
  10ca02:	b9 08 00 00 00       	mov    $0x8,%ecx
  10ca07:	f7 f9                	idiv   %ecx
  10ca09:	b9 07 00 00 00       	mov    $0x7,%ecx
  10ca0e:	29 d1                	sub    %edx,%ecx
  10ca10:	88 4c 24 43          	mov    %cl,0x43(%esp)
		} else {
  10ca14:	e9 10 00 00 00       	jmp    10ca29 <lvgl_set_px_cb_mono+0xd9>
			bit = y%8;
  10ca19:	0f bf 45 18          	movswl 0x18(%ebp),%eax
  10ca1d:	99                   	cltd   
  10ca1e:	b9 08 00 00 00       	mov    $0x8,%ecx
  10ca23:	f7 f9                	idiv   %ecx
  10ca25:	88 54 24 43          	mov    %dl,0x43(%esp)
		}
	} else {
  10ca29:	e9 70 00 00 00       	jmp    10ca9e <lvgl_set_px_cb_mono+0x14e>
		buf_xy = buf + x/8 + y * buf_w/8;
  10ca2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ca31:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx
  10ca35:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ca39:	89 c8                	mov    %ecx,%eax
  10ca3b:	99                   	cltd   
  10ca3c:	b9 08 00 00 00       	mov    $0x8,%ecx
  10ca41:	f7 f9                	idiv   %ecx
  10ca43:	8b 74 24 08          	mov    0x8(%esp),%esi
  10ca47:	01 c6                	add    %eax,%esi
  10ca49:	0f bf 45 18          	movswl 0x18(%ebp),%eax
  10ca4d:	0f bf 7d 10          	movswl 0x10(%ebp),%edi
  10ca51:	0f af c7             	imul   %edi,%eax
  10ca54:	99                   	cltd   
  10ca55:	f7 f9                	idiv   %ecx
  10ca57:	01 c6                	add    %eax,%esi
  10ca59:	89 74 24 44          	mov    %esi,0x44(%esp)

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
  10ca5d:	8b 44 24 30          	mov    0x30(%esp),%eax
  10ca61:	83 e0 02             	and    $0x2,%eax
  10ca64:	83 f8 00             	cmp    $0x0,%eax
  10ca67:	0f 84 1c 00 00 00    	je     10ca89 <lvgl_set_px_cb_mono+0x139>
			bit = 7 - x%8;
  10ca6d:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  10ca71:	99                   	cltd   
  10ca72:	b9 08 00 00 00       	mov    $0x8,%ecx
  10ca77:	f7 f9                	idiv   %ecx
  10ca79:	b9 07 00 00 00       	mov    $0x7,%ecx
  10ca7e:	29 d1                	sub    %edx,%ecx
  10ca80:	88 4c 24 43          	mov    %cl,0x43(%esp)
		} else {
  10ca84:	e9 10 00 00 00       	jmp    10ca99 <lvgl_set_px_cb_mono+0x149>
			bit = x%8;
  10ca89:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  10ca8d:	99                   	cltd   
  10ca8e:	b9 08 00 00 00       	mov    $0x8,%ecx
  10ca93:	f7 f9                	idiv   %ecx
  10ca95:	88 54 24 43          	mov    %dl,0x43(%esp)
  10ca99:	e9 00 00 00 00       	jmp    10ca9e <lvgl_set_px_cb_mono+0x14e>
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
  10ca9e:	83 7c 24 34 04       	cmpl   $0x4,0x34(%esp)
  10caa3:	0f 85 4c 00 00 00    	jne    10caf5 <lvgl_set_px_cb_mono+0x1a5>
  10caa9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
		if (color.full == 0) {
  10caad:	83 38 00             	cmpl   $0x0,(%eax)
  10cab0:	0f 85 21 00 00 00    	jne    10cad7 <lvgl_set_px_cb_mono+0x187>
			*buf_xy &= ~BIT(bit);
  10cab6:	0f b6 4c 24 43       	movzbl 0x43(%esp),%ecx
  10cabb:	b8 01 00 00 00       	mov    $0x1,%eax
  10cac0:	d3 e0                	shl    %cl,%eax
  10cac2:	83 f0 ff             	xor    $0xffffffff,%eax
  10cac5:	8b 54 24 44          	mov    0x44(%esp),%edx
  10cac9:	0f b6 32             	movzbl (%edx),%esi
  10cacc:	89 f3                	mov    %esi,%ebx
  10cace:	21 c3                	and    %eax,%ebx
  10cad0:	88 1a                	mov    %bl,(%edx)
		} else {
  10cad2:	e9 19 00 00 00       	jmp    10caf0 <lvgl_set_px_cb_mono+0x1a0>
			*buf_xy |= BIT(bit);
  10cad7:	0f b6 4c 24 43       	movzbl 0x43(%esp),%ecx
  10cadc:	b8 01 00 00 00       	mov    $0x1,%eax
  10cae1:	d3 e0                	shl    %cl,%eax
  10cae3:	8b 54 24 44          	mov    0x44(%esp),%edx
  10cae7:	0f b6 32             	movzbl (%edx),%esi
  10caea:	89 f3                	mov    %esi,%ebx
  10caec:	09 c3                	or     %eax,%ebx
  10caee:	88 1a                	mov    %bl,(%edx)
		}
	} else {
  10caf0:	e9 4c 00 00 00       	jmp    10cb41 <lvgl_set_px_cb_mono+0x1f1>
  10caf5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
		if (color.full == 0) {
  10caf9:	83 38 00             	cmpl   $0x0,(%eax)
  10cafc:	0f 85 1e 00 00 00    	jne    10cb20 <lvgl_set_px_cb_mono+0x1d0>
			*buf_xy |= BIT(bit);
  10cb02:	0f b6 4c 24 43       	movzbl 0x43(%esp),%ecx
  10cb07:	b8 01 00 00 00       	mov    $0x1,%eax
  10cb0c:	d3 e0                	shl    %cl,%eax
  10cb0e:	8b 54 24 44          	mov    0x44(%esp),%edx
  10cb12:	0f b6 32             	movzbl (%edx),%esi
  10cb15:	89 f3                	mov    %esi,%ebx
  10cb17:	09 c3                	or     %eax,%ebx
  10cb19:	88 1a                	mov    %bl,(%edx)
		} else {
  10cb1b:	e9 1c 00 00 00       	jmp    10cb3c <lvgl_set_px_cb_mono+0x1ec>
			*buf_xy &= ~BIT(bit);
  10cb20:	0f b6 4c 24 43       	movzbl 0x43(%esp),%ecx
  10cb25:	b8 01 00 00 00       	mov    $0x1,%eax
  10cb2a:	d3 e0                	shl    %cl,%eax
  10cb2c:	83 f0 ff             	xor    $0xffffffff,%eax
  10cb2f:	8b 54 24 44          	mov    0x44(%esp),%edx
  10cb33:	0f b6 32             	movzbl (%edx),%esi
  10cb36:	89 f3                	mov    %esi,%ebx
  10cb38:	21 c3                	and    %eax,%ebx
  10cb3a:	88 1a                	mov    %bl,(%edx)
  10cb3c:	e9 00 00 00 00       	jmp    10cb41 <lvgl_set_px_cb_mono+0x1f1>
		}
	}
}
  10cb41:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10cb44:	5e                   	pop    %esi
  10cb45:	5f                   	pop    %edi
  10cb46:	5b                   	pop    %ebx
  10cb47:	5d                   	pop    %ebp
  10cb48:	c3                   	ret    
  10cb49:	66 90                	xchg   %ax,%ax
  10cb4b:	66 90                	xchg   %ax,%ax
  10cb4d:	66 90                	xchg   %ax,%ax
  10cb4f:	90                   	nop

0010cb50 <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
  10cb50:	55                   	push   %ebp
  10cb51:	89 e5                	mov    %esp,%ebp
  10cb53:	83 e4 f8             	and    $0xfffffff8,%esp
  10cb56:	83 ec 28             	sub    $0x28,%esp
  10cb59:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cb5c:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10cb5f:	8b 55 08             	mov    0x8(%ebp),%edx
  10cb62:	8b 52 20             	mov    0x20(%edx),%edx
  10cb65:	89 54 24 24          	mov    %edx,0x24(%esp)
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
  10cb69:	8b 54 24 24          	mov    0x24(%esp),%edx
  10cb6d:	89 14 24             	mov    %edx,(%esp)
  10cb70:	8d 54 24 10          	lea    0x10(%esp),%edx
  10cb74:	89 54 24 04          	mov    %edx,0x4(%esp)
  10cb78:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10cb7c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10cb80:	e8 fb fc ff ff       	call   10c880 <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
  10cb85:	8b 44 24 18          	mov    0x18(%esp),%eax
  10cb89:	83 e0 01             	and    $0x1,%eax
  10cb8c:	83 f8 00             	cmp    $0x0,%eax
  10cb8f:	0f 84 21 00 00 00    	je     10cbb6 <lvgl_rounder_cb_mono+0x66>
		area->y1 &= ~0x7;
  10cb95:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cb98:	0f bf 48 02          	movswl 0x2(%eax),%ecx
  10cb9c:	83 e1 f8             	and    $0xfffffff8,%ecx
  10cb9f:	66 89 48 02          	mov    %cx,0x2(%eax)
		area->y2 |= 0x7;
  10cba3:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cba6:	0f bf 50 06          	movswl 0x6(%eax),%edx
  10cbaa:	83 ca 07             	or     $0x7,%edx
  10cbad:	66 89 50 06          	mov    %dx,0x6(%eax)
	} else {
  10cbb1:	e9 1a 00 00 00       	jmp    10cbd0 <lvgl_rounder_cb_mono+0x80>
		area->x1 &= ~0x7;
  10cbb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cbb9:	0f bf 08             	movswl (%eax),%ecx
  10cbbc:	83 e1 f8             	and    $0xfffffff8,%ecx
  10cbbf:	66 89 08             	mov    %cx,(%eax)
		area->x2 |= 0x7;
  10cbc2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cbc5:	0f bf 50 04          	movswl 0x4(%eax),%edx
  10cbc9:	83 ca 07             	or     $0x7,%edx
  10cbcc:	66 89 50 04          	mov    %dx,0x4(%eax)
	}
}
  10cbd0:	89 ec                	mov    %ebp,%esp
  10cbd2:	5d                   	pop    %ebp
  10cbd3:	c3                   	ret    
  10cbd4:	66 90                	xchg   %ax,%ax
  10cbd6:	66 90                	xchg   %ax,%ax
  10cbd8:	66 90                	xchg   %ax,%ax
  10cbda:	66 90                	xchg   %ax,%ax
  10cbdc:	66 90                	xchg   %ax,%ax
  10cbde:	66 90                	xchg   %ax,%ax

0010cbe0 <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
  10cbe0:	55                   	push   %ebp
  10cbe1:	89 e5                	mov    %esp,%ebp
  10cbe3:	53                   	push   %ebx
  10cbe4:	57                   	push   %edi
  10cbe5:	56                   	push   %esi
  10cbe6:	83 e4 f8             	and    $0xfffffff8,%esp
  10cbe9:	83 ec 40             	sub    $0x40,%esp
  10cbec:	8b 45 10             	mov    0x10(%ebp),%eax
  10cbef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10cbf2:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10cbf5:	8b 75 08             	mov    0x8(%ebp),%esi
  10cbf8:	8b 76 20             	mov    0x20(%esi),%esi
  10cbfb:	89 74 24 38          	mov    %esi,0x38(%esp)
	u16_t w = area->x2 - area->x1 + 1;
  10cbff:	8b 75 0c             	mov    0xc(%ebp),%esi
  10cc02:	0f bf 76 04          	movswl 0x4(%esi),%esi
  10cc06:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10cc09:	0f bf 3f             	movswl (%edi),%edi
  10cc0c:	29 fe                	sub    %edi,%esi
  10cc0e:	83 c6 01             	add    $0x1,%esi
  10cc11:	66 89 74 24 36       	mov    %si,0x36(%esp)
	u16_t h = area->y2 - area->y1 + 1;
  10cc16:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10cc19:	0f bf 7f 06          	movswl 0x6(%edi),%edi
  10cc1d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cc20:	0f bf 5b 02          	movswl 0x2(%ebx),%ebx
  10cc24:	29 df                	sub    %ebx,%edi
  10cc26:	83 c7 01             	add    $0x1,%edi
  10cc29:	66 89 7c 24 34       	mov    %di,0x34(%esp)
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
  10cc2e:	0f b7 5c 24 36       	movzwl 0x36(%esp),%ebx
  10cc33:	c1 e3 01             	shl    $0x1,%ebx
  10cc36:	0f b7 74 24 34       	movzwl 0x34(%esp),%esi
  10cc3b:	0f af de             	imul   %esi,%ebx
  10cc3e:	89 5c 24 28          	mov    %ebx,0x28(%esp)
	desc.width = w;
  10cc42:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10cc47:	66 89 7c 24 2c       	mov    %di,0x2c(%esp)
	desc.pitch = w;
  10cc4c:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10cc51:	66 89 7c 24 30       	mov    %di,0x30(%esp)
	desc.height = h;
  10cc56:	66 8b 7c 24 34       	mov    0x34(%esp),%di
  10cc5b:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
  10cc60:	8b 74 24 38          	mov    0x38(%esp),%esi
  10cc64:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cc67:	66 8b 3b             	mov    (%ebx),%di
  10cc6a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cc6d:	66 8b 5b 02          	mov    0x2(%ebx),%bx
  10cc71:	89 44 24 24          	mov    %eax,0x24(%esp)
  10cc75:	8b 45 10             	mov    0x10(%ebp),%eax
  10cc78:	89 34 24             	mov    %esi,(%esp)
  10cc7b:	0f b7 f7             	movzwl %di,%esi
  10cc7e:	89 74 24 04          	mov    %esi,0x4(%esp)
  10cc82:	0f b7 f3             	movzwl %bx,%esi
  10cc85:	89 74 24 08          	mov    %esi,0x8(%esp)
  10cc89:	8d 74 24 28          	lea    0x28(%esp),%esi
  10cc8d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10cc91:	89 44 24 10          	mov    %eax,0x10(%esp)
  10cc95:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10cc99:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  10cc9d:	e8 1e 00 00 00       	call   10ccc0 <display_write>

	lv_disp_flush_ready(disp_drv);
  10cca2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10cca5:	89 0c 24             	mov    %ecx,(%esp)
  10cca8:	89 44 24 18          	mov    %eax,0x18(%esp)
  10ccac:	e8 df ab 00 00       	call   117890 <lv_disp_flush_ready>
}
  10ccb1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ccb4:	5e                   	pop    %esi
  10ccb5:	5f                   	pop    %edi
  10ccb6:	5b                   	pop    %ebx
  10ccb7:	5d                   	pop    %ebp
  10ccb8:	c3                   	ret    
  10ccb9:	66 90                	xchg   %ax,%ax
  10ccbb:	66 90                	xchg   %ax,%ax
  10ccbd:	66 90                	xchg   %ax,%ax
  10ccbf:	90                   	nop

0010ccc0 <display_write>:
{
  10ccc0:	55                   	push   %ebp
  10ccc1:	89 e5                	mov    %esp,%ebp
  10ccc3:	53                   	push   %ebx
  10ccc4:	57                   	push   %edi
  10ccc5:	56                   	push   %esi
  10ccc6:	83 ec 38             	sub    $0x38,%esp
  10ccc9:	8b 45 18             	mov    0x18(%ebp),%eax
  10cccc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10cccf:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10ccd3:	66 8b 75 0c          	mov    0xc(%ebp),%si
  10ccd7:	8b 7d 08             	mov    0x8(%ebp),%edi
		(struct display_driver_api *)dev->driver_api;
  10ccda:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10ccdd:	8b 5b 04             	mov    0x4(%ebx),%ebx
	struct display_driver_api *api =
  10cce0:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	return api->write(dev, x, y, desc, buf);
  10cce3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10cce6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10cce9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ccec:	8b 45 08             	mov    0x8(%ebp),%eax
  10ccef:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
  10ccf3:	66 8b 55 0c          	mov    0xc(%ebp),%dx
  10ccf7:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  10ccfb:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10ccff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10cd02:	8b 45 14             	mov    0x14(%ebp),%eax
  10cd05:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10cd08:	8b 45 18             	mov    0x18(%ebp),%eax
  10cd0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10cd0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10cd11:	89 04 24             	mov    %eax,(%esp)
  10cd14:	66 8b 45 e8          	mov    -0x18(%ebp),%ax
  10cd18:	0f b7 c0             	movzwl %ax,%eax
  10cd1b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10cd1f:	0f b7 c2             	movzwl %dx,%eax
  10cd22:	89 44 24 08          	mov    %eax,0x8(%esp)
  10cd26:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10cd29:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10cd2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10cd30:	89 44 24 10          	mov    %eax,0x10(%esp)
  10cd34:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10cd37:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  10cd3b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  10cd3e:	ff d3                	call   *%ebx
  10cd40:	83 c4 38             	add    $0x38,%esp
  10cd43:	5e                   	pop    %esi
  10cd44:	5f                   	pop    %edi
  10cd45:	5b                   	pop    %ebx
  10cd46:	5d                   	pop    %ebp
  10cd47:	c3                   	ret    
  10cd48:	66 90                	xchg   %ax,%ax
  10cd4a:	66 90                	xchg   %ax,%ax
  10cd4c:	66 90                	xchg   %ax,%ax
  10cd4e:	66 90                	xchg   %ax,%ax

0010cd50 <lvgl_set_px_cb_16bit>:

#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
  10cd50:	55                   	push   %ebp
  10cd51:	89 e5                	mov    %esp,%ebp
  10cd53:	53                   	push   %ebx
  10cd54:	57                   	push   %edi
  10cd55:	56                   	push   %esi
  10cd56:	83 ec 2c             	sub    $0x2c,%esp
  10cd59:	8a 45 20             	mov    0x20(%ebp),%al
  10cd5c:	8d 4d 1c             	lea    0x1c(%ebp),%ecx
  10cd5f:	66 8b 55 18          	mov    0x18(%ebp),%dx
  10cd63:	66 8b 75 14          	mov    0x14(%ebp),%si
  10cd67:	66 8b 7d 10          	mov    0x10(%ebp),%di
  10cd6b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cd6e:	88 45 ef             	mov    %al,-0x11(%ebp)
  10cd71:	8b 45 08             	mov    0x8(%ebp),%eax
  10cd74:	89 45 e8             	mov    %eax,-0x18(%ebp)
	u16_t *buf_xy = (u16_t *)(buf + x * 2U + y * 2U * buf_w);
  10cd77:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cd7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10cd7d:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  10cd81:	c1 e0 01             	shl    $0x1,%eax
  10cd84:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10cd87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10cd8a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10cd8d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10cd90:	01 c8                	add    %ecx,%eax
  10cd92:	0f bf 4d 18          	movswl 0x18(%ebp),%ecx
  10cd96:	c1 e1 01             	shl    $0x1,%ecx
  10cd99:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10cd9c:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  10cda0:	0f af c8             	imul   %eax,%ecx
  10cda3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10cda6:	01 c8                	add    %ecx,%eax
  10cda8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10cdab:	8b 45 dc             	mov    -0x24(%ebp),%eax
	*buf_xy = lv_color_to16(color);
  10cdae:	8b 08                	mov    (%eax),%ecx
  10cdb0:	89 0c 24             	mov    %ecx,(%esp)
  10cdb3:	66 89 55 d6          	mov    %dx,-0x2a(%ebp)
  10cdb7:	66 89 75 d4          	mov    %si,-0x2c(%ebp)
  10cdbb:	66 89 7d d2          	mov    %di,-0x2e(%ebp)
  10cdbf:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  10cdc2:	e8 19 00 00 00       	call   10cde0 <lv_color_to16>
  10cdc7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10cdca:	66 89 01             	mov    %ax,(%ecx)
}
  10cdcd:	83 c4 2c             	add    $0x2c,%esp
  10cdd0:	5e                   	pop    %esi
  10cdd1:	5f                   	pop    %edi
  10cdd2:	5b                   	pop    %ebx
  10cdd3:	5d                   	pop    %ebp
  10cdd4:	c3                   	ret    
  10cdd5:	66 90                	xchg   %ax,%ax
  10cdd7:	66 90                	xchg   %ax,%ax
  10cdd9:	66 90                	xchg   %ax,%ax
  10cddb:	66 90                	xchg   %ax,%ax
  10cddd:	66 90                	xchg   %ax,%ax
  10cddf:	90                   	nop

0010cde0 <lv_color_to16>:
    return ret.full;
#endif
}

static inline uint16_t lv_color_to16(lv_color_t color)
{
  10cde0:	55                   	push   %ebp
  10cde1:	89 e5                	mov    %esp,%ebp
  10cde3:	56                   	push   %esi
  10cde4:	83 e4 f8             	and    $0xfffffff8,%esp
  10cde7:	83 ec 08             	sub    $0x8,%esp
  10cdea:	8d 45 08             	lea    0x8(%ebp),%eax
#elif LV_COLOR_DEPTH == 16
    return color.full;
#elif LV_COLOR_DEPTH == 32
    lv_color16_t ret;
#if LV_COLOR_16_SWAP == 0
    ret.ch.red   = color.ch.red >> 3;   /* 8 - 5  = 3*/
  10cded:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
  10cdf1:	c1 f9 03             	sar    $0x3,%ecx
  10cdf4:	66 8b 14 24          	mov    (%esp),%dx
  10cdf8:	66 83 e1 1f          	and    $0x1f,%cx
  10cdfc:	66 c1 e1 0b          	shl    $0xb,%cx
  10ce00:	66 81 e2 ff 07       	and    $0x7ff,%dx
  10ce05:	66 09 ca             	or     %cx,%dx
  10ce08:	66 89 14 24          	mov    %dx,(%esp)
    ret.ch.green = color.ch.green >> 2; /* 8 - 6  = 2*/
  10ce0c:	0f b6 70 01          	movzbl 0x1(%eax),%esi
  10ce10:	c1 fe 02             	sar    $0x2,%esi
  10ce13:	66 8b 0c 24          	mov    (%esp),%cx
  10ce17:	66 83 e6 3f          	and    $0x3f,%si
  10ce1b:	66 c1 e6 05          	shl    $0x5,%si
  10ce1f:	66 81 e1 1f f8       	and    $0xf81f,%cx
  10ce24:	66 09 f1             	or     %si,%cx
  10ce27:	66 89 0c 24          	mov    %cx,(%esp)
    ret.ch.blue  = color.ch.blue >> 3;  /* 8 - 5  = 3*/
  10ce2b:	0f b6 00             	movzbl (%eax),%eax
  10ce2e:	c1 f8 03             	sar    $0x3,%eax
  10ce31:	66 8b 0c 24          	mov    (%esp),%cx
  10ce35:	66 83 e0 1f          	and    $0x1f,%ax
  10ce39:	66 83 e1 e0          	and    $0xffe0,%cx
  10ce3d:	66 09 c1             	or     %ax,%cx
  10ce40:	66 89 0c 24          	mov    %cx,(%esp)
    ret.ch.red     = color.ch.red >> 3;
    ret.ch.green_h = (color.ch.green & 0xE0) >> 5;
    ret.ch.green_l = (color.ch.green & 0x1C) >> 2;
    ret.ch.blue    = color.ch.blue >> 3;
#endif
    return ret.full;
  10ce44:	0f b7 04 24          	movzwl (%esp),%eax
  10ce48:	8d 65 fc             	lea    -0x4(%ebp),%esp
  10ce4b:	5e                   	pop    %esi
  10ce4c:	5d                   	pop    %ebp
  10ce4d:	c3                   	ret    
  10ce4e:	66 90                	xchg   %ax,%ax

0010ce50 <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
  10ce50:	55                   	push   %ebp
  10ce51:	89 e5                	mov    %esp,%ebp
  10ce53:	53                   	push   %ebx
  10ce54:	57                   	push   %edi
  10ce55:	56                   	push   %esi
  10ce56:	83 e4 f8             	and    $0xfffffff8,%esp
  10ce59:	83 ec 40             	sub    $0x40,%esp
  10ce5c:	8b 45 10             	mov    0x10(%ebp),%eax
  10ce5f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10ce62:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10ce65:	8b 75 08             	mov    0x8(%ebp),%esi
  10ce68:	8b 76 20             	mov    0x20(%esi),%esi
  10ce6b:	89 74 24 38          	mov    %esi,0x38(%esp)
	u16_t w = area->x2 - area->x1 + 1;
  10ce6f:	8b 75 0c             	mov    0xc(%ebp),%esi
  10ce72:	0f bf 76 04          	movswl 0x4(%esi),%esi
  10ce76:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10ce79:	0f bf 3f             	movswl (%edi),%edi
  10ce7c:	29 fe                	sub    %edi,%esi
  10ce7e:	83 c6 01             	add    $0x1,%esi
  10ce81:	66 89 74 24 36       	mov    %si,0x36(%esp)
	u16_t h = area->y2 - area->y1 + 1;
  10ce86:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10ce89:	0f bf 7f 06          	movswl 0x6(%edi),%edi
  10ce8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10ce90:	0f bf 5b 02          	movswl 0x2(%ebx),%ebx
  10ce94:	29 df                	sub    %ebx,%edi
  10ce96:	83 c7 01             	add    $0x1,%edi
  10ce99:	66 89 7c 24 34       	mov    %di,0x34(%esp)
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
  10ce9e:	0f b7 5c 24 36       	movzwl 0x36(%esp),%ebx
  10cea3:	6b db 03             	imul   $0x3,%ebx,%ebx
  10cea6:	0f b7 74 24 34       	movzwl 0x34(%esp),%esi
  10ceab:	0f af de             	imul   %esi,%ebx
  10ceae:	89 5c 24 28          	mov    %ebx,0x28(%esp)
	desc.width = w;
  10ceb2:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10ceb7:	66 89 7c 24 2c       	mov    %di,0x2c(%esp)
	desc.pitch = w;
  10cebc:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10cec1:	66 89 7c 24 30       	mov    %di,0x30(%esp)
	desc.height = h;
  10cec6:	66 8b 7c 24 34       	mov    0x34(%esp),%di
  10cecb:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
  10ced0:	8b 74 24 38          	mov    0x38(%esp),%esi
  10ced4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10ced7:	66 8b 3b             	mov    (%ebx),%di
  10ceda:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cedd:	66 8b 5b 02          	mov    0x2(%ebx),%bx
  10cee1:	89 44 24 24          	mov    %eax,0x24(%esp)
  10cee5:	8b 45 10             	mov    0x10(%ebp),%eax
  10cee8:	89 34 24             	mov    %esi,(%esp)
  10ceeb:	0f b7 f7             	movzwl %di,%esi
  10ceee:	89 74 24 04          	mov    %esi,0x4(%esp)
  10cef2:	0f b7 f3             	movzwl %bx,%esi
  10cef5:	89 74 24 08          	mov    %esi,0x8(%esp)
  10cef9:	8d 74 24 28          	lea    0x28(%esp),%esi
  10cefd:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10cf01:	89 44 24 10          	mov    %eax,0x10(%esp)
  10cf05:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10cf09:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  10cf0d:	e8 1e 00 00 00       	call   10cf30 <display_write>

	lv_disp_flush_ready(disp_drv);
  10cf12:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10cf15:	89 0c 24             	mov    %ecx,(%esp)
  10cf18:	89 44 24 18          	mov    %eax,0x18(%esp)
  10cf1c:	e8 6f a9 00 00       	call   117890 <lv_disp_flush_ready>
}
  10cf21:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10cf24:	5e                   	pop    %esi
  10cf25:	5f                   	pop    %edi
  10cf26:	5b                   	pop    %ebx
  10cf27:	5d                   	pop    %ebp
  10cf28:	c3                   	ret    
  10cf29:	66 90                	xchg   %ax,%ax
  10cf2b:	66 90                	xchg   %ax,%ax
  10cf2d:	66 90                	xchg   %ax,%ax
  10cf2f:	90                   	nop

0010cf30 <display_write>:
{
  10cf30:	55                   	push   %ebp
  10cf31:	89 e5                	mov    %esp,%ebp
  10cf33:	53                   	push   %ebx
  10cf34:	57                   	push   %edi
  10cf35:	56                   	push   %esi
  10cf36:	83 ec 38             	sub    $0x38,%esp
  10cf39:	8b 45 18             	mov    0x18(%ebp),%eax
  10cf3c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10cf3f:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10cf43:	66 8b 75 0c          	mov    0xc(%ebp),%si
  10cf47:	8b 7d 08             	mov    0x8(%ebp),%edi
		(struct display_driver_api *)dev->driver_api;
  10cf4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10cf4d:	8b 5b 04             	mov    0x4(%ebx),%ebx
	struct display_driver_api *api =
  10cf50:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	return api->write(dev, x, y, desc, buf);
  10cf53:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10cf56:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10cf59:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10cf5c:	8b 45 08             	mov    0x8(%ebp),%eax
  10cf5f:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
  10cf63:	66 8b 55 0c          	mov    0xc(%ebp),%dx
  10cf67:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  10cf6b:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10cf6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10cf72:	8b 45 14             	mov    0x14(%ebp),%eax
  10cf75:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10cf78:	8b 45 18             	mov    0x18(%ebp),%eax
  10cf7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10cf7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10cf81:	89 04 24             	mov    %eax,(%esp)
  10cf84:	66 8b 45 e8          	mov    -0x18(%ebp),%ax
  10cf88:	0f b7 c0             	movzwl %ax,%eax
  10cf8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10cf8f:	0f b7 c2             	movzwl %dx,%eax
  10cf92:	89 44 24 08          	mov    %eax,0x8(%esp)
  10cf96:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10cf99:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10cf9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10cfa0:	89 44 24 10          	mov    %eax,0x10(%esp)
  10cfa4:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10cfa7:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  10cfab:	89 7d d0             	mov    %edi,-0x30(%ebp)
  10cfae:	ff d3                	call   *%ebx
  10cfb0:	83 c4 38             	add    $0x38,%esp
  10cfb3:	5e                   	pop    %esi
  10cfb4:	5f                   	pop    %edi
  10cfb5:	5b                   	pop    %ebx
  10cfb6:	5d                   	pop    %ebp
  10cfb7:	c3                   	ret    
  10cfb8:	66 90                	xchg   %ax,%ax
  10cfba:	66 90                	xchg   %ax,%ax
  10cfbc:	66 90                	xchg   %ax,%ax
  10cfbe:	66 90                	xchg   %ax,%ax

0010cfc0 <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		u8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
  10cfc0:	55                   	push   %ebp
  10cfc1:	89 e5                	mov    %esp,%ebp
  10cfc3:	53                   	push   %ebx
  10cfc4:	57                   	push   %edi
  10cfc5:	56                   	push   %esi
  10cfc6:	83 e4 f8             	and    $0xfffffff8,%esp
  10cfc9:	83 ec 48             	sub    $0x48,%esp
  10cfcc:	8a 45 20             	mov    0x20(%ebp),%al
  10cfcf:	8d 4d 1c             	lea    0x1c(%ebp),%ecx
  10cfd2:	66 8b 55 18          	mov    0x18(%ebp),%dx
  10cfd6:	66 8b 75 14          	mov    0x14(%ebp),%si
  10cfda:	66 8b 7d 10          	mov    0x10(%ebp),%di
  10cfde:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10cfe1:	88 44 24 27          	mov    %al,0x27(%esp)
  10cfe5:	8b 45 08             	mov    0x8(%ebp),%eax
  10cfe8:	89 44 24 20          	mov    %eax,0x20(%esp)
	u8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
  10cfec:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cfef:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10cff3:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  10cff7:	6b c0 03             	imul   $0x3,%eax,%eax
  10cffa:	89 44 24 18          	mov    %eax,0x18(%esp)
  10cffe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10d002:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10d006:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10d00a:	01 c8                	add    %ecx,%eax
  10d00c:	0f bf 4d 18          	movswl 0x18(%ebp),%ecx
  10d010:	6b c9 03             	imul   $0x3,%ecx,%ecx
  10d013:	89 44 24 10          	mov    %eax,0x10(%esp)
  10d017:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  10d01b:	0f af c8             	imul   %eax,%ecx
  10d01e:	8b 44 24 10          	mov    0x10(%esp),%eax
  10d022:	01 c8                	add    %ecx,%eax
  10d024:	89 44 24 40          	mov    %eax,0x40(%esp)
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
  10d028:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  10d02c:	3d ff 00 00 00       	cmp    $0xff,%eax
  10d031:	0f 84 55 00 00 00    	je     10d08c <lvgl_set_px_cb_24bit+0xcc>
		lv_color_t mix_color;

		mix_color.ch.red = *buf_xy;
  10d037:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d03b:	8a 08                	mov    (%eax),%cl
  10d03d:	88 4c 24 32          	mov    %cl,0x32(%esp)
		mix_color.ch.green = *(buf_xy+1);
  10d041:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d045:	8a 48 01             	mov    0x1(%eax),%cl
  10d048:	88 4c 24 31          	mov    %cl,0x31(%esp)
		mix_color.ch.blue = *(buf_xy+2);
  10d04c:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d050:	8a 48 02             	mov    0x2(%eax),%cl
  10d053:	88 4c 24 30          	mov    %cl,0x30(%esp)
		color = lv_color_mix(color, mix_color, opa);
  10d057:	8d 44 24 28          	lea    0x28(%esp),%eax
  10d05b:	89 04 24             	mov    %eax,(%esp)
  10d05e:	8b 44 24 14          	mov    0x14(%esp),%eax
  10d062:	8b 10                	mov    (%eax),%edx
  10d064:	89 54 24 04          	mov    %edx,0x4(%esp)
  10d068:	8d 54 24 30          	lea    0x30(%esp),%edx
  10d06c:	8b 12                	mov    (%edx),%edx
  10d06e:	89 54 24 08          	mov    %edx,0x8(%esp)
  10d072:	0f b6 55 20          	movzbl 0x20(%ebp),%edx
  10d076:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10d07a:	e8 51 00 00 00       	call   10d0d0 <lv_color_mix>
  10d07f:	83 ec 04             	sub    $0x4,%esp
  10d082:	8b 44 24 28          	mov    0x28(%esp),%eax
  10d086:	8b 54 24 14          	mov    0x14(%esp),%edx
  10d08a:	89 02                	mov    %eax,(%edx)
  10d08c:	8b 44 24 14          	mov    0x14(%esp),%eax
	}
#endif

	converted_color.full = lv_color_to32(color);
  10d090:	8b 08                	mov    (%eax),%ecx
  10d092:	89 0c 24             	mov    %ecx,(%esp)
  10d095:	e8 06 01 00 00       	call   10d1a0 <lv_color_to32>
  10d09a:	89 44 24 38          	mov    %eax,0x38(%esp)
	*buf_xy = converted_color.ch.red;
  10d09e:	8a 54 24 3a          	mov    0x3a(%esp),%dl
  10d0a2:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d0a6:	88 10                	mov    %dl,(%eax)
	*(buf_xy + 1) = converted_color.ch.green;
  10d0a8:	8a 54 24 39          	mov    0x39(%esp),%dl
  10d0ac:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d0b0:	88 50 01             	mov    %dl,0x1(%eax)
	*(buf_xy + 2) = converted_color.ch.blue;
  10d0b3:	8a 54 24 38          	mov    0x38(%esp),%dl
  10d0b7:	8b 44 24 40          	mov    0x40(%esp),%eax
  10d0bb:	88 50 02             	mov    %dl,0x2(%eax)
}
  10d0be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d0c1:	5e                   	pop    %esi
  10d0c2:	5f                   	pop    %edi
  10d0c3:	5b                   	pop    %ebx
  10d0c4:	5d                   	pop    %ebp
  10d0c5:	c3                   	ret    
  10d0c6:	66 90                	xchg   %ax,%ax
  10d0c8:	66 90                	xchg   %ax,%ax
  10d0ca:	66 90                	xchg   %ax,%ax
  10d0cc:	66 90                	xchg   %ax,%ax
  10d0ce:	66 90                	xchg   %ax,%ax

0010d0d0 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
  10d0d0:	55                   	push   %ebp
  10d0d1:	89 e5                	mov    %esp,%ebp
  10d0d3:	53                   	push   %ebx
  10d0d4:	57                   	push   %edi
  10d0d5:	56                   	push   %esi
  10d0d6:	83 ec 18             	sub    $0x18,%esp
  10d0d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10d0dc:	89 c1                	mov    %eax,%ecx
  10d0de:	8a 55 14             	mov    0x14(%ebp),%dl
  10d0e1:	8d 75 10             	lea    0x10(%ebp),%esi
  10d0e4:	8d 7d 0c             	lea    0xc(%ebp),%edi
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
  10d0e7:	0f b6 5f 02          	movzbl 0x2(%edi),%ebx
  10d0eb:	0f b7 db             	movzwl %bx,%ebx
  10d0ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10d0f1:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  10d0f5:	0f af d8             	imul   %eax,%ebx
  10d0f8:	0f b6 46 02          	movzbl 0x2(%esi),%eax
  10d0fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10d0ff:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  10d103:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10d106:	b8 ff 00 00 00       	mov    $0xff,%eax
  10d10b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10d10e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10d111:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10d114:	29 c8                	sub    %ecx,%eax
  10d116:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10d119:	0f af c8             	imul   %eax,%ecx
  10d11c:	01 cb                	add    %ecx,%ebx
  10d11e:	0f b7 c3             	movzwl %bx,%eax
  10d121:	c1 f8 08             	sar    $0x8,%eax
  10d124:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10d127:	88 41 02             	mov    %al,0x2(%ecx)
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
  10d12a:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  10d12e:	0f b7 c0             	movzwl %ax,%eax
  10d131:	0f b6 5d 14          	movzbl 0x14(%ebp),%ebx
  10d135:	0f af c3             	imul   %ebx,%eax
  10d138:	0f b6 5e 01          	movzbl 0x1(%esi),%ebx
  10d13c:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  10d140:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10d143:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10d146:	29 c8                	sub    %ecx,%eax
  10d148:	0f af d8             	imul   %eax,%ebx
  10d14b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10d14e:	01 d8                	add    %ebx,%eax
  10d150:	0f b7 c8             	movzwl %ax,%ecx
  10d153:	c1 f9 08             	sar    $0x8,%ecx
  10d156:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10d159:	88 4b 01             	mov    %cl,0x1(%ebx)
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
  10d15c:	0f b6 3f             	movzbl (%edi),%edi
  10d15f:	0f b7 cf             	movzwl %di,%ecx
  10d162:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  10d166:	0f af c8             	imul   %eax,%ecx
  10d169:	0f b6 06             	movzbl (%esi),%eax
  10d16c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  10d170:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  10d173:	29 f7                	sub    %esi,%edi
  10d175:	0f af c7             	imul   %edi,%eax
  10d178:	01 c1                	add    %eax,%ecx
  10d17a:	0f b7 c1             	movzwl %cx,%eax
  10d17d:	c1 f8 08             	sar    $0x8,%eax
  10d180:	88 03                	mov    %al,(%ebx)
#if LV_COLOR_DEPTH == 32
    ret.ch.alpha = 0xFF;
  10d182:	c6 43 03 ff          	movb   $0xff,0x3(%ebx)
  10d186:	8b 45 e0             	mov    -0x20(%ebp),%eax
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
  10d189:	83 c4 18             	add    $0x18,%esp
  10d18c:	5e                   	pop    %esi
  10d18d:	5f                   	pop    %edi
  10d18e:	5b                   	pop    %ebx
  10d18f:	5d                   	pop    %ebp
  10d190:	c2 04 00             	ret    $0x4
  10d193:	66 90                	xchg   %ax,%ax
  10d195:	66 90                	xchg   %ax,%ax
  10d197:	66 90                	xchg   %ax,%ax
  10d199:	66 90                	xchg   %ax,%ax
  10d19b:	66 90                	xchg   %ax,%ax
  10d19d:	66 90                	xchg   %ax,%ax
  10d19f:	90                   	nop

0010d1a0 <lv_color_to32>:
{
  10d1a0:	55                   	push   %ebp
  10d1a1:	89 e5                	mov    %esp,%ebp
  10d1a3:	8d 45 08             	lea    0x8(%ebp),%eax
    return color.full;
  10d1a6:	8b 00                	mov    (%eax),%eax
  10d1a8:	5d                   	pop    %ebp
  10d1a9:	c3                   	ret    
  10d1aa:	66 90                	xchg   %ax,%ax
  10d1ac:	66 90                	xchg   %ax,%ax
  10d1ae:	66 90                	xchg   %ax,%ax

0010d1b0 <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
  10d1b0:	55                   	push   %ebp
  10d1b1:	89 e5                	mov    %esp,%ebp
  10d1b3:	53                   	push   %ebx
  10d1b4:	57                   	push   %edi
  10d1b5:	56                   	push   %esi
  10d1b6:	83 e4 f8             	and    $0xfffffff8,%esp
  10d1b9:	83 ec 40             	sub    $0x40,%esp
  10d1bc:	8b 45 10             	mov    0x10(%ebp),%eax
  10d1bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10d1c2:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *display_dev = (struct device *)disp_drv->user_data;
  10d1c5:	8b 75 08             	mov    0x8(%ebp),%esi
  10d1c8:	8b 76 20             	mov    0x20(%esi),%esi
  10d1cb:	89 74 24 38          	mov    %esi,0x38(%esp)
	u16_t w = area->x2 - area->x1 + 1;
  10d1cf:	8b 75 0c             	mov    0xc(%ebp),%esi
  10d1d2:	0f bf 76 04          	movswl 0x4(%esi),%esi
  10d1d6:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10d1d9:	0f bf 3f             	movswl (%edi),%edi
  10d1dc:	29 fe                	sub    %edi,%esi
  10d1de:	83 c6 01             	add    $0x1,%esi
  10d1e1:	66 89 74 24 36       	mov    %si,0x36(%esp)
	u16_t h = area->y2 - area->y1 + 1;
  10d1e6:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10d1e9:	0f bf 7f 06          	movswl 0x6(%edi),%edi
  10d1ed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10d1f0:	0f bf 5b 02          	movswl 0x2(%ebx),%ebx
  10d1f4:	29 df                	sub    %ebx,%edi
  10d1f6:	83 c7 01             	add    $0x1,%edi
  10d1f9:	66 89 7c 24 34       	mov    %di,0x34(%esp)
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
  10d1fe:	0f b7 5c 24 36       	movzwl 0x36(%esp),%ebx
  10d203:	c1 e3 02             	shl    $0x2,%ebx
  10d206:	0f b7 74 24 34       	movzwl 0x34(%esp),%esi
  10d20b:	0f af de             	imul   %esi,%ebx
  10d20e:	89 5c 24 28          	mov    %ebx,0x28(%esp)
	desc.width = w;
  10d212:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10d217:	66 89 7c 24 2c       	mov    %di,0x2c(%esp)
	desc.pitch = w;
  10d21c:	66 8b 7c 24 36       	mov    0x36(%esp),%di
  10d221:	66 89 7c 24 30       	mov    %di,0x30(%esp)
	desc.height = h;
  10d226:	66 8b 7c 24 34       	mov    0x34(%esp),%di
  10d22b:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
  10d230:	8b 74 24 38          	mov    0x38(%esp),%esi
  10d234:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10d237:	66 8b 3b             	mov    (%ebx),%di
  10d23a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10d23d:	66 8b 5b 02          	mov    0x2(%ebx),%bx
  10d241:	89 44 24 24          	mov    %eax,0x24(%esp)
  10d245:	8b 45 10             	mov    0x10(%ebp),%eax
  10d248:	89 34 24             	mov    %esi,(%esp)
  10d24b:	0f b7 f7             	movzwl %di,%esi
  10d24e:	89 74 24 04          	mov    %esi,0x4(%esp)
  10d252:	0f b7 f3             	movzwl %bx,%esi
  10d255:	89 74 24 08          	mov    %esi,0x8(%esp)
  10d259:	8d 74 24 28          	lea    0x28(%esp),%esi
  10d25d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10d261:	89 44 24 10          	mov    %eax,0x10(%esp)
  10d265:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  10d269:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  10d26d:	e8 1e 00 00 00       	call   10d290 <display_write>

	lv_disp_flush_ready(disp_drv);
  10d272:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d275:	89 0c 24             	mov    %ecx,(%esp)
  10d278:	89 44 24 18          	mov    %eax,0x18(%esp)
  10d27c:	e8 0f a6 00 00       	call   117890 <lv_disp_flush_ready>
}
  10d281:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d284:	5e                   	pop    %esi
  10d285:	5f                   	pop    %edi
  10d286:	5b                   	pop    %ebx
  10d287:	5d                   	pop    %ebp
  10d288:	c3                   	ret    
  10d289:	66 90                	xchg   %ax,%ax
  10d28b:	66 90                	xchg   %ax,%ax
  10d28d:	66 90                	xchg   %ax,%ax
  10d28f:	90                   	nop

0010d290 <display_write>:
{
  10d290:	55                   	push   %ebp
  10d291:	89 e5                	mov    %esp,%ebp
  10d293:	53                   	push   %ebx
  10d294:	57                   	push   %edi
  10d295:	56                   	push   %esi
  10d296:	83 ec 38             	sub    $0x38,%esp
  10d299:	8b 45 18             	mov    0x18(%ebp),%eax
  10d29c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10d29f:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10d2a3:	66 8b 75 0c          	mov    0xc(%ebp),%si
  10d2a7:	8b 7d 08             	mov    0x8(%ebp),%edi
		(struct display_driver_api *)dev->driver_api;
  10d2aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10d2ad:	8b 5b 04             	mov    0x4(%ebx),%ebx
	struct display_driver_api *api =
  10d2b0:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	return api->write(dev, x, y, desc, buf);
  10d2b3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10d2b6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  10d2b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10d2bc:	8b 45 08             	mov    0x8(%ebp),%eax
  10d2bf:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
  10d2c3:	66 8b 55 0c          	mov    0xc(%ebp),%dx
  10d2c7:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
  10d2cb:	66 8b 55 10          	mov    0x10(%ebp),%dx
  10d2cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10d2d2:	8b 45 14             	mov    0x14(%ebp),%eax
  10d2d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10d2d8:	8b 45 18             	mov    0x18(%ebp),%eax
  10d2db:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10d2de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10d2e1:	89 04 24             	mov    %eax,(%esp)
  10d2e4:	66 8b 45 e8          	mov    -0x18(%ebp),%ax
  10d2e8:	0f b7 c0             	movzwl %ax,%eax
  10d2eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d2ef:	0f b7 c2             	movzwl %dx,%eax
  10d2f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d2f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10d2f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10d2fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10d300:	89 44 24 10          	mov    %eax,0x10(%esp)
  10d304:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10d307:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  10d30b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  10d30e:	ff d3                	call   *%ebx
  10d310:	83 c4 38             	add    $0x38,%esp
  10d313:	5e                   	pop    %esi
  10d314:	5f                   	pop    %edi
  10d315:	5b                   	pop    %ebx
  10d316:	5d                   	pop    %ebp
  10d317:	c3                   	ret    
  10d318:	66 90                	xchg   %ax,%ax
  10d31a:	66 90                	xchg   %ax,%ax
  10d31c:	66 90                	xchg   %ax,%ax
  10d31e:	66 90                	xchg   %ax,%ax

0010d320 <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_BUFFER_ALLOC_STATIC */

static int lvgl_init(struct device *dev)
{
  10d320:	55                   	push   %ebp
  10d321:	89 e5                	mov    %esp,%ebp
  10d323:	83 e4 f8             	and    $0xfffffff8,%esp
  10d326:	83 ec 58             	sub    $0x58,%esp
  10d329:	8b 45 08             	mov    0x8(%ebp),%eax
	ARG_UNUSED(dev);

	struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
  10d32c:	8d 0d c4 36 12 00    	lea    0x1236c4,%ecx
  10d332:	89 0c 24             	mov    %ecx,(%esp)
  10d335:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10d339:	e8 02 03 00 00       	call   10d640 <device_get_binding>
	struct device *display_dev =
  10d33e:	89 44 24 50          	mov    %eax,0x50(%esp)
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
  10d342:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
  10d347:	0f 85 d1 00 00 00    	jne    10d41e <lvgl_init+0xfe>
		LOG_ERR("Display device not found.");
  10d34d:	e9 00 00 00 00       	jmp    10d352 <lvgl_init+0x32>
  10d352:	e8 09 03 00 00       	call   10d660 <_is_user_context>
  10d357:	24 01                	and    $0x1,%al
  10d359:	88 44 24 27          	mov    %al,0x27(%esp)
  10d35d:	f6 44 24 27 01       	testb  $0x1,0x27(%esp)
  10d362:	0f 85 0f 00 00 00    	jne    10d377 <lvgl_init+0x57>
  10d368:	b0 01                	mov    $0x1,%al
  10d36a:	a8 01                	test   $0x1,%al
  10d36c:	0f 85 05 00 00 00    	jne    10d377 <lvgl_init+0x57>
  10d372:	e9 95 00 00 00       	jmp    10d40c <lvgl_init+0xec>
  10d377:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  10d37c:	66 83 e0 f8          	and    $0xfff8,%ax
  10d380:	66 83 c8 01          	or     $0x1,%ax
  10d384:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  10d389:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  10d38e:	66 83 e0 c7          	and    $0xffc7,%ax
  10d392:	66 89 44 24 20       	mov    %ax,0x20(%esp)
  10d397:	8b 0d 24 30 14 00    	mov    0x143024,%ecx
  10d39d:	89 0c 24             	mov    %ecx,(%esp)
  10d3a0:	e8 cb 02 00 00       	call   10d670 <log_const_source_id>
  10d3a5:	66 8b 54 24 20       	mov    0x20(%esp),%dx
  10d3aa:	66 25 ff 03          	and    $0x3ff,%ax
  10d3ae:	66 c1 e0 06          	shl    $0x6,%ax
  10d3b2:	66 83 e2 3f          	and    $0x3f,%dx
  10d3b6:	66 09 c2             	or     %ax,%dx
  10d3b9:	66 89 54 24 20       	mov    %dx,0x20(%esp)
  10d3be:	f6 44 24 27 01       	testb  $0x1,0x27(%esp)
  10d3c3:	0f 84 1f 00 00 00    	je     10d3e8 <lvgl_init+0xc8>
  10d3c9:	8d 44 24 20          	lea    0x20(%esp),%eax
  10d3cd:	66 8b 08             	mov    (%eax),%cx
  10d3d0:	66 89 0c 24          	mov    %cx,(%esp)
  10d3d4:	8d 05 11 3b 12 00    	lea    0x123b11,%eax
  10d3da:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d3de:	e8 5d 6c ff ff       	call   104040 <log_from_user>
  10d3e3:	e9 1a 00 00 00       	jmp    10d402 <lvgl_init+0xe2>
  10d3e8:	8d 05 11 3b 12 00    	lea    0x123b11,%eax
  10d3ee:	89 04 24             	mov    %eax,(%esp)
  10d3f1:	8d 44 24 20          	lea    0x20(%esp),%eax
  10d3f5:	66 8b 08             	mov    (%eax),%cx
  10d3f8:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10d3fd:	e8 9e 5d ff ff       	call   1031a0 <log_0>
  10d402:	e9 00 00 00 00       	jmp    10d407 <lvgl_init+0xe7>
  10d407:	e9 00 00 00 00       	jmp    10d40c <lvgl_init+0xec>
  10d40c:	e9 00 00 00 00       	jmp    10d411 <lvgl_init+0xf1>
		return -ENODEV;
  10d411:	c7 44 24 54 ed ff ff 	movl   $0xffffffed,0x54(%esp)
  10d418:	ff 
  10d419:	e9 0b 02 00 00       	jmp    10d629 <lvgl_init+0x309>
	}

#if CONFIG_LVGL_LOG_LEVEL != 0
	lv_log_register_print_cb(lvgl_log);
  10d41e:	8d 05 90 d6 10 00    	lea    0x10d690,%eax
  10d424:	89 04 24             	mov    %eax,(%esp)
  10d427:	e8 f4 c5 00 00       	call   119a20 <lv_log_register_print_cb>
#endif

	lv_init();
  10d42c:	e8 7f 09 00 00       	call   10ddb0 <lv_init>

#ifdef CONFIG_LVGL_FILESYSTEM
	lvgl_fs_init();
#endif

	lv_disp_drv_init(&disp_drv);
  10d431:	8d 44 24 28          	lea    0x28(%esp),%eax
  10d435:	89 04 24             	mov    %eax,(%esp)
  10d438:	e8 c3 9f 00 00       	call   117400 <lv_disp_drv_init>
	disp_drv.user_data = (void *) display_dev;
  10d43d:	8b 44 24 50          	mov    0x50(%esp),%eax
  10d441:	89 44 24 48          	mov    %eax,0x48(%esp)

	lvgl_allocate_rendering_buffers(&disp_drv);
  10d445:	8d 44 24 28          	lea    0x28(%esp),%eax
  10d449:	89 04 24             	mov    %eax,(%esp)
  10d44c:	e8 0f 04 00 00       	call   10d860 <lvgl_allocate_rendering_buffers>

	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
  10d451:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  10d455:	89 0c 24             	mov    %ecx,(%esp)
  10d458:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d45c:	e8 7f f1 ff ff       	call   10c5e0 <set_lvgl_rendering_cb>
  10d461:	83 f8 00             	cmp    $0x0,%eax
  10d464:	0f 84 d1 00 00 00    	je     10d53b <lvgl_init+0x21b>
		LOG_ERR("Display not supported.");
  10d46a:	e9 00 00 00 00       	jmp    10d46f <lvgl_init+0x14f>
  10d46f:	e8 ec 01 00 00       	call   10d660 <_is_user_context>
  10d474:	24 01                	and    $0x1,%al
  10d476:	88 44 24 1f          	mov    %al,0x1f(%esp)
  10d47a:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  10d47f:	0f 85 0f 00 00 00    	jne    10d494 <lvgl_init+0x174>
  10d485:	b0 01                	mov    $0x1,%al
  10d487:	a8 01                	test   $0x1,%al
  10d489:	0f 85 05 00 00 00    	jne    10d494 <lvgl_init+0x174>
  10d48f:	e9 95 00 00 00       	jmp    10d529 <lvgl_init+0x209>
  10d494:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  10d499:	66 83 e0 f8          	and    $0xfff8,%ax
  10d49d:	66 83 c8 01          	or     $0x1,%ax
  10d4a1:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  10d4a6:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  10d4ab:	66 83 e0 c7          	and    $0xffc7,%ax
  10d4af:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  10d4b4:	8b 0d 24 30 14 00    	mov    0x143024,%ecx
  10d4ba:	89 0c 24             	mov    %ecx,(%esp)
  10d4bd:	e8 ae 01 00 00       	call   10d670 <log_const_source_id>
  10d4c2:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  10d4c7:	66 25 ff 03          	and    $0x3ff,%ax
  10d4cb:	66 c1 e0 06          	shl    $0x6,%ax
  10d4cf:	66 83 e2 3f          	and    $0x3f,%dx
  10d4d3:	66 09 c2             	or     %ax,%dx
  10d4d6:	66 89 54 24 18       	mov    %dx,0x18(%esp)
  10d4db:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  10d4e0:	0f 84 1f 00 00 00    	je     10d505 <lvgl_init+0x1e5>
  10d4e6:	8d 44 24 18          	lea    0x18(%esp),%eax
  10d4ea:	66 8b 08             	mov    (%eax),%cx
  10d4ed:	66 89 0c 24          	mov    %cx,(%esp)
  10d4f1:	8d 05 2b 3b 12 00    	lea    0x123b2b,%eax
  10d4f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d4fb:	e8 40 6b ff ff       	call   104040 <log_from_user>
  10d500:	e9 1a 00 00 00       	jmp    10d51f <lvgl_init+0x1ff>
  10d505:	8d 05 2b 3b 12 00    	lea    0x123b2b,%eax
  10d50b:	89 04 24             	mov    %eax,(%esp)
  10d50e:	8d 44 24 18          	lea    0x18(%esp),%eax
  10d512:	66 8b 08             	mov    (%eax),%cx
  10d515:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10d51a:	e8 81 5c ff ff       	call   1031a0 <log_0>
  10d51f:	e9 00 00 00 00       	jmp    10d524 <lvgl_init+0x204>
  10d524:	e9 00 00 00 00       	jmp    10d529 <lvgl_init+0x209>
  10d529:	e9 00 00 00 00       	jmp    10d52e <lvgl_init+0x20e>
		return -ENOTSUP;
  10d52e:	c7 44 24 54 dd ff ff 	movl   $0xffffffdd,0x54(%esp)
  10d535:	ff 
  10d536:	e9 ee 00 00 00       	jmp    10d629 <lvgl_init+0x309>
	}

	if (lv_disp_drv_register(&disp_drv) == NULL) {
  10d53b:	8d 44 24 28          	lea    0x28(%esp),%eax
  10d53f:	89 04 24             	mov    %eax,(%esp)
  10d542:	e8 c9 9f 00 00       	call   117510 <lv_disp_drv_register>
  10d547:	83 f8 00             	cmp    $0x0,%eax
  10d54a:	0f 85 d1 00 00 00    	jne    10d621 <lvgl_init+0x301>
		LOG_ERR("Failed to register display device.");
  10d550:	e9 00 00 00 00       	jmp    10d555 <lvgl_init+0x235>
  10d555:	e8 06 01 00 00       	call   10d660 <_is_user_context>
  10d55a:	24 01                	and    $0x1,%al
  10d55c:	88 44 24 17          	mov    %al,0x17(%esp)
  10d560:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  10d565:	0f 85 0f 00 00 00    	jne    10d57a <lvgl_init+0x25a>
  10d56b:	b0 01                	mov    $0x1,%al
  10d56d:	a8 01                	test   $0x1,%al
  10d56f:	0f 85 05 00 00 00    	jne    10d57a <lvgl_init+0x25a>
  10d575:	e9 95 00 00 00       	jmp    10d60f <lvgl_init+0x2ef>
  10d57a:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  10d57f:	66 83 e0 f8          	and    $0xfff8,%ax
  10d583:	66 83 c8 01          	or     $0x1,%ax
  10d587:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  10d58c:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  10d591:	66 83 e0 c7          	and    $0xffc7,%ax
  10d595:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  10d59a:	8b 0d 24 30 14 00    	mov    0x143024,%ecx
  10d5a0:	89 0c 24             	mov    %ecx,(%esp)
  10d5a3:	e8 c8 00 00 00       	call   10d670 <log_const_source_id>
  10d5a8:	66 8b 54 24 10       	mov    0x10(%esp),%dx
  10d5ad:	66 25 ff 03          	and    $0x3ff,%ax
  10d5b1:	66 c1 e0 06          	shl    $0x6,%ax
  10d5b5:	66 83 e2 3f          	and    $0x3f,%dx
  10d5b9:	66 09 c2             	or     %ax,%dx
  10d5bc:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  10d5c1:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  10d5c6:	0f 84 1f 00 00 00    	je     10d5eb <lvgl_init+0x2cb>
  10d5cc:	8d 44 24 10          	lea    0x10(%esp),%eax
  10d5d0:	66 8b 08             	mov    (%eax),%cx
  10d5d3:	66 89 0c 24          	mov    %cx,(%esp)
  10d5d7:	8d 05 42 3b 12 00    	lea    0x123b42,%eax
  10d5dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d5e1:	e8 5a 6a ff ff       	call   104040 <log_from_user>
  10d5e6:	e9 1a 00 00 00       	jmp    10d605 <lvgl_init+0x2e5>
  10d5eb:	8d 05 42 3b 12 00    	lea    0x123b42,%eax
  10d5f1:	89 04 24             	mov    %eax,(%esp)
  10d5f4:	8d 44 24 10          	lea    0x10(%esp),%eax
  10d5f8:	66 8b 08             	mov    (%eax),%cx
  10d5fb:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  10d600:	e8 9b 5b ff ff       	call   1031a0 <log_0>
  10d605:	e9 00 00 00 00       	jmp    10d60a <lvgl_init+0x2ea>
  10d60a:	e9 00 00 00 00       	jmp    10d60f <lvgl_init+0x2ef>
  10d60f:	e9 00 00 00 00       	jmp    10d614 <lvgl_init+0x2f4>
		return -EPERM;
  10d614:	c7 44 24 54 ff ff ff 	movl   $0xffffffff,0x54(%esp)
  10d61b:	ff 
  10d61c:	e9 08 00 00 00       	jmp    10d629 <lvgl_init+0x309>
	}

	return 0;
  10d621:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  10d628:	00 
}
  10d629:	8b 44 24 54          	mov    0x54(%esp),%eax
  10d62d:	89 ec                	mov    %ebp,%esp
  10d62f:	5d                   	pop    %ebp
  10d630:	c3                   	ret    
  10d631:	66 90                	xchg   %ax,%ax
  10d633:	66 90                	xchg   %ax,%ax
  10d635:	66 90                	xchg   %ax,%ax
  10d637:	66 90                	xchg   %ax,%ax
  10d639:	66 90                	xchg   %ax,%ax
  10d63b:	66 90                	xchg   %ax,%ax
  10d63d:	66 90                	xchg   %ax,%ax
  10d63f:	90                   	nop

0010d640 <device_get_binding>:
{
  10d640:	55                   	push   %ebp
  10d641:	89 e5                	mov    %esp,%ebp
  10d643:	50                   	push   %eax
  10d644:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_impl_device_get_binding(name);
  10d647:	8b 45 08             	mov    0x8(%ebp),%eax
  10d64a:	89 04 24             	mov    %eax,(%esp)
  10d64d:	e8 be f0 00 00       	call   11c710 <z_impl_device_get_binding>
  10d652:	83 c4 04             	add    $0x4,%esp
  10d655:	5d                   	pop    %ebp
  10d656:	c3                   	ret    
  10d657:	66 90                	xchg   %ax,%ax
  10d659:	66 90                	xchg   %ax,%ax
  10d65b:	66 90                	xchg   %ax,%ax
  10d65d:	66 90                	xchg   %ax,%ax
  10d65f:	90                   	nop

0010d660 <_is_user_context>:
{
  10d660:	55                   	push   %ebp
  10d661:	89 e5                	mov    %esp,%ebp
  10d663:	31 c0                	xor    %eax,%eax
	return false;
  10d665:	24 01                	and    $0x1,%al
  10d667:	0f b6 c0             	movzbl %al,%eax
  10d66a:	5d                   	pop    %ebp
  10d66b:	c3                   	ret    
  10d66c:	66 90                	xchg   %ax,%ax
  10d66e:	66 90                	xchg   %ax,%ax

0010d670 <log_const_source_id>:
{
  10d670:	55                   	push   %ebp
  10d671:	89 e5                	mov    %esp,%ebp
  10d673:	50                   	push   %eax
  10d674:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  10d677:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d67a:	8d 15 84 30 12 00    	lea    0x123084,%edx
  10d680:	29 d1                	sub    %edx,%ecx
  10d682:	c1 e9 03             	shr    $0x3,%ecx
  10d685:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10d688:	89 c8                	mov    %ecx,%eax
  10d68a:	83 c4 04             	add    $0x4,%esp
  10d68d:	5d                   	pop    %ebp
  10d68e:	c3                   	ret    
  10d68f:	90                   	nop

0010d690 <lvgl_log>:
{
  10d690:	55                   	push   %ebp
  10d691:	89 e5                	mov    %esp,%ebp
  10d693:	53                   	push   %ebx
  10d694:	57                   	push   %edi
  10d695:	56                   	push   %esi
  10d696:	83 e4 f8             	and    $0xfffffff8,%esp
  10d699:	83 ec 20             	sub    $0x20,%esp
  10d69c:	8b 45 14             	mov    0x14(%ebp),%eax
  10d69f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10d6a2:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d6a5:	8a 5d 08             	mov    0x8(%ebp),%bl
	u8_t zephyr_level = LOG_LEVEL_DBG - level;
  10d6a8:	0f be 75 08          	movsbl 0x8(%ebp),%esi
  10d6ac:	bf 04 00 00 00       	mov    $0x4,%edi
  10d6b1:	89 44 24 14          	mov    %eax,0x14(%esp)
  10d6b5:	89 f8                	mov    %edi,%eax
  10d6b7:	29 f0                	sub    %esi,%eax
  10d6b9:	88 44 24 1b          	mov    %al,0x1b(%esp)
	Z_LOG(zephyr_level, "%s", dsc);
  10d6bd:	e8 9e ff ff ff       	call   10d660 <_is_user_context>
  10d6c2:	24 01                	and    $0x1,%al
  10d6c4:	88 44 24 1a          	mov    %al,0x1a(%esp)
  10d6c8:	0f b6 4c 24 1b       	movzbl 0x1b(%esp),%ecx
  10d6cd:	83 f9 00             	cmp    $0x0,%ecx
  10d6d0:	0f 8e 1c 00 00 00    	jle    10d6f2 <lvgl_log+0x62>
  10d6d6:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
  10d6db:	83 f8 03             	cmp    $0x3,%eax
  10d6de:	0f 87 6e 01 00 00    	ja     10d852 <lvgl_log+0x1c2>
  10d6e4:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
  10d6e9:	83 f8 04             	cmp    $0x4,%eax
  10d6ec:	0f 8f 60 01 00 00    	jg     10d852 <lvgl_log+0x1c2>
  10d6f2:	f6 44 24 1a 01       	testb  $0x1,0x1a(%esp)
  10d6f7:	0f 85 0e 00 00 00    	jne    10d70b <lvgl_log+0x7b>
  10d6fd:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
  10d702:	83 f8 04             	cmp    $0x4,%eax
  10d705:	0f 8f 42 01 00 00    	jg     10d84d <lvgl_log+0x1bd>
  10d70b:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
  10d710:	66 8b 4c 24 18       	mov    0x18(%esp),%cx
  10d715:	66 83 e0 07          	and    $0x7,%ax
  10d719:	66 83 e1 f8          	and    $0xfff8,%cx
  10d71d:	66 09 c1             	or     %ax,%cx
  10d720:	66 89 4c 24 18       	mov    %cx,0x18(%esp)
  10d725:	66 8b 44 24 18       	mov    0x18(%esp),%ax
  10d72a:	66 83 e0 c7          	and    $0xffc7,%ax
  10d72e:	66 89 44 24 18       	mov    %ax,0x18(%esp)
  10d733:	8b 15 24 30 14 00    	mov    0x143024,%edx
  10d739:	89 14 24             	mov    %edx,(%esp)
  10d73c:	e8 2f ff ff ff       	call   10d670 <log_const_source_id>
  10d741:	66 8b 4c 24 18       	mov    0x18(%esp),%cx
  10d746:	66 25 ff 03          	and    $0x3ff,%ax
  10d74a:	66 c1 e0 06          	shl    $0x6,%ax
  10d74e:	66 83 e1 3f          	and    $0x3f,%cx
  10d752:	66 09 c1             	or     %ax,%cx
  10d755:	66 89 4c 24 18       	mov    %cx,0x18(%esp)
  10d75a:	0f b6 4c 24 1b       	movzbl 0x1b(%esp),%ecx
  10d75f:	ba 01 00 00 00       	mov    $0x1,%edx
  10d764:	d3 e2                	shl    %cl,%edx
  10d766:	83 e2 10             	and    $0x10,%edx
  10d769:	83 fa 00             	cmp    $0x0,%edx
  10d76c:	0f 84 75 00 00 00    	je     10d7e7 <lvgl_log+0x157>
  10d772:	e9 00 00 00 00       	jmp    10d777 <lvgl_log+0xe7>
  10d777:	f6 44 24 1a 01       	testb  $0x1,0x1a(%esp)
  10d77c:	0f 84 30 00 00 00    	je     10d7b2 <lvgl_log+0x122>
  10d782:	8b 45 14             	mov    0x14(%ebp),%eax
  10d785:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  10d789:	66 8b 11             	mov    (%ecx),%dx
  10d78c:	66 89 14 24          	mov    %dx,(%esp)
  10d790:	8d 0d 65 3b 12 00    	lea    0x123b65,%ecx
  10d796:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10d79a:	8d 0d 6c 3b 12 00    	lea    0x123b6c,%ecx
  10d7a0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10d7a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10d7a8:	e8 93 68 ff ff       	call   104040 <log_from_user>
  10d7ad:	e9 2b 00 00 00       	jmp    10d7dd <lvgl_log+0x14d>
  10d7b2:	8b 45 14             	mov    0x14(%ebp),%eax
  10d7b5:	8d 0d 65 3b 12 00    	lea    0x123b65,%ecx
  10d7bb:	89 0c 24             	mov    %ecx,(%esp)
  10d7be:	8d 0d 6c 3b 12 00    	lea    0x123b6c,%ecx
  10d7c4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10d7c8:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d7cc:	8d 44 24 18          	lea    0x18(%esp),%eax
  10d7d0:	66 8b 10             	mov    (%eax),%dx
  10d7d3:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
  10d7d8:	e8 43 5c ff ff       	call   103420 <log_2>
  10d7dd:	e9 00 00 00 00       	jmp    10d7e2 <lvgl_log+0x152>
  10d7e2:	e9 61 00 00 00       	jmp    10d848 <lvgl_log+0x1b8>
  10d7e7:	e9 00 00 00 00       	jmp    10d7ec <lvgl_log+0x15c>
  10d7ec:	f6 44 24 1a 01       	testb  $0x1,0x1a(%esp)
  10d7f1:	0f 84 26 00 00 00    	je     10d81d <lvgl_log+0x18d>
  10d7f7:	8b 45 14             	mov    0x14(%ebp),%eax
  10d7fa:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  10d7fe:	66 8b 11             	mov    (%ecx),%dx
  10d801:	66 89 14 24          	mov    %dx,(%esp)
  10d805:	8d 0d 91 39 12 00    	lea    0x123991,%ecx
  10d80b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10d80f:	89 44 24 08          	mov    %eax,0x8(%esp)
  10d813:	e8 28 68 ff ff       	call   104040 <log_from_user>
  10d818:	e9 21 00 00 00       	jmp    10d83e <lvgl_log+0x1ae>
  10d81d:	8b 45 14             	mov    0x14(%ebp),%eax
  10d820:	8d 0d 91 39 12 00    	lea    0x123991,%ecx
  10d826:	89 0c 24             	mov    %ecx,(%esp)
  10d829:	89 44 24 04          	mov    %eax,0x4(%esp)
  10d82d:	8d 44 24 18          	lea    0x18(%esp),%eax
  10d831:	66 8b 10             	mov    (%eax),%dx
  10d834:	66 89 54 24 08       	mov    %dx,0x8(%esp)
  10d839:	e8 22 5b ff ff       	call   103360 <log_1>
  10d83e:	e9 00 00 00 00       	jmp    10d843 <lvgl_log+0x1b3>
  10d843:	e9 00 00 00 00       	jmp    10d848 <lvgl_log+0x1b8>
  10d848:	e9 00 00 00 00       	jmp    10d84d <lvgl_log+0x1bd>
  10d84d:	e9 00 00 00 00       	jmp    10d852 <lvgl_log+0x1c2>
  10d852:	e9 00 00 00 00       	jmp    10d857 <lvgl_log+0x1c7>
}
  10d857:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d85a:	5e                   	pop    %esi
  10d85b:	5f                   	pop    %edi
  10d85c:	5b                   	pop    %ebx
  10d85d:	5d                   	pop    %ebp
  10d85e:	c3                   	ret    
  10d85f:	90                   	nop

0010d860 <lvgl_allocate_rendering_buffers>:
{
  10d860:	55                   	push   %ebp
  10d861:	89 e5                	mov    %esp,%ebp
  10d863:	56                   	push   %esi
  10d864:	83 ec 18             	sub    $0x18,%esp
  10d867:	8b 45 08             	mov    0x8(%ebp),%eax
  10d86a:	31 c9                	xor    %ecx,%ecx
	disp_drv->buffer = &disp_buf;
  10d86c:	8b 55 08             	mov    0x8(%ebp),%edx
  10d86f:	8d 35 2c 51 13 00    	lea    0x13512c,%esi
  10d875:	89 72 04             	mov    %esi,0x4(%edx)
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
  10d878:	8b 55 08             	mov    0x8(%ebp),%edx
  10d87b:	8b 52 04             	mov    0x4(%edx),%edx
  10d87e:	89 14 24             	mov    %edx,(%esp)
  10d881:	8d 15 e9 96 13 00    	lea    0x1396e9,%edx
  10d887:	89 54 24 04          	mov    %edx,0x4(%esp)
  10d88b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10d892:	00 
  10d893:	c7 44 24 0c 00 1e 00 	movl   $0x1e00,0xc(%esp)
  10d89a:	00 
  10d89b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10d89e:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10d8a1:	e8 fa 9b 00 00       	call   1174a0 <lv_disp_buf_init>
  10d8a6:	31 c0                	xor    %eax,%eax
	return 0;
  10d8a8:	83 c4 18             	add    $0x18,%esp
  10d8ab:	5e                   	pop    %esi
  10d8ac:	5d                   	pop    %ebp
  10d8ad:	c3                   	ret    
  10d8ae:	66 90                	xchg   %ax,%ax

0010d8b0 <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
  10d8b0:	55                   	push   %ebp
  10d8b1:	89 e5                	mov    %esp,%ebp
  10d8b3:	83 ec 48             	sub    $0x48,%esp
  10d8b6:	8b 45 08             	mov    0x8(%ebp),%eax
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  10d8b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d8bc:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d8bf:	89 4d d0             	mov    %ecx,-0x30(%ebp)
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  10d8c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d8c5:	8b 09                	mov    (%ecx),%ecx
  10d8c7:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d8ca:	89 4d cc             	mov    %ecx,-0x34(%ebp)

	unsigned int old_level;     /* old interrupt lock level */
	u8_t mdc = 0U;
  10d8cd:	c6 45 c7 00          	movb   $0x0,-0x39(%ebp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  10d8d1:	9c                   	pushf  
  10d8d2:	fa                   	cli    
  10d8d3:	8f 45 d4             	popl   -0x2c(%ebp)
	return key;
  10d8d6:	8b 4d d4             	mov    -0x2c(%ebp),%ecx

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0U;
#endif

	old_level = irq_lock();
  10d8d9:	89 4d c8             	mov    %ecx,-0x38(%ebp)
		OUTWORD(PCP(dev), pcp & ~PCP_UPDATE);
		OUTWORD(PCP(dev), pcp | PCP_UPDATE);
	}
#endif

	set_baud_rate(dev, dev_data->baud_rate);
  10d8dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d8df:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10d8e2:	8b 52 04             	mov    0x4(%edx),%edx
  10d8e5:	89 0c 24             	mov    %ecx,(%esp)
  10d8e8:	89 54 24 04          	mov    %edx,0x4(%esp)
  10d8ec:	89 45 c0             	mov    %eax,-0x40(%ebp)
  10d8ef:	e8 bc 00 00 00       	call   10d9b0 <set_baud_rate>

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  10d8f4:	8b 45 08             	mov    0x8(%ebp),%eax
  10d8f7:	8b 40 08             	mov    0x8(%eax),%eax
  10d8fa:	8b 00                	mov    (%eax),%eax
  10d8fc:	83 c0 03             	add    $0x3,%eax
  10d8ff:	c6 45 df 03          	movb   $0x3,-0x21(%ebp)
  10d903:	89 45 d8             	mov    %eax,-0x28(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10d906:	8a 45 df             	mov    -0x21(%ebp),%al
  10d909:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10d90c:	ee                   	out    %al,(%dx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
  10d90d:	c6 45 c7 0b          	movb   $0xb,-0x39(%ebp)
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE) {
  10d911:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10d914:	0f b6 49 08          	movzbl 0x8(%ecx),%ecx
  10d918:	83 e1 01             	and    $0x1,%ecx
  10d91b:	83 f9 01             	cmp    $0x1,%ecx
  10d91e:	0f 85 0a 00 00 00    	jne    10d92e <uart_ns16550_init+0x7e>
		mdc |= MCR_AFCE;
  10d924:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  10d928:	83 c8 20             	or     $0x20,%eax
  10d92b:	88 45 c7             	mov    %al,-0x39(%ebp)
	}

	OUTBYTE(MDC(dev), mdc);
  10d92e:	8a 45 c7             	mov    -0x39(%ebp),%al
  10d931:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d934:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d937:	8b 09                	mov    (%ecx),%ecx
  10d939:	83 c1 04             	add    $0x4,%ecx
  10d93c:	88 45 e7             	mov    %al,-0x19(%ebp)
  10d93f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10d942:	8a 45 e7             	mov    -0x19(%ebp),%al
  10d945:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10d948:	ee                   	out    %al,(%dx)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
  10d949:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d94c:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d94f:	8b 09                	mov    (%ecx),%ecx
  10d951:	83 c1 02             	add    $0x2,%ecx
  10d954:	c6 45 ee 87          	movb   $0x87,-0x12(%ebp)
  10d958:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10d95b:	8a 45 ee             	mov    -0x12(%ebp),%al
  10d95e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10d961:	ee                   	out    %al,(%dx)
		| FCR_FIFO_64
#endif
		);

	/* clear the port */
	INBYTE(RDR(dev));
  10d962:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d965:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d968:	8b 09                	mov    (%ecx),%ecx
  10d96a:	83 c1 00             	add    $0x0,%ecx
  10d96d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10d970:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10d973:	ec                   	in     (%dx),%al
  10d974:	88 45 ef             	mov    %al,-0x11(%ebp)

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
  10d977:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d97a:	8b 49 08             	mov    0x8(%ecx),%ecx
  10d97d:	8b 09                	mov    (%ecx),%ecx
  10d97f:	83 c1 01             	add    $0x1,%ecx
  10d982:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
  10d986:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10d989:	8a 45 fb             	mov    -0x5(%ebp),%al
  10d98c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10d98f:	ee                   	out    %al,(%dx)

	irq_unlock(old_level);
  10d990:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  10d993:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10d996:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10d999:	81 e1 00 02 00 00    	and    $0x200,%ecx
  10d99f:	83 f9 00             	cmp    $0x0,%ecx
  10d9a2:	0f 84 01 00 00 00    	je     10d9a9 <uart_ns16550_init+0xf9>
		__asm__ volatile ("sti" ::: "memory");
  10d9a8:	fb                   	sti    
  10d9a9:	31 c0                	xor    %eax,%eax

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
  10d9ab:	83 c4 48             	add    $0x48,%esp
  10d9ae:	5d                   	pop    %ebp
  10d9af:	c3                   	ret    

0010d9b0 <set_baud_rate>:
{
  10d9b0:	55                   	push   %ebp
  10d9b1:	89 e5                	mov    %esp,%ebp
  10d9b3:	56                   	push   %esi
  10d9b4:	83 ec 38             	sub    $0x38,%esp
  10d9b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d9ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  10d9bd:	8b 55 08             	mov    0x8(%ebp),%edx
  10d9c0:	8b 12                	mov    (%edx),%edx
  10d9c2:	8b 52 08             	mov    0x8(%edx),%edx
  10d9c5:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  10d9c8:	8b 55 08             	mov    0x8(%ebp),%edx
  10d9cb:	8b 52 08             	mov    0x8(%edx),%edx
  10d9ce:	89 55 cc             	mov    %edx,-0x34(%ebp)
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  10d9d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10d9d5:	0f 84 cc 00 00 00    	je     10daa7 <set_baud_rate+0xf7>
  10d9db:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10d9de:	83 38 00             	cmpl   $0x0,(%eax)
  10d9e1:	0f 84 c0 00 00 00    	je     10daa7 <set_baud_rate+0xf7>
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  10d9e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10d9ea:	8b 00                	mov    (%eax),%eax
  10d9ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10d9ef:	c1 e1 03             	shl    $0x3,%ecx
  10d9f2:	01 c8                	add    %ecx,%eax
					/ baud_rate) >> 4;
  10d9f4:	31 d2                	xor    %edx,%edx
  10d9f6:	f7 75 0c             	divl   0xc(%ebp)
  10d9f9:	c1 e8 04             	shr    $0x4,%eax
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  10d9fc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		lcr_cache = INBYTE(LCR(dev));
  10d9ff:	8b 45 08             	mov    0x8(%ebp),%eax
  10da02:	8b 40 08             	mov    0x8(%eax),%eax
  10da05:	8b 00                	mov    (%eax),%eax
  10da07:	83 c0 03             	add    $0x3,%eax
  10da0a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10da0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10da10:	89 c2                	mov    %eax,%edx
  10da12:	ec                   	in     (%dx),%al
  10da13:	88 45 d7             	mov    %al,-0x29(%ebp)
	return ret;
  10da16:	8a 45 d7             	mov    -0x29(%ebp),%al
  10da19:	88 45 c7             	mov    %al,-0x39(%ebp)
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
  10da1c:	0f b6 4d c7          	movzbl -0x39(%ebp),%ecx
  10da20:	81 c9 80 00 00 00    	or     $0x80,%ecx
  10da26:	8b 55 08             	mov    0x8(%ebp),%edx
  10da29:	8b 52 08             	mov    0x8(%edx),%edx
  10da2c:	8b 12                	mov    (%edx),%edx
  10da2e:	83 c2 03             	add    $0x3,%edx
  10da31:	88 4d e3             	mov    %cl,-0x1d(%ebp)
  10da34:	89 55 dc             	mov    %edx,-0x24(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10da37:	8a 45 e3             	mov    -0x1d(%ebp),%al
  10da3a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10da3d:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
  10da3e:	8b 55 c8             	mov    -0x38(%ebp),%edx
  10da41:	81 e2 ff 00 00 00    	and    $0xff,%edx
  10da47:	8b 75 08             	mov    0x8(%ebp),%esi
  10da4a:	8b 76 08             	mov    0x8(%esi),%esi
  10da4d:	8b 36                	mov    (%esi),%esi
  10da4f:	83 c6 00             	add    $0x0,%esi
  10da52:	88 55 eb             	mov    %dl,-0x15(%ebp)
  10da55:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  10da58:	8a 45 eb             	mov    -0x15(%ebp),%al
  10da5b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10da5e:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  10da5f:	8b 55 c8             	mov    -0x38(%ebp),%edx
  10da62:	c1 ea 08             	shr    $0x8,%edx
  10da65:	81 e2 ff 00 00 00    	and    $0xff,%edx
  10da6b:	8b 75 08             	mov    0x8(%ebp),%esi
  10da6e:	8b 76 08             	mov    0x8(%esi),%esi
  10da71:	8b 36                	mov    (%esi),%esi
  10da73:	83 c6 01             	add    $0x1,%esi
  10da76:	88 55 f3             	mov    %dl,-0xd(%ebp)
  10da79:	89 75 ec             	mov    %esi,-0x14(%ebp)
  10da7c:	8a 45 f3             	mov    -0xd(%ebp),%al
  10da7f:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10da82:	ee                   	out    %al,(%dx)
		OUTBYTE(LCR(dev), lcr_cache);
  10da83:	8a 45 c7             	mov    -0x39(%ebp),%al
  10da86:	8b 55 08             	mov    0x8(%ebp),%edx
  10da89:	8b 52 08             	mov    0x8(%edx),%edx
  10da8c:	8b 12                	mov    (%edx),%edx
  10da8e:	83 c2 03             	add    $0x3,%edx
  10da91:	88 45 fb             	mov    %al,-0x5(%ebp)
  10da94:	89 55 f4             	mov    %edx,-0xc(%ebp)
  10da97:	8a 45 fb             	mov    -0x5(%ebp),%al
  10da9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10da9d:	ee                   	out    %al,(%dx)
		dev_data->baud_rate = baud_rate;
  10da9e:	8b 55 0c             	mov    0xc(%ebp),%edx
  10daa1:	8b 75 cc             	mov    -0x34(%ebp),%esi
  10daa4:	89 56 04             	mov    %edx,0x4(%esi)
}
  10daa7:	83 c4 38             	add    $0x38,%esp
  10daaa:	5e                   	pop    %esi
  10daab:	5d                   	pop    %ebp
  10daac:	c3                   	ret    
  10daad:	66 90                	xchg   %ax,%ax
  10daaf:	90                   	nop

0010dab0 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  10dab0:	55                   	push   %ebp
  10dab1:	89 e5                	mov    %esp,%ebp
  10dab3:	83 ec 18             	sub    $0x18,%esp
  10dab6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10dab9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00) {
  10dabc:	8b 55 08             	mov    0x8(%ebp),%edx
  10dabf:	8b 52 08             	mov    0x8(%edx),%edx
  10dac2:	8b 12                	mov    (%edx),%edx
  10dac4:	83 c2 05             	add    $0x5,%edx
  10dac7:	89 55 f4             	mov    %edx,-0xc(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10daca:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10dacd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10dad0:	ec                   	in     (%dx),%al
  10dad1:	88 45 f3             	mov    %al,-0xd(%ebp)
  10dad4:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
  10dad8:	83 e2 01             	and    $0x1,%edx
  10dadb:	83 fa 00             	cmp    $0x0,%edx
  10dade:	0f 85 0c 00 00 00    	jne    10daf0 <uart_ns16550_poll_in+0x40>
		return (-1);
  10dae4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10daeb:	e9 24 00 00 00       	jmp    10db14 <uart_ns16550_poll_in+0x64>
	}

	/* got a character */
	*c = INBYTE(RDR(dev));
  10daf0:	8b 45 08             	mov    0x8(%ebp),%eax
  10daf3:	8b 40 08             	mov    0x8(%eax),%eax
  10daf6:	8b 00                	mov    (%eax),%eax
  10daf8:	83 c0 00             	add    $0x0,%eax
  10dafb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10dafe:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10db01:	ec                   	in     (%dx),%al
  10db02:	88 45 fb             	mov    %al,-0x5(%ebp)
	return ret;
  10db05:	8a 45 fb             	mov    -0x5(%ebp),%al
  10db08:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10db0b:	88 01                	mov    %al,(%ecx)

	return 0;
  10db0d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}
  10db14:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10db17:	83 c4 18             	add    $0x18,%esp
  10db1a:	5d                   	pop    %ebp
  10db1b:	c3                   	ret    
  10db1c:	66 90                	xchg   %ax,%ax
  10db1e:	66 90                	xchg   %ax,%ax

0010db20 <uart_ns16550_poll_out>:
 * @param dev UART device struct
 * @param c Character to send
 */
static void uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  10db20:	55                   	push   %ebp
  10db21:	89 e5                	mov    %esp,%ebp
  10db23:	83 ec 10             	sub    $0x10,%esp
  10db26:	8a 45 0c             	mov    0xc(%ebp),%al
  10db29:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
  10db2c:	8b 45 08             	mov    0x8(%ebp),%eax
  10db2f:	8b 40 08             	mov    0x8(%eax),%eax
  10db32:	8b 00                	mov    (%eax),%eax
  10db34:	83 c0 05             	add    $0x5,%eax
  10db37:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10db3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10db3d:	ec                   	in     (%dx),%al
  10db3e:	88 45 f3             	mov    %al,-0xd(%ebp)
  10db41:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
  10db45:	83 e1 20             	and    $0x20,%ecx
  10db48:	83 f9 00             	cmp    $0x0,%ecx
  10db4b:	0f 85 05 00 00 00    	jne    10db56 <uart_ns16550_poll_out+0x36>
  10db51:	e9 d6 ff ff ff       	jmp    10db2c <uart_ns16550_poll_out+0xc>
	}

	OUTBYTE(THR(dev), c);
  10db56:	8a 45 0c             	mov    0xc(%ebp),%al
  10db59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10db5c:	8b 49 08             	mov    0x8(%ecx),%ecx
  10db5f:	8b 09                	mov    (%ecx),%ecx
  10db61:	83 c1 00             	add    $0x0,%ecx
  10db64:	88 45 ff             	mov    %al,-0x1(%ebp)
  10db67:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10db6a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10db6d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10db70:	ee                   	out    %al,(%dx)
}
  10db71:	83 c4 10             	add    $0x10,%esp
  10db74:	5d                   	pop    %ebp
  10db75:	c3                   	ret    
  10db76:	66 90                	xchg   %ax,%ax
  10db78:	66 90                	xchg   %ax,%ax
  10db7a:	66 90                	xchg   %ax,%ax
  10db7c:	66 90                	xchg   %ax,%ax
  10db7e:	66 90                	xchg   %ax,%ax

0010db80 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  10db80:	55                   	push   %ebp
  10db81:	89 e5                	mov    %esp,%ebp
  10db83:	83 ec 0c             	sub    $0xc,%esp
  10db86:	8b 45 08             	mov    0x8(%ebp),%eax
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  10db89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10db8c:	8b 49 08             	mov    0x8(%ecx),%ecx
  10db8f:	8b 09                	mov    (%ecx),%ecx
  10db91:	83 c1 05             	add    $0x5,%ecx
  10db94:	89 4d fc             	mov    %ecx,-0x4(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10db97:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10db9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10db9d:	ec                   	in     (%dx),%al
  10db9e:	88 45 fb             	mov    %al,-0x5(%ebp)
  10dba1:	0f b6 4d fb          	movzbl -0x5(%ebp),%ecx
  10dba5:	83 e1 1e             	and    $0x1e,%ecx
  10dba8:	c1 f9 01             	sar    $0x1,%ecx
  10dbab:	89 c8                	mov    %ecx,%eax
  10dbad:	83 c4 0c             	add    $0xc,%esp
  10dbb0:	5d                   	pop    %ebp
  10dbb1:	c3                   	ret    
  10dbb2:	66 90                	xchg   %ax,%ax
  10dbb4:	66 90                	xchg   %ax,%ax
  10dbb6:	66 90                	xchg   %ax,%ax
  10dbb8:	66 90                	xchg   %ax,%ax
  10dbba:	66 90                	xchg   %ax,%ax
  10dbbc:	66 90                	xchg   %ax,%ax
  10dbbe:	66 90                	xchg   %ax,%ax

0010dbc0 <lv_indev_init>:

/**
 * Initialize the display input device subsystem
 */
void lv_indev_init(void)
{
  10dbc0:	55                   	push   %ebp
  10dbc1:	89 e5                	mov    %esp,%ebp
  10dbc3:	83 ec 08             	sub    $0x8,%esp
  10dbc6:	31 c0                	xor    %eax,%eax
    lv_indev_reset(NULL); /*Reset all input devices*/
  10dbc8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10dbcf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10dbd2:	e8 09 00 00 00       	call   10dbe0 <lv_indev_reset>
}
  10dbd7:	83 c4 08             	add    $0x8,%esp
  10dbda:	5d                   	pop    %ebp
  10dbdb:	c3                   	ret    
  10dbdc:	66 90                	xchg   %ax,%ax
  10dbde:	66 90                	xchg   %ax,%ax

0010dbe0 <lv_indev_reset>:
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
{
  10dbe0:	55                   	push   %ebp
  10dbe1:	89 e5                	mov    %esp,%ebp
  10dbe3:	83 ec 0c             	sub    $0xc,%esp
  10dbe6:	8b 45 08             	mov    0x8(%ebp),%eax
    if(indev)
  10dbe9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dbed:	0f 84 14 00 00 00    	je     10dc07 <lv_indev_reset+0x27>
        indev->proc.reset_query = 1;
  10dbf3:	8b 45 08             	mov    0x8(%ebp),%eax
  10dbf6:	8a 48 50             	mov    0x50(%eax),%cl
  10dbf9:	80 e1 fd             	and    $0xfd,%cl
  10dbfc:	80 c9 02             	or     $0x2,%cl
  10dbff:	88 48 50             	mov    %cl,0x50(%eax)
  10dc02:	e9 45 00 00 00       	jmp    10dc4c <lv_indev_reset+0x6c>
  10dc07:	31 c0                	xor    %eax,%eax
    else {
        lv_indev_t * i = lv_indev_get_next(NULL);
  10dc09:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10dc10:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10dc13:	e8 68 9d 00 00       	call   117980 <lv_indev_get_next>
  10dc18:	89 45 fc             	mov    %eax,-0x4(%ebp)
        while(i) {
  10dc1b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10dc1f:	0f 84 22 00 00 00    	je     10dc47 <lv_indev_reset+0x67>
            i->proc.reset_query = 1;
  10dc25:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10dc28:	8a 48 50             	mov    0x50(%eax),%cl
  10dc2b:	80 e1 fd             	and    $0xfd,%cl
  10dc2e:	80 c9 02             	or     $0x2,%cl
  10dc31:	88 48 50             	mov    %cl,0x50(%eax)

            i = lv_indev_get_next(i);
  10dc34:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10dc37:	89 04 24             	mov    %eax,(%esp)
  10dc3a:	e8 41 9d 00 00       	call   117980 <lv_indev_get_next>
  10dc3f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        while(i) {
  10dc42:	e9 d4 ff ff ff       	jmp    10dc1b <lv_indev_reset+0x3b>
  10dc47:	e9 00 00 00 00       	jmp    10dc4c <lv_indev_reset+0x6c>
        }
    }
}
  10dc4c:	83 c4 0c             	add    $0xc,%esp
  10dc4f:	5d                   	pop    %ebp
  10dc50:	c3                   	ret    
  10dc51:	66 90                	xchg   %ax,%ax
  10dc53:	66 90                	xchg   %ax,%ax
  10dc55:	66 90                	xchg   %ax,%ax
  10dc57:	66 90                	xchg   %ax,%ax
  10dc59:	66 90                	xchg   %ax,%ax
  10dc5b:	66 90                	xchg   %ax,%ax
  10dc5d:	66 90                	xchg   %ax,%ax
  10dc5f:	90                   	nop

0010dc60 <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
  10dc60:	55                   	push   %ebp
  10dc61:	89 e5                	mov    %esp,%ebp
  10dc63:	83 ec 14             	sub    $0x14,%esp
  10dc66:	8b 45 08             	mov    0x8(%ebp),%eax
    if(!disp) disp = lv_disp_get_default();
  10dc69:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dc6d:	0f 85 08 00 00 00    	jne    10dc7b <lv_disp_get_scr_act+0x1b>
  10dc73:	e8 e8 9b 00 00       	call   117860 <lv_disp_get_default>
  10dc78:	89 45 08             	mov    %eax,0x8(%ebp)
    if(!disp) {
  10dc7b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dc7f:	0f 85 34 00 00 00    	jne    10dcb9 <lv_disp_get_scr_act+0x59>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
  10dc85:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10dc8c:	8d 05 7c 3b 12 00    	lea    0x123b7c,%eax
  10dc92:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dc96:	c7 44 24 08 2e 00 00 	movl   $0x2e,0x8(%esp)
  10dc9d:	00 
  10dc9e:	8d 05 c1 3b 12 00    	lea    0x123bc1,%eax
  10dca4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10dca8:	e8 93 bd 00 00       	call   119a40 <lv_log_add>
        return NULL;
  10dcad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10dcb4:	e9 09 00 00 00       	jmp    10dcc2 <lv_disp_get_scr_act+0x62>
    }

    return disp->act_scr;
  10dcb9:	8b 45 08             	mov    0x8(%ebp),%eax
  10dcbc:	8b 40 34             	mov    0x34(%eax),%eax
  10dcbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10dcc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10dcc5:	83 c4 14             	add    $0x14,%esp
  10dcc8:	5d                   	pop    %ebp
  10dcc9:	c3                   	ret    
  10dcca:	66 90                	xchg   %ax,%ax
  10dccc:	66 90                	xchg   %ax,%ax
  10dcce:	66 90                	xchg   %ax,%ax

0010dcd0 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
  10dcd0:	55                   	push   %ebp
  10dcd1:	89 e5                	mov    %esp,%ebp
  10dcd3:	83 ec 14             	sub    $0x14,%esp
  10dcd6:	8b 45 08             	mov    0x8(%ebp),%eax
    if(!disp) disp = lv_disp_get_default();
  10dcd9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dcdd:	0f 85 08 00 00 00    	jne    10dceb <lv_disp_get_layer_top+0x1b>
  10dce3:	e8 78 9b 00 00       	call   117860 <lv_disp_get_default>
  10dce8:	89 45 08             	mov    %eax,0x8(%ebp)
    if(!disp) {
  10dceb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dcef:	0f 85 34 00 00 00    	jne    10dd29 <lv_disp_get_layer_top+0x59>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
  10dcf5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10dcfc:	8d 05 7c 3b 12 00    	lea    0x123b7c,%eax
  10dd02:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dd06:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
  10dd0d:	00 
  10dd0e:	8d 05 f8 3b 12 00    	lea    0x123bf8,%eax
  10dd14:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10dd18:	e8 23 bd 00 00       	call   119a40 <lv_log_add>
        return NULL;
  10dd1d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10dd24:	e9 09 00 00 00       	jmp    10dd32 <lv_disp_get_layer_top+0x62>
    }

    return disp->top_layer;
  10dd29:	8b 45 08             	mov    0x8(%ebp),%eax
  10dd2c:	8b 40 38             	mov    0x38(%eax),%eax
  10dd2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10dd32:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10dd35:	83 c4 14             	add    $0x14,%esp
  10dd38:	5d                   	pop    %ebp
  10dd39:	c3                   	ret    
  10dd3a:	66 90                	xchg   %ax,%ax
  10dd3c:	66 90                	xchg   %ax,%ax
  10dd3e:	66 90                	xchg   %ax,%ax

0010dd40 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
  10dd40:	55                   	push   %ebp
  10dd41:	89 e5                	mov    %esp,%ebp
  10dd43:	83 ec 14             	sub    $0x14,%esp
  10dd46:	8b 45 08             	mov    0x8(%ebp),%eax
    if(!disp) disp = lv_disp_get_default();
  10dd49:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dd4d:	0f 85 08 00 00 00    	jne    10dd5b <lv_disp_get_layer_sys+0x1b>
  10dd53:	e8 08 9b 00 00       	call   117860 <lv_disp_get_default>
  10dd58:	89 45 08             	mov    %eax,0x8(%ebp)
    if(!disp) {
  10dd5b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10dd5f:	0f 85 34 00 00 00    	jne    10dd99 <lv_disp_get_layer_sys+0x59>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
  10dd65:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10dd6c:	8d 05 7c 3b 12 00    	lea    0x123b7c,%eax
  10dd72:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dd76:	c7 44 24 08 5c 00 00 	movl   $0x5c,0x8(%esp)
  10dd7d:	00 
  10dd7e:	8d 05 31 3c 12 00    	lea    0x123c31,%eax
  10dd84:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10dd88:	e8 b3 bc 00 00       	call   119a40 <lv_log_add>
        return NULL;
  10dd8d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10dd94:	e9 09 00 00 00       	jmp    10dda2 <lv_disp_get_layer_sys+0x62>
    }

    return disp->sys_layer;
  10dd99:	8b 45 08             	mov    0x8(%ebp),%eax
  10dd9c:	8b 40 3c             	mov    0x3c(%eax),%eax
  10dd9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10dda2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10dda5:	83 c4 14             	add    $0x14,%esp
  10dda8:	5d                   	pop    %ebp
  10dda9:	c3                   	ret    
  10ddaa:	66 90                	xchg   %ax,%ax
  10ddac:	66 90                	xchg   %ax,%ax
  10ddae:	66 90                	xchg   %ax,%ax

0010ddb0 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
  10ddb0:	55                   	push   %ebp
  10ddb1:	89 e5                	mov    %esp,%ebp
  10ddb3:	83 ec 10             	sub    $0x10,%esp
    /* Do nothing if already initialized */
    if(lv_initialized) {
  10ddb6:	f6 05 e9 0e 14 00 01 	testb  $0x1,0x140ee9
  10ddbd:	0f 84 2d 00 00 00    	je     10ddf0 <lv_init+0x40>
        LV_LOG_WARN("lv_init: already inited");
  10ddc3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10ddca:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10ddd0:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ddd4:	c7 44 24 08 4f 00 00 	movl   $0x4f,0x8(%esp)
  10dddb:	00 
  10dddc:	8d 05 72 3d 12 00    	lea    0x123d72,%eax
  10dde2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10dde6:	e8 55 bc 00 00       	call   119a40 <lv_log_add>
        return;
  10ddeb:	e9 85 00 00 00       	jmp    10de75 <lv_init+0xc5>
    }

    LV_LOG_TRACE("lv_init started");

    /*Initialize the lv_misc modules*/
    lv_mem_init();
  10ddf0:	e8 5b a9 00 00       	call   118750 <lv_mem_init>
    lv_task_core_init();
  10ddf5:	e8 46 a1 00 00       	call   117f40 <lv_task_core_init>
#if LV_USE_GROUP
    lv_group_init();
#endif

    /*Init. the sstyles*/
    lv_style_init();
  10ddfa:	e8 c1 30 00 00       	call   110ec0 <lv_style_init>

    /*Initialize the screen refresh system*/
    lv_refr_init();
  10ddff:	e8 9c 1e 00 00       	call   10fca0 <lv_refr_init>

    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
  10de04:	8d 05 88 55 13 00    	lea    0x135588,%eax
  10de0a:	89 04 24             	mov    %eax,(%esp)
  10de0d:	c7 44 24 04 68 01 00 	movl   $0x168,0x4(%esp)
  10de14:	00 
  10de15:	e8 56 ac 00 00       	call   118a70 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
  10de1a:	8d 05 94 55 13 00    	lea    0x135594,%eax
  10de20:	89 04 24             	mov    %eax,(%esp)
  10de23:	c7 44 24 04 60 00 00 	movl   $0x60,0x4(%esp)
  10de2a:	00 
  10de2b:	e8 40 ac 00 00       	call   118a70 <lv_ll_init>

    /*Init the input device handling*/
    lv_indev_init();
  10de30:	e8 8b fd ff ff       	call   10dbc0 <lv_indev_init>

    lv_img_decoder_init();
  10de35:	e8 a6 81 00 00       	call   115fe0 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
  10de3a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10de41:	e8 8a 93 00 00       	call   1171d0 <lv_img_cache_set_size>

    lv_initialized = true;
  10de46:	c6 05 e9 0e 14 00 01 	movb   $0x1,0x140ee9
    LV_LOG_INFO("lv_init ready");
  10de4d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10de54:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10de5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10de5e:	c7 44 24 08 75 00 00 	movl   $0x75,0x8(%esp)
  10de65:	00 
  10de66:	8d 05 8a 3d 12 00    	lea    0x123d8a,%eax
  10de6c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10de70:	e8 cb bb 00 00       	call   119a40 <lv_log_add>
}
  10de75:	83 c4 10             	add    $0x10,%esp
  10de78:	5d                   	pop    %ebp
  10de79:	c3                   	ret    
  10de7a:	66 90                	xchg   %ax,%ax
  10de7c:	66 90                	xchg   %ax,%ax
  10de7e:	66 90                	xchg   %ax,%ax

0010de80 <lv_obj_create>:
 *                  If NULL then a screen will be created
 * @param copy pointer to a base object, if not NULL then the new object will be copied from it
 * @return pointer to the new object
 */
lv_obj_t * lv_obj_create(lv_obj_t * parent, const lv_obj_t * copy)
{
  10de80:	55                   	push   %ebp
  10de81:	89 e5                	mov    %esp,%ebp
  10de83:	53                   	push   %ebx
  10de84:	57                   	push   %edi
  10de85:	56                   	push   %esi
  10de86:	83 ec 4c             	sub    $0x4c,%esp
  10de89:	8b 45 0c             	mov    0xc(%ebp),%eax
  10de8c:	8b 4d 08             	mov    0x8(%ebp),%ecx

    lv_obj_t * new_obj = NULL;
  10de8f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    /*Create a screen if the parent is NULL*/
    if(parent == NULL) {
  10de96:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10de9a:	0f 85 70 02 00 00    	jne    10e110 <lv_obj_create+0x290>
        LV_LOG_TRACE("Screen create started");
        lv_disp_t * disp = lv_disp_get_default();
  10dea0:	e8 bb 99 00 00       	call   117860 <lv_disp_get_default>
  10dea5:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(!disp) {
  10dea8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  10deac:	0f 85 34 00 00 00    	jne    10dee6 <lv_obj_create+0x66>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
  10deb2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10deb9:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10debf:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dec3:	c7 44 24 08 8c 00 00 	movl   $0x8c,0x8(%esp)
  10deca:	00 
  10decb:	8d 05 98 3d 12 00    	lea    0x123d98,%eax
  10ded1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10ded5:	e8 66 bb 00 00       	call   119a40 <lv_log_add>
            return NULL;
  10deda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10dee1:	e9 0c 07 00 00       	jmp    10e5f2 <lv_obj_create+0x772>
        }

        new_obj = lv_ll_ins_head(&disp->scr_ll);
  10dee6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10dee9:	83 c0 28             	add    $0x28,%eax
  10deec:	89 04 24             	mov    %eax,(%esp)
  10deef:	e8 cc ab 00 00       	call   118ac0 <lv_ll_ins_head>
  10def4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        lv_mem_assert(new_obj);
  10def7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10defb:	0f 85 2d 00 00 00    	jne    10df2e <lv_obj_create+0xae>
  10df01:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10df08:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10df0e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10df12:	c7 44 24 08 91 00 00 	movl   $0x91,0x8(%esp)
  10df19:	00 
  10df1a:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  10df20:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10df24:	e8 17 bb 00 00       	call   119a40 <lv_log_add>
  10df29:	e9 fb ff ff ff       	jmp    10df29 <lv_obj_create+0xa9>
        if(new_obj == NULL) return NULL;
  10df2e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10df32:	0f 85 0c 00 00 00    	jne    10df44 <lv_obj_create+0xc4>
  10df38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10df3f:	e9 ae 06 00 00       	jmp    10e5f2 <lv_obj_create+0x772>

        new_obj->par = NULL; /*Screens has no a parent*/
  10df44:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10df47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
  10df4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10df50:	83 c0 04             	add    $0x4,%eax
  10df53:	89 04 24             	mov    %eax,(%esp)
  10df56:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  10df5d:	00 
  10df5e:	e8 0d ab 00 00       	call   118a70 <lv_ll_init>
  10df63:	31 c0                	xor    %eax,%eax

        /*Set coordinates to full screen size*/
        new_obj->coords.x1    = 0;
  10df65:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10df68:	66 c7 41 10 00 00    	movw   $0x0,0x10(%ecx)
        new_obj->coords.y1    = 0;
  10df6e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10df71:	66 c7 41 12 00 00    	movw   $0x0,0x12(%ecx)
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
  10df77:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10df7e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10df81:	e8 fa 97 00 00       	call   117780 <lv_disp_get_hor_res>
  10df86:	31 c9                	xor    %ecx,%ecx
  10df88:	0f bf d0             	movswl %ax,%edx
  10df8b:	83 ea 01             	sub    $0x1,%edx
  10df8e:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10df91:	66 89 56 14          	mov    %dx,0x14(%esi)
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
  10df95:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10df9c:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10df9f:	e8 4c 98 00 00       	call   1177f0 <lv_disp_get_ver_res>
  10dfa4:	0f bf c8             	movswl %ax,%ecx
  10dfa7:	83 e9 01             	sub    $0x1,%ecx
  10dfaa:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10dfad:	66 89 4e 16          	mov    %cx,0x16(%esi)
        new_obj->ext_draw_pad = 0;
  10dfb1:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10dfb4:	66 c7 46 30 00 00    	movw   $0x0,0x30(%esi)
        new_obj->realign.base         = NULL;
        new_obj->realign.auto_realign = 0;
#endif

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
  10dfba:	e8 b1 dd 00 00       	call   11bd70 <lv_theme_get_current>
  10dfbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(th) {
  10dfc2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  10dfc6:	0f 84 10 00 00 00    	je     10dfdc <lv_obj_create+0x15c>
            new_obj->style_p = th->style.scr;
  10dfcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10dfcf:	8b 00                	mov    (%eax),%eax
  10dfd1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10dfd4:	89 41 28             	mov    %eax,0x28(%ecx)
        } else {
  10dfd7:	e9 0c 00 00 00       	jmp    10dfe8 <lv_obj_create+0x168>
            new_obj->style_p = &lv_style_scr;
  10dfdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10dfdf:	8d 0d 50 51 13 00    	lea    0x135150,%ecx
  10dfe5:	89 48 28             	mov    %ecx,0x28(%eax)
        }
        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
  10dfe8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10dfeb:	89 04 24             	mov    %eax,(%esp)
  10dfee:	8d 05 20 e6 10 00    	lea    0x10e620,%eax
  10dff4:	89 44 24 04          	mov    %eax,0x4(%esp)
  10dff8:	e8 03 06 00 00       	call   10e600 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
  10dffd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e000:	89 04 24             	mov    %eax,(%esp)
  10e003:	8d 05 30 e7 10 00    	lea    0x10e730,%eax
  10e009:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e00d:	e8 fe 06 00 00       	call   10e710 <lv_obj_set_design_cb>
  10e012:	31 c0                	xor    %eax,%eax
        new_obj->event_cb = NULL;
  10e014:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e017:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%ecx)

        /*Init. user date*/
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
  10e01e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e021:	83 c1 34             	add    $0x34,%ecx
  10e024:	89 0c 24             	mov    %ecx,(%esp)
  10e027:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10e02e:	00 
  10e02f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10e036:	00 
  10e037:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10e03a:	e8 31 c4 ff ff       	call   10a470 <memset>

#if LV_USE_GROUP
        new_obj->group_p = NULL;
#endif
        /*Set attributes*/
        new_obj->click        = 0;
  10e03f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e042:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e046:	66 83 e2 fe          	and    $0xfffe,%dx
  10e04a:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag         = 0;
  10e04e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e051:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e055:	66 83 e2 fd          	and    $0xfffd,%dx
  10e059:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag_throw   = 0;
  10e05d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e060:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e064:	66 83 e2 fb          	and    $0xfffb,%dx
  10e068:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag_parent  = 0;
  10e06c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e06f:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e073:	66 83 e2 f7          	and    $0xfff7,%dx
  10e077:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->hidden       = 0;
  10e07b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e07e:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e082:	66 83 e2 ef          	and    $0xffef,%dx
  10e086:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->top          = 0;
  10e08a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e08d:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e091:	66 83 e2 df          	and    $0xffdf,%dx
  10e095:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->protect      = LV_PROTECT_NONE;
  10e099:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e09c:	c6 41 2e 00          	movb   $0x0,0x2e(%ecx)
        new_obj->opa_scale_en = 0;
  10e0a0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e0a3:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e0a7:	66 83 e2 bf          	and    $0xffbf,%dx
  10e0ab:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->opa_scale    = LV_OPA_COVER;
  10e0af:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e0b2:	c6 41 2f ff          	movb   $0xff,0x2f(%ecx)
        new_obj->parent_event = 0;
  10e0b6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e0b9:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e0bd:	66 81 e2 7f ff       	and    $0xff7f,%dx
  10e0c2:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->reserved     = 0;
  10e0c6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e0c9:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e0cd:	66 81 e2 ff 03       	and    $0x3ff,%dx
  10e0d2:	66 89 51 2c          	mov    %dx,0x2c(%ecx)

        new_obj->ext_attr = NULL;
  10e0d6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e0d9:	c7 41 24 00 00 00 00 	movl   $0x0,0x24(%ecx)

        LV_LOG_INFO("Screen create ready");
  10e0e0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e0e7:	8d 0d 2e 3d 12 00    	lea    0x123d2e,%ecx
  10e0ed:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e0f1:	c7 44 24 08 d3 00 00 	movl   $0xd3,0x8(%esp)
  10e0f8:	00 
  10e0f9:	8d 0d f7 3d 12 00    	lea    0x123df7,%ecx
  10e0ff:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10e103:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10e106:	e8 35 b9 00 00       	call   119a40 <lv_log_add>
    }
  10e10b:	e9 f3 01 00 00       	jmp    10e303 <lv_obj_create+0x483>
    /*parent != NULL create normal obj. on a parent*/
    else {
        LV_LOG_TRACE("Object create started");

        new_obj = lv_ll_ins_head(&parent->child_ll);
  10e110:	8b 45 08             	mov    0x8(%ebp),%eax
  10e113:	83 c0 04             	add    $0x4,%eax
  10e116:	89 04 24             	mov    %eax,(%esp)
  10e119:	e8 a2 a9 00 00       	call   118ac0 <lv_ll_ins_head>
  10e11e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        lv_mem_assert(new_obj);
  10e121:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10e125:	0f 85 2d 00 00 00    	jne    10e158 <lv_obj_create+0x2d8>
  10e12b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10e132:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10e138:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e13c:	c7 44 24 08 da 00 00 	movl   $0xda,0x8(%esp)
  10e143:	00 
  10e144:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  10e14a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10e14e:	e8 ed b8 00 00       	call   119a40 <lv_log_add>
  10e153:	e9 fb ff ff ff       	jmp    10e153 <lv_obj_create+0x2d3>
        if(new_obj == NULL) return NULL;
  10e158:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10e15c:	0f 85 0c 00 00 00    	jne    10e16e <lv_obj_create+0x2ee>
  10e162:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10e169:	e9 84 04 00 00       	jmp    10e5f2 <lv_obj_create+0x772>

        new_obj->par = parent; /*Set the parent*/
  10e16e:	8b 45 08             	mov    0x8(%ebp),%eax
  10e171:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e174:	89 01                	mov    %eax,(%ecx)
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
  10e176:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e179:	83 c0 04             	add    $0x4,%eax
  10e17c:	89 04 24             	mov    %eax,(%esp)
  10e17f:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  10e186:	00 
  10e187:	e8 e4 a8 00 00       	call   118a70 <lv_ll_init>

        /*Set coordinates left top corner of parent*/
        new_obj->coords.x1    = parent->coords.x1;
  10e18c:	8b 45 08             	mov    0x8(%ebp),%eax
  10e18f:	66 8b 50 10          	mov    0x10(%eax),%dx
  10e193:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e196:	66 89 50 10          	mov    %dx,0x10(%eax)
        new_obj->coords.y1    = parent->coords.y1;
  10e19a:	8b 45 08             	mov    0x8(%ebp),%eax
  10e19d:	66 8b 50 12          	mov    0x12(%eax),%dx
  10e1a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e1a4:	66 89 50 12          	mov    %dx,0x12(%eax)
        new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
  10e1a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10e1ab:	0f bf 40 10          	movswl 0x10(%eax),%eax
  10e1af:	83 c0 64             	add    $0x64,%eax
  10e1b2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e1b5:	66 89 41 14          	mov    %ax,0x14(%ecx)
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
  10e1b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e1bc:	0f bf 49 12          	movswl 0x12(%ecx),%ecx
  10e1c0:	83 c1 42             	add    $0x42,%ecx
  10e1c3:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10e1c6:	66 89 4e 16          	mov    %cx,0x16(%esi)
        new_obj->ext_draw_pad = 0;
  10e1ca:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10e1cd:	66 c7 46 30 00 00    	movw   $0x0,0x30(%esi)
        new_obj->realign.yofs         = 0;
        new_obj->realign.base         = NULL;
        new_obj->realign.auto_realign = 0;
#endif
        /*Set appearance*/
        lv_theme_t * th = lv_theme_get_current();
  10e1d3:	e8 98 db 00 00       	call   11bd70 <lv_theme_get_current>
  10e1d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(th) {
  10e1db:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  10e1df:	0f 84 11 00 00 00    	je     10e1f6 <lv_obj_create+0x376>
            new_obj->style_p = th->style.panel;
  10e1e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10e1e8:	8b 40 08             	mov    0x8(%eax),%eax
  10e1eb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e1ee:	89 41 28             	mov    %eax,0x28(%ecx)
        } else {
  10e1f1:	e9 0c 00 00 00       	jmp    10e202 <lv_obj_create+0x382>
            new_obj->style_p = &lv_style_plain_color;
  10e1f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e1f9:	8d 0d f0 51 13 00    	lea    0x1351f0,%ecx
  10e1ff:	89 48 28             	mov    %ecx,0x28(%eax)
        }

        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
  10e202:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e205:	89 04 24             	mov    %eax,(%esp)
  10e208:	8d 05 20 e6 10 00    	lea    0x10e620,%eax
  10e20e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e212:	e8 e9 03 00 00       	call   10e600 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
  10e217:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e21a:	89 04 24             	mov    %eax,(%esp)
  10e21d:	8d 05 30 e7 10 00    	lea    0x10e730,%eax
  10e223:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e227:	e8 e4 04 00 00       	call   10e710 <lv_obj_set_design_cb>
  10e22c:	31 c0                	xor    %eax,%eax
        new_obj->event_cb = NULL;
  10e22e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e231:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%ecx)
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init. user date*/
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
  10e238:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e23b:	83 c1 34             	add    $0x34,%ecx
  10e23e:	89 0c 24             	mov    %ecx,(%esp)
  10e241:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10e248:	00 
  10e249:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10e250:	00 
  10e251:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10e254:	e8 17 c2 ff ff       	call   10a470 <memset>
#if LV_USE_GROUP
        new_obj->group_p = NULL;
#endif

        /*Set attributes*/
        new_obj->click        = 1;
  10e259:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e25c:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e260:	66 83 e2 fe          	and    $0xfffe,%dx
  10e264:	66 83 ca 01          	or     $0x1,%dx
  10e268:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag         = 0;
  10e26c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e26f:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e273:	66 83 e2 fd          	and    $0xfffd,%dx
  10e277:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag_dir     = LV_DRAG_DIR_ALL;
  10e27b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e27e:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e282:	66 81 e2 ff fc       	and    $0xfcff,%dx
  10e287:	66 81 ca 00 03       	or     $0x300,%dx
  10e28c:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag_throw   = 0;
  10e290:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e293:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e297:	66 83 e2 fb          	and    $0xfffb,%dx
  10e29b:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->drag_parent  = 0;
  10e29f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2a2:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e2a6:	66 83 e2 f7          	and    $0xfff7,%dx
  10e2aa:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->hidden       = 0;
  10e2ae:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2b1:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e2b5:	66 83 e2 ef          	and    $0xffef,%dx
  10e2b9:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->top          = 0;
  10e2bd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2c0:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e2c4:	66 83 e2 df          	and    $0xffdf,%dx
  10e2c8:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->protect      = LV_PROTECT_NONE;
  10e2cc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2cf:	c6 41 2e 00          	movb   $0x0,0x2e(%ecx)
        new_obj->opa_scale    = LV_OPA_COVER;
  10e2d3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2d6:	c6 41 2f ff          	movb   $0xff,0x2f(%ecx)
        new_obj->opa_scale_en = 0;
  10e2da:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2dd:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e2e1:	66 83 e2 bf          	and    $0xffbf,%dx
  10e2e5:	66 89 51 2c          	mov    %dx,0x2c(%ecx)
        new_obj->parent_event = 0;
  10e2e9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2ec:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e2f0:	66 81 e2 7f ff       	and    $0xff7f,%dx
  10e2f5:	66 89 51 2c          	mov    %dx,0x2c(%ecx)

        new_obj->ext_attr = NULL;
  10e2f9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e2fc:	c7 41 24 00 00 00 00 	movl   $0x0,0x24(%ecx)
    }

    /*Copy the attributes if required*/
    if(copy != NULL) {
  10e303:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10e307:	0f 84 aa 02 00 00    	je     10e5b7 <lv_obj_create+0x737>
        lv_area_copy(&new_obj->coords, &copy->coords);
  10e30d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e310:	83 c0 10             	add    $0x10,%eax
  10e313:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e316:	83 c1 10             	add    $0x10,%ecx
  10e319:	89 04 24             	mov    %eax,(%esp)
  10e31c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e320:	e8 fb 05 00 00       	call   10e920 <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
  10e325:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e328:	66 8b 50 30          	mov    0x30(%eax),%dx
  10e32c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e32f:	66 89 50 30          	mov    %dx,0x30(%eax)
        new_obj->ext_click_pad_ver = copy->ext_click_pad_ver;
#endif

        /*Set free data*/
#if LV_USE_USER_DATA
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
  10e333:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e336:	83 c0 34             	add    $0x34,%eax
  10e339:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e33c:	83 c1 34             	add    $0x34,%ecx
  10e33f:	89 04 24             	mov    %eax,(%esp)
  10e342:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e346:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10e34d:	00 
  10e34e:	e8 fd bf ff ff       	call   10a350 <memcpy>
        new_obj->realign.auto_realign = copy->realign.auto_realign;
#endif

        /*Only copy the `event_cb`. `signal_cb` and `design_cb` will be copied the the derived
         * object type (e.g. `lv_btn`)*/
        new_obj->event_cb = copy->event_cb;
  10e353:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e356:	8b 49 18             	mov    0x18(%ecx),%ecx
  10e359:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10e35c:	89 4e 18             	mov    %ecx,0x18(%esi)

        /*Copy attributes*/
        new_obj->click        = copy->click;
  10e35f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e362:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e366:	66 83 e2 01          	and    $0x1,%dx
  10e36a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e36d:	0f b6 f2             	movzbl %dl,%esi
  10e370:	66 8b 79 2c          	mov    0x2c(%ecx),%di
  10e374:	66 83 e6 01          	and    $0x1,%si
  10e378:	66 83 e7 fe          	and    $0xfffe,%di
  10e37c:	66 09 f7             	or     %si,%di
  10e37f:	66 89 79 2c          	mov    %di,0x2c(%ecx)
        new_obj->drag         = copy->drag;
  10e383:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e386:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e38a:	66 c1 ee 01          	shr    $0x1,%si
  10e38e:	66 89 f3             	mov    %si,%bx
  10e391:	66 83 e3 01          	and    $0x1,%bx
  10e395:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e398:	0f b6 d3             	movzbl %bl,%edx
  10e39b:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e39f:	66 83 e2 01          	and    $0x1,%dx
  10e3a3:	66 c1 e2 01          	shl    $0x1,%dx
  10e3a7:	66 83 e6 fd          	and    $0xfffd,%si
  10e3ab:	66 09 d6             	or     %dx,%si
  10e3ae:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->drag_dir     = copy->drag_dir;
  10e3b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e3b5:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e3b9:	66 c1 ea 08          	shr    $0x8,%dx
  10e3bd:	66 83 e2 03          	and    $0x3,%dx
  10e3c1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e3c4:	0f b6 d2             	movzbl %dl,%edx
  10e3c7:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e3cb:	66 83 e2 03          	and    $0x3,%dx
  10e3cf:	66 c1 e2 08          	shl    $0x8,%dx
  10e3d3:	66 81 e6 ff fc       	and    $0xfcff,%si
  10e3d8:	66 09 d6             	or     %dx,%si
  10e3db:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->drag_throw   = copy->drag_throw;
  10e3df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e3e2:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e3e6:	66 c1 ea 02          	shr    $0x2,%dx
  10e3ea:	66 83 e2 01          	and    $0x1,%dx
  10e3ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e3f1:	0f b6 d2             	movzbl %dl,%edx
  10e3f4:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e3f8:	66 83 e2 01          	and    $0x1,%dx
  10e3fc:	66 c1 e2 02          	shl    $0x2,%dx
  10e400:	66 83 e6 fb          	and    $0xfffb,%si
  10e404:	66 09 d6             	or     %dx,%si
  10e407:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->drag_parent  = copy->drag_parent;
  10e40b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e40e:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e412:	66 c1 ea 03          	shr    $0x3,%dx
  10e416:	66 83 e2 01          	and    $0x1,%dx
  10e41a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e41d:	0f b6 d2             	movzbl %dl,%edx
  10e420:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e424:	66 83 e2 01          	and    $0x1,%dx
  10e428:	66 c1 e2 03          	shl    $0x3,%dx
  10e42c:	66 83 e6 f7          	and    $0xfff7,%si
  10e430:	66 09 d6             	or     %dx,%si
  10e433:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->hidden       = copy->hidden;
  10e437:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e43a:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e43e:	66 c1 ea 04          	shr    $0x4,%dx
  10e442:	66 83 e2 01          	and    $0x1,%dx
  10e446:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e449:	0f b6 d2             	movzbl %dl,%edx
  10e44c:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e450:	66 83 e2 01          	and    $0x1,%dx
  10e454:	66 c1 e2 04          	shl    $0x4,%dx
  10e458:	66 83 e6 ef          	and    $0xffef,%si
  10e45c:	66 09 d6             	or     %dx,%si
  10e45f:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->top          = copy->top;
  10e463:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e466:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e46a:	66 c1 ea 05          	shr    $0x5,%dx
  10e46e:	66 83 e2 01          	and    $0x1,%dx
  10e472:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e475:	0f b6 d2             	movzbl %dl,%edx
  10e478:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e47c:	66 83 e2 01          	and    $0x1,%dx
  10e480:	66 c1 e2 05          	shl    $0x5,%dx
  10e484:	66 83 e6 df          	and    $0xffdf,%si
  10e488:	66 09 d6             	or     %dx,%si
  10e48b:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->parent_event = copy->parent_event;
  10e48f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e492:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e496:	66 c1 ea 07          	shr    $0x7,%dx
  10e49a:	66 83 e2 01          	and    $0x1,%dx
  10e49e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e4a1:	0f b6 d2             	movzbl %dl,%edx
  10e4a4:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e4a8:	66 83 e2 01          	and    $0x1,%dx
  10e4ac:	66 c1 e2 07          	shl    $0x7,%dx
  10e4b0:	66 81 e6 7f ff       	and    $0xff7f,%si
  10e4b5:	66 09 d6             	or     %dx,%si
  10e4b8:	66 89 71 2c          	mov    %si,0x2c(%ecx)

        new_obj->opa_scale_en = copy->opa_scale_en;
  10e4bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e4bf:	66 8b 51 2c          	mov    0x2c(%ecx),%dx
  10e4c3:	66 c1 ea 06          	shr    $0x6,%dx
  10e4c7:	66 83 e2 01          	and    $0x1,%dx
  10e4cb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e4ce:	0f b6 d2             	movzbl %dl,%edx
  10e4d1:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10e4d5:	66 83 e2 01          	and    $0x1,%dx
  10e4d9:	66 c1 e2 06          	shl    $0x6,%dx
  10e4dd:	66 83 e6 bf          	and    $0xffbf,%si
  10e4e1:	66 09 d6             	or     %dx,%si
  10e4e4:	66 89 71 2c          	mov    %si,0x2c(%ecx)
        new_obj->protect      = copy->protect;
  10e4e8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e4eb:	8a 59 2e             	mov    0x2e(%ecx),%bl
  10e4ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e4f1:	88 59 2e             	mov    %bl,0x2e(%ecx)
        new_obj->opa_scale    = copy->opa_scale;
  10e4f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e4f7:	8a 59 2f             	mov    0x2f(%ecx),%bl
  10e4fa:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e4fd:	88 59 2f             	mov    %bl,0x2f(%ecx)

        new_obj->style_p = copy->style_p;
  10e500:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e503:	8b 49 28             	mov    0x28(%ecx),%ecx
  10e506:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  10e509:	89 4b 28             	mov    %ecx,0x28(%ebx)
            lv_group_add_obj(copy->group_p, new_obj);
        }
#endif

        /*Set the same coordinates for non screen objects*/
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
  10e50c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e50f:	89 0c 24             	mov    %ecx,(%esp)
  10e512:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10e515:	e8 46 04 00 00       	call   10e960 <lv_obj_get_parent>
  10e51a:	83 f8 00             	cmp    $0x0,%eax
  10e51d:	0f 84 4c 00 00 00    	je     10e56f <lv_obj_create+0x6ef>
  10e523:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e527:	0f 84 42 00 00 00    	je     10e56f <lv_obj_create+0x6ef>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
  10e52d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e530:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e533:	89 0c 24             	mov    %ecx,(%esp)
  10e536:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  10e539:	e8 b2 05 00 00       	call   10eaf0 <lv_obj_get_x>
  10e53e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e541:	89 0c 24             	mov    %ecx,(%esp)
  10e544:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  10e548:	e8 e3 05 00 00       	call   10eb30 <lv_obj_get_y>
  10e54d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  10e550:	89 0c 24             	mov    %ecx,(%esp)
  10e553:	66 8b 55 c2          	mov    -0x3e(%ebp),%dx
  10e557:	0f bf ca             	movswl %dx,%ecx
  10e55a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e55e:	0f bf c8             	movswl %ax,%ecx
  10e561:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10e565:	e8 16 04 00 00       	call   10e980 <lv_obj_set_pos>
        } else {
  10e56a:	e9 20 00 00 00       	jmp    10e58f <lv_obj_create+0x70f>
  10e56f:	31 c0                	xor    %eax,%eax
            lv_obj_set_pos(new_obj, 0, 0);
  10e571:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e574:	89 0c 24             	mov    %ecx,(%esp)
  10e577:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10e57e:	00 
  10e57f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10e586:	00 
  10e587:	89 45 bc             	mov    %eax,-0x44(%ebp)
  10e58a:	e8 f1 03 00 00       	call   10e980 <lv_obj_set_pos>
        }

        LV_LOG_INFO("Object create ready");
  10e58f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10e596:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10e59c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e5a0:	c7 44 24 08 64 01 00 	movl   $0x164,0x8(%esp)
  10e5a7:	00 
  10e5a8:	8d 05 0b 3e 12 00    	lea    0x123e0b,%eax
  10e5ae:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10e5b2:	e8 89 b4 00 00       	call   119a40 <lv_log_add>
    }

    /*Send a signal to the parent to notify it about the new child*/
    if(parent != NULL) {
  10e5b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10e5bb:	0f 84 2b 00 00 00    	je     10e5ec <lv_obj_create+0x76c>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
  10e5c1:	8b 45 08             	mov    0x8(%ebp),%eax
  10e5c4:	8b 40 1c             	mov    0x1c(%eax),%eax
  10e5c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e5ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10e5cd:	89 0c 24             	mov    %ecx,(%esp)
  10e5d0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10e5d7:	00 
  10e5d8:	89 54 24 08          	mov    %edx,0x8(%esp)
  10e5dc:	ff d0                	call   *%eax

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(new_obj);
  10e5de:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10e5e1:	89 0c 24             	mov    %ecx,(%esp)
  10e5e4:	88 45 bb             	mov    %al,-0x45(%ebp)
  10e5e7:	e8 84 05 00 00       	call   10eb70 <lv_obj_invalidate>
    }

    return new_obj;
  10e5ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10e5ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
}
  10e5f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10e5f5:	83 c4 4c             	add    $0x4c,%esp
  10e5f8:	5e                   	pop    %esi
  10e5f9:	5f                   	pop    %edi
  10e5fa:	5b                   	pop    %ebx
  10e5fb:	5d                   	pop    %ebp
  10e5fc:	c3                   	ret    
  10e5fd:	66 90                	xchg   %ax,%ax
  10e5ff:	90                   	nop

0010e600 <lv_obj_set_signal_cb>:
 * Always call the previous signal function in the new.
 * @param obj pointer to an object
 * @param cb the new signal function
 */
void lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)
{
  10e600:	55                   	push   %ebp
  10e601:	89 e5                	mov    %esp,%ebp
  10e603:	56                   	push   %esi
  10e604:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e607:	8b 4d 08             	mov    0x8(%ebp),%ecx
    obj->signal_cb = signal_cb;
  10e60a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10e60d:	8b 75 08             	mov    0x8(%ebp),%esi
  10e610:	89 56 1c             	mov    %edx,0x1c(%esi)
}
  10e613:	5e                   	pop    %esi
  10e614:	5d                   	pop    %ebp
  10e615:	c3                   	ret    
  10e616:	66 90                	xchg   %ax,%ax
  10e618:	66 90                	xchg   %ax,%ax
  10e61a:	66 90                	xchg   %ax,%ax
  10e61c:	66 90                	xchg   %ax,%ax
  10e61e:	66 90                	xchg   %ax,%ax

0010e620 <lv_obj_signal>:
 * @param sign signal type
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
  10e620:	55                   	push   %ebp
  10e621:	89 e5                	mov    %esp,%ebp
  10e623:	56                   	push   %esi
  10e624:	83 ec 20             	sub    $0x20,%esp
  10e627:	8b 45 10             	mov    0x10(%ebp),%eax
  10e62a:	8a 4d 0c             	mov    0xc(%ebp),%cl
  10e62d:	8b 55 08             	mov    0x8(%ebp),%edx
    (void)param;

    lv_res_t res = LV_RES_OK;
  10e630:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)

    const lv_style_t * style = lv_obj_get_style(obj);
  10e634:	8b 75 08             	mov    0x8(%ebp),%esi
  10e637:	89 34 24             	mov    %esi,(%esp)
  10e63a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10e63d:	88 4d eb             	mov    %cl,-0x15(%ebp)
  10e640:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10e643:	e8 68 14 00 00       	call   10fab0 <lv_obj_get_style>
  10e648:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(sign == LV_SIGNAL_CHILD_CHG) {
  10e64b:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  10e64f:	83 f8 01             	cmp    $0x1,%eax
  10e652:	0f 85 2a 00 00 00    	jne    10e682 <lv_obj_signal+0x62>
        /*Return 'invalid' if the child change signal is not enabled*/
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
  10e658:	8b 45 08             	mov    0x8(%ebp),%eax
  10e65b:	89 04 24             	mov    %eax,(%esp)
  10e65e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10e665:	00 
  10e666:	e8 a5 15 00 00       	call   10fc10 <lv_obj_is_protected>
  10e66b:	24 01                	and    $0x1,%al
  10e66d:	0f b6 c8             	movzbl %al,%ecx
  10e670:	83 f9 00             	cmp    $0x0,%ecx
  10e673:	0f 84 04 00 00 00    	je     10e67d <lv_obj_signal+0x5d>
  10e679:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
  10e67d:	e9 80 00 00 00       	jmp    10e702 <lv_obj_signal+0xe2>
  10e682:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  10e686:	83 f8 05             	cmp    $0x5,%eax
  10e689:	0f 85 29 00 00 00    	jne    10e6b8 <lv_obj_signal+0x98>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
  10e68f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10e692:	0f bf 40 1c          	movswl 0x1c(%eax),%eax
  10e696:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e699:	0f bf 49 30          	movswl 0x30(%ecx),%ecx
  10e69d:	39 c8                	cmp    %ecx,%eax
  10e69f:	0f 8e 0e 00 00 00    	jle    10e6b3 <lv_obj_signal+0x93>
  10e6a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10e6a8:	66 8b 48 1c          	mov    0x1c(%eax),%cx
  10e6ac:	8b 45 08             	mov    0x8(%ebp),%eax
  10e6af:	66 89 48 30          	mov    %cx,0x30(%eax)
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
  10e6b3:	e9 45 00 00 00       	jmp    10e6fd <lv_obj_signal+0xdd>
  10e6b8:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  10e6bc:	83 f8 04             	cmp    $0x4,%eax
  10e6bf:	0f 85 10 00 00 00    	jne    10e6d5 <lv_obj_signal+0xb5>
        lv_obj_refresh_ext_draw_pad(obj);
  10e6c5:	8b 45 08             	mov    0x8(%ebp),%eax
  10e6c8:	89 04 24             	mov    %eax,(%esp)
  10e6cb:	e8 90 13 00 00       	call   10fa60 <lv_obj_refresh_ext_draw_pad>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
  10e6d0:	e9 23 00 00 00       	jmp    10e6f8 <lv_obj_signal+0xd8>
  10e6d5:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  10e6d9:	83 f8 06             	cmp    $0x6,%eax
  10e6dc:	0f 85 11 00 00 00    	jne    10e6f3 <lv_obj_signal+0xd3>
        lv_obj_type_t * buf = param;
  10e6e2:	8b 45 10             	mov    0x10(%ebp),%eax
  10e6e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        buf->type[0]        = "lv_obj";
  10e6e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10e6eb:	8d 0d 04 3f 12 00    	lea    0x123f04,%ecx
  10e6f1:	89 08                	mov    %ecx,(%eax)
  10e6f3:	e9 00 00 00 00       	jmp    10e6f8 <lv_obj_signal+0xd8>
  10e6f8:	e9 00 00 00 00       	jmp    10e6fd <lv_obj_signal+0xdd>
  10e6fd:	e9 00 00 00 00       	jmp    10e702 <lv_obj_signal+0xe2>
    }

    return res;
  10e702:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  10e706:	83 c4 20             	add    $0x20,%esp
  10e709:	5e                   	pop    %esi
  10e70a:	5d                   	pop    %ebp
  10e70b:	c3                   	ret    
  10e70c:	66 90                	xchg   %ax,%ax
  10e70e:	66 90                	xchg   %ax,%ax

0010e710 <lv_obj_set_design_cb>:
{
  10e710:	55                   	push   %ebp
  10e711:	89 e5                	mov    %esp,%ebp
  10e713:	56                   	push   %esi
  10e714:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e717:	8b 4d 08             	mov    0x8(%ebp),%ecx
    obj->design_cb = design_cb;
  10e71a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10e71d:	8b 75 08             	mov    0x8(%ebp),%esi
  10e720:	89 56 20             	mov    %edx,0x20(%esi)
}
  10e723:	5e                   	pop    %esi
  10e724:	5d                   	pop    %ebp
  10e725:	c3                   	ret    
  10e726:	66 90                	xchg   %ax,%ax
  10e728:	66 90                	xchg   %ax,%ax
  10e72a:	66 90                	xchg   %ax,%ax
  10e72c:	66 90                	xchg   %ax,%ax
  10e72e:	66 90                	xchg   %ax,%ax

0010e730 <lv_obj_design>:
{
  10e730:	55                   	push   %ebp
  10e731:	89 e5                	mov    %esp,%ebp
  10e733:	56                   	push   %esi
  10e734:	83 e4 f8             	and    $0xfffffff8,%esp
  10e737:	83 ec 38             	sub    $0x38,%esp
  10e73a:	8a 45 10             	mov    0x10(%ebp),%al
  10e73d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e740:	8b 55 08             	mov    0x8(%ebp),%edx
    if(mode == LV_DESIGN_COVER_CHK) {
  10e743:	0f b6 75 10          	movzbl 0x10(%ebp),%esi
  10e747:	83 fe 02             	cmp    $0x2,%esi
  10e74a:	0f 85 45 01 00 00    	jne    10e895 <lv_obj_design+0x165>
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
  10e750:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e753:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e756:	83 c1 10             	add    $0x10,%ecx
  10e759:	89 04 24             	mov    %eax,(%esp)
  10e75c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e760:	e8 5b 97 00 00       	call   117ec0 <lv_area_is_in>
  10e765:	24 01                	and    $0x1,%al
  10e767:	0f b6 c8             	movzbl %al,%ecx
  10e76a:	83 f9 00             	cmp    $0x0,%ecx
  10e76d:	0f 85 0a 00 00 00    	jne    10e77d <lv_obj_design+0x4d>
  10e773:	c6 44 24 33 00       	movb   $0x0,0x33(%esp)
  10e778:	e9 85 01 00 00       	jmp    10e902 <lv_obj_design+0x1d2>
        const lv_style_t * style = lv_obj_get_style(obj);
  10e77d:	8b 45 08             	mov    0x8(%ebp),%eax
  10e780:	89 04 24             	mov    %eax,(%esp)
  10e783:	e8 28 13 00 00       	call   10fab0 <lv_obj_get_style>
  10e788:	89 44 24 2c          	mov    %eax,0x2c(%esp)
        if(style->body.opa < LV_OPA_MAX) return false;
  10e78c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10e790:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  10e794:	3d fb 00 00 00       	cmp    $0xfb,%eax
  10e799:	0f 8d 0a 00 00 00    	jge    10e7a9 <lv_obj_design+0x79>
  10e79f:	c6 44 24 33 00       	movb   $0x0,0x33(%esp)
  10e7a4:	e9 59 01 00 00       	jmp    10e902 <lv_obj_design+0x1d2>
        lv_coord_t r = style->body.radius;
  10e7a9:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10e7ad:	66 8b 48 0c          	mov    0xc(%eax),%cx
  10e7b1:	66 89 4c 24 2a       	mov    %cx,0x2a(%esp)
        if(r == LV_RADIUS_CIRCLE) return false;
  10e7b6:	0f bf 44 24 2a       	movswl 0x2a(%esp),%eax
  10e7bb:	3d 18 7c 00 00       	cmp    $0x7c18,%eax
  10e7c0:	0f 85 0a 00 00 00    	jne    10e7d0 <lv_obj_design+0xa0>
  10e7c6:	c6 44 24 33 00       	movb   $0x0,0x33(%esp)
  10e7cb:	e9 32 01 00 00       	jmp    10e902 <lv_obj_design+0x1d2>
        lv_obj_get_coords(obj, &area_tmp);
  10e7d0:	8b 45 08             	mov    0x8(%ebp),%eax
  10e7d3:	89 04 24             	mov    %eax,(%esp)
  10e7d6:	8d 44 24 20          	lea    0x20(%esp),%eax
  10e7da:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e7de:	e8 5d 07 00 00       	call   10ef40 <lv_obj_get_coords>
        area_tmp.x1 += r;
  10e7e3:	0f bf 44 24 2a       	movswl 0x2a(%esp),%eax
  10e7e8:	0f bf 4c 24 20       	movswl 0x20(%esp),%ecx
  10e7ed:	01 c1                	add    %eax,%ecx
  10e7ef:	66 89 4c 24 20       	mov    %cx,0x20(%esp)
        area_tmp.x2 -= r;
  10e7f4:	0f bf 44 24 2a       	movswl 0x2a(%esp),%eax
  10e7f9:	0f bf 54 24 24       	movswl 0x24(%esp),%edx
  10e7fe:	29 c2                	sub    %eax,%edx
  10e800:	66 89 54 24 24       	mov    %dx,0x24(%esp)
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
  10e805:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e808:	89 04 24             	mov    %eax,(%esp)
  10e80b:	8d 44 24 20          	lea    0x20(%esp),%eax
  10e80f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e813:	e8 a8 96 00 00       	call   117ec0 <lv_area_is_in>
  10e818:	24 01                	and    $0x1,%al
  10e81a:	0f b6 f0             	movzbl %al,%esi
  10e81d:	83 fe 00             	cmp    $0x0,%esi
  10e820:	0f 85 0a 00 00 00    	jne    10e830 <lv_obj_design+0x100>
  10e826:	c6 44 24 33 00       	movb   $0x0,0x33(%esp)
  10e82b:	e9 d2 00 00 00       	jmp    10e902 <lv_obj_design+0x1d2>
        lv_obj_get_coords(obj, &area_tmp);
  10e830:	8b 45 08             	mov    0x8(%ebp),%eax
  10e833:	89 04 24             	mov    %eax,(%esp)
  10e836:	8d 44 24 20          	lea    0x20(%esp),%eax
  10e83a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e83e:	e8 fd 06 00 00       	call   10ef40 <lv_obj_get_coords>
        area_tmp.y1 += r;
  10e843:	0f bf 44 24 2a       	movswl 0x2a(%esp),%eax
  10e848:	0f bf 4c 24 22       	movswl 0x22(%esp),%ecx
  10e84d:	01 c1                	add    %eax,%ecx
  10e84f:	66 89 4c 24 22       	mov    %cx,0x22(%esp)
        area_tmp.y2 -= r;
  10e854:	0f bf 44 24 2a       	movswl 0x2a(%esp),%eax
  10e859:	0f bf 54 24 26       	movswl 0x26(%esp),%edx
  10e85e:	29 c2                	sub    %eax,%edx
  10e860:	66 89 54 24 26       	mov    %dx,0x26(%esp)
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
  10e865:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e868:	89 04 24             	mov    %eax,(%esp)
  10e86b:	8d 44 24 20          	lea    0x20(%esp),%eax
  10e86f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10e873:	e8 48 96 00 00       	call   117ec0 <lv_area_is_in>
  10e878:	24 01                	and    $0x1,%al
  10e87a:	0f b6 f0             	movzbl %al,%esi
  10e87d:	83 fe 00             	cmp    $0x0,%esi
  10e880:	0f 85 0a 00 00 00    	jne    10e890 <lv_obj_design+0x160>
  10e886:	c6 44 24 33 00       	movb   $0x0,0x33(%esp)
  10e88b:	e9 72 00 00 00       	jmp    10e902 <lv_obj_design+0x1d2>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
  10e890:	e9 68 00 00 00       	jmp    10e8fd <lv_obj_design+0x1cd>
  10e895:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  10e899:	83 f8 00             	cmp    $0x0,%eax
  10e89c:	0f 85 56 00 00 00    	jne    10e8f8 <lv_obj_design+0x1c8>
        const lv_style_t * style = lv_obj_get_style(obj);
  10e8a2:	8b 45 08             	mov    0x8(%ebp),%eax
  10e8a5:	89 04 24             	mov    %eax,(%esp)
  10e8a8:	e8 03 12 00 00       	call   10fab0 <lv_obj_get_style>
  10e8ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
  10e8b1:	8b 45 08             	mov    0x8(%ebp),%eax
  10e8b4:	83 c0 10             	add    $0x10,%eax
  10e8b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10e8ba:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  10e8be:	8b 75 08             	mov    0x8(%ebp),%esi
  10e8c1:	89 34 24             	mov    %esi,(%esp)
  10e8c4:	89 44 24 18          	mov    %eax,0x18(%esp)
  10e8c8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10e8cc:	89 54 24 10          	mov    %edx,0x10(%esp)
  10e8d0:	e8 db 12 00 00       	call   10fbb0 <lv_obj_get_opa_scale>
  10e8d5:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10e8d9:	89 0c 24             	mov    %ecx,(%esp)
  10e8dc:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  10e8e0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10e8e4:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10e8e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10e8ec:	0f b6 c8             	movzbl %al,%ecx
  10e8ef:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  10e8f3:	e8 38 42 00 00       	call   112b30 <lv_draw_rect>
  10e8f8:	e9 00 00 00 00       	jmp    10e8fd <lv_obj_design+0x1cd>
    return true;
  10e8fd:	c6 44 24 33 01       	movb   $0x1,0x33(%esp)
}
  10e902:	8a 44 24 33          	mov    0x33(%esp),%al
  10e906:	24 01                	and    $0x1,%al
  10e908:	0f b6 c0             	movzbl %al,%eax
  10e90b:	8d 65 fc             	lea    -0x4(%ebp),%esp
  10e90e:	5e                   	pop    %esi
  10e90f:	5d                   	pop    %ebp
  10e910:	c3                   	ret    
  10e911:	66 90                	xchg   %ax,%ax
  10e913:	66 90                	xchg   %ax,%ax
  10e915:	66 90                	xchg   %ax,%ax
  10e917:	66 90                	xchg   %ax,%ax
  10e919:	66 90                	xchg   %ax,%ax
  10e91b:	66 90                	xchg   %ax,%ax
  10e91d:	66 90                	xchg   %ax,%ax
  10e91f:	90                   	nop

0010e920 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
  10e920:	55                   	push   %ebp
  10e921:	89 e5                	mov    %esp,%ebp
  10e923:	56                   	push   %esi
  10e924:	83 ec 14             	sub    $0x14,%esp
  10e927:	8b 45 0c             	mov    0xc(%ebp),%eax
  10e92a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    memcpy(dest, src, sizeof(lv_area_t));
  10e92d:	8b 55 08             	mov    0x8(%ebp),%edx
  10e930:	8b 75 0c             	mov    0xc(%ebp),%esi
  10e933:	89 14 24             	mov    %edx,(%esp)
  10e936:	89 74 24 04          	mov    %esi,0x4(%esp)
  10e93a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10e941:	00 
  10e942:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10e945:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10e948:	e8 03 ba ff ff       	call   10a350 <memcpy>
}
  10e94d:	83 c4 14             	add    $0x14,%esp
  10e950:	5e                   	pop    %esi
  10e951:	5d                   	pop    %ebp
  10e952:	c3                   	ret    
  10e953:	66 90                	xchg   %ax,%ax
  10e955:	66 90                	xchg   %ax,%ax
  10e957:	66 90                	xchg   %ax,%ax
  10e959:	66 90                	xchg   %ax,%ax
  10e95b:	66 90                	xchg   %ax,%ax
  10e95d:	66 90                	xchg   %ax,%ax
  10e95f:	90                   	nop

0010e960 <lv_obj_get_parent>:
{
  10e960:	55                   	push   %ebp
  10e961:	89 e5                	mov    %esp,%ebp
  10e963:	50                   	push   %eax
  10e964:	8b 45 08             	mov    0x8(%ebp),%eax
    return obj->par;
  10e967:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10e96a:	8b 09                	mov    (%ecx),%ecx
  10e96c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10e96f:	89 c8                	mov    %ecx,%eax
  10e971:	83 c4 04             	add    $0x4,%esp
  10e974:	5d                   	pop    %ebp
  10e975:	c3                   	ret    
  10e976:	66 90                	xchg   %ax,%ax
  10e978:	66 90                	xchg   %ax,%ax
  10e97a:	66 90                	xchg   %ax,%ax
  10e97c:	66 90                	xchg   %ax,%ax
  10e97e:	66 90                	xchg   %ax,%ax

0010e980 <lv_obj_set_pos>:
{
  10e980:	55                   	push   %ebp
  10e981:	89 e5                	mov    %esp,%ebp
  10e983:	53                   	push   %ebx
  10e984:	57                   	push   %edi
  10e985:	56                   	push   %esi
  10e986:	83 e4 f8             	and    $0xfffffff8,%esp
  10e989:	83 ec 28             	sub    $0x28,%esp
  10e98c:	66 8b 45 10          	mov    0x10(%ebp),%ax
  10e990:	66 8b 4d 0c          	mov    0xc(%ebp),%cx
  10e994:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_obj_t * par = obj->par;
  10e997:	8b 75 08             	mov    0x8(%ebp),%esi
  10e99a:	8b 36                	mov    (%esi),%esi
  10e99c:	89 74 24 20          	mov    %esi,0x20(%esp)
    x = x + par->coords.x1;
  10e9a0:	0f bf 75 0c          	movswl 0xc(%ebp),%esi
  10e9a4:	8b 7c 24 20          	mov    0x20(%esp),%edi
  10e9a8:	0f bf 7f 10          	movswl 0x10(%edi),%edi
  10e9ac:	01 fe                	add    %edi,%esi
  10e9ae:	66 89 75 0c          	mov    %si,0xc(%ebp)
    y = y + par->coords.y1;
  10e9b2:	0f bf 7d 10          	movswl 0x10(%ebp),%edi
  10e9b6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  10e9ba:	0f bf 5b 12          	movswl 0x12(%ebx),%ebx
  10e9be:	01 df                	add    %ebx,%edi
  10e9c0:	66 89 7d 10          	mov    %di,0x10(%ebp)
    diff.x = x - obj->coords.x1;
  10e9c4:	0f bf 5d 0c          	movswl 0xc(%ebp),%ebx
  10e9c8:	8b 75 08             	mov    0x8(%ebp),%esi
  10e9cb:	0f bf 76 10          	movswl 0x10(%esi),%esi
  10e9cf:	29 f3                	sub    %esi,%ebx
  10e9d1:	66 89 5c 24 18       	mov    %bx,0x18(%esp)
    diff.y = y - obj->coords.y1;
  10e9d6:	0f bf 75 10          	movswl 0x10(%ebp),%esi
  10e9da:	8b 7d 08             	mov    0x8(%ebp),%edi
  10e9dd:	0f bf 7f 12          	movswl 0x12(%edi),%edi
  10e9e1:	29 fe                	sub    %edi,%esi
  10e9e3:	66 89 74 24 1a       	mov    %si,0x1a(%esp)
    if(diff.x == 0 && diff.y == 0) return;
  10e9e8:	0f bf 7c 24 18       	movswl 0x18(%esp),%edi
  10e9ed:	83 ff 00             	cmp    $0x0,%edi
  10e9f0:	0f 85 13 00 00 00    	jne    10ea09 <lv_obj_set_pos+0x89>
  10e9f6:	0f bf 44 24 1a       	movswl 0x1a(%esp),%eax
  10e9fb:	83 f8 00             	cmp    $0x0,%eax
  10e9fe:	0f 85 05 00 00 00    	jne    10ea09 <lv_obj_set_pos+0x89>
  10ea04:	e9 d6 00 00 00       	jmp    10eadf <lv_obj_set_pos+0x15f>
    lv_obj_invalidate(obj);
  10ea09:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea0c:	89 04 24             	mov    %eax,(%esp)
  10ea0f:	e8 5c 01 00 00       	call   10eb70 <lv_obj_invalidate>
    lv_obj_get_coords(obj, &ori);
  10ea14:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea17:	89 04 24             	mov    %eax,(%esp)
  10ea1a:	8d 44 24 10          	lea    0x10(%esp),%eax
  10ea1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ea22:	e8 19 05 00 00       	call   10ef40 <lv_obj_get_coords>
    obj->coords.x1 += diff.x;
  10ea27:	0f bf 44 24 18       	movswl 0x18(%esp),%eax
  10ea2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea2f:	0f bf 51 10          	movswl 0x10(%ecx),%edx
  10ea33:	01 c2                	add    %eax,%edx
  10ea35:	66 89 51 10          	mov    %dx,0x10(%ecx)
    obj->coords.y1 += diff.y;
  10ea39:	0f bf 44 24 1a       	movswl 0x1a(%esp),%eax
  10ea3e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea41:	0f bf 71 12          	movswl 0x12(%ecx),%esi
  10ea45:	01 c6                	add    %eax,%esi
  10ea47:	66 89 71 12          	mov    %si,0x12(%ecx)
    obj->coords.x2 += diff.x;
  10ea4b:	0f bf 44 24 18       	movswl 0x18(%esp),%eax
  10ea50:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea53:	0f bf 79 14          	movswl 0x14(%ecx),%edi
  10ea57:	01 c7                	add    %eax,%edi
  10ea59:	66 89 79 14          	mov    %di,0x14(%ecx)
    obj->coords.y2 += diff.y;
  10ea5d:	0f bf 44 24 1a       	movswl 0x1a(%esp),%eax
  10ea62:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea65:	0f bf 59 16          	movswl 0x16(%ecx),%ebx
  10ea69:	01 c3                	add    %eax,%ebx
  10ea6b:	66 89 59 16          	mov    %bx,0x16(%ecx)
    refresh_children_position(obj, diff.x, diff.y);
  10ea6f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea72:	66 8b 54 24 18       	mov    0x18(%esp),%dx
  10ea77:	89 04 24             	mov    %eax,(%esp)
  10ea7a:	0f bf c2             	movswl %dx,%eax
  10ea7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ea81:	0f bf 44 24 1a       	movswl 0x1a(%esp),%eax
  10ea86:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ea8a:	e8 e1 04 00 00       	call   10ef70 <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
  10ea8f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea92:	8b 40 1c             	mov    0x1c(%eax),%eax
  10ea95:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ea98:	8d 54 24 10          	lea    0x10(%esp),%edx
  10ea9c:	89 0c 24             	mov    %ecx,(%esp)
  10ea9f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10eaa6:	00 
  10eaa7:	89 54 24 08          	mov    %edx,0x8(%esp)
  10eaab:	ff d0                	call   *%eax
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
  10eaad:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10eab1:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  10eab4:	8b 54 24 20          	mov    0x20(%esp),%edx
  10eab8:	8b 75 08             	mov    0x8(%ebp),%esi
  10eabb:	89 14 24             	mov    %edx,(%esp)
  10eabe:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10eac5:	00 
  10eac6:	89 74 24 08          	mov    %esi,0x8(%esp)
  10eaca:	88 44 24 0f          	mov    %al,0xf(%esp)
  10eace:	ff d1                	call   *%ecx
    lv_obj_invalidate(obj);
  10ead0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ead3:	89 0c 24             	mov    %ecx,(%esp)
  10ead6:	88 44 24 0e          	mov    %al,0xe(%esp)
  10eada:	e8 91 00 00 00       	call   10eb70 <lv_obj_invalidate>
}
  10eadf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10eae2:	5e                   	pop    %esi
  10eae3:	5f                   	pop    %edi
  10eae4:	5b                   	pop    %ebx
  10eae5:	5d                   	pop    %ebp
  10eae6:	c3                   	ret    
  10eae7:	66 90                	xchg   %ax,%ax
  10eae9:	66 90                	xchg   %ax,%ax
  10eaeb:	66 90                	xchg   %ax,%ax
  10eaed:	66 90                	xchg   %ax,%ax
  10eaef:	90                   	nop

0010eaf0 <lv_obj_get_x>:
{
  10eaf0:	55                   	push   %ebp
  10eaf1:	89 e5                	mov    %esp,%ebp
  10eaf3:	83 ec 10             	sub    $0x10,%esp
  10eaf6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_obj_t * parent = lv_obj_get_parent(obj);
  10eaf9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10eafc:	89 0c 24             	mov    %ecx,(%esp)
  10eaff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10eb02:	e8 59 fe ff ff       	call   10e960 <lv_obj_get_parent>
  10eb07:	89 45 f8             	mov    %eax,-0x8(%ebp)
    rel_x             = obj->coords.x1 - parent->coords.x1;
  10eb0a:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb0d:	0f bf 40 10          	movswl 0x10(%eax),%eax
  10eb11:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10eb14:	0f bf 49 10          	movswl 0x10(%ecx),%ecx
  10eb18:	29 c8                	sub    %ecx,%eax
  10eb1a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rel_x;
  10eb1e:	0f bf 45 fe          	movswl -0x2(%ebp),%eax
  10eb22:	83 c4 10             	add    $0x10,%esp
  10eb25:	5d                   	pop    %ebp
  10eb26:	c3                   	ret    
  10eb27:	66 90                	xchg   %ax,%ax
  10eb29:	66 90                	xchg   %ax,%ax
  10eb2b:	66 90                	xchg   %ax,%ax
  10eb2d:	66 90                	xchg   %ax,%ax
  10eb2f:	90                   	nop

0010eb30 <lv_obj_get_y>:
{
  10eb30:	55                   	push   %ebp
  10eb31:	89 e5                	mov    %esp,%ebp
  10eb33:	83 ec 10             	sub    $0x10,%esp
  10eb36:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_obj_t * parent = lv_obj_get_parent(obj);
  10eb39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10eb3c:	89 0c 24             	mov    %ecx,(%esp)
  10eb3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10eb42:	e8 19 fe ff ff       	call   10e960 <lv_obj_get_parent>
  10eb47:	89 45 f8             	mov    %eax,-0x8(%ebp)
    rel_y             = obj->coords.y1 - parent->coords.y1;
  10eb4a:	8b 45 08             	mov    0x8(%ebp),%eax
  10eb4d:	0f bf 40 12          	movswl 0x12(%eax),%eax
  10eb51:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10eb54:	0f bf 49 12          	movswl 0x12(%ecx),%ecx
  10eb58:	29 c8                	sub    %ecx,%eax
  10eb5a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rel_y;
  10eb5e:	0f bf 45 fe          	movswl -0x2(%ebp),%eax
  10eb62:	83 c4 10             	add    $0x10,%esp
  10eb65:	5d                   	pop    %ebp
  10eb66:	c3                   	ret    
  10eb67:	66 90                	xchg   %ax,%ax
  10eb69:	66 90                	xchg   %ax,%ax
  10eb6b:	66 90                	xchg   %ax,%ax
  10eb6d:	66 90                	xchg   %ax,%ax
  10eb6f:	90                   	nop

0010eb70 <lv_obj_invalidate>:
{
  10eb70:	55                   	push   %ebp
  10eb71:	89 e5                	mov    %esp,%ebp
  10eb73:	53                   	push   %ebx
  10eb74:	57                   	push   %edi
  10eb75:	56                   	push   %esi
  10eb76:	83 e4 f8             	and    $0xfffffff8,%esp
  10eb79:	83 ec 40             	sub    $0x40,%esp
  10eb7c:	8b 45 08             	mov    0x8(%ebp),%eax
    if(lv_obj_get_hidden(obj)) return;
  10eb7f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10eb82:	89 0c 24             	mov    %ecx,(%esp)
  10eb85:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10eb89:	e8 12 03 00 00       	call   10eea0 <lv_obj_get_hidden>
  10eb8e:	a8 01                	test   $0x1,%al
  10eb90:	0f 85 05 00 00 00    	jne    10eb9b <lv_obj_invalidate+0x2b>
  10eb96:	e9 05 00 00 00       	jmp    10eba0 <lv_obj_invalidate+0x30>
  10eb9b:	e9 93 01 00 00       	jmp    10ed33 <lv_obj_invalidate+0x1c3>
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
  10eba0:	8b 45 08             	mov    0x8(%ebp),%eax
  10eba3:	89 04 24             	mov    %eax,(%esp)
  10eba6:	e8 55 03 00 00       	call   10ef00 <lv_obj_get_screen>
  10ebab:	89 44 24 38          	mov    %eax,0x38(%esp)
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
  10ebaf:	8b 44 24 38          	mov    0x38(%esp),%eax
  10ebb3:	89 04 24             	mov    %eax,(%esp)
  10ebb6:	e8 85 01 00 00       	call   10ed40 <lv_obj_get_disp>
  10ebbb:	89 44 24 34          	mov    %eax,0x34(%esp)
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
  10ebbf:	8b 44 24 38          	mov    0x38(%esp),%eax
  10ebc3:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10ebc7:	89 0c 24             	mov    %ecx,(%esp)
  10ebca:	89 44 24 18          	mov    %eax,0x18(%esp)
  10ebce:	e8 8d f0 ff ff       	call   10dc60 <lv_disp_get_scr_act>
  10ebd3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10ebd7:	39 c1                	cmp    %eax,%ecx
  10ebd9:	0f 84 40 00 00 00    	je     10ec1f <lv_obj_invalidate+0xaf>
  10ebdf:	8b 44 24 38          	mov    0x38(%esp),%eax
  10ebe3:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10ebe7:	89 0c 24             	mov    %ecx,(%esp)
  10ebea:	89 44 24 14          	mov    %eax,0x14(%esp)
  10ebee:	e8 dd f0 ff ff       	call   10dcd0 <lv_disp_get_layer_top>
  10ebf3:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  10ebf7:	39 c1                	cmp    %eax,%ecx
  10ebf9:	0f 84 20 00 00 00    	je     10ec1f <lv_obj_invalidate+0xaf>
       obj_scr == lv_disp_get_layer_sys(disp)) {
  10ebff:	8b 44 24 38          	mov    0x38(%esp),%eax
  10ec03:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10ec07:	89 0c 24             	mov    %ecx,(%esp)
  10ec0a:	89 44 24 10          	mov    %eax,0x10(%esp)
  10ec0e:	e8 2d f1 ff ff       	call   10dd40 <lv_disp_get_layer_sys>
  10ec13:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10ec17:	39 c1                	cmp    %eax,%ecx
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
  10ec19:	0f 85 14 01 00 00    	jne    10ed33 <lv_obj_invalidate+0x1c3>
        lv_obj_t * par = lv_obj_get_parent(obj);
  10ec1f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec22:	89 04 24             	mov    %eax,(%esp)
  10ec25:	e8 36 fd ff ff       	call   10e960 <lv_obj_get_parent>
  10ec2a:	89 44 24 24          	mov    %eax,0x24(%esp)
        bool union_ok  = true;
  10ec2e:	c6 44 24 23 01       	movb   $0x1,0x23(%esp)
        lv_coord_t ext_size = obj->ext_draw_pad;
  10ec33:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec36:	66 8b 48 30          	mov    0x30(%eax),%cx
  10ec3a:	66 89 4c 24 20       	mov    %cx,0x20(%esp)
        lv_area_copy(&area_trunc, &obj->coords);
  10ec3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ec42:	83 c0 10             	add    $0x10,%eax
  10ec45:	8d 54 24 28          	lea    0x28(%esp),%edx
  10ec49:	89 14 24             	mov    %edx,(%esp)
  10ec4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ec50:	e8 cb fc ff ff       	call   10e920 <lv_area_copy>
        area_trunc.x1 -= ext_size;
  10ec55:	0f bf 44 24 20       	movswl 0x20(%esp),%eax
  10ec5a:	0f bf 54 24 28       	movswl 0x28(%esp),%edx
  10ec5f:	29 c2                	sub    %eax,%edx
  10ec61:	66 89 54 24 28       	mov    %dx,0x28(%esp)
        area_trunc.y1 -= ext_size;
  10ec66:	0f bf 44 24 20       	movswl 0x20(%esp),%eax
  10ec6b:	0f bf 74 24 2a       	movswl 0x2a(%esp),%esi
  10ec70:	29 c6                	sub    %eax,%esi
  10ec72:	66 89 74 24 2a       	mov    %si,0x2a(%esp)
        area_trunc.x2 += ext_size;
  10ec77:	0f bf 44 24 20       	movswl 0x20(%esp),%eax
  10ec7c:	0f bf 7c 24 2c       	movswl 0x2c(%esp),%edi
  10ec81:	01 c7                	add    %eax,%edi
  10ec83:	66 89 7c 24 2c       	mov    %di,0x2c(%esp)
        area_trunc.y2 += ext_size;
  10ec88:	0f bf 44 24 20       	movswl 0x20(%esp),%eax
  10ec8d:	0f bf 5c 24 2e       	movswl 0x2e(%esp),%ebx
  10ec92:	01 c3                	add    %eax,%ebx
  10ec94:	66 89 5c 24 2e       	mov    %bx,0x2e(%esp)
        while(par != NULL) {
  10ec99:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  10ec9e:	0f 84 6b 00 00 00    	je     10ed0f <lv_obj_invalidate+0x19f>
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
  10eca4:	8b 44 24 24          	mov    0x24(%esp),%eax
  10eca8:	83 c0 10             	add    $0x10,%eax
  10ecab:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  10ecaf:	89 0c 24             	mov    %ecx,(%esp)
  10ecb2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ecb6:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ecba:	e8 41 8f 00 00       	call   117c00 <lv_area_intersect>
  10ecbf:	24 01                	and    $0x1,%al
  10ecc1:	88 44 24 23          	mov    %al,0x23(%esp)
            if(union_ok == false) break;       /*If no common parts with parent break;*/
  10ecc5:	8a 44 24 23          	mov    0x23(%esp),%al
  10ecc9:	24 01                	and    $0x1,%al
  10eccb:	0f b6 c8             	movzbl %al,%ecx
  10ecce:	83 f9 00             	cmp    $0x0,%ecx
  10ecd1:	0f 85 05 00 00 00    	jne    10ecdc <lv_obj_invalidate+0x16c>
  10ecd7:	e9 33 00 00 00       	jmp    10ed0f <lv_obj_invalidate+0x19f>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
  10ecdc:	8b 44 24 24          	mov    0x24(%esp),%eax
  10ece0:	89 04 24             	mov    %eax,(%esp)
  10ece3:	e8 b8 01 00 00       	call   10eea0 <lv_obj_get_hidden>
  10ece8:	a8 01                	test   $0x1,%al
  10ecea:	0f 85 05 00 00 00    	jne    10ecf5 <lv_obj_invalidate+0x185>
  10ecf0:	e9 05 00 00 00       	jmp    10ecfa <lv_obj_invalidate+0x18a>
  10ecf5:	e9 39 00 00 00       	jmp    10ed33 <lv_obj_invalidate+0x1c3>
            par = lv_obj_get_parent(par);
  10ecfa:	8b 44 24 24          	mov    0x24(%esp),%eax
  10ecfe:	89 04 24             	mov    %eax,(%esp)
  10ed01:	e8 5a fc ff ff       	call   10e960 <lv_obj_get_parent>
  10ed06:	89 44 24 24          	mov    %eax,0x24(%esp)
        while(par != NULL) {
  10ed0a:	e9 8a ff ff ff       	jmp    10ec99 <lv_obj_invalidate+0x129>
        if(union_ok) lv_inv_area(disp, &area_trunc);
  10ed0f:	f6 44 24 23 01       	testb  $0x1,0x23(%esp)
  10ed14:	0f 84 14 00 00 00    	je     10ed2e <lv_obj_invalidate+0x1be>
  10ed1a:	8b 44 24 34          	mov    0x34(%esp),%eax
  10ed1e:	89 04 24             	mov    %eax,(%esp)
  10ed21:	8d 44 24 28          	lea    0x28(%esp),%eax
  10ed25:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ed29:	e8 42 12 00 00       	call   10ff70 <lv_inv_area>
    }
  10ed2e:	e9 00 00 00 00       	jmp    10ed33 <lv_obj_invalidate+0x1c3>
}
  10ed33:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ed36:	5e                   	pop    %esi
  10ed37:	5f                   	pop    %edi
  10ed38:	5b                   	pop    %ebx
  10ed39:	5d                   	pop    %ebp
  10ed3a:	c3                   	ret    
  10ed3b:	66 90                	xchg   %ax,%ax
  10ed3d:	66 90                	xchg   %ax,%ax
  10ed3f:	90                   	nop

0010ed40 <lv_obj_get_disp>:
{
  10ed40:	55                   	push   %ebp
  10ed41:	89 e5                	mov    %esp,%ebp
  10ed43:	83 ec 20             	sub    $0x20,%esp
  10ed46:	8b 45 08             	mov    0x8(%ebp),%eax
    if(obj->par == NULL)
  10ed49:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ed4c:	83 39 00             	cmpl   $0x0,(%ecx)
  10ed4f:	0f 85 0b 00 00 00    	jne    10ed60 <lv_obj_get_disp+0x20>
        scr = obj; /*`obj` is a screen*/
  10ed55:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed58:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10ed5b:	e9 0e 00 00 00       	jmp    10ed6e <lv_obj_get_disp+0x2e>
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
  10ed60:	8b 45 08             	mov    0x8(%ebp),%eax
  10ed63:	89 04 24             	mov    %eax,(%esp)
  10ed66:	e8 95 01 00 00       	call   10ef00 <lv_obj_get_screen>
  10ed6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
  10ed6e:	8d 05 88 55 13 00    	lea    0x135588,%eax
  10ed74:	89 04 24             	mov    %eax,(%esp)
  10ed77:	e8 34 a0 00 00       	call   118db0 <lv_ll_get_head>
  10ed7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10ed7f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10ed83:	0f 84 76 00 00 00    	je     10edff <lv_obj_get_disp+0xbf>
        LV_LL_READ(d->scr_ll, s)
  10ed89:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10ed8c:	83 c0 28             	add    $0x28,%eax
  10ed8f:	89 04 24             	mov    %eax,(%esp)
  10ed92:	e8 19 a0 00 00       	call   118db0 <lv_ll_get_head>
  10ed97:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10ed9a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10ed9e:	0f 84 39 00 00 00    	je     10eddd <lv_obj_get_disp+0x9d>
            if(s == scr) return d;
  10eda4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10eda7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10edaa:	0f 85 0b 00 00 00    	jne    10edbb <lv_obj_get_disp+0x7b>
  10edb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10edb3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10edb6:	e9 73 00 00 00       	jmp    10ee2e <lv_obj_get_disp+0xee>
        }
  10edbb:	e9 00 00 00 00       	jmp    10edc0 <lv_obj_get_disp+0x80>
        LV_LL_READ(d->scr_ll, s)
  10edc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10edc3:	83 c0 28             	add    $0x28,%eax
  10edc6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10edc9:	89 04 24             	mov    %eax,(%esp)
  10edcc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10edd0:	e8 9b a2 00 00       	call   119070 <lv_ll_get_next>
  10edd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10edd8:	e9 bd ff ff ff       	jmp    10ed9a <lv_obj_get_disp+0x5a>
    }
  10eddd:	e9 00 00 00 00       	jmp    10ede2 <lv_obj_get_disp+0xa2>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
  10ede2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10ede5:	8d 0d 88 55 13 00    	lea    0x135588,%ecx
  10edeb:	89 0c 24             	mov    %ecx,(%esp)
  10edee:	89 44 24 04          	mov    %eax,0x4(%esp)
  10edf2:	e8 79 a2 00 00       	call   119070 <lv_ll_get_next>
  10edf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10edfa:	e9 80 ff ff ff       	jmp    10ed7f <lv_obj_get_disp+0x3f>
    LV_LOG_WARN("lv_scr_get_disp: screen not found")
  10edff:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10ee06:	8d 05 2e 3d 12 00    	lea    0x123d2e,%eax
  10ee0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ee10:	c7 44 24 08 eb 05 00 	movl   $0x5eb,0x8(%esp)
  10ee17:	00 
  10ee18:	8d 05 e2 3e 12 00    	lea    0x123ee2,%eax
  10ee1e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10ee22:	e8 19 ac 00 00       	call   119a40 <lv_log_add>
    return NULL;
  10ee27:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10ee2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ee31:	83 c4 20             	add    $0x20,%esp
  10ee34:	5d                   	pop    %ebp
  10ee35:	c3                   	ret    
  10ee36:	66 90                	xchg   %ax,%ax
  10ee38:	66 90                	xchg   %ax,%ax
  10ee3a:	66 90                	xchg   %ax,%ax
  10ee3c:	66 90                	xchg   %ax,%ax
  10ee3e:	66 90                	xchg   %ax,%ax

0010ee40 <lv_obj_get_child>:
{
  10ee40:	55                   	push   %ebp
  10ee41:	89 e5                	mov    %esp,%ebp
  10ee43:	83 ec 0c             	sub    $0xc,%esp
  10ee46:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ee49:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_obj_t * result = NULL;
  10ee4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(child == NULL) {
  10ee53:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ee57:	0f 85 16 00 00 00    	jne    10ee73 <lv_obj_get_child+0x33>
        result = lv_ll_get_head(&obj->child_ll);
  10ee5d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee60:	83 c0 04             	add    $0x4,%eax
  10ee63:	89 04 24             	mov    %eax,(%esp)
  10ee66:	e8 45 9f 00 00       	call   118db0 <lv_ll_get_head>
  10ee6b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    } else {
  10ee6e:	e9 18 00 00 00       	jmp    10ee8b <lv_obj_get_child+0x4b>
        result = lv_ll_get_next(&obj->child_ll, child);
  10ee73:	8b 45 08             	mov    0x8(%ebp),%eax
  10ee76:	83 c0 04             	add    $0x4,%eax
  10ee79:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10ee7c:	89 04 24             	mov    %eax,(%esp)
  10ee7f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10ee83:	e8 e8 a1 00 00       	call   119070 <lv_ll_get_next>
  10ee88:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return result;
  10ee8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ee8e:	83 c4 0c             	add    $0xc,%esp
  10ee91:	5d                   	pop    %ebp
  10ee92:	c3                   	ret    
  10ee93:	66 90                	xchg   %ax,%ax
  10ee95:	66 90                	xchg   %ax,%ax
  10ee97:	66 90                	xchg   %ax,%ax
  10ee99:	66 90                	xchg   %ax,%ax
  10ee9b:	66 90                	xchg   %ax,%ax
  10ee9d:	66 90                	xchg   %ax,%ax
  10ee9f:	90                   	nop

0010eea0 <lv_obj_get_hidden>:
{
  10eea0:	55                   	push   %ebp
  10eea1:	89 e5                	mov    %esp,%ebp
  10eea3:	53                   	push   %ebx
  10eea4:	56                   	push   %esi
  10eea5:	83 ec 08             	sub    $0x8,%esp
  10eea8:	8b 45 08             	mov    0x8(%ebp),%eax
  10eeab:	31 c9                	xor    %ecx,%ecx
    return obj->hidden == 0 ? false : true;
  10eead:	8b 55 08             	mov    0x8(%ebp),%edx
  10eeb0:	66 8b 72 2c          	mov    0x2c(%edx),%si
  10eeb4:	66 c1 ee 04          	shr    $0x4,%si
  10eeb8:	66 89 f3             	mov    %si,%bx
  10eebb:	66 83 e3 01          	and    $0x1,%bx
  10eebf:	0f b6 d3             	movzbl %bl,%edx
  10eec2:	83 fa 00             	cmp    $0x0,%edx
  10eec5:	ba 01 00 00 00       	mov    $0x1,%edx
  10eeca:	89 55 f4             	mov    %edx,-0xc(%ebp)
  10eecd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10eed0:	0f 84 06 00 00 00    	je     10eedc <lv_obj_get_hidden+0x3c>
  10eed6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10eed9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10eedc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10eedf:	83 f8 00             	cmp    $0x0,%eax
  10eee2:	0f 95 c1             	setne  %cl
  10eee5:	80 e1 01             	and    $0x1,%cl
  10eee8:	0f b6 c1             	movzbl %cl,%eax
  10eeeb:	83 c4 08             	add    $0x8,%esp
  10eeee:	5e                   	pop    %esi
  10eeef:	5b                   	pop    %ebx
  10eef0:	5d                   	pop    %ebp
  10eef1:	c3                   	ret    
  10eef2:	66 90                	xchg   %ax,%ax
  10eef4:	66 90                	xchg   %ax,%ax
  10eef6:	66 90                	xchg   %ax,%ax
  10eef8:	66 90                	xchg   %ax,%ax
  10eefa:	66 90                	xchg   %ax,%ax
  10eefc:	66 90                	xchg   %ax,%ax
  10eefe:	66 90                	xchg   %ax,%ax

0010ef00 <lv_obj_get_screen>:
{
  10ef00:	55                   	push   %ebp
  10ef01:	89 e5                	mov    %esp,%ebp
  10ef03:	83 ec 0c             	sub    $0xc,%esp
  10ef06:	8b 45 08             	mov    0x8(%ebp),%eax
    const lv_obj_t * par = obj;
  10ef09:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ef0c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
        act_p = par;
  10ef0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ef12:	89 45 f8             	mov    %eax,-0x8(%ebp)
        par   = lv_obj_get_parent(act_p);
  10ef15:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ef18:	89 04 24             	mov    %eax,(%esp)
  10ef1b:	e8 40 fa ff ff       	call   10e960 <lv_obj_get_parent>
  10ef20:	89 45 fc             	mov    %eax,-0x4(%ebp)
    } while(par != NULL);
  10ef23:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10ef27:	0f 85 e2 ff ff ff    	jne    10ef0f <lv_obj_get_screen+0xf>
    return (lv_obj_t *)act_p;
  10ef2d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ef30:	83 c4 0c             	add    $0xc,%esp
  10ef33:	5d                   	pop    %ebp
  10ef34:	c3                   	ret    
  10ef35:	66 90                	xchg   %ax,%ax
  10ef37:	66 90                	xchg   %ax,%ax
  10ef39:	66 90                	xchg   %ax,%ax
  10ef3b:	66 90                	xchg   %ax,%ax
  10ef3d:	66 90                	xchg   %ax,%ax
  10ef3f:	90                   	nop

0010ef40 <lv_obj_get_coords>:
{
  10ef40:	55                   	push   %ebp
  10ef41:	89 e5                	mov    %esp,%ebp
  10ef43:	56                   	push   %esi
  10ef44:	83 ec 10             	sub    $0x10,%esp
  10ef47:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ef4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_area_copy(cords_p, &obj->coords);
  10ef4d:	8b 55 0c             	mov    0xc(%ebp),%edx
  10ef50:	8b 75 08             	mov    0x8(%ebp),%esi
  10ef53:	83 c6 10             	add    $0x10,%esi
  10ef56:	89 14 24             	mov    %edx,(%esp)
  10ef59:	89 74 24 04          	mov    %esi,0x4(%esp)
  10ef5d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10ef60:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10ef63:	e8 b8 f9 ff ff       	call   10e920 <lv_area_copy>
}
  10ef68:	83 c4 10             	add    $0x10,%esp
  10ef6b:	5e                   	pop    %esi
  10ef6c:	5d                   	pop    %ebp
  10ef6d:	c3                   	ret    
  10ef6e:	66 90                	xchg   %ax,%ax

0010ef70 <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
  10ef70:	55                   	push   %ebp
  10ef71:	89 e5                	mov    %esp,%ebp
  10ef73:	53                   	push   %ebx
  10ef74:	57                   	push   %edi
  10ef75:	56                   	push   %esi
  10ef76:	83 ec 18             	sub    $0x18,%esp
  10ef79:	66 8b 45 10          	mov    0x10(%ebp),%ax
  10ef7d:	66 8b 4d 0c          	mov    0xc(%ebp),%cx
  10ef81:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
  10ef84:	8b 75 08             	mov    0x8(%ebp),%esi
  10ef87:	83 c6 04             	add    $0x4,%esi
  10ef8a:	89 34 24             	mov    %esi,(%esp)
  10ef8d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  10ef91:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
  10ef95:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10ef98:	e8 13 9e 00 00       	call   118db0 <lv_ll_get_head>
  10ef9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10efa0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10efa4:	0f 84 7f 00 00 00    	je     10f029 <refresh_children_position+0xb9>
    {
        i->coords.x1 += x_diff;
  10efaa:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  10efae:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10efb1:	0f bf 51 10          	movswl 0x10(%ecx),%edx
  10efb5:	01 c2                	add    %eax,%edx
  10efb7:	66 89 51 10          	mov    %dx,0x10(%ecx)
        i->coords.y1 += y_diff;
  10efbb:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  10efbf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10efc2:	0f bf 71 12          	movswl 0x12(%ecx),%esi
  10efc6:	01 c6                	add    %eax,%esi
  10efc8:	66 89 71 12          	mov    %si,0x12(%ecx)
        i->coords.x2 += x_diff;
  10efcc:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  10efd0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10efd3:	0f bf 79 14          	movswl 0x14(%ecx),%edi
  10efd7:	01 c7                	add    %eax,%edi
  10efd9:	66 89 79 14          	mov    %di,0x14(%ecx)
        i->coords.y2 += y_diff;
  10efdd:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  10efe1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10efe4:	0f bf 59 16          	movswl 0x16(%ecx),%ebx
  10efe8:	01 c3                	add    %eax,%ebx
  10efea:	66 89 59 16          	mov    %bx,0x16(%ecx)

        refresh_children_position(i, x_diff, y_diff);
  10efee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10eff1:	66 8b 55 0c          	mov    0xc(%ebp),%dx
  10eff5:	89 04 24             	mov    %eax,(%esp)
  10eff8:	0f bf c2             	movswl %dx,%eax
  10effb:	89 44 24 04          	mov    %eax,0x4(%esp)
  10efff:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  10f003:	89 44 24 08          	mov    %eax,0x8(%esp)
  10f007:	e8 64 ff ff ff       	call   10ef70 <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
  10f00c:	8b 45 08             	mov    0x8(%ebp),%eax
  10f00f:	83 c0 04             	add    $0x4,%eax
  10f012:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10f015:	89 04 24             	mov    %eax,(%esp)
  10f018:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f01c:	e8 4f a0 00 00       	call   119070 <lv_ll_get_next>
  10f021:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10f024:	e9 77 ff ff ff       	jmp    10efa0 <refresh_children_position+0x30>
    }
}
  10f029:	83 c4 18             	add    $0x18,%esp
  10f02c:	5e                   	pop    %esi
  10f02d:	5f                   	pop    %edi
  10f02e:	5b                   	pop    %ebx
  10f02f:	5d                   	pop    %ebp
  10f030:	c3                   	ret    
  10f031:	66 90                	xchg   %ax,%ax
  10f033:	66 90                	xchg   %ax,%ax
  10f035:	66 90                	xchg   %ax,%ax
  10f037:	66 90                	xchg   %ax,%ax
  10f039:	66 90                	xchg   %ax,%ax
  10f03b:	66 90                	xchg   %ax,%ax
  10f03d:	66 90                	xchg   %ax,%ax
  10f03f:	90                   	nop

0010f040 <lv_obj_set_size>:
{
  10f040:	55                   	push   %ebp
  10f041:	89 e5                	mov    %esp,%ebp
  10f043:	57                   	push   %edi
  10f044:	56                   	push   %esi
  10f045:	83 e4 f8             	and    $0xfffffff8,%esp
  10f048:	83 ec 30             	sub    $0x30,%esp
  10f04b:	66 8b 45 10          	mov    0x10(%ebp),%ax
  10f04f:	66 8b 4d 0c          	mov    0xc(%ebp),%cx
  10f053:	8b 55 08             	mov    0x8(%ebp),%edx
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
  10f056:	8b 75 08             	mov    0x8(%ebp),%esi
  10f059:	89 34 24             	mov    %esi,(%esp)
  10f05c:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
  10f061:	66 89 4c 24 1c       	mov    %cx,0x1c(%esp)
  10f066:	89 54 24 18          	mov    %edx,0x18(%esp)
  10f06a:	e8 51 01 00 00       	call   10f1c0 <lv_obj_get_width>
  10f06f:	0f bf d0             	movswl %ax,%edx
  10f072:	0f bf 75 0c          	movswl 0xc(%ebp),%esi
  10f076:	39 f2                	cmp    %esi,%edx
  10f078:	0f 85 1f 00 00 00    	jne    10f09d <lv_obj_set_size+0x5d>
  10f07e:	8b 45 08             	mov    0x8(%ebp),%eax
  10f081:	89 04 24             	mov    %eax,(%esp)
  10f084:	e8 57 01 00 00       	call   10f1e0 <lv_obj_get_height>
  10f089:	0f bf c8             	movswl %ax,%ecx
  10f08c:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  10f090:	39 d1                	cmp    %edx,%ecx
  10f092:	0f 85 05 00 00 00    	jne    10f09d <lv_obj_set_size+0x5d>
        return;
  10f098:	e9 14 01 00 00       	jmp    10f1b1 <lv_obj_set_size+0x171>
    lv_obj_invalidate(obj);
  10f09d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f0a0:	89 04 24             	mov    %eax,(%esp)
  10f0a3:	e8 c8 fa ff ff       	call   10eb70 <lv_obj_invalidate>
    lv_obj_get_coords(obj, &ori);
  10f0a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f0ab:	89 04 24             	mov    %eax,(%esp)
  10f0ae:	8d 44 24 28          	lea    0x28(%esp),%eax
  10f0b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f0b6:	e8 85 fe ff ff       	call   10ef40 <lv_obj_get_coords>
    obj->coords.x2 = obj->coords.x1 + w - 1;
  10f0bb:	8b 45 08             	mov    0x8(%ebp),%eax
  10f0be:	0f bf 40 10          	movswl 0x10(%eax),%eax
  10f0c2:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  10f0c6:	01 c8                	add    %ecx,%eax
  10f0c8:	83 e8 01             	sub    $0x1,%eax
  10f0cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f0ce:	66 89 41 14          	mov    %ax,0x14(%ecx)
    obj->coords.y2 = obj->coords.y1 + h - 1;
  10f0d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f0d5:	0f bf 49 12          	movswl 0x12(%ecx),%ecx
  10f0d9:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  10f0dd:	01 d1                	add    %edx,%ecx
  10f0df:	83 e9 01             	sub    $0x1,%ecx
  10f0e2:	8b 55 08             	mov    0x8(%ebp),%edx
  10f0e5:	66 89 4a 16          	mov    %cx,0x16(%edx)
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
  10f0e9:	8b 55 08             	mov    0x8(%ebp),%edx
  10f0ec:	8b 52 1c             	mov    0x1c(%edx),%edx
  10f0ef:	8b 75 08             	mov    0x8(%ebp),%esi
  10f0f2:	8d 7c 24 28          	lea    0x28(%esp),%edi
  10f0f6:	89 34 24             	mov    %esi,(%esp)
  10f0f9:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  10f100:	00 
  10f101:	89 7c 24 08          	mov    %edi,0x8(%esp)
  10f105:	ff d2                	call   *%edx
    lv_obj_t * par = lv_obj_get_parent(obj);
  10f107:	8b 55 08             	mov    0x8(%ebp),%edx
  10f10a:	89 14 24             	mov    %edx,(%esp)
  10f10d:	88 44 24 17          	mov    %al,0x17(%esp)
  10f111:	e8 4a f8 ff ff       	call   10e960 <lv_obj_get_parent>
  10f116:	89 44 24 24          	mov    %eax,0x24(%esp)
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
  10f11a:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  10f11f:	0f 84 1f 00 00 00    	je     10f144 <lv_obj_set_size+0x104>
  10f125:	8b 44 24 24          	mov    0x24(%esp),%eax
  10f129:	8b 40 1c             	mov    0x1c(%eax),%eax
  10f12c:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  10f130:	8b 55 08             	mov    0x8(%ebp),%edx
  10f133:	89 0c 24             	mov    %ecx,(%esp)
  10f136:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10f13d:	00 
  10f13e:	89 54 24 08          	mov    %edx,0x8(%esp)
  10f142:	ff d0                	call   *%eax
    LV_LL_READ(obj->child_ll, i)
  10f144:	8b 45 08             	mov    0x8(%ebp),%eax
  10f147:	83 c0 04             	add    $0x4,%eax
  10f14a:	89 04 24             	mov    %eax,(%esp)
  10f14d:	e8 5e 9c 00 00       	call   118db0 <lv_ll_get_head>
  10f152:	89 44 24 20          	mov    %eax,0x20(%esp)
  10f156:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  10f15b:	0f 84 45 00 00 00    	je     10f1a6 <lv_obj_set_size+0x166>
  10f161:	31 c0                	xor    %eax,%eax
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
  10f163:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10f167:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  10f16a:	8b 54 24 20          	mov    0x20(%esp),%edx
  10f16e:	89 14 24             	mov    %edx,(%esp)
  10f171:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  10f178:	00 
  10f179:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10f180:	00 
  10f181:	89 44 24 10          	mov    %eax,0x10(%esp)
  10f185:	ff d1                	call   *%ecx
    LV_LL_READ(obj->child_ll, i)
  10f187:	8b 45 08             	mov    0x8(%ebp),%eax
  10f18a:	83 c0 04             	add    $0x4,%eax
  10f18d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  10f191:	89 04 24             	mov    %eax,(%esp)
  10f194:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f198:	e8 d3 9e 00 00       	call   119070 <lv_ll_get_next>
  10f19d:	89 44 24 20          	mov    %eax,0x20(%esp)
  10f1a1:	e9 b0 ff ff ff       	jmp    10f156 <lv_obj_set_size+0x116>
    lv_obj_invalidate(obj);
  10f1a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10f1a9:	89 04 24             	mov    %eax,(%esp)
  10f1ac:	e8 bf f9 ff ff       	call   10eb70 <lv_obj_invalidate>
}
  10f1b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10f1b4:	5e                   	pop    %esi
  10f1b5:	5f                   	pop    %edi
  10f1b6:	5d                   	pop    %ebp
  10f1b7:	c3                   	ret    
  10f1b8:	66 90                	xchg   %ax,%ax
  10f1ba:	66 90                	xchg   %ax,%ax
  10f1bc:	66 90                	xchg   %ax,%ax
  10f1be:	66 90                	xchg   %ax,%ax

0010f1c0 <lv_obj_get_width>:
{
  10f1c0:	55                   	push   %ebp
  10f1c1:	89 e5                	mov    %esp,%ebp
  10f1c3:	83 ec 08             	sub    $0x8,%esp
  10f1c6:	8b 45 08             	mov    0x8(%ebp),%eax
    return lv_area_get_width(&obj->coords);
  10f1c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f1cc:	83 c1 10             	add    $0x10,%ecx
  10f1cf:	89 0c 24             	mov    %ecx,(%esp)
  10f1d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10f1d5:	e8 76 09 00 00       	call   10fb50 <lv_area_get_width>
  10f1da:	98                   	cwtl   
  10f1db:	83 c4 08             	add    $0x8,%esp
  10f1de:	5d                   	pop    %ebp
  10f1df:	c3                   	ret    

0010f1e0 <lv_obj_get_height>:
{
  10f1e0:	55                   	push   %ebp
  10f1e1:	89 e5                	mov    %esp,%ebp
  10f1e3:	83 ec 08             	sub    $0x8,%esp
  10f1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    return lv_area_get_height(&obj->coords);
  10f1e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f1ec:	83 c1 10             	add    $0x10,%ecx
  10f1ef:	89 0c 24             	mov    %ecx,(%esp)
  10f1f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10f1f5:	e8 86 09 00 00       	call   10fb80 <lv_area_get_height>
  10f1fa:	98                   	cwtl   
  10f1fb:	83 c4 08             	add    $0x8,%esp
  10f1fe:	5d                   	pop    %ebp
  10f1ff:	c3                   	ret    

0010f200 <lv_obj_set_height>:
{
  10f200:	55                   	push   %ebp
  10f201:	89 e5                	mov    %esp,%ebp
  10f203:	56                   	push   %esi
  10f204:	83 ec 18             	sub    $0x18,%esp
  10f207:	66 8b 45 0c          	mov    0xc(%ebp),%ax
  10f20b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
  10f20e:	8b 55 08             	mov    0x8(%ebp),%edx
  10f211:	8b 75 08             	mov    0x8(%ebp),%esi
  10f214:	89 34 24             	mov    %esi,(%esp)
  10f217:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  10f21b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10f21e:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10f221:	e8 9a ff ff ff       	call   10f1c0 <lv_obj_get_width>
  10f226:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10f229:	89 0c 24             	mov    %ecx,(%esp)
  10f22c:	0f bf c8             	movswl %ax,%ecx
  10f22f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f233:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  10f237:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10f23b:	e8 00 fe ff ff       	call   10f040 <lv_obj_set_size>
}
  10f240:	83 c4 18             	add    $0x18,%esp
  10f243:	5e                   	pop    %esi
  10f244:	5d                   	pop    %ebp
  10f245:	c3                   	ret    
  10f246:	66 90                	xchg   %ax,%ax
  10f248:	66 90                	xchg   %ax,%ax
  10f24a:	66 90                	xchg   %ax,%ax
  10f24c:	66 90                	xchg   %ax,%ax
  10f24e:	66 90                	xchg   %ax,%ax

0010f250 <lv_obj_align>:
{
  10f250:	55                   	push   %ebp
  10f251:	89 e5                	mov    %esp,%ebp
  10f253:	53                   	push   %ebx
  10f254:	57                   	push   %edi
  10f255:	56                   	push   %esi
  10f256:	81 ec 80 00 00 00    	sub    $0x80,%esp
  10f25c:	66 8b 45 18          	mov    0x18(%ebp),%ax
  10f260:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  10f264:	8a 55 10             	mov    0x10(%ebp),%dl
  10f267:	8b 75 0c             	mov    0xc(%ebp),%esi
  10f26a:	8b 7d 08             	mov    0x8(%ebp),%edi
    lv_coord_t new_x = lv_obj_get_x(obj);
  10f26d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10f270:	89 1c 24             	mov    %ebx,(%esp)
  10f273:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  10f277:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  10f27b:	88 55 df             	mov    %dl,-0x21(%ebp)
  10f27e:	89 75 d8             	mov    %esi,-0x28(%ebp)
  10f281:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  10f284:	e8 67 f8 ff ff       	call   10eaf0 <lv_obj_get_x>
  10f289:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    lv_coord_t new_y = lv_obj_get_y(obj);
  10f28d:	8b 75 08             	mov    0x8(%ebp),%esi
  10f290:	89 34 24             	mov    %esi,(%esp)
  10f293:	e8 98 f8 ff ff       	call   10eb30 <lv_obj_get_y>
  10f298:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
    if(base == NULL) {
  10f29c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10f2a0:	0f 85 0e 00 00 00    	jne    10f2b4 <lv_obj_align+0x64>
        base = lv_obj_get_parent(obj);
  10f2a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10f2a9:	89 04 24             	mov    %eax,(%esp)
  10f2ac:	e8 af f6 ff ff       	call   10e960 <lv_obj_get_parent>
  10f2b1:	89 45 0c             	mov    %eax,0xc(%ebp)
    switch(align) {
  10f2b4:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  10f2b8:	89 c1                	mov    %eax,%ecx
  10f2ba:	83 e9 14             	sub    $0x14,%ecx
  10f2bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10f2c0:	0f 87 22 05 00 00    	ja     10f7e8 <lv_obj_align+0x598>
  10f2c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10f2c9:	8b 0c 85 a0 35 12 00 	mov    0x1235a0(,%eax,4),%ecx
  10f2d0:	ff e1                	jmp    *%ecx
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
  10f2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f2d5:	89 04 24             	mov    %eax,(%esp)
  10f2d8:	e8 e3 fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f2dd:	98                   	cwtl   
  10f2de:	99                   	cltd   
  10f2df:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f2e4:	f7 f9                	idiv   %ecx
  10f2e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f2e9:	89 0c 24             	mov    %ecx,(%esp)
  10f2ec:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10f2ef:	e8 cc fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f2f4:	98                   	cwtl   
  10f2f5:	99                   	cltd   
  10f2f6:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f2fb:	f7 f9                	idiv   %ecx
  10f2fd:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  10f300:	29 c1                	sub    %eax,%ecx
  10f302:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
  10f306:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f309:	89 04 24             	mov    %eax,(%esp)
  10f30c:	e8 cf fe ff ff       	call   10f1e0 <lv_obj_get_height>
  10f311:	98                   	cwtl   
  10f312:	99                   	cltd   
  10f313:	be 02 00 00 00       	mov    $0x2,%esi
  10f318:	f7 fe                	idiv   %esi
  10f31a:	8b 75 08             	mov    0x8(%ebp),%esi
  10f31d:	89 34 24             	mov    %esi,(%esp)
  10f320:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10f323:	e8 b8 fe ff ff       	call   10f1e0 <lv_obj_get_height>
  10f328:	98                   	cwtl   
  10f329:	99                   	cltd   
  10f32a:	be 02 00 00 00       	mov    $0x2,%esi
  10f32f:	f7 fe                	idiv   %esi
  10f331:	8b 75 c8             	mov    -0x38(%ebp),%esi
  10f334:	29 c6                	sub    %eax,%esi
  10f336:	66 89 75 f0          	mov    %si,-0x10(%ebp)
            break;
  10f33a:	e9 a9 04 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = 0;
  10f33f:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
            new_y = 0;
  10f345:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
            break;
  10f34b:	e9 98 04 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
  10f350:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f353:	89 04 24             	mov    %eax,(%esp)
  10f356:	e8 65 fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f35b:	98                   	cwtl   
  10f35c:	99                   	cltd   
  10f35d:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f362:	f7 f9                	idiv   %ecx
  10f364:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f367:	89 0c 24             	mov    %ecx,(%esp)
  10f36a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  10f36d:	e8 4e fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f372:	98                   	cwtl   
  10f373:	99                   	cltd   
  10f374:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f379:	f7 f9                	idiv   %ecx
  10f37b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  10f37e:	29 c1                	sub    %eax,%ecx
  10f380:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = 0;
  10f384:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
            break;
  10f38a:	e9 59 04 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
  10f38f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f392:	89 04 24             	mov    %eax,(%esp)
  10f395:	e8 26 fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f39a:	0f bf c8             	movswl %ax,%ecx
  10f39d:	8b 55 08             	mov    0x8(%ebp),%edx
  10f3a0:	89 14 24             	mov    %edx,(%esp)
  10f3a3:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  10f3a6:	e8 15 fe ff ff       	call   10f1c0 <lv_obj_get_width>
  10f3ab:	0f bf c8             	movswl %ax,%ecx
  10f3ae:	8b 55 c0             	mov    -0x40(%ebp),%edx
  10f3b1:	29 ca                	sub    %ecx,%edx
  10f3b3:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
            new_y = 0;
  10f3b7:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
            break;
  10f3bd:	e9 26 04 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = 0;
  10f3c2:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
  10f3c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f3cb:	89 04 24             	mov    %eax,(%esp)
  10f3ce:	e8 0d fe ff ff       	call   10f1e0 <lv_obj_get_height>
  10f3d3:	0f bf c8             	movswl %ax,%ecx
  10f3d6:	8b 55 08             	mov    0x8(%ebp),%edx
  10f3d9:	89 14 24             	mov    %edx,(%esp)
  10f3dc:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  10f3df:	e8 fc fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f3e4:	0f bf c8             	movswl %ax,%ecx
  10f3e7:	8b 55 bc             	mov    -0x44(%ebp),%edx
  10f3ea:	29 ca                	sub    %ecx,%edx
  10f3ec:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
            break;
  10f3f0:	e9 f3 03 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
  10f3f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f3f8:	89 04 24             	mov    %eax,(%esp)
  10f3fb:	e8 c0 fd ff ff       	call   10f1c0 <lv_obj_get_width>
  10f400:	98                   	cwtl   
  10f401:	99                   	cltd   
  10f402:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f407:	f7 f9                	idiv   %ecx
  10f409:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f40c:	89 0c 24             	mov    %ecx,(%esp)
  10f40f:	89 45 b8             	mov    %eax,-0x48(%ebp)
  10f412:	e8 a9 fd ff ff       	call   10f1c0 <lv_obj_get_width>
  10f417:	98                   	cwtl   
  10f418:	99                   	cltd   
  10f419:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f41e:	f7 f9                	idiv   %ecx
  10f420:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  10f423:	29 c1                	sub    %eax,%ecx
  10f425:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
  10f429:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f42c:	89 04 24             	mov    %eax,(%esp)
  10f42f:	e8 ac fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f434:	0f bf f0             	movswl %ax,%esi
  10f437:	8b 7d 08             	mov    0x8(%ebp),%edi
  10f43a:	89 3c 24             	mov    %edi,(%esp)
  10f43d:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  10f440:	e8 9b fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f445:	0f bf f0             	movswl %ax,%esi
  10f448:	8b 7d b4             	mov    -0x4c(%ebp),%edi
  10f44b:	29 f7                	sub    %esi,%edi
  10f44d:	66 89 7d f0          	mov    %di,-0x10(%ebp)
            break;
  10f451:	e9 92 03 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
  10f456:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f459:	89 04 24             	mov    %eax,(%esp)
  10f45c:	e8 5f fd ff ff       	call   10f1c0 <lv_obj_get_width>
  10f461:	0f bf c8             	movswl %ax,%ecx
  10f464:	8b 55 08             	mov    0x8(%ebp),%edx
  10f467:	89 14 24             	mov    %edx,(%esp)
  10f46a:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  10f46d:	e8 4e fd ff ff       	call   10f1c0 <lv_obj_get_width>
  10f472:	0f bf c8             	movswl %ax,%ecx
  10f475:	8b 55 b0             	mov    -0x50(%ebp),%edx
  10f478:	29 ca                	sub    %ecx,%edx
  10f47a:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
  10f47e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f481:	89 0c 24             	mov    %ecx,(%esp)
  10f484:	e8 57 fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f489:	0f bf c8             	movswl %ax,%ecx
  10f48c:	8b 75 08             	mov    0x8(%ebp),%esi
  10f48f:	89 34 24             	mov    %esi,(%esp)
  10f492:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  10f495:	e8 46 fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f49a:	0f bf c8             	movswl %ax,%ecx
  10f49d:	8b 75 ac             	mov    -0x54(%ebp),%esi
  10f4a0:	29 ce                	sub    %ecx,%esi
  10f4a2:	66 89 75 f0          	mov    %si,-0x10(%ebp)
            break;
  10f4a6:	e9 3d 03 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = 0;
  10f4ab:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
  10f4b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f4b4:	89 04 24             	mov    %eax,(%esp)
  10f4b7:	e8 24 fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f4bc:	98                   	cwtl   
  10f4bd:	99                   	cltd   
  10f4be:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f4c3:	f7 f9                	idiv   %ecx
  10f4c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f4c8:	89 0c 24             	mov    %ecx,(%esp)
  10f4cb:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10f4ce:	e8 0d fd ff ff       	call   10f1e0 <lv_obj_get_height>
  10f4d3:	98                   	cwtl   
  10f4d4:	99                   	cltd   
  10f4d5:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f4da:	f7 f9                	idiv   %ecx
  10f4dc:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  10f4df:	29 c1                	sub    %eax,%ecx
  10f4e1:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
            break;
  10f4e5:	e9 fe 02 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
  10f4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f4ed:	89 04 24             	mov    %eax,(%esp)
  10f4f0:	e8 cb fc ff ff       	call   10f1c0 <lv_obj_get_width>
  10f4f5:	0f bf c8             	movswl %ax,%ecx
  10f4f8:	8b 55 08             	mov    0x8(%ebp),%edx
  10f4fb:	89 14 24             	mov    %edx,(%esp)
  10f4fe:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  10f501:	e8 ba fc ff ff       	call   10f1c0 <lv_obj_get_width>
  10f506:	0f bf c8             	movswl %ax,%ecx
  10f509:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  10f50c:	29 ca                	sub    %ecx,%edx
  10f50e:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
  10f512:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f515:	89 0c 24             	mov    %ecx,(%esp)
  10f518:	e8 c3 fc ff ff       	call   10f1e0 <lv_obj_get_height>
  10f51d:	98                   	cwtl   
  10f51e:	99                   	cltd   
  10f51f:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f524:	f7 f9                	idiv   %ecx
  10f526:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f529:	89 0c 24             	mov    %ecx,(%esp)
  10f52c:	89 45 a0             	mov    %eax,-0x60(%ebp)
  10f52f:	e8 ac fc ff ff       	call   10f1e0 <lv_obj_get_height>
  10f534:	98                   	cwtl   
  10f535:	99                   	cltd   
  10f536:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f53b:	f7 f9                	idiv   %ecx
  10f53d:	8b 4d a0             	mov    -0x60(%ebp),%ecx
  10f540:	29 c1                	sub    %eax,%ecx
  10f542:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
            break;
  10f546:	e9 9d 02 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = 0;
  10f54b:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
            new_y = -lv_obj_get_height(obj);
  10f551:	8b 45 08             	mov    0x8(%ebp),%eax
  10f554:	89 04 24             	mov    %eax,(%esp)
  10f557:	e8 84 fc ff ff       	call   10f1e0 <lv_obj_get_height>
  10f55c:	31 c9                	xor    %ecx,%ecx
  10f55e:	0f bf d0             	movswl %ax,%edx
  10f561:	29 d1                	sub    %edx,%ecx
  10f563:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
            break;
  10f567:	e9 7c 02 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
  10f56c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f56f:	89 04 24             	mov    %eax,(%esp)
  10f572:	e8 49 fc ff ff       	call   10f1c0 <lv_obj_get_width>
  10f577:	98                   	cwtl   
  10f578:	99                   	cltd   
  10f579:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f57e:	f7 f9                	idiv   %ecx
  10f580:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f583:	89 0c 24             	mov    %ecx,(%esp)
  10f586:	89 45 9c             	mov    %eax,-0x64(%ebp)
  10f589:	e8 32 fc ff ff       	call   10f1c0 <lv_obj_get_width>
  10f58e:	98                   	cwtl   
  10f58f:	99                   	cltd   
  10f590:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f595:	f7 f9                	idiv   %ecx
  10f597:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
  10f59a:	29 c1                	sub    %eax,%ecx
  10f59c:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = -lv_obj_get_height(obj);
  10f5a0:	8b 45 08             	mov    0x8(%ebp),%eax
  10f5a3:	89 04 24             	mov    %eax,(%esp)
  10f5a6:	e8 35 fc ff ff       	call   10f1e0 <lv_obj_get_height>
  10f5ab:	31 f6                	xor    %esi,%esi
  10f5ad:	0f bf f8             	movswl %ax,%edi
  10f5b0:	29 fe                	sub    %edi,%esi
  10f5b2:	66 89 75 f0          	mov    %si,-0x10(%ebp)
            break;
  10f5b6:	e9 2d 02 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
  10f5bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f5be:	89 04 24             	mov    %eax,(%esp)
  10f5c1:	e8 fa fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f5c6:	0f bf c8             	movswl %ax,%ecx
  10f5c9:	8b 55 08             	mov    0x8(%ebp),%edx
  10f5cc:	89 14 24             	mov    %edx,(%esp)
  10f5cf:	89 4d 98             	mov    %ecx,-0x68(%ebp)
  10f5d2:	e8 e9 fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f5d7:	0f bf c8             	movswl %ax,%ecx
  10f5da:	8b 55 98             	mov    -0x68(%ebp),%edx
  10f5dd:	29 ca                	sub    %ecx,%edx
  10f5df:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
            new_y = -lv_obj_get_height(obj);
  10f5e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f5e6:	89 0c 24             	mov    %ecx,(%esp)
  10f5e9:	e8 f2 fb ff ff       	call   10f1e0 <lv_obj_get_height>
  10f5ee:	31 c9                	xor    %ecx,%ecx
  10f5f0:	0f bf f0             	movswl %ax,%esi
  10f5f3:	29 f1                	sub    %esi,%ecx
  10f5f5:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
            break;
  10f5f9:	e9 ea 01 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = 0;
  10f5fe:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
            new_y = lv_obj_get_height(base);
  10f604:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f607:	89 04 24             	mov    %eax,(%esp)
  10f60a:	e8 d1 fb ff ff       	call   10f1e0 <lv_obj_get_height>
  10f60f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
            break;
  10f613:	e9 d0 01 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
  10f618:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f61b:	89 04 24             	mov    %eax,(%esp)
  10f61e:	e8 9d fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f623:	98                   	cwtl   
  10f624:	99                   	cltd   
  10f625:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f62a:	f7 f9                	idiv   %ecx
  10f62c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f62f:	89 0c 24             	mov    %ecx,(%esp)
  10f632:	89 45 94             	mov    %eax,-0x6c(%ebp)
  10f635:	e8 86 fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f63a:	98                   	cwtl   
  10f63b:	99                   	cltd   
  10f63c:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f641:	f7 f9                	idiv   %ecx
  10f643:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
  10f646:	29 c1                	sub    %eax,%ecx
  10f648:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = lv_obj_get_height(base);
  10f64c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f64f:	89 04 24             	mov    %eax,(%esp)
  10f652:	e8 89 fb ff ff       	call   10f1e0 <lv_obj_get_height>
  10f657:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
            break;
  10f65b:	e9 88 01 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
  10f660:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f663:	89 04 24             	mov    %eax,(%esp)
  10f666:	e8 55 fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f66b:	0f bf c8             	movswl %ax,%ecx
  10f66e:	8b 55 08             	mov    0x8(%ebp),%edx
  10f671:	89 14 24             	mov    %edx,(%esp)
  10f674:	89 4d 90             	mov    %ecx,-0x70(%ebp)
  10f677:	e8 44 fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f67c:	0f bf c8             	movswl %ax,%ecx
  10f67f:	8b 55 90             	mov    -0x70(%ebp),%edx
  10f682:	29 ca                	sub    %ecx,%edx
  10f684:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
            new_y = lv_obj_get_height(base);
  10f688:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f68b:	89 0c 24             	mov    %ecx,(%esp)
  10f68e:	e8 4d fb ff ff       	call   10f1e0 <lv_obj_get_height>
  10f693:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
            break;
  10f697:	e9 4c 01 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = -lv_obj_get_width(obj);
  10f69c:	8b 45 08             	mov    0x8(%ebp),%eax
  10f69f:	89 04 24             	mov    %eax,(%esp)
  10f6a2:	e8 19 fb ff ff       	call   10f1c0 <lv_obj_get_width>
  10f6a7:	31 c9                	xor    %ecx,%ecx
  10f6a9:	0f bf d0             	movswl %ax,%edx
  10f6ac:	29 d1                	sub    %edx,%ecx
  10f6ae:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = 0;
  10f6b2:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
            break;
  10f6b8:	e9 2b 01 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = -lv_obj_get_width(obj);
  10f6bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10f6c0:	89 04 24             	mov    %eax,(%esp)
  10f6c3:	e8 f8 fa ff ff       	call   10f1c0 <lv_obj_get_width>
  10f6c8:	31 c9                	xor    %ecx,%ecx
  10f6ca:	0f bf d0             	movswl %ax,%edx
  10f6cd:	29 d1                	sub    %edx,%ecx
  10f6cf:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
  10f6d3:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f6d6:	89 14 24             	mov    %edx,(%esp)
  10f6d9:	e8 02 fb ff ff       	call   10f1e0 <lv_obj_get_height>
  10f6de:	98                   	cwtl   
  10f6df:	99                   	cltd   
  10f6e0:	be 02 00 00 00       	mov    $0x2,%esi
  10f6e5:	f7 fe                	idiv   %esi
  10f6e7:	8b 75 08             	mov    0x8(%ebp),%esi
  10f6ea:	89 34 24             	mov    %esi,(%esp)
  10f6ed:	89 45 8c             	mov    %eax,-0x74(%ebp)
  10f6f0:	e8 eb fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f6f5:	98                   	cwtl   
  10f6f6:	99                   	cltd   
  10f6f7:	be 02 00 00 00       	mov    $0x2,%esi
  10f6fc:	f7 fe                	idiv   %esi
  10f6fe:	8b 75 8c             	mov    -0x74(%ebp),%esi
  10f701:	29 c6                	sub    %eax,%esi
  10f703:	66 89 75 f0          	mov    %si,-0x10(%ebp)
            break;
  10f707:	e9 dc 00 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = -lv_obj_get_width(obj);
  10f70c:	8b 45 08             	mov    0x8(%ebp),%eax
  10f70f:	89 04 24             	mov    %eax,(%esp)
  10f712:	e8 a9 fa ff ff       	call   10f1c0 <lv_obj_get_width>
  10f717:	31 c9                	xor    %ecx,%ecx
  10f719:	0f bf d0             	movswl %ax,%edx
  10f71c:	29 d1                	sub    %edx,%ecx
  10f71e:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
  10f722:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f725:	89 14 24             	mov    %edx,(%esp)
  10f728:	e8 b3 fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f72d:	0f bf d0             	movswl %ax,%edx
  10f730:	8b 75 08             	mov    0x8(%ebp),%esi
  10f733:	89 34 24             	mov    %esi,(%esp)
  10f736:	89 55 88             	mov    %edx,-0x78(%ebp)
  10f739:	e8 a2 fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f73e:	0f bf d0             	movswl %ax,%edx
  10f741:	8b 75 88             	mov    -0x78(%ebp),%esi
  10f744:	29 d6                	sub    %edx,%esi
  10f746:	66 89 75 f0          	mov    %si,-0x10(%ebp)
            break;
  10f74a:	e9 99 00 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base);
  10f74f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f752:	89 04 24             	mov    %eax,(%esp)
  10f755:	e8 66 fa ff ff       	call   10f1c0 <lv_obj_get_width>
  10f75a:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
            new_y = 0;
  10f75e:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
            break;
  10f764:	e9 7f 00 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base);
  10f769:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f76c:	89 04 24             	mov    %eax,(%esp)
  10f76f:	e8 4c fa ff ff       	call   10f1c0 <lv_obj_get_width>
  10f774:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
  10f778:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f77b:	89 0c 24             	mov    %ecx,(%esp)
  10f77e:	e8 5d fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f783:	98                   	cwtl   
  10f784:	99                   	cltd   
  10f785:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f78a:	f7 f9                	idiv   %ecx
  10f78c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f78f:	89 0c 24             	mov    %ecx,(%esp)
  10f792:	89 45 84             	mov    %eax,-0x7c(%ebp)
  10f795:	e8 46 fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f79a:	98                   	cwtl   
  10f79b:	99                   	cltd   
  10f79c:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f7a1:	f7 f9                	idiv   %ecx
  10f7a3:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
  10f7a6:	29 c1                	sub    %eax,%ecx
  10f7a8:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
            break;
  10f7ac:	e9 37 00 00 00       	jmp    10f7e8 <lv_obj_align+0x598>
            new_x = lv_obj_get_width(base);
  10f7b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f7b4:	89 04 24             	mov    %eax,(%esp)
  10f7b7:	e8 04 fa ff ff       	call   10f1c0 <lv_obj_get_width>
  10f7bc:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
  10f7c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f7c3:	89 0c 24             	mov    %ecx,(%esp)
  10f7c6:	e8 15 fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f7cb:	0f bf c8             	movswl %ax,%ecx
  10f7ce:	8b 55 08             	mov    0x8(%ebp),%edx
  10f7d1:	89 14 24             	mov    %edx,(%esp)
  10f7d4:	89 4d 80             	mov    %ecx,-0x80(%ebp)
  10f7d7:	e8 04 fa ff ff       	call   10f1e0 <lv_obj_get_height>
  10f7dc:	0f bf c8             	movswl %ax,%ecx
  10f7df:	8b 55 80             	mov    -0x80(%ebp),%edx
  10f7e2:	29 ca                	sub    %ecx,%edx
  10f7e4:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
    lv_obj_t * par        = lv_obj_get_parent(obj);
  10f7e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10f7eb:	89 04 24             	mov    %eax,(%esp)
  10f7ee:	e8 6d f1 ff ff       	call   10e960 <lv_obj_get_parent>
  10f7f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    lv_coord_t base_abs_x = base->coords.x1;
  10f7f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f7f9:	66 8b 48 10          	mov    0x10(%eax),%cx
  10f7fd:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
    lv_coord_t base_abs_y = base->coords.y1;
  10f801:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f804:	66 8b 48 12          	mov    0x12(%eax),%cx
  10f808:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
    lv_coord_t par_abs_x  = par->coords.x1;
  10f80c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10f80f:	66 8b 48 10          	mov    0x10(%eax),%cx
  10f813:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
    lv_coord_t par_abs_y  = par->coords.y1;
  10f817:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10f81a:	66 8b 48 12          	mov    0x12(%eax),%cx
  10f81e:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    new_x += x_mod + base_abs_x;
  10f822:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  10f826:	0f bf 55 ea          	movswl -0x16(%ebp),%edx
  10f82a:	01 d0                	add    %edx,%eax
  10f82c:	0f bf 55 f2          	movswl -0xe(%ebp),%edx
  10f830:	01 c2                	add    %eax,%edx
  10f832:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
    new_y += y_mod + base_abs_y;
  10f836:	0f bf 45 18          	movswl 0x18(%ebp),%eax
  10f83a:	0f bf 75 e8          	movswl -0x18(%ebp),%esi
  10f83e:	01 f0                	add    %esi,%eax
  10f840:	0f bf 75 f0          	movswl -0x10(%ebp),%esi
  10f844:	01 c6                	add    %eax,%esi
  10f846:	66 89 75 f0          	mov    %si,-0x10(%ebp)
    new_x -= par_abs_x;
  10f84a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  10f84e:	0f bf 7d f2          	movswl -0xe(%ebp),%edi
  10f852:	29 c7                	sub    %eax,%edi
  10f854:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    new_y -= par_abs_y;
  10f858:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
  10f85c:	0f bf 5d f0          	movswl -0x10(%ebp),%ebx
  10f860:	29 c3                	sub    %eax,%ebx
  10f862:	66 89 5d f0          	mov    %bx,-0x10(%ebp)
    lv_obj_set_pos(obj, new_x, new_y);
  10f866:	8b 45 08             	mov    0x8(%ebp),%eax
  10f869:	66 8b 4d f2          	mov    -0xe(%ebp),%cx
  10f86d:	89 04 24             	mov    %eax,(%esp)
  10f870:	0f bf c1             	movswl %cx,%eax
  10f873:	89 44 24 04          	mov    %eax,0x4(%esp)
  10f877:	0f bf 45 f0          	movswl -0x10(%ebp),%eax
  10f87b:	89 44 24 08          	mov    %eax,0x8(%esp)
  10f87f:	e8 fc f0 ff ff       	call   10e980 <lv_obj_set_pos>
}
  10f884:	81 c4 80 00 00 00    	add    $0x80,%esp
  10f88a:	5e                   	pop    %esi
  10f88b:	5f                   	pop    %edi
  10f88c:	5b                   	pop    %ebx
  10f88d:	5d                   	pop    %ebp
  10f88e:	c3                   	ret    
  10f88f:	90                   	nop

0010f890 <lv_obj_set_style>:
{
  10f890:	55                   	push   %ebp
  10f891:	89 e5                	mov    %esp,%ebp
  10f893:	56                   	push   %esi
  10f894:	83 ec 0c             	sub    $0xc,%esp
  10f897:	8b 45 0c             	mov    0xc(%ebp),%eax
  10f89a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    obj->style_p = style;
  10f89d:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f8a0:	8b 75 08             	mov    0x8(%ebp),%esi
  10f8a3:	89 56 28             	mov    %edx,0x28(%esi)
    refresh_children_style(obj);
  10f8a6:	8b 55 08             	mov    0x8(%ebp),%edx
  10f8a9:	89 14 24             	mov    %edx,(%esp)
  10f8ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10f8af:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10f8b2:	e8 19 00 00 00       	call   10f8d0 <refresh_children_style>
    lv_obj_refresh_style(obj);
  10f8b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8ba:	89 04 24             	mov    %eax,(%esp)
  10f8bd:	e8 ae 00 00 00       	call   10f970 <lv_obj_refresh_style>
}
  10f8c2:	83 c4 0c             	add    $0xc,%esp
  10f8c5:	5e                   	pop    %esi
  10f8c6:	5d                   	pop    %ebp
  10f8c7:	c3                   	ret    
  10f8c8:	66 90                	xchg   %ax,%ax
  10f8ca:	66 90                	xchg   %ax,%ax
  10f8cc:	66 90                	xchg   %ax,%ax
  10f8ce:	66 90                	xchg   %ax,%ax

0010f8d0 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
  10f8d0:	55                   	push   %ebp
  10f8d1:	89 e5                	mov    %esp,%ebp
  10f8d3:	83 ec 14             	sub    $0x14,%esp
  10f8d6:	8b 45 08             	mov    0x8(%ebp),%eax
  10f8d9:	31 c9                	xor    %ecx,%ecx
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
  10f8db:	8b 55 08             	mov    0x8(%ebp),%edx
  10f8de:	89 14 24             	mov    %edx,(%esp)
  10f8e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10f8e8:	00 
  10f8e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10f8ec:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10f8ef:	e8 4c f5 ff ff       	call   10ee40 <lv_obj_get_child>
  10f8f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(child != NULL) {
  10f8f7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10f8fb:	0f 84 66 00 00 00    	je     10f967 <refresh_children_style+0x97>
        if(child->style_p == NULL) {
  10f901:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10f904:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
  10f908:	0f 85 1b 00 00 00    	jne    10f929 <refresh_children_style+0x59>
            refresh_children_style(child); /*Check children too*/
  10f90e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10f911:	89 04 24             	mov    %eax,(%esp)
  10f914:	e8 b7 ff ff ff       	call   10f8d0 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
  10f919:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10f91c:	89 04 24             	mov    %eax,(%esp)
  10f91f:	e8 4c 00 00 00       	call   10f970 <lv_obj_refresh_style>
        } else if(child->style_p->glass) {
  10f924:	e9 24 00 00 00       	jmp    10f94d <refresh_children_style+0x7d>
  10f929:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10f92c:	8b 40 28             	mov    0x28(%eax),%eax
  10f92f:	8a 08                	mov    (%eax),%cl
  10f931:	80 e1 01             	and    $0x1,%cl
  10f934:	80 f9 00             	cmp    $0x0,%cl
  10f937:	0f 84 0b 00 00 00    	je     10f948 <refresh_children_style+0x78>
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
  10f93d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10f940:	89 04 24             	mov    %eax,(%esp)
  10f943:	e8 88 ff ff ff       	call   10f8d0 <refresh_children_style>
  10f948:	e9 00 00 00 00       	jmp    10f94d <refresh_children_style+0x7d>
        }
        child = lv_obj_get_child(obj, child);
  10f94d:	8b 45 08             	mov    0x8(%ebp),%eax
  10f950:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10f953:	89 04 24             	mov    %eax,(%esp)
  10f956:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10f95a:	e8 e1 f4 ff ff       	call   10ee40 <lv_obj_get_child>
  10f95f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(child != NULL) {
  10f962:	e9 90 ff ff ff       	jmp    10f8f7 <refresh_children_style+0x27>
    }
}
  10f967:	83 c4 14             	add    $0x14,%esp
  10f96a:	5d                   	pop    %ebp
  10f96b:	c3                   	ret    
  10f96c:	66 90                	xchg   %ax,%ax
  10f96e:	66 90                	xchg   %ax,%ax

0010f970 <lv_obj_refresh_style>:
{
  10f970:	55                   	push   %ebp
  10f971:	89 e5                	mov    %esp,%ebp
  10f973:	83 ec 18             	sub    $0x18,%esp
  10f976:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_obj_invalidate(obj);
  10f979:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f97c:	89 0c 24             	mov    %ecx,(%esp)
  10f97f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10f982:	e8 e9 f1 ff ff       	call   10eb70 <lv_obj_invalidate>
  10f987:	31 c0                	xor    %eax,%eax
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
  10f989:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f98c:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  10f98f:	8b 55 08             	mov    0x8(%ebp),%edx
  10f992:	89 14 24             	mov    %edx,(%esp)
  10f995:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  10f99c:	00 
  10f99d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10f9a4:	00 
  10f9a5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10f9a8:	ff d1                	call   *%ecx
    lv_obj_invalidate(obj);
  10f9aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f9ad:	89 0c 24             	mov    %ecx,(%esp)
  10f9b0:	88 45 f7             	mov    %al,-0x9(%ebp)
  10f9b3:	e8 b8 f1 ff ff       	call   10eb70 <lv_obj_invalidate>
}
  10f9b8:	83 c4 18             	add    $0x18,%esp
  10f9bb:	5d                   	pop    %ebp
  10f9bc:	c3                   	ret    
  10f9bd:	66 90                	xchg   %ax,%ax
  10f9bf:	90                   	nop

0010f9c0 <lv_obj_set_click>:
{
  10f9c0:	55                   	push   %ebp
  10f9c1:	89 e5                	mov    %esp,%ebp
  10f9c3:	53                   	push   %ebx
  10f9c4:	56                   	push   %esi
  10f9c5:	83 ec 0c             	sub    $0xc,%esp
  10f9c8:	8a 45 0c             	mov    0xc(%ebp),%al
  10f9cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f9ce:	31 d2                	xor    %edx,%edx
  10f9d0:	24 01                	and    $0x1,%al
  10f9d2:	88 45 f7             	mov    %al,-0x9(%ebp)
    obj->click = (en == true ? 1 : 0);
  10f9d5:	8a 45 f7             	mov    -0x9(%ebp),%al
  10f9d8:	24 01                	and    $0x1,%al
  10f9da:	0f b6 f0             	movzbl %al,%esi
  10f9dd:	83 fe 01             	cmp    $0x1,%esi
  10f9e0:	be 01 00 00 00       	mov    $0x1,%esi
  10f9e5:	89 f3                	mov    %esi,%ebx
  10f9e7:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10f9ea:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  10f9ed:	0f 84 06 00 00 00    	je     10f9f9 <lv_obj_set_click+0x39>
  10f9f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10f9f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10f9f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10f9fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10f9ff:	0f b6 d0             	movzbl %al,%edx
  10fa02:	66 8b 71 2c          	mov    0x2c(%ecx),%si
  10fa06:	66 83 e2 01          	and    $0x1,%dx
  10fa0a:	66 83 e6 fe          	and    $0xfffe,%si
  10fa0e:	66 09 d6             	or     %dx,%si
  10fa11:	66 89 71 2c          	mov    %si,0x2c(%ecx)
}
  10fa15:	83 c4 0c             	add    $0xc,%esp
  10fa18:	5e                   	pop    %esi
  10fa19:	5b                   	pop    %ebx
  10fa1a:	5d                   	pop    %ebp
  10fa1b:	c3                   	ret    
  10fa1c:	66 90                	xchg   %ax,%ax
  10fa1e:	66 90                	xchg   %ax,%ax

0010fa20 <lv_obj_allocate_ext_attr>:
{
  10fa20:	55                   	push   %ebp
  10fa21:	89 e5                	mov    %esp,%ebp
  10fa23:	56                   	push   %esi
  10fa24:	83 ec 10             	sub    $0x10,%esp
  10fa27:	66 8b 45 0c          	mov    0xc(%ebp),%ax
  10fa2b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
  10fa2e:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa31:	8b 52 24             	mov    0x24(%edx),%edx
  10fa34:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  10fa38:	89 14 24             	mov    %edx,(%esp)
  10fa3b:	89 74 24 04          	mov    %esi,0x4(%esp)
  10fa3f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  10fa43:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10fa46:	e8 f5 8e 00 00       	call   118940 <lv_mem_realloc>
  10fa4b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fa4e:	89 41 24             	mov    %eax,0x24(%ecx)
    return (void *)obj->ext_attr;
  10fa51:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa54:	8b 40 24             	mov    0x24(%eax),%eax
  10fa57:	83 c4 10             	add    $0x10,%esp
  10fa5a:	5e                   	pop    %esi
  10fa5b:	5d                   	pop    %ebp
  10fa5c:	c3                   	ret    
  10fa5d:	66 90                	xchg   %ax,%ax
  10fa5f:	90                   	nop

0010fa60 <lv_obj_refresh_ext_draw_pad>:
{
  10fa60:	55                   	push   %ebp
  10fa61:	89 e5                	mov    %esp,%ebp
  10fa63:	56                   	push   %esi
  10fa64:	83 ec 18             	sub    $0x18,%esp
  10fa67:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa6a:	31 c9                	xor    %ecx,%ecx
    obj->ext_draw_pad = 0;
  10fa6c:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa6f:	66 c7 42 30 00 00    	movw   $0x0,0x30(%edx)
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
  10fa75:	8b 55 08             	mov    0x8(%ebp),%edx
  10fa78:	8b 52 1c             	mov    0x1c(%edx),%edx
  10fa7b:	8b 75 08             	mov    0x8(%ebp),%esi
  10fa7e:	89 34 24             	mov    %esi,(%esp)
  10fa81:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  10fa88:	00 
  10fa89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10fa90:	00 
  10fa91:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10fa94:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10fa97:	ff d2                	call   *%edx
    lv_obj_invalidate(obj);
  10fa99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fa9c:	89 0c 24             	mov    %ecx,(%esp)
  10fa9f:	88 45 f3             	mov    %al,-0xd(%ebp)
  10faa2:	e8 c9 f0 ff ff       	call   10eb70 <lv_obj_invalidate>
}
  10faa7:	83 c4 18             	add    $0x18,%esp
  10faaa:	5e                   	pop    %esi
  10faab:	5d                   	pop    %ebp
  10faac:	c3                   	ret    
  10faad:	66 90                	xchg   %ax,%ax
  10faaf:	90                   	nop

0010fab0 <lv_obj_get_style>:
{
  10fab0:	55                   	push   %ebp
  10fab1:	89 e5                	mov    %esp,%ebp
  10fab3:	83 ec 08             	sub    $0x8,%esp
  10fab6:	8b 45 08             	mov    0x8(%ebp),%eax
    const lv_style_t * style_act = obj->style_p;
  10fab9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fabc:	8b 49 28             	mov    0x28(%ecx),%ecx
  10fabf:	89 4d fc             	mov    %ecx,-0x4(%ebp)
    if(style_act == NULL) {
  10fac2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10fac6:	0f 85 5b 00 00 00    	jne    10fb27 <lv_obj_get_style+0x77>
        lv_obj_t * par = obj->par;
  10facc:	8b 45 08             	mov    0x8(%ebp),%eax
  10facf:	8b 00                	mov    (%eax),%eax
  10fad1:	89 45 f8             	mov    %eax,-0x8(%ebp)
        while(par) {
  10fad4:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10fad8:	0f 84 44 00 00 00    	je     10fb22 <lv_obj_get_style+0x72>
            if(par->style_p) {
  10fade:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fae1:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
  10fae5:	0f 84 2a 00 00 00    	je     10fb15 <lv_obj_get_style+0x65>
                if(par->style_p->glass == 0) {
  10faeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10faee:	8b 40 28             	mov    0x28(%eax),%eax
  10faf1:	8a 08                	mov    (%eax),%cl
  10faf3:	80 e1 01             	and    $0x1,%cl
  10faf6:	0f b6 c1             	movzbl %cl,%eax
  10faf9:	83 f8 00             	cmp    $0x0,%eax
  10fafc:	0f 85 0e 00 00 00    	jne    10fb10 <lv_obj_get_style+0x60>
                    style_act = par->style_p;
  10fb02:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fb05:	8b 40 28             	mov    0x28(%eax),%eax
  10fb08:	89 45 fc             	mov    %eax,-0x4(%ebp)
                    break;
  10fb0b:	e9 12 00 00 00       	jmp    10fb22 <lv_obj_get_style+0x72>
            }
  10fb10:	e9 00 00 00 00       	jmp    10fb15 <lv_obj_get_style+0x65>
            par = par->par;
  10fb15:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fb18:	8b 00                	mov    (%eax),%eax
  10fb1a:	89 45 f8             	mov    %eax,-0x8(%ebp)
        while(par) {
  10fb1d:	e9 b2 ff ff ff       	jmp    10fad4 <lv_obj_get_style+0x24>
    }
  10fb22:	e9 00 00 00 00       	jmp    10fb27 <lv_obj_get_style+0x77>
    if(style_act == NULL) style_act = &lv_style_plain;
  10fb27:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10fb2b:	0f 85 09 00 00 00    	jne    10fb3a <lv_obj_get_style+0x8a>
  10fb31:	8d 05 a0 51 13 00    	lea    0x1351a0,%eax
  10fb37:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return style_act;
  10fb3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10fb3d:	83 c4 08             	add    $0x8,%esp
  10fb40:	5d                   	pop    %ebp
  10fb41:	c3                   	ret    
  10fb42:	66 90                	xchg   %ax,%ax
  10fb44:	66 90                	xchg   %ax,%ax
  10fb46:	66 90                	xchg   %ax,%ax
  10fb48:	66 90                	xchg   %ax,%ax
  10fb4a:	66 90                	xchg   %ax,%ax
  10fb4c:	66 90                	xchg   %ax,%ax
  10fb4e:	66 90                	xchg   %ax,%ax

0010fb50 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
  10fb50:	55                   	push   %ebp
  10fb51:	89 e5                	mov    %esp,%ebp
  10fb53:	50                   	push   %eax
  10fb54:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  10fb57:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fb5a:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  10fb5e:	8b 55 08             	mov    0x8(%ebp),%edx
  10fb61:	0f bf 12             	movswl (%edx),%edx
  10fb64:	29 d1                	sub    %edx,%ecx
  10fb66:	83 c1 01             	add    $0x1,%ecx
  10fb69:	0f bf d1             	movswl %cx,%edx
  10fb6c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10fb6f:	89 d0                	mov    %edx,%eax
  10fb71:	83 c4 04             	add    $0x4,%esp
  10fb74:	5d                   	pop    %ebp
  10fb75:	c3                   	ret    
  10fb76:	66 90                	xchg   %ax,%ax
  10fb78:	66 90                	xchg   %ax,%ax
  10fb7a:	66 90                	xchg   %ax,%ax
  10fb7c:	66 90                	xchg   %ax,%ax
  10fb7e:	66 90                	xchg   %ax,%ax

0010fb80 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
  10fb80:	55                   	push   %ebp
  10fb81:	89 e5                	mov    %esp,%ebp
  10fb83:	50                   	push   %eax
  10fb84:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->y2 - area_p->y1 + 1;
  10fb87:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fb8a:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  10fb8e:	8b 55 08             	mov    0x8(%ebp),%edx
  10fb91:	0f bf 52 02          	movswl 0x2(%edx),%edx
  10fb95:	29 d1                	sub    %edx,%ecx
  10fb97:	83 c1 01             	add    $0x1,%ecx
  10fb9a:	0f bf d1             	movswl %cx,%edx
  10fb9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10fba0:	89 d0                	mov    %edx,%eax
  10fba2:	83 c4 04             	add    $0x4,%esp
  10fba5:	5d                   	pop    %ebp
  10fba6:	c3                   	ret    
  10fba7:	66 90                	xchg   %ax,%ax
  10fba9:	66 90                	xchg   %ax,%ax
  10fbab:	66 90                	xchg   %ax,%ax
  10fbad:	66 90                	xchg   %ax,%ax
  10fbaf:	90                   	nop

0010fbb0 <lv_obj_get_opa_scale>:
{
  10fbb0:	55                   	push   %ebp
  10fbb1:	89 e5                	mov    %esp,%ebp
  10fbb3:	83 ec 0c             	sub    $0xc,%esp
  10fbb6:	8b 45 08             	mov    0x8(%ebp),%eax
    const lv_obj_t * parent = obj;
  10fbb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fbbc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    while(parent) {
  10fbbf:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10fbc3:	0f 84 39 00 00 00    	je     10fc02 <lv_obj_get_opa_scale+0x52>
        if(parent->opa_scale_en) return parent->opa_scale;
  10fbc9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fbcc:	66 8b 48 2c          	mov    0x2c(%eax),%cx
  10fbd0:	66 c1 e9 06          	shr    $0x6,%cx
  10fbd4:	66 83 e1 01          	and    $0x1,%cx
  10fbd8:	80 f9 00             	cmp    $0x0,%cl
  10fbdb:	0f 84 0e 00 00 00    	je     10fbef <lv_obj_get_opa_scale+0x3f>
  10fbe1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fbe4:	8a 48 2f             	mov    0x2f(%eax),%cl
  10fbe7:	88 4d ff             	mov    %cl,-0x1(%ebp)
  10fbea:	e9 17 00 00 00       	jmp    10fc06 <lv_obj_get_opa_scale+0x56>
        parent = lv_obj_get_parent(parent);
  10fbef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10fbf2:	89 04 24             	mov    %eax,(%esp)
  10fbf5:	e8 66 ed ff ff       	call   10e960 <lv_obj_get_parent>
  10fbfa:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(parent) {
  10fbfd:	e9 bd ff ff ff       	jmp    10fbbf <lv_obj_get_opa_scale+0xf>
    return LV_OPA_COVER;
  10fc02:	c6 45 ff ff          	movb   $0xff,-0x1(%ebp)
}
  10fc06:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  10fc0a:	83 c4 0c             	add    $0xc,%esp
  10fc0d:	5d                   	pop    %ebp
  10fc0e:	c3                   	ret    
  10fc0f:	90                   	nop

0010fc10 <lv_obj_is_protected>:
{
  10fc10:	55                   	push   %ebp
  10fc11:	89 e5                	mov    %esp,%ebp
  10fc13:	57                   	push   %edi
  10fc14:	56                   	push   %esi
  10fc15:	83 ec 08             	sub    $0x8,%esp
  10fc18:	8a 45 0c             	mov    0xc(%ebp),%al
  10fc1b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fc1e:	31 d2                	xor    %edx,%edx
    return (obj->protect & prot) == 0 ? false : true;
  10fc20:	8b 75 08             	mov    0x8(%ebp),%esi
  10fc23:	0f b6 76 2e          	movzbl 0x2e(%esi),%esi
  10fc27:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  10fc2b:	21 fe                	and    %edi,%esi
  10fc2d:	83 fe 00             	cmp    $0x0,%esi
  10fc30:	be 01 00 00 00       	mov    $0x1,%esi
  10fc35:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10fc38:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10fc3b:	0f 84 06 00 00 00    	je     10fc47 <lv_obj_is_protected+0x37>
  10fc41:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fc44:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10fc47:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10fc4a:	83 f8 00             	cmp    $0x0,%eax
  10fc4d:	0f 95 c1             	setne  %cl
  10fc50:	80 e1 01             	and    $0x1,%cl
  10fc53:	0f b6 c1             	movzbl %cl,%eax
  10fc56:	83 c4 08             	add    $0x8,%esp
  10fc59:	5e                   	pop    %esi
  10fc5a:	5f                   	pop    %edi
  10fc5b:	5d                   	pop    %ebp
  10fc5c:	c3                   	ret    
  10fc5d:	66 90                	xchg   %ax,%ax
  10fc5f:	90                   	nop

0010fc60 <lv_obj_get_signal_cb>:
{
  10fc60:	55                   	push   %ebp
  10fc61:	89 e5                	mov    %esp,%ebp
  10fc63:	50                   	push   %eax
  10fc64:	8b 45 08             	mov    0x8(%ebp),%eax
    return obj->signal_cb;
  10fc67:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fc6a:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  10fc6d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10fc70:	89 c8                	mov    %ecx,%eax
  10fc72:	83 c4 04             	add    $0x4,%esp
  10fc75:	5d                   	pop    %ebp
  10fc76:	c3                   	ret    
  10fc77:	66 90                	xchg   %ax,%ax
  10fc79:	66 90                	xchg   %ax,%ax
  10fc7b:	66 90                	xchg   %ax,%ax
  10fc7d:	66 90                	xchg   %ax,%ax
  10fc7f:	90                   	nop

0010fc80 <lv_obj_get_ext_attr>:
{
  10fc80:	55                   	push   %ebp
  10fc81:	89 e5                	mov    %esp,%ebp
  10fc83:	50                   	push   %eax
  10fc84:	8b 45 08             	mov    0x8(%ebp),%eax
    return obj->ext_attr;
  10fc87:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10fc8a:	8b 49 24             	mov    0x24(%ecx),%ecx
  10fc8d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10fc90:	89 c8                	mov    %ecx,%eax
  10fc92:	83 c4 04             	add    $0x4,%esp
  10fc95:	5d                   	pop    %ebp
  10fc96:	c3                   	ret    
  10fc97:	66 90                	xchg   %ax,%ax
  10fc99:	66 90                	xchg   %ax,%ax
  10fc9b:	66 90                	xchg   %ax,%ax
  10fc9d:	66 90                	xchg   %ax,%ax
  10fc9f:	90                   	nop

0010fca0 <lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void lv_refr_init(void)
{
  10fca0:	55                   	push   %ebp
  10fca1:	89 e5                	mov    %esp,%ebp
    /*Nothing to do*/
}
  10fca3:	5d                   	pop    %ebp
  10fca4:	c3                   	ret    
  10fca5:	66 90                	xchg   %ax,%ax
  10fca7:	66 90                	xchg   %ax,%ax
  10fca9:	66 90                	xchg   %ax,%ax
  10fcab:	66 90                	xchg   %ax,%ax
  10fcad:	66 90                	xchg   %ax,%ax
  10fcaf:	90                   	nop

0010fcb0 <lv_disp_refr_task>:
/**
 * Called periodically to handle the refreshing
 * @param task pointer to the task itself
 */
void lv_disp_refr_task(lv_task_t * task)
{
  10fcb0:	55                   	push   %ebp
  10fcb1:	89 e5                	mov    %esp,%ebp
  10fcb3:	56                   	push   %esi
  10fcb4:	83 ec 48             	sub    $0x48,%esp
  10fcb7:	8b 45 08             	mov    0x8(%ebp),%eax
  10fcba:	89 45 d8             	mov    %eax,-0x28(%ebp)
    LV_LOG_TRACE("lv_refr_task: started");

    uint32_t start = lv_tick_get();
  10fcbd:	e8 0e 7d 00 00       	call   1179d0 <lv_tick_get>
  10fcc2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    disp_refr = task->user_data;
  10fcc5:	8b 45 08             	mov    0x8(%ebp),%eax
  10fcc8:	8b 40 0c             	mov    0xc(%eax),%eax
  10fccb:	a3 48 51 13 00       	mov    %eax,0x135148

    lv_refr_join_area();
  10fcd0:	e8 0b 05 00 00       	call   1101e0 <lv_refr_join_area>

    lv_refr_areas();
  10fcd5:	e8 e6 06 00 00       	call   1103c0 <lv_refr_areas>

    /*If refresh happened ...*/
    if(disp_refr->inv_p != 0) {
  10fcda:	a1 48 51 13 00       	mov    0x135148,%eax
  10fcdf:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  10fce6:	66 81 e1 ff 03       	and    $0x3ff,%cx
  10fceb:	0f b7 c1             	movzwl %cx,%eax
  10fcee:	83 f8 00             	cmp    $0x0,%eax
  10fcf1:	0f 84 63 02 00 00    	je     10ff5a <lv_disp_refr_task+0x2aa>
        /*In true double buffered mode copy the refreshed areas to the new VDB to keep it up to
         * date*/
        if(lv_disp_is_true_double_buf(disp_refr)) {
  10fcf7:	a1 48 51 13 00       	mov    0x135148,%eax
  10fcfc:	89 04 24             	mov    %eax,(%esp)
  10fcff:	e8 0c 7c 00 00       	call   117910 <lv_disp_is_true_double_buf>
  10fd04:	a8 01                	test   $0x1,%al
  10fd06:	0f 85 05 00 00 00    	jne    10fd11 <lv_disp_refr_task+0x61>
  10fd0c:	e9 91 01 00 00       	jmp    10fea2 <lv_disp_refr_task+0x1f2>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
  10fd11:	a1 48 51 13 00       	mov    0x135148,%eax
  10fd16:	89 04 24             	mov    %eax,(%esp)
  10fd19:	e8 92 7b 00 00       	call   1178b0 <lv_disp_get_buf>
  10fd1e:	89 45 f4             	mov    %eax,-0xc(%ebp)

            /*Flush the content of the VDB*/
            lv_refr_vdb_flush();
  10fd21:	e8 5a 07 00 00       	call   110480 <lv_refr_vdb_flush>

            /* With true double buffering the flushing should be only the address change of the
             * current frame buffer. Wait until the address change is ready and copy the changed
             * content to the other frame buffer (new active VDB) to keep the buffers synchronized*/
            while(vdb->flushing)
  10fd26:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fd29:	8a 48 18             	mov    0x18(%eax),%cl
  10fd2c:	80 e1 01             	and    $0x1,%cl
  10fd2f:	0f b6 c1             	movzbl %cl,%eax
  10fd32:	83 f8 00             	cmp    $0x0,%eax
  10fd35:	0f 84 05 00 00 00    	je     10fd40 <lv_disp_refr_task+0x90>
  10fd3b:	e9 e6 ff ff ff       	jmp    10fd26 <lv_disp_refr_task+0x76>
                ;

            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
  10fd40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fd43:	8b 40 08             	mov    0x8(%eax),%eax
  10fd46:	89 45 f0             	mov    %eax,-0x10(%ebp)
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
  10fd49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fd4c:	8b 40 08             	mov    0x8(%eax),%eax
  10fd4f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10fd52:	3b 01                	cmp    (%ecx),%eax
  10fd54:	0f 85 0e 00 00 00    	jne    10fd68 <lv_disp_refr_task+0xb8>
  10fd5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fd5d:	8b 40 04             	mov    0x4(%eax),%eax
  10fd60:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10fd63:	e9 08 00 00 00       	jmp    10fd70 <lv_disp_refr_task+0xc0>
  10fd68:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10fd6b:	8b 00                	mov    (%eax),%eax
  10fd6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10fd70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10fd73:	89 45 ec             	mov    %eax,-0x14(%ebp)

            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
  10fd76:	a1 48 51 13 00       	mov    0x135148,%eax
  10fd7b:	89 04 24             	mov    %eax,(%esp)
  10fd7e:	e8 fd 79 00 00       	call   117780 <lv_disp_get_hor_res>
  10fd83:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
            uint16_t a;
            for(a = 0; a < disp_refr->inv_p; a++) {
  10fd87:	66 c7 45 e8 00 00    	movw   $0x0,-0x18(%ebp)
  10fd8d:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
  10fd91:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fd97:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  10fd9e:	66 81 e2 ff 03       	and    $0x3ff,%dx
  10fda3:	0f b7 ca             	movzwl %dx,%ecx
  10fda6:	39 c8                	cmp    %ecx,%eax
  10fda8:	0f 8d ef 00 00 00    	jge    10fe9d <lv_disp_refr_task+0x1ed>
                if(disp_refr->inv_area_joined[a] == 0) {
  10fdae:	a1 48 51 13 00       	mov    0x135148,%eax
  10fdb3:	0f b7 4d e8          	movzwl -0x18(%ebp),%ecx
  10fdb7:	0f b6 84 08 40 01 00 	movzbl 0x140(%eax,%ecx,1),%eax
  10fdbe:	00 
  10fdbf:	83 f8 00             	cmp    $0x0,%eax
  10fdc2:	0f 85 bf 00 00 00    	jne    10fe87 <lv_disp_refr_task+0x1d7>
                    lv_coord_t y;
                    uint32_t start_offs =
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
  10fdc8:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  10fdcc:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fdd2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  10fdd6:	0f bf 4c d1 42       	movswl 0x42(%ecx,%edx,8),%ecx
  10fddb:	0f af c1             	imul   %ecx,%eax
  10fdde:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fde4:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  10fde8:	0f bf 4c d1 40       	movswl 0x40(%ecx,%edx,8),%ecx
  10fded:	01 c8                	add    %ecx,%eax
  10fdef:	c1 e0 02             	shl    $0x2,%eax
                    uint32_t start_offs =
  10fdf2:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
  10fdf5:	a1 48 51 13 00       	mov    0x135148,%eax
  10fdfa:	83 c0 40             	add    $0x40,%eax
  10fdfd:	0f b7 4d e8          	movzwl -0x18(%ebp),%ecx
  10fe01:	c1 e1 03             	shl    $0x3,%ecx
  10fe04:	01 c8                	add    %ecx,%eax
  10fe06:	89 04 24             	mov    %eax,(%esp)
  10fe09:	e8 62 07 00 00       	call   110570 <lv_area_get_width>
  10fe0e:	0f bf c8             	movswl %ax,%ecx
  10fe11:	c1 e1 02             	shl    $0x2,%ecx
  10fe14:	89 4d dc             	mov    %ecx,-0x24(%ebp)

                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
  10fe17:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fe1d:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  10fe21:	66 8b 44 d1 42       	mov    0x42(%ecx,%edx,8),%ax
  10fe26:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  10fe2a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  10fe2e:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fe34:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  10fe38:	0f bf 4c d1 46       	movswl 0x46(%ecx,%edx,8),%ecx
  10fe3d:	39 c8                	cmp    %ecx,%eax
  10fe3f:	0f 8f 3d 00 00 00    	jg     10fe82 <lv_disp_refr_task+0x1d2>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
  10fe45:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10fe48:	03 45 e0             	add    -0x20(%ebp),%eax
  10fe4b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10fe4e:	03 4d e0             	add    -0x20(%ebp),%ecx
  10fe51:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10fe54:	89 04 24             	mov    %eax,(%esp)
  10fe57:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10fe5b:	89 54 24 08          	mov    %edx,0x8(%esp)
  10fe5f:	e8 ec a4 ff ff       	call   10a350 <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
  10fe64:	0f bf 4d ea          	movswl -0x16(%ebp),%ecx
  10fe68:	c1 e1 02             	shl    $0x2,%ecx
  10fe6b:	03 4d e0             	add    -0x20(%ebp),%ecx
  10fe6e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
  10fe71:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
  10fe75:	66 83 c0 01          	add    $0x1,%ax
  10fe79:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  10fe7d:	e9 a8 ff ff ff       	jmp    10fe2a <lv_disp_refr_task+0x17a>
                    }
                }
  10fe82:	e9 00 00 00 00       	jmp    10fe87 <lv_disp_refr_task+0x1d7>
            }
  10fe87:	e9 00 00 00 00       	jmp    10fe8c <lv_disp_refr_task+0x1dc>
            for(a = 0; a < disp_refr->inv_p; a++) {
  10fe8c:	66 8b 45 e8          	mov    -0x18(%ebp),%ax
  10fe90:	66 83 c0 01          	add    $0x1,%ax
  10fe94:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
  10fe98:	e9 f0 fe ff ff       	jmp    10fd8d <lv_disp_refr_task+0xdd>
        } /*End of true double buffer handling*/
  10fe9d:	e9 00 00 00 00       	jmp    10fea2 <lv_disp_refr_task+0x1f2>
  10fea2:	31 c0                	xor    %eax,%eax

        /*Clean up*/
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
  10fea4:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10feaa:	83 c1 40             	add    $0x40,%ecx
  10fead:	89 0c 24             	mov    %ecx,(%esp)
  10feb0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10feb7:	00 
  10feb8:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  10febf:	00 
  10fec0:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10fec3:	e8 a8 a5 ff ff       	call   10a470 <memset>
  10fec8:	31 c9                	xor    %ecx,%ecx
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
  10feca:	8b 15 48 51 13 00    	mov    0x135148,%edx
  10fed0:	81 c2 40 01 00 00    	add    $0x140,%edx
  10fed6:	89 14 24             	mov    %edx,(%esp)
  10fed9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10fee0:	00 
  10fee1:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  10fee8:	00 
  10fee9:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10feec:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  10feef:	e8 7c a5 ff ff       	call   10a470 <memset>
        disp_refr->inv_p = 0;
  10fef4:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10fefa:	66 8b b1 60 01 00 00 	mov    0x160(%ecx),%si
  10ff01:	66 81 e6 00 fc       	and    $0xfc00,%si
  10ff06:	66 89 b1 60 01 00 00 	mov    %si,0x160(%ecx)

        /*Call monitor cb if present*/
        if(disp_refr->driver.monitor_cb) {
  10ff0d:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10ff13:	83 79 18 00          	cmpl   $0x0,0x18(%ecx)
  10ff17:	0f 84 38 00 00 00    	je     10ff55 <lv_disp_refr_task+0x2a5>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
  10ff1d:	a1 48 51 13 00       	mov    0x135148,%eax
  10ff22:	8b 40 18             	mov    0x18(%eax),%eax
  10ff25:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  10ff2b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10ff2e:	89 14 24             	mov    %edx,(%esp)
  10ff31:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  10ff34:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  10ff37:	e8 b4 7a 00 00       	call   1179f0 <lv_tick_elaps>
  10ff3c:	8b 0d 4c 51 13 00    	mov    0x13514c,%ecx
  10ff42:	8b 55 c0             	mov    -0x40(%ebp),%edx
  10ff45:	89 14 24             	mov    %edx,(%esp)
  10ff48:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ff4c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  10ff50:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10ff53:	ff d0                	call   *%eax
        }
    }
  10ff55:	e9 00 00 00 00       	jmp    10ff5a <lv_disp_refr_task+0x2aa>

    lv_draw_free_buf();
  10ff5a:	e8 91 2b 00 00       	call   112af0 <lv_draw_free_buf>

    LV_LOG_TRACE("lv_refr_task: ready");
}
  10ff5f:	83 c4 48             	add    $0x48,%esp
  10ff62:	5e                   	pop    %esi
  10ff63:	5d                   	pop    %ebp
  10ff64:	c3                   	ret    
  10ff65:	66 90                	xchg   %ax,%ax
  10ff67:	66 90                	xchg   %ax,%ax
  10ff69:	66 90                	xchg   %ax,%ax
  10ff6b:	66 90                	xchg   %ax,%ax
  10ff6d:	66 90                	xchg   %ax,%ax
  10ff6f:	90                   	nop

0010ff70 <lv_inv_area>:
{
  10ff70:	55                   	push   %ebp
  10ff71:	89 e5                	mov    %esp,%ebp
  10ff73:	57                   	push   %edi
  10ff74:	56                   	push   %esi
  10ff75:	83 e4 f8             	and    $0xfffffff8,%esp
  10ff78:	83 ec 20             	sub    $0x20,%esp
  10ff7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ff7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(!disp) disp = lv_disp_get_default();
  10ff81:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ff85:	0f 85 08 00 00 00    	jne    10ff93 <lv_inv_area+0x23>
  10ff8b:	e8 d0 78 00 00       	call   117860 <lv_disp_get_default>
  10ff90:	89 45 08             	mov    %eax,0x8(%ebp)
    if(!disp) return;
  10ff93:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ff97:	0f 85 05 00 00 00    	jne    10ffa2 <lv_inv_area+0x32>
  10ff9d:	e9 e6 01 00 00       	jmp    110188 <lv_inv_area+0x218>
    if(area_p == NULL) {
  10ffa2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ffa6:	0f 85 1b 00 00 00    	jne    10ffc7 <lv_inv_area+0x57>
        disp->inv_p = 0;
  10ffac:	8b 45 08             	mov    0x8(%ebp),%eax
  10ffaf:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  10ffb6:	66 81 e1 00 fc       	and    $0xfc00,%cx
  10ffbb:	66 89 88 60 01 00 00 	mov    %cx,0x160(%eax)
        return;
  10ffc2:	e9 c1 01 00 00       	jmp    110188 <lv_inv_area+0x218>
    scr_area.x1 = 0;
  10ffc7:	66 c7 44 24 18 00 00 	movw   $0x0,0x18(%esp)
    scr_area.y1 = 0;
  10ffce:	66 c7 44 24 1a 00 00 	movw   $0x0,0x1a(%esp)
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
  10ffd5:	8b 45 08             	mov    0x8(%ebp),%eax
  10ffd8:	89 04 24             	mov    %eax,(%esp)
  10ffdb:	e8 a0 77 00 00       	call   117780 <lv_disp_get_hor_res>
  10ffe0:	0f bf c8             	movswl %ax,%ecx
  10ffe3:	83 e9 01             	sub    $0x1,%ecx
  10ffe6:	66 89 4c 24 1c       	mov    %cx,0x1c(%esp)
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
  10ffeb:	8b 55 08             	mov    0x8(%ebp),%edx
  10ffee:	89 14 24             	mov    %edx,(%esp)
  10fff1:	e8 fa 77 00 00       	call   1177f0 <lv_disp_get_ver_res>
  10fff6:	0f bf d0             	movswl %ax,%edx
  10fff9:	83 ea 01             	sub    $0x1,%edx
  10fffc:	66 89 54 24 1e       	mov    %dx,0x1e(%esp)
    suc = lv_area_intersect(&com_area, area_p, &scr_area);
  110001:	8b 75 0c             	mov    0xc(%ebp),%esi
  110004:	8d 7c 24 10          	lea    0x10(%esp),%edi
  110008:	89 3c 24             	mov    %edi,(%esp)
  11000b:	89 74 24 04          	mov    %esi,0x4(%esp)
  11000f:	8d 74 24 18          	lea    0x18(%esp),%esi
  110013:	89 74 24 08          	mov    %esi,0x8(%esp)
  110017:	e8 e4 7b 00 00       	call   117c00 <lv_area_intersect>
  11001c:	24 01                	and    $0x1,%al
  11001e:	88 44 24 0f          	mov    %al,0xf(%esp)
    if(suc != false) {
  110022:	8a 44 24 0f          	mov    0xf(%esp),%al
  110026:	24 01                	and    $0x1,%al
  110028:	0f b6 f0             	movzbl %al,%esi
  11002b:	83 fe 00             	cmp    $0x0,%esi
  11002e:	0f 84 54 01 00 00    	je     110188 <lv_inv_area+0x218>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
  110034:	8b 45 08             	mov    0x8(%ebp),%eax
  110037:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  11003b:	0f 84 16 00 00 00    	je     110057 <lv_inv_area+0xe7>
  110041:	8b 45 08             	mov    0x8(%ebp),%eax
  110044:	8b 40 10             	mov    0x10(%eax),%eax
  110047:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11004a:	89 0c 24             	mov    %ecx,(%esp)
  11004d:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  110051:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110055:	ff d0                	call   *%eax
        for(i = 0; i < disp->inv_p; i++) {
  110057:	66 c7 44 24 0c 00 00 	movw   $0x0,0xc(%esp)
  11005e:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
  110063:	8b 4d 08             	mov    0x8(%ebp),%ecx
  110066:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  11006d:	66 81 e2 ff 03       	and    $0x3ff,%dx
  110072:	0f b7 ca             	movzwl %dx,%ecx
  110075:	39 c8                	cmp    %ecx,%eax
  110077:	0f 8d 4b 00 00 00    	jge    1100c8 <lv_inv_area+0x158>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
  11007d:	8b 45 08             	mov    0x8(%ebp),%eax
  110080:	83 c0 40             	add    $0x40,%eax
  110083:	0f b7 4c 24 0c       	movzwl 0xc(%esp),%ecx
  110088:	c1 e1 03             	shl    $0x3,%ecx
  11008b:	01 c8                	add    %ecx,%eax
  11008d:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  110091:	89 0c 24             	mov    %ecx,(%esp)
  110094:	89 44 24 04          	mov    %eax,0x4(%esp)
  110098:	e8 23 7e 00 00       	call   117ec0 <lv_area_is_in>
  11009d:	24 01                	and    $0x1,%al
  11009f:	0f b6 c8             	movzbl %al,%ecx
  1100a2:	83 f9 00             	cmp    $0x0,%ecx
  1100a5:	0f 84 05 00 00 00    	je     1100b0 <lv_inv_area+0x140>
  1100ab:	e9 d8 00 00 00       	jmp    110188 <lv_inv_area+0x218>
        }
  1100b0:	e9 00 00 00 00       	jmp    1100b5 <lv_inv_area+0x145>
        for(i = 0; i < disp->inv_p; i++) {
  1100b5:	66 8b 44 24 0c       	mov    0xc(%esp),%ax
  1100ba:	66 83 c0 01          	add    $0x1,%ax
  1100be:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
  1100c3:	e9 96 ff ff ff       	jmp    11005e <lv_inv_area+0xee>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
  1100c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1100cb:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  1100d2:	66 81 e1 ff 03       	and    $0x3ff,%cx
  1100d7:	0f b7 c1             	movzwl %cx,%eax
  1100da:	83 f8 20             	cmp    $0x20,%eax
  1100dd:	0f 8d 32 00 00 00    	jge    110115 <lv_inv_area+0x1a5>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
  1100e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1100e6:	83 c0 40             	add    $0x40,%eax
  1100e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1100ec:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  1100f3:	66 81 e2 ff 03       	and    $0x3ff,%dx
  1100f8:	0f b7 ca             	movzwl %dx,%ecx
  1100fb:	c1 e1 03             	shl    $0x3,%ecx
  1100fe:	01 c8                	add    %ecx,%eax
  110100:	89 04 24             	mov    %eax,(%esp)
  110103:	8d 44 24 10          	lea    0x10(%esp),%eax
  110107:	89 44 24 04          	mov    %eax,0x4(%esp)
  11010b:	e8 80 00 00 00       	call   110190 <lv_area_copy>
        } else { /*If no place for the area add the screen*/
  110110:	e9 43 00 00 00       	jmp    110158 <lv_inv_area+0x1e8>
            disp->inv_p = 0;
  110115:	8b 45 08             	mov    0x8(%ebp),%eax
  110118:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  11011f:	66 81 e1 00 fc       	and    $0xfc00,%cx
  110124:	66 89 88 60 01 00 00 	mov    %cx,0x160(%eax)
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
  11012b:	8b 45 08             	mov    0x8(%ebp),%eax
  11012e:	83 c0 40             	add    $0x40,%eax
  110131:	8b 55 08             	mov    0x8(%ebp),%edx
  110134:	66 8b 8a 60 01 00 00 	mov    0x160(%edx),%cx
  11013b:	66 81 e1 ff 03       	and    $0x3ff,%cx
  110140:	0f b7 d1             	movzwl %cx,%edx
  110143:	c1 e2 03             	shl    $0x3,%edx
  110146:	01 d0                	add    %edx,%eax
  110148:	89 04 24             	mov    %eax,(%esp)
  11014b:	8d 44 24 18          	lea    0x18(%esp),%eax
  11014f:	89 44 24 04          	mov    %eax,0x4(%esp)
  110153:	e8 38 00 00 00       	call   110190 <lv_area_copy>
        disp->inv_p++;
  110158:	8b 45 08             	mov    0x8(%ebp),%eax
  11015b:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  110162:	66 81 e1 ff 03       	and    $0x3ff,%cx
  110167:	0f b7 d1             	movzwl %cx,%edx
  11016a:	83 c2 01             	add    $0x1,%edx
  11016d:	66 8b 88 60 01 00 00 	mov    0x160(%eax),%cx
  110174:	66 81 e2 ff 03       	and    $0x3ff,%dx
  110179:	66 81 e1 00 fc       	and    $0xfc00,%cx
  11017e:	66 09 d1             	or     %dx,%cx
  110181:	66 89 88 60 01 00 00 	mov    %cx,0x160(%eax)
}
  110188:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11018b:	5e                   	pop    %esi
  11018c:	5f                   	pop    %edi
  11018d:	5d                   	pop    %ebp
  11018e:	c3                   	ret    
  11018f:	90                   	nop

00110190 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
  110190:	55                   	push   %ebp
  110191:	89 e5                	mov    %esp,%ebp
  110193:	56                   	push   %esi
  110194:	83 ec 14             	sub    $0x14,%esp
  110197:	8b 45 0c             	mov    0xc(%ebp),%eax
  11019a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    memcpy(dest, src, sizeof(lv_area_t));
  11019d:	8b 55 08             	mov    0x8(%ebp),%edx
  1101a0:	8b 75 0c             	mov    0xc(%ebp),%esi
  1101a3:	89 14 24             	mov    %edx,(%esp)
  1101a6:	89 74 24 04          	mov    %esi,0x4(%esp)
  1101aa:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1101b1:	00 
  1101b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1101b5:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1101b8:	e8 93 a1 ff ff       	call   10a350 <memcpy>
}
  1101bd:	83 c4 14             	add    $0x14,%esp
  1101c0:	5e                   	pop    %esi
  1101c1:	5d                   	pop    %ebp
  1101c2:	c3                   	ret    
  1101c3:	66 90                	xchg   %ax,%ax
  1101c5:	66 90                	xchg   %ax,%ax
  1101c7:	66 90                	xchg   %ax,%ax
  1101c9:	66 90                	xchg   %ax,%ax
  1101cb:	66 90                	xchg   %ax,%ax
  1101cd:	66 90                	xchg   %ax,%ax
  1101cf:	90                   	nop

001101d0 <lv_refr_get_disp_refreshing>:
{
  1101d0:	55                   	push   %ebp
  1101d1:	89 e5                	mov    %esp,%ebp
    return disp_refr;
  1101d3:	a1 48 51 13 00       	mov    0x135148,%eax
  1101d8:	5d                   	pop    %ebp
  1101d9:	c3                   	ret    
  1101da:	66 90                	xchg   %ax,%ax
  1101dc:	66 90                	xchg   %ax,%ax
  1101de:	66 90                	xchg   %ax,%ax

001101e0 <lv_refr_join_area>:

/**
 * Join the areas which has got common parts
 */
static void lv_refr_join_area(void)
{
  1101e0:	55                   	push   %ebp
  1101e1:	89 e5                	mov    %esp,%ebp
  1101e3:	83 e4 f8             	and    $0xfffffff8,%esp
  1101e6:	83 ec 28             	sub    $0x28,%esp
    uint32_t join_from;
    uint32_t join_in;
    lv_area_t joined_area;
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
  1101e9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
  1101f0:	00 
  1101f1:	8b 44 24 20          	mov    0x20(%esp),%eax
  1101f5:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  1101fb:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  110202:	66 81 e2 ff 03       	and    $0x3ff,%dx
  110207:	0f b7 ca             	movzwl %dx,%ecx
  11020a:	39 c8                	cmp    %ecx,%eax
  11020c:	0f 83 a4 01 00 00    	jae    1103b6 <lv_refr_join_area+0x1d6>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
  110212:	a1 48 51 13 00       	mov    0x135148,%eax
  110217:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  11021b:	0f b6 84 08 40 01 00 	movzbl 0x140(%eax,%ecx,1),%eax
  110222:	00 
  110223:	83 f8 00             	cmp    $0x0,%eax
  110226:	0f 84 05 00 00 00    	je     110231 <lv_refr_join_area+0x51>
  11022c:	e9 75 01 00 00       	jmp    1103a6 <lv_refr_join_area+0x1c6>

        /*Check all areas to join them in 'join_in'*/
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
  110231:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  110238:	00 
  110239:	8b 44 24 24          	mov    0x24(%esp),%eax
  11023d:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110243:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  11024a:	66 81 e2 ff 03       	and    $0x3ff,%dx
  11024f:	0f b7 ca             	movzwl %dx,%ecx
  110252:	39 c8                	cmp    %ecx,%eax
  110254:	0f 83 47 01 00 00    	jae    1103a1 <lv_refr_join_area+0x1c1>
            /*Handle only unjoined areas and ignore itself*/
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
  11025a:	a1 48 51 13 00       	mov    0x135148,%eax
  11025f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  110263:	0f b6 84 08 40 01 00 	movzbl 0x140(%eax,%ecx,1),%eax
  11026a:	00 
  11026b:	83 f8 00             	cmp    $0x0,%eax
  11026e:	0f 85 0e 00 00 00    	jne    110282 <lv_refr_join_area+0xa2>
  110274:	8b 44 24 20          	mov    0x20(%esp),%eax
  110278:	3b 44 24 24          	cmp    0x24(%esp),%eax
  11027c:	0f 85 05 00 00 00    	jne    110287 <lv_refr_join_area+0xa7>
                continue;
  110282:	e9 0a 01 00 00       	jmp    110391 <lv_refr_join_area+0x1b1>
            }

            /*Check if the areas are on each other*/
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
  110287:	a1 48 51 13 00       	mov    0x135148,%eax
  11028c:	83 c0 40             	add    $0x40,%eax
  11028f:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  110293:	c1 e1 03             	shl    $0x3,%ecx
  110296:	01 c8                	add    %ecx,%eax
  110298:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  11029e:	83 c1 40             	add    $0x40,%ecx
  1102a1:	8b 54 24 24          	mov    0x24(%esp),%edx
  1102a5:	c1 e2 03             	shl    $0x3,%edx
  1102a8:	01 d1                	add    %edx,%ecx
  1102aa:	89 04 24             	mov    %eax,(%esp)
  1102ad:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1102b1:	e8 8a 7b 00 00       	call   117e40 <lv_area_is_on>
  1102b6:	24 01                	and    $0x1,%al
  1102b8:	0f b6 c8             	movzbl %al,%ecx
  1102bb:	83 f9 00             	cmp    $0x0,%ecx
  1102be:	0f 85 05 00 00 00    	jne    1102c9 <lv_refr_join_area+0xe9>
                continue;
  1102c4:	e9 c8 00 00 00       	jmp    110391 <lv_refr_join_area+0x1b1>
            }

            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
  1102c9:	a1 48 51 13 00       	mov    0x135148,%eax
  1102ce:	83 c0 40             	add    $0x40,%eax
  1102d1:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1102d5:	c1 e1 03             	shl    $0x3,%ecx
  1102d8:	01 c8                	add    %ecx,%eax
  1102da:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  1102e0:	83 c1 40             	add    $0x40,%ecx
  1102e3:	8b 54 24 24          	mov    0x24(%esp),%edx
  1102e7:	c1 e2 03             	shl    $0x3,%edx
  1102ea:	01 d1                	add    %edx,%ecx
  1102ec:	8d 54 24 18          	lea    0x18(%esp),%edx
  1102f0:	89 14 24             	mov    %edx,(%esp)
  1102f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1102f7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1102fb:	e8 40 7a 00 00       	call   117d40 <lv_area_join>

            /*Join two area only if the joined area size is smaller*/
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
  110300:	8d 44 24 18          	lea    0x18(%esp),%eax
  110304:	89 04 24             	mov    %eax,(%esp)
  110307:	e8 a4 78 00 00       	call   117bb0 <lv_area_get_size>
  11030c:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110312:	83 c1 40             	add    $0x40,%ecx
  110315:	8b 54 24 20          	mov    0x20(%esp),%edx
  110319:	c1 e2 03             	shl    $0x3,%edx
  11031c:	01 d1                	add    %edx,%ecx
  11031e:	89 0c 24             	mov    %ecx,(%esp)
  110321:	89 44 24 14          	mov    %eax,0x14(%esp)
  110325:	e8 86 78 00 00       	call   117bb0 <lv_area_get_size>
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
  11032a:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110330:	83 c1 40             	add    $0x40,%ecx
  110333:	8b 54 24 24          	mov    0x24(%esp),%edx
  110337:	c1 e2 03             	shl    $0x3,%edx
  11033a:	01 d1                	add    %edx,%ecx
  11033c:	89 0c 24             	mov    %ecx,(%esp)
  11033f:	89 44 24 10          	mov    %eax,0x10(%esp)
  110343:	e8 68 78 00 00       	call   117bb0 <lv_area_get_size>
  110348:	8b 4c 24 10          	mov    0x10(%esp),%ecx
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
  11034c:	01 c1                	add    %eax,%ecx
  11034e:	8b 44 24 14          	mov    0x14(%esp),%eax
  110352:	39 c8                	cmp    %ecx,%eax
  110354:	0f 83 32 00 00 00    	jae    11038c <lv_refr_join_area+0x1ac>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
  11035a:	a1 48 51 13 00       	mov    0x135148,%eax
  11035f:	83 c0 40             	add    $0x40,%eax
  110362:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  110366:	c1 e1 03             	shl    $0x3,%ecx
  110369:	01 c8                	add    %ecx,%eax
  11036b:	89 04 24             	mov    %eax,(%esp)
  11036e:	8d 44 24 18          	lea    0x18(%esp),%eax
  110372:	89 44 24 04          	mov    %eax,0x4(%esp)
  110376:	e8 15 fe ff ff       	call   110190 <lv_area_copy>

                /*Mark 'join_form' is joined into 'join_in'*/
                disp_refr->inv_area_joined[join_from] = 1;
  11037b:	a1 48 51 13 00       	mov    0x135148,%eax
  110380:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  110384:	c6 84 08 40 01 00 00 	movb   $0x1,0x140(%eax,%ecx,1)
  11038b:	01 
            }
        }
  11038c:	e9 00 00 00 00       	jmp    110391 <lv_refr_join_area+0x1b1>
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
  110391:	8b 44 24 24          	mov    0x24(%esp),%eax
  110395:	83 c0 01             	add    $0x1,%eax
  110398:	89 44 24 24          	mov    %eax,0x24(%esp)
  11039c:	e9 98 fe ff ff       	jmp    110239 <lv_refr_join_area+0x59>
    }
  1103a1:	e9 00 00 00 00       	jmp    1103a6 <lv_refr_join_area+0x1c6>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
  1103a6:	8b 44 24 20          	mov    0x20(%esp),%eax
  1103aa:	83 c0 01             	add    $0x1,%eax
  1103ad:	89 44 24 20          	mov    %eax,0x20(%esp)
  1103b1:	e9 3b fe ff ff       	jmp    1101f1 <lv_refr_join_area+0x11>
}
  1103b6:	89 ec                	mov    %ebp,%esp
  1103b8:	5d                   	pop    %ebp
  1103b9:	c3                   	ret    
  1103ba:	66 90                	xchg   %ax,%ax
  1103bc:	66 90                	xchg   %ax,%ax
  1103be:	66 90                	xchg   %ax,%ax

001103c0 <lv_refr_areas>:

/**
 * Refresh the joined areas
 */
static void lv_refr_areas(void)
{
  1103c0:	55                   	push   %ebp
  1103c1:	89 e5                	mov    %esp,%ebp
  1103c3:	83 ec 08             	sub    $0x8,%esp
    px_num = 0;
  1103c6:	c7 05 4c 51 13 00 00 	movl   $0x0,0x13514c
  1103cd:	00 00 00 
    uint32_t i;

    for(i = 0; i < disp_refr->inv_p; i++) {
  1103d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1103d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1103da:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  1103e0:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  1103e7:	66 81 e2 ff 03       	and    $0x3ff,%dx
  1103ec:	0f b7 ca             	movzwl %dx,%ecx
  1103ef:	39 c8                	cmp    %ecx,%eax
  1103f1:	0f 83 7b 00 00 00    	jae    110472 <lv_refr_areas+0xb2>
        /*Refresh the unjoined areas*/
        if(disp_refr->inv_area_joined[i] == 0) {
  1103f7:	a1 48 51 13 00       	mov    0x135148,%eax
  1103fc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1103ff:	0f b6 84 08 40 01 00 	movzbl 0x140(%eax,%ecx,1),%eax
  110406:	00 
  110407:	83 f8 00             	cmp    $0x0,%eax
  11040a:	0f 85 4f 00 00 00    	jne    11045f <lv_refr_areas+0x9f>

            lv_refr_area(&disp_refr->inv_areas[i]);
  110410:	a1 48 51 13 00       	mov    0x135148,%eax
  110415:	83 c0 40             	add    $0x40,%eax
  110418:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11041b:	c1 e1 03             	shl    $0x3,%ecx
  11041e:	01 c8                	add    %ecx,%eax
  110420:	89 04 24             	mov    %eax,(%esp)
  110423:	e8 78 01 00 00       	call   1105a0 <lv_refr_area>

            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
  110428:	a1 48 51 13 00       	mov    0x135148,%eax
  11042d:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
  110431:	0f 84 23 00 00 00    	je     11045a <lv_refr_areas+0x9a>
  110437:	a1 48 51 13 00       	mov    0x135148,%eax
  11043c:	83 c0 40             	add    $0x40,%eax
  11043f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  110442:	c1 e1 03             	shl    $0x3,%ecx
  110445:	01 c8                	add    %ecx,%eax
  110447:	89 04 24             	mov    %eax,(%esp)
  11044a:	e8 61 77 00 00       	call   117bb0 <lv_area_get_size>
  11044f:	03 05 4c 51 13 00    	add    0x13514c,%eax
  110455:	a3 4c 51 13 00       	mov    %eax,0x13514c
        }
  11045a:	e9 00 00 00 00       	jmp    11045f <lv_refr_areas+0x9f>
    }
  11045f:	e9 00 00 00 00       	jmp    110464 <lv_refr_areas+0xa4>
    for(i = 0; i < disp_refr->inv_p; i++) {
  110464:	8b 45 fc             	mov    -0x4(%ebp),%eax
  110467:	83 c0 01             	add    $0x1,%eax
  11046a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11046d:	e9 65 ff ff ff       	jmp    1103d7 <lv_refr_areas+0x17>
}
  110472:	83 c4 08             	add    $0x8,%esp
  110475:	5d                   	pop    %ebp
  110476:	c3                   	ret    
  110477:	66 90                	xchg   %ax,%ax
  110479:	66 90                	xchg   %ax,%ax
  11047b:	66 90                	xchg   %ax,%ax
  11047d:	66 90                	xchg   %ax,%ax
  11047f:	90                   	nop

00110480 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
  110480:	55                   	push   %ebp
  110481:	89 e5                	mov    %esp,%ebp
  110483:	56                   	push   %esi
  110484:	83 ec 14             	sub    $0x14,%esp
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
  110487:	a1 48 51 13 00       	mov    0x135148,%eax
  11048c:	89 04 24             	mov    %eax,(%esp)
  11048f:	e8 1c 74 00 00       	call   1178b0 <lv_disp_get_buf>
  110494:	89 45 f8             	mov    %eax,-0x8(%ebp)

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
  110497:	a1 48 51 13 00       	mov    0x135148,%eax
  11049c:	89 04 24             	mov    %eax,(%esp)
  11049f:	e8 2c 74 00 00       	call   1178d0 <lv_disp_is_double_buf>
  1104a4:	a8 01                	test   $0x1,%al
  1104a6:	0f 85 05 00 00 00    	jne    1104b1 <lv_refr_vdb_flush+0x31>
  1104ac:	e9 24 00 00 00       	jmp    1104d5 <lv_refr_vdb_flush+0x55>
        while(vdb->flushing)
  1104b1:	e9 00 00 00 00       	jmp    1104b6 <lv_refr_vdb_flush+0x36>
  1104b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1104b9:	8a 48 18             	mov    0x18(%eax),%cl
  1104bc:	80 e1 01             	and    $0x1,%cl
  1104bf:	0f b6 c1             	movzbl %cl,%eax
  1104c2:	83 f8 00             	cmp    $0x0,%eax
  1104c5:	0f 84 05 00 00 00    	je     1104d0 <lv_refr_vdb_flush+0x50>
  1104cb:	e9 e6 ff ff ff       	jmp    1104b6 <lv_refr_vdb_flush+0x36>
            ;
    }
  1104d0:	e9 00 00 00 00       	jmp    1104d5 <lv_refr_vdb_flush+0x55>

    vdb->flushing = 1;
  1104d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1104d8:	8a 48 18             	mov    0x18(%eax),%cl
  1104db:	80 e1 fe             	and    $0xfe,%cl
  1104de:	80 c9 01             	or     $0x1,%cl
  1104e1:	88 48 18             	mov    %cl,0x18(%eax)

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
  1104e4:	e8 e7 fc ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  1104e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
  1104ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1104ef:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  1104f3:	0f 84 22 00 00 00    	je     11051b <lv_refr_vdb_flush+0x9b>
  1104f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1104fc:	8b 40 0c             	mov    0xc(%eax),%eax
  1104ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  110502:	8b 55 f8             	mov    -0x8(%ebp),%edx
  110505:	83 c2 10             	add    $0x10,%edx
  110508:	8b 75 f8             	mov    -0x8(%ebp),%esi
  11050b:	8b 76 08             	mov    0x8(%esi),%esi
  11050e:	89 0c 24             	mov    %ecx,(%esp)
  110511:	89 54 24 04          	mov    %edx,0x4(%esp)
  110515:	89 74 24 08          	mov    %esi,0x8(%esp)
  110519:	ff d0                	call   *%eax

    if(vdb->buf1 && vdb->buf2) {
  11051b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11051e:	83 38 00             	cmpl   $0x0,(%eax)
  110521:	0f 84 3f 00 00 00    	je     110566 <lv_refr_vdb_flush+0xe6>
  110527:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11052a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11052e:	0f 84 32 00 00 00    	je     110566 <lv_refr_vdb_flush+0xe6>
        if(vdb->buf_act == vdb->buf1)
  110534:	8b 45 f8             	mov    -0x8(%ebp),%eax
  110537:	8b 40 08             	mov    0x8(%eax),%eax
  11053a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11053d:	3b 01                	cmp    (%ecx),%eax
  11053f:	0f 85 11 00 00 00    	jne    110556 <lv_refr_vdb_flush+0xd6>
            vdb->buf_act = vdb->buf2;
  110545:	8b 45 f8             	mov    -0x8(%ebp),%eax
  110548:	8b 40 04             	mov    0x4(%eax),%eax
  11054b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11054e:	89 41 08             	mov    %eax,0x8(%ecx)
  110551:	e9 0b 00 00 00       	jmp    110561 <lv_refr_vdb_flush+0xe1>
        else
            vdb->buf_act = vdb->buf1;
  110556:	8b 45 f8             	mov    -0x8(%ebp),%eax
  110559:	8b 00                	mov    (%eax),%eax
  11055b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11055e:	89 41 08             	mov    %eax,0x8(%ecx)
    }
  110561:	e9 00 00 00 00       	jmp    110566 <lv_refr_vdb_flush+0xe6>
}
  110566:	83 c4 14             	add    $0x14,%esp
  110569:	5e                   	pop    %esi
  11056a:	5d                   	pop    %ebp
  11056b:	c3                   	ret    
  11056c:	66 90                	xchg   %ax,%ax
  11056e:	66 90                	xchg   %ax,%ax

00110570 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
  110570:	55                   	push   %ebp
  110571:	89 e5                	mov    %esp,%ebp
  110573:	50                   	push   %eax
  110574:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  110577:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11057a:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  11057e:	8b 55 08             	mov    0x8(%ebp),%edx
  110581:	0f bf 12             	movswl (%edx),%edx
  110584:	29 d1                	sub    %edx,%ecx
  110586:	83 c1 01             	add    $0x1,%ecx
  110589:	0f bf d1             	movswl %cx,%edx
  11058c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11058f:	89 d0                	mov    %edx,%eax
  110591:	83 c4 04             	add    $0x4,%esp
  110594:	5d                   	pop    %ebp
  110595:	c3                   	ret    
  110596:	66 90                	xchg   %ax,%ax
  110598:	66 90                	xchg   %ax,%ax
  11059a:	66 90                	xchg   %ax,%ax
  11059c:	66 90                	xchg   %ax,%ax
  11059e:	66 90                	xchg   %ax,%ax

001105a0 <lv_refr_area>:
{
  1105a0:	55                   	push   %ebp
  1105a1:	89 e5                	mov    %esp,%ebp
  1105a3:	56                   	push   %esi
  1105a4:	83 e4 f8             	and    $0xfffffff8,%esp
  1105a7:	83 ec 48             	sub    $0x48,%esp
  1105aa:	8b 45 08             	mov    0x8(%ebp),%eax
    if(lv_disp_is_true_double_buf(disp_refr)) {
  1105ad:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  1105b3:	89 0c 24             	mov    %ecx,(%esp)
  1105b6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1105ba:	e8 51 73 00 00       	call   117910 <lv_disp_is_true_double_buf>
  1105bf:	a8 01                	test   $0x1,%al
  1105c1:	0f 85 05 00 00 00    	jne    1105cc <lv_refr_area+0x2c>
  1105c7:	e9 6c 00 00 00       	jmp    110638 <lv_refr_area+0x98>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
  1105cc:	a1 48 51 13 00       	mov    0x135148,%eax
  1105d1:	89 04 24             	mov    %eax,(%esp)
  1105d4:	e8 d7 72 00 00       	call   1178b0 <lv_disp_get_buf>
  1105d9:	89 44 24 40          	mov    %eax,0x40(%esp)
        vdb->area.x1        = 0;
  1105dd:	8b 44 24 40          	mov    0x40(%esp),%eax
  1105e1:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
  1105e7:	a1 48 51 13 00       	mov    0x135148,%eax
  1105ec:	89 04 24             	mov    %eax,(%esp)
  1105ef:	e8 8c 71 00 00       	call   117780 <lv_disp_get_hor_res>
  1105f4:	0f bf c8             	movswl %ax,%ecx
  1105f7:	83 e9 01             	sub    $0x1,%ecx
  1105fa:	8b 54 24 40          	mov    0x40(%esp),%edx
  1105fe:	66 89 4a 14          	mov    %cx,0x14(%edx)
        vdb->area.y1        = 0;
  110602:	8b 54 24 40          	mov    0x40(%esp),%edx
  110606:	66 c7 42 12 00 00    	movw   $0x0,0x12(%edx)
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
  11060c:	8b 15 48 51 13 00    	mov    0x135148,%edx
  110612:	89 14 24             	mov    %edx,(%esp)
  110615:	e8 d6 71 00 00       	call   1177f0 <lv_disp_get_ver_res>
  11061a:	0f bf d0             	movswl %ax,%edx
  11061d:	83 ea 01             	sub    $0x1,%edx
  110620:	8b 74 24 40          	mov    0x40(%esp),%esi
  110624:	66 89 56 16          	mov    %dx,0x16(%esi)
        lv_refr_area_part(area_p);
  110628:	8b 75 08             	mov    0x8(%ebp),%esi
  11062b:	89 34 24             	mov    %esi,(%esp)
  11062e:	e8 bd 02 00 00       	call   1108f0 <lv_refr_area_part>
    }
  110633:	e9 ad 02 00 00       	jmp    1108e5 <lv_refr_area+0x345>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
  110638:	a1 48 51 13 00       	mov    0x135148,%eax
  11063d:	89 04 24             	mov    %eax,(%esp)
  110640:	e8 6b 72 00 00       	call   1178b0 <lv_disp_get_buf>
  110645:	89 44 24 3c          	mov    %eax,0x3c(%esp)
        lv_coord_t w = lv_area_get_width(area_p);
  110649:	8b 45 08             	mov    0x8(%ebp),%eax
  11064c:	89 04 24             	mov    %eax,(%esp)
  11064f:	e8 1c ff ff ff       	call   110570 <lv_area_get_width>
  110654:	66 89 44 24 3a       	mov    %ax,0x3a(%esp)
        lv_coord_t h = lv_area_get_height(area_p);
  110659:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11065c:	89 0c 24             	mov    %ecx,(%esp)
  11065f:	e8 ac 03 00 00       	call   110a10 <lv_area_get_height>
  110664:	66 89 44 24 38       	mov    %ax,0x38(%esp)
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
  110669:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11066c:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  110670:	8b 15 48 51 13 00    	mov    0x135148,%edx
  110676:	89 14 24             	mov    %edx,(%esp)
  110679:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  11067d:	e8 6e 71 00 00       	call   1177f0 <lv_disp_get_ver_res>
  110682:	0f bf c8             	movswl %ax,%ecx
  110685:	8b 54 24 18          	mov    0x18(%esp),%edx
  110689:	39 ca                	cmp    %ecx,%edx
  11068b:	0f 8c 24 00 00 00    	jl     1106b5 <lv_refr_area+0x115>
  110691:	a1 48 51 13 00       	mov    0x135148,%eax
  110696:	89 04 24             	mov    %eax,(%esp)
  110699:	e8 52 71 00 00       	call   1177f0 <lv_disp_get_ver_res>
  11069e:	0f bf c8             	movswl %ax,%ecx
  1106a1:	83 e9 01             	sub    $0x1,%ecx
  1106a4:	66 89 4c 24 36       	mov    %cx,0x36(%esp)
  1106a9:	0f bf d1             	movswl %cx,%edx
  1106ac:	89 54 24 14          	mov    %edx,0x14(%esp)
  1106b0:	e9 0b 00 00 00       	jmp    1106c0 <lv_refr_area+0x120>
  1106b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1106b8:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1106bc:	89 44 24 14          	mov    %eax,0x14(%esp)
  1106c0:	8b 44 24 14          	mov    0x14(%esp),%eax
        lv_coord_t y2 =
  1106c4:	66 89 44 24 36       	mov    %ax,0x36(%esp)
        int32_t max_row = (uint32_t)vdb->size / w;
  1106c9:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  1106cd:	8b 41 0c             	mov    0xc(%ecx),%eax
  1106d0:	0f bf 4c 24 3a       	movswl 0x3a(%esp),%ecx
  1106d5:	31 d2                	xor    %edx,%edx
  1106d7:	f7 f1                	div    %ecx
  1106d9:	89 44 24 30          	mov    %eax,0x30(%esp)
        if(max_row > h) max_row = h;
  1106dd:	8b 44 24 30          	mov    0x30(%esp),%eax
  1106e1:	0f bf 4c 24 38       	movswl 0x38(%esp),%ecx
  1106e6:	39 c8                	cmp    %ecx,%eax
  1106e8:	0f 8e 09 00 00 00    	jle    1106f7 <lv_refr_area+0x157>
  1106ee:	0f bf 44 24 38       	movswl 0x38(%esp),%eax
  1106f3:	89 44 24 30          	mov    %eax,0x30(%esp)
        if(disp_refr->driver.rounder_cb) {
  1106f7:	a1 48 51 13 00       	mov    0x135148,%eax
  1106fc:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  110700:	0f 84 cd 00 00 00    	je     1107d3 <lv_refr_area+0x233>
            tmp.x1 = 0;
  110706:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%esp)
            tmp.x2 = 0;
  11070d:	66 c7 44 24 2c 00 00 	movw   $0x0,0x2c(%esp)
            tmp.y1 = 0;
  110714:	66 c7 44 24 2a 00 00 	movw   $0x0,0x2a(%esp)
            lv_coord_t y_tmp = max_row - 1;
  11071b:	8b 44 24 30          	mov    0x30(%esp),%eax
  11071f:	83 e8 01             	sub    $0x1,%eax
  110722:	66 89 44 24 26       	mov    %ax,0x26(%esp)
                tmp.y2 = y_tmp;
  110727:	66 8b 44 24 26       	mov    0x26(%esp),%ax
  11072c:	66 89 44 24 2e       	mov    %ax,0x2e(%esp)
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
  110731:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110737:	8b 49 10             	mov    0x10(%ecx),%ecx
  11073a:	8b 15 48 51 13 00    	mov    0x135148,%edx
  110740:	89 14 24             	mov    %edx,(%esp)
  110743:	8d 54 24 28          	lea    0x28(%esp),%edx
  110747:	89 54 24 04          	mov    %edx,0x4(%esp)
  11074b:	ff d1                	call   *%ecx
                if(lv_area_get_height(&tmp) <= max_row) break;
  11074d:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  110751:	89 0c 24             	mov    %ecx,(%esp)
  110754:	e8 b7 02 00 00       	call   110a10 <lv_area_get_height>
  110759:	0f bf c8             	movswl %ax,%ecx
  11075c:	3b 4c 24 30          	cmp    0x30(%esp),%ecx
  110760:	0f 8f 05 00 00 00    	jg     11076b <lv_refr_area+0x1cb>
  110766:	e9 1c 00 00 00       	jmp    110787 <lv_refr_area+0x1e7>
                y_tmp--;
  11076b:	66 8b 44 24 26       	mov    0x26(%esp),%ax
  110770:	66 83 c0 ff          	add    $0xffff,%ax
  110774:	66 89 44 24 26       	mov    %ax,0x26(%esp)
            } while(y_tmp != 0);
  110779:	0f bf 44 24 26       	movswl 0x26(%esp),%eax
  11077e:	83 f8 00             	cmp    $0x0,%eax
  110781:	0f 85 a0 ff ff ff    	jne    110727 <lv_refr_area+0x187>
            if(y_tmp == 0) {
  110787:	0f bf 44 24 26       	movswl 0x26(%esp),%eax
  11078c:	83 f8 00             	cmp    $0x0,%eax
  11078f:	0f 85 2d 00 00 00    	jne    1107c2 <lv_refr_area+0x222>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
  110795:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  11079c:	8d 05 0b 3f 12 00    	lea    0x123f0b,%eax
  1107a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1107a6:	c7 44 24 08 4f 01 00 	movl   $0x14f,0x8(%esp)
  1107ad:	00 
  1107ae:	8d 05 50 3f 12 00    	lea    0x123f50,%eax
  1107b4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1107b8:	e8 83 92 00 00       	call   119a40 <lv_log_add>
                return;
  1107bd:	e9 23 01 00 00       	jmp    1108e5 <lv_refr_area+0x345>
                max_row = tmp.y2 + 1;
  1107c2:	0f bf 44 24 2e       	movswl 0x2e(%esp),%eax
  1107c7:	83 c0 01             	add    $0x1,%eax
  1107ca:	89 44 24 30          	mov    %eax,0x30(%esp)
        }
  1107ce:	e9 00 00 00 00       	jmp    1107d3 <lv_refr_area+0x233>
        lv_coord_t row_last = 0;
  1107d3:	66 c7 44 24 22 00 00 	movw   $0x0,0x22(%esp)
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
  1107da:	8b 45 08             	mov    0x8(%ebp),%eax
  1107dd:	66 8b 48 02          	mov    0x2(%eax),%cx
  1107e1:	66 89 4c 24 24       	mov    %cx,0x24(%esp)
  1107e6:	0f bf 44 24 24       	movswl 0x24(%esp),%eax
  1107eb:	03 44 24 30          	add    0x30(%esp),%eax
  1107ef:	83 e8 01             	sub    $0x1,%eax
  1107f2:	0f bf 4c 24 36       	movswl 0x36(%esp),%ecx
  1107f7:	39 c8                	cmp    %ecx,%eax
  1107f9:	0f 8f 8d 00 00 00    	jg     11088c <lv_refr_area+0x2ec>
            vdb->area.x1 = area_p->x1;
  1107ff:	8b 45 08             	mov    0x8(%ebp),%eax
  110802:	66 8b 08             	mov    (%eax),%cx
  110805:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  110809:	66 89 48 10          	mov    %cx,0x10(%eax)
            vdb->area.x2 = area_p->x2;
  11080d:	8b 45 08             	mov    0x8(%ebp),%eax
  110810:	66 8b 48 04          	mov    0x4(%eax),%cx
  110814:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  110818:	66 89 48 14          	mov    %cx,0x14(%eax)
            vdb->area.y1 = row;
  11081c:	66 8b 4c 24 24       	mov    0x24(%esp),%cx
  110821:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  110825:	66 89 48 12          	mov    %cx,0x12(%eax)
            vdb->area.y2 = row + max_row - 1;
  110829:	0f bf 44 24 24       	movswl 0x24(%esp),%eax
  11082e:	03 44 24 30          	add    0x30(%esp),%eax
  110832:	83 e8 01             	sub    $0x1,%eax
  110835:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  110839:	66 89 42 16          	mov    %ax,0x16(%edx)
            if(vdb->area.y2 > y2) vdb->area.y2 = y2;
  11083d:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  110841:	0f bf 52 16          	movswl 0x16(%edx),%edx
  110845:	0f bf 74 24 36       	movswl 0x36(%esp),%esi
  11084a:	39 f2                	cmp    %esi,%edx
  11084c:	0f 8e 0d 00 00 00    	jle    11085f <lv_refr_area+0x2bf>
  110852:	66 8b 44 24 36       	mov    0x36(%esp),%ax
  110857:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  11085b:	66 89 41 16          	mov    %ax,0x16(%ecx)
            row_last = vdb->area.y2;
  11085f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  110863:	66 8b 48 16          	mov    0x16(%eax),%cx
  110867:	66 89 4c 24 22       	mov    %cx,0x22(%esp)
            lv_refr_area_part(area_p);
  11086c:	8b 45 08             	mov    0x8(%ebp),%eax
  11086f:	89 04 24             	mov    %eax,(%esp)
  110872:	e8 79 00 00 00       	call   1108f0 <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
  110877:	8b 44 24 30          	mov    0x30(%esp),%eax
  11087b:	0f bf 4c 24 24       	movswl 0x24(%esp),%ecx
  110880:	01 c1                	add    %eax,%ecx
  110882:	66 89 4c 24 24       	mov    %cx,0x24(%esp)
  110887:	e9 5a ff ff ff       	jmp    1107e6 <lv_refr_area+0x246>
        if(y2 != row_last) {
  11088c:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110891:	0f bf 4c 24 22       	movswl 0x22(%esp),%ecx
  110896:	39 c8                	cmp    %ecx,%eax
  110898:	0f 84 42 00 00 00    	je     1108e0 <lv_refr_area+0x340>
            vdb->area.x1 = area_p->x1;
  11089e:	8b 45 08             	mov    0x8(%ebp),%eax
  1108a1:	66 8b 08             	mov    (%eax),%cx
  1108a4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1108a8:	66 89 48 10          	mov    %cx,0x10(%eax)
            vdb->area.x2 = area_p->x2;
  1108ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1108af:	66 8b 48 04          	mov    0x4(%eax),%cx
  1108b3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1108b7:	66 89 48 14          	mov    %cx,0x14(%eax)
            vdb->area.y1 = row;
  1108bb:	66 8b 4c 24 24       	mov    0x24(%esp),%cx
  1108c0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1108c4:	66 89 48 12          	mov    %cx,0x12(%eax)
            vdb->area.y2 = y2;
  1108c8:	66 8b 4c 24 36       	mov    0x36(%esp),%cx
  1108cd:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1108d1:	66 89 48 16          	mov    %cx,0x16(%eax)
            lv_refr_area_part(area_p);
  1108d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1108d8:	89 04 24             	mov    %eax,(%esp)
  1108db:	e8 10 00 00 00       	call   1108f0 <lv_refr_area_part>
  1108e0:	e9 00 00 00 00       	jmp    1108e5 <lv_refr_area+0x345>
}
  1108e5:	8d 65 fc             	lea    -0x4(%ebp),%esp
  1108e8:	5e                   	pop    %esi
  1108e9:	5d                   	pop    %ebp
  1108ea:	c3                   	ret    
  1108eb:	66 90                	xchg   %ax,%ax
  1108ed:	66 90                	xchg   %ax,%ax
  1108ef:	90                   	nop

001108f0 <lv_refr_area_part>:
{
  1108f0:	55                   	push   %ebp
  1108f1:	89 e5                	mov    %esp,%ebp
  1108f3:	83 e4 f8             	and    $0xfffffff8,%esp
  1108f6:	83 ec 28             	sub    $0x28,%esp
  1108f9:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
  1108fc:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110902:	89 0c 24             	mov    %ecx,(%esp)
  110905:	89 44 24 14          	mov    %eax,0x14(%esp)
  110909:	e8 a2 6f 00 00       	call   1178b0 <lv_disp_get_buf>
  11090e:	89 44 24 24          	mov    %eax,0x24(%esp)
    if(lv_disp_is_double_buf(disp_refr) == false) {
  110912:	a1 48 51 13 00       	mov    0x135148,%eax
  110917:	89 04 24             	mov    %eax,(%esp)
  11091a:	e8 b1 6f 00 00       	call   1178d0 <lv_disp_is_double_buf>
  11091f:	24 01                	and    $0x1,%al
  110921:	0f b6 c8             	movzbl %al,%ecx
  110924:	83 f9 00             	cmp    $0x0,%ecx
  110927:	0f 85 25 00 00 00    	jne    110952 <lv_refr_area_part+0x62>
        while(vdb->flushing)
  11092d:	e9 00 00 00 00       	jmp    110932 <lv_refr_area_part+0x42>
  110932:	8b 44 24 24          	mov    0x24(%esp),%eax
  110936:	8a 48 18             	mov    0x18(%eax),%cl
  110939:	80 e1 01             	and    $0x1,%cl
  11093c:	0f b6 c1             	movzbl %cl,%eax
  11093f:	83 f8 00             	cmp    $0x0,%eax
  110942:	0f 84 05 00 00 00    	je     11094d <lv_refr_area_part+0x5d>
  110948:	e9 e5 ff ff ff       	jmp    110932 <lv_refr_area_part+0x42>
    }
  11094d:	e9 00 00 00 00       	jmp    110952 <lv_refr_area_part+0x62>
    lv_area_intersect(&start_mask, area_p, &vdb->area);
  110952:	8b 45 08             	mov    0x8(%ebp),%eax
  110955:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  110959:	83 c1 10             	add    $0x10,%ecx
  11095c:	8d 54 24 18          	lea    0x18(%esp),%edx
  110960:	89 14 24             	mov    %edx,(%esp)
  110963:	89 44 24 04          	mov    %eax,0x4(%esp)
  110967:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11096b:	e8 90 72 00 00       	call   117c00 <lv_area_intersect>
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
  110970:	8b 0d 48 51 13 00    	mov    0x135148,%ecx
  110976:	89 0c 24             	mov    %ecx,(%esp)
  110979:	88 44 24 13          	mov    %al,0x13(%esp)
  11097d:	e8 de d2 ff ff       	call   10dc60 <lv_disp_get_scr_act>
  110982:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  110986:	89 0c 24             	mov    %ecx,(%esp)
  110989:	89 44 24 04          	mov    %eax,0x4(%esp)
  11098d:	e8 ae 00 00 00       	call   110a40 <lv_refr_get_top_obj>
  110992:	89 44 24 20          	mov    %eax,0x20(%esp)
    lv_refr_obj_and_children(top_p, &start_mask);
  110996:	8b 44 24 20          	mov    0x20(%esp),%eax
  11099a:	89 04 24             	mov    %eax,(%esp)
  11099d:	8d 44 24 18          	lea    0x18(%esp),%eax
  1109a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1109a5:	e8 d6 01 00 00       	call   110b80 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
  1109aa:	a1 48 51 13 00       	mov    0x135148,%eax
  1109af:	89 04 24             	mov    %eax,(%esp)
  1109b2:	e8 19 d3 ff ff       	call   10dcd0 <lv_disp_get_layer_top>
  1109b7:	89 04 24             	mov    %eax,(%esp)
  1109ba:	8d 44 24 18          	lea    0x18(%esp),%eax
  1109be:	89 44 24 04          	mov    %eax,0x4(%esp)
  1109c2:	e8 b9 01 00 00       	call   110b80 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
  1109c7:	a1 48 51 13 00       	mov    0x135148,%eax
  1109cc:	89 04 24             	mov    %eax,(%esp)
  1109cf:	e8 6c d3 ff ff       	call   10dd40 <lv_disp_get_layer_sys>
  1109d4:	89 04 24             	mov    %eax,(%esp)
  1109d7:	8d 44 24 18          	lea    0x18(%esp),%eax
  1109db:	89 44 24 04          	mov    %eax,0x4(%esp)
  1109df:	e8 9c 01 00 00       	call   110b80 <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
  1109e4:	a1 48 51 13 00       	mov    0x135148,%eax
  1109e9:	89 04 24             	mov    %eax,(%esp)
  1109ec:	e8 1f 6f 00 00       	call   117910 <lv_disp_is_true_double_buf>
  1109f1:	24 01                	and    $0x1,%al
  1109f3:	0f b6 c8             	movzbl %al,%ecx
  1109f6:	83 f9 00             	cmp    $0x0,%ecx
  1109f9:	0f 85 05 00 00 00    	jne    110a04 <lv_refr_area_part+0x114>
        lv_refr_vdb_flush();
  1109ff:	e8 7c fa ff ff       	call   110480 <lv_refr_vdb_flush>
}
  110a04:	89 ec                	mov    %ebp,%esp
  110a06:	5d                   	pop    %ebp
  110a07:	c3                   	ret    
  110a08:	66 90                	xchg   %ax,%ax
  110a0a:	66 90                	xchg   %ax,%ax
  110a0c:	66 90                	xchg   %ax,%ax
  110a0e:	66 90                	xchg   %ax,%ax

00110a10 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
  110a10:	55                   	push   %ebp
  110a11:	89 e5                	mov    %esp,%ebp
  110a13:	50                   	push   %eax
  110a14:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->y2 - area_p->y1 + 1;
  110a17:	8b 4d 08             	mov    0x8(%ebp),%ecx
  110a1a:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  110a1e:	8b 55 08             	mov    0x8(%ebp),%edx
  110a21:	0f bf 52 02          	movswl 0x2(%edx),%edx
  110a25:	29 d1                	sub    %edx,%ecx
  110a27:	83 c1 01             	add    $0x1,%ecx
  110a2a:	0f bf d1             	movswl %cx,%edx
  110a2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  110a30:	89 d0                	mov    %edx,%eax
  110a32:	83 c4 04             	add    $0x4,%esp
  110a35:	5d                   	pop    %ebp
  110a36:	c3                   	ret    
  110a37:	66 90                	xchg   %ax,%ax
  110a39:	66 90                	xchg   %ax,%ax
  110a3b:	66 90                	xchg   %ax,%ax
  110a3d:	66 90                	xchg   %ax,%ax
  110a3f:	90                   	nop

00110a40 <lv_refr_get_top_obj>:
{
  110a40:	55                   	push   %ebp
  110a41:	89 e5                	mov    %esp,%ebp
  110a43:	56                   	push   %esi
  110a44:	83 ec 20             	sub    $0x20,%esp
  110a47:	8b 45 0c             	mov    0xc(%ebp),%eax
  110a4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_obj_t * found_p = NULL;
  110a4d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
  110a54:	8b 55 08             	mov    0x8(%ebp),%edx
  110a57:	8b 75 0c             	mov    0xc(%ebp),%esi
  110a5a:	83 c6 10             	add    $0x10,%esi
  110a5d:	89 14 24             	mov    %edx,(%esp)
  110a60:	89 74 24 04          	mov    %esi,0x4(%esp)
  110a64:	89 45 ec             	mov    %eax,-0x14(%ebp)
  110a67:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  110a6a:	e8 51 74 00 00       	call   117ec0 <lv_area_is_in>
  110a6f:	a8 01                	test   $0x1,%al
  110a71:	0f 85 05 00 00 00    	jne    110a7c <lv_refr_get_top_obj+0x3c>
  110a77:	e9 fb 00 00 00       	jmp    110b77 <lv_refr_get_top_obj+0x137>
  110a7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  110a7f:	66 8b 48 2c          	mov    0x2c(%eax),%cx
  110a83:	66 c1 e9 04          	shr    $0x4,%cx
  110a87:	66 83 e1 01          	and    $0x1,%cx
  110a8b:	0f b6 c1             	movzbl %cl,%eax
  110a8e:	83 f8 00             	cmp    $0x0,%eax
  110a91:	0f 85 e0 00 00 00    	jne    110b77 <lv_refr_get_top_obj+0x137>
        LV_LL_READ(obj->child_ll, i)
  110a97:	8b 45 0c             	mov    0xc(%ebp),%eax
  110a9a:	83 c0 04             	add    $0x4,%eax
  110a9d:	89 04 24             	mov    %eax,(%esp)
  110aa0:	e8 0b 83 00 00       	call   118db0 <lv_ll_get_head>
  110aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  110aa8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  110aac:	0f 84 46 00 00 00    	je     110af8 <lv_refr_get_top_obj+0xb8>
            found_p = lv_refr_get_top_obj(area_p, i);
  110ab2:	8b 45 08             	mov    0x8(%ebp),%eax
  110ab5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  110ab8:	89 04 24             	mov    %eax,(%esp)
  110abb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110abf:	e8 7c ff ff ff       	call   110a40 <lv_refr_get_top_obj>
  110ac4:	89 45 f8             	mov    %eax,-0x8(%ebp)
            if(found_p != NULL) {
  110ac7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  110acb:	0f 84 05 00 00 00    	je     110ad6 <lv_refr_get_top_obj+0x96>
                break;
  110ad1:	e9 22 00 00 00       	jmp    110af8 <lv_refr_get_top_obj+0xb8>
        }
  110ad6:	e9 00 00 00 00       	jmp    110adb <lv_refr_get_top_obj+0x9b>
        LV_LL_READ(obj->child_ll, i)
  110adb:	8b 45 0c             	mov    0xc(%ebp),%eax
  110ade:	83 c0 04             	add    $0x4,%eax
  110ae1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  110ae4:	89 04 24             	mov    %eax,(%esp)
  110ae7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110aeb:	e8 80 85 00 00       	call   119070 <lv_ll_get_next>
  110af0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  110af3:	e9 b0 ff ff ff       	jmp    110aa8 <lv_refr_get_top_obj+0x68>
        if(found_p == NULL) {
  110af8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  110afc:	0f 85 70 00 00 00    	jne    110b72 <lv_refr_get_top_obj+0x132>
            const lv_style_t * style = lv_obj_get_style(obj);
  110b02:	8b 45 0c             	mov    0xc(%ebp),%eax
  110b05:	89 04 24             	mov    %eax,(%esp)
  110b08:	e8 a3 ef ff ff       	call   10fab0 <lv_obj_get_style>
  110b0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
  110b10:	8b 45 f0             	mov    -0x10(%ebp),%eax
  110b13:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  110b17:	3d ff 00 00 00       	cmp    $0xff,%eax
  110b1c:	0f 85 4b 00 00 00    	jne    110b6d <lv_refr_get_top_obj+0x12d>
  110b22:	8b 45 0c             	mov    0xc(%ebp),%eax
  110b25:	8b 40 20             	mov    0x20(%eax),%eax
  110b28:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  110b2b:	8b 55 08             	mov    0x8(%ebp),%edx
  110b2e:	89 0c 24             	mov    %ecx,(%esp)
  110b31:	89 54 24 04          	mov    %edx,0x4(%esp)
  110b35:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  110b3c:	00 
  110b3d:	ff d0                	call   *%eax
  110b3f:	24 01                	and    $0x1,%al
  110b41:	0f b6 c8             	movzbl %al,%ecx
  110b44:	83 f9 00             	cmp    $0x0,%ecx
  110b47:	0f 84 20 00 00 00    	je     110b6d <lv_refr_get_top_obj+0x12d>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
  110b4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  110b50:	89 04 24             	mov    %eax,(%esp)
  110b53:	e8 58 f0 ff ff       	call   10fbb0 <lv_obj_get_opa_scale>
  110b58:	0f b6 c8             	movzbl %al,%ecx
  110b5b:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
  110b61:	0f 85 06 00 00 00    	jne    110b6d <lv_refr_get_top_obj+0x12d>
                found_p = obj;
  110b67:	8b 45 0c             	mov    0xc(%ebp),%eax
  110b6a:	89 45 f8             	mov    %eax,-0x8(%ebp)
        }
  110b6d:	e9 00 00 00 00       	jmp    110b72 <lv_refr_get_top_obj+0x132>
    }
  110b72:	e9 00 00 00 00       	jmp    110b77 <lv_refr_get_top_obj+0x137>
    return found_p;
  110b77:	8b 45 f8             	mov    -0x8(%ebp),%eax
  110b7a:	83 c4 20             	add    $0x20,%esp
  110b7d:	5e                   	pop    %esi
  110b7e:	5d                   	pop    %ebp
  110b7f:	c3                   	ret    

00110b80 <lv_refr_obj_and_children>:
{
  110b80:	55                   	push   %ebp
  110b81:	89 e5                	mov    %esp,%ebp
  110b83:	83 ec 1c             	sub    $0x1c,%esp
  110b86:	8b 45 0c             	mov    0xc(%ebp),%eax
  110b89:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
  110b8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  110b90:	0f 85 10 00 00 00    	jne    110ba6 <lv_refr_obj_and_children+0x26>
  110b96:	a1 48 51 13 00       	mov    0x135148,%eax
  110b9b:	89 04 24             	mov    %eax,(%esp)
  110b9e:	e8 bd d0 ff ff       	call   10dc60 <lv_disp_get_scr_act>
  110ba3:	89 45 08             	mov    %eax,0x8(%ebp)
    lv_refr_obj(top_p, mask_p);
  110ba6:	8b 45 08             	mov    0x8(%ebp),%eax
  110ba9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  110bac:	89 04 24             	mov    %eax,(%esp)
  110baf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110bb3:	e8 b8 00 00 00       	call   110c70 <lv_refr_obj>
    lv_obj_t * border_p = top_p;
  110bb8:	8b 45 08             	mov    0x8(%ebp),%eax
  110bbb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    par = lv_obj_get_parent(top_p);
  110bbe:	8b 45 08             	mov    0x8(%ebp),%eax
  110bc1:	89 04 24             	mov    %eax,(%esp)
  110bc4:	e8 97 dd ff ff       	call   10e960 <lv_obj_get_parent>
  110bc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(par != NULL) {
  110bcc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  110bd0:	0f 84 8a 00 00 00    	je     110c60 <lv_refr_obj_and_children+0xe0>
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
  110bd6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  110bd9:	83 c0 04             	add    $0x4,%eax
  110bdc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  110bdf:	89 04 24             	mov    %eax,(%esp)
  110be2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110be6:	e8 f5 81 00 00       	call   118de0 <lv_ll_get_prev>
  110beb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while(i != NULL) {
  110bee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  110bf2:	0f 84 2f 00 00 00    	je     110c27 <lv_refr_obj_and_children+0xa7>
            lv_refr_obj(i, mask_p);
  110bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  110bfb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  110bfe:	89 04 24             	mov    %eax,(%esp)
  110c01:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110c05:	e8 66 00 00 00       	call   110c70 <lv_refr_obj>
            i = lv_ll_get_prev(&(par->child_ll), i);
  110c0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  110c0d:	83 c0 04             	add    $0x4,%eax
  110c10:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  110c13:	89 04 24             	mov    %eax,(%esp)
  110c16:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110c1a:	e8 c1 81 00 00       	call   118de0 <lv_ll_get_prev>
  110c1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while(i != NULL) {
  110c22:	e9 c7 ff ff ff       	jmp    110bee <lv_refr_obj_and_children+0x6e>
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
  110c27:	8b 45 fc             	mov    -0x4(%ebp),%eax
  110c2a:	8b 40 20             	mov    0x20(%eax),%eax
  110c2d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  110c30:	8b 55 0c             	mov    0xc(%ebp),%edx
  110c33:	89 0c 24             	mov    %ecx,(%esp)
  110c36:	89 54 24 04          	mov    %edx,0x4(%esp)
  110c3a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  110c41:	00 
  110c42:	ff d0                	call   *%eax
        border_p = par;
  110c44:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  110c47:	89 4d f8             	mov    %ecx,-0x8(%ebp)
        par = lv_obj_get_parent(par);
  110c4a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  110c4d:	89 0c 24             	mov    %ecx,(%esp)
  110c50:	88 45 f3             	mov    %al,-0xd(%ebp)
  110c53:	e8 08 dd ff ff       	call   10e960 <lv_obj_get_parent>
  110c58:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(par != NULL) {
  110c5b:	e9 6c ff ff ff       	jmp    110bcc <lv_refr_obj_and_children+0x4c>
}
  110c60:	83 c4 1c             	add    $0x1c,%esp
  110c63:	5d                   	pop    %ebp
  110c64:	c3                   	ret    
  110c65:	66 90                	xchg   %ax,%ax
  110c67:	66 90                	xchg   %ax,%ax
  110c69:	66 90                	xchg   %ax,%ax
  110c6b:	66 90                	xchg   %ax,%ax
  110c6d:	66 90                	xchg   %ax,%ax
  110c6f:	90                   	nop

00110c70 <lv_refr_obj>:
{
  110c70:	55                   	push   %ebp
  110c71:	89 e5                	mov    %esp,%ebp
  110c73:	53                   	push   %ebx
  110c74:	57                   	push   %edi
  110c75:	56                   	push   %esi
  110c76:	83 e4 f8             	and    $0xfffffff8,%esp
  110c79:	83 ec 58             	sub    $0x58,%esp
  110c7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  110c7f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(obj->hidden != 0) return;
  110c82:	8b 55 08             	mov    0x8(%ebp),%edx
  110c85:	66 8b 72 2c          	mov    0x2c(%edx),%si
  110c89:	66 c1 ee 04          	shr    $0x4,%si
  110c8d:	66 89 f3             	mov    %si,%bx
  110c90:	66 83 e3 01          	and    $0x1,%bx
  110c94:	0f b6 d3             	movzbl %bl,%edx
  110c97:	83 fa 00             	cmp    $0x0,%edx
  110c9a:	0f 84 05 00 00 00    	je     110ca5 <lv_refr_obj+0x35>
  110ca0:	e9 0e 02 00 00       	jmp    110eb3 <lv_refr_obj+0x243>
    lv_coord_t ext_size = obj->ext_draw_pad;
  110ca5:	8b 45 08             	mov    0x8(%ebp),%eax
  110ca8:	66 8b 48 30          	mov    0x30(%eax),%cx
  110cac:	66 89 4c 24 36       	mov    %cx,0x36(%esp)
    lv_obj_get_coords(obj, &obj_area);
  110cb1:	8b 45 08             	mov    0x8(%ebp),%eax
  110cb4:	89 04 24             	mov    %eax,(%esp)
  110cb7:	8d 44 24 38          	lea    0x38(%esp),%eax
  110cbb:	89 44 24 04          	mov    %eax,0x4(%esp)
  110cbf:	e8 7c e2 ff ff       	call   10ef40 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
  110cc4:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110cc9:	0f bf 54 24 38       	movswl 0x38(%esp),%edx
  110cce:	29 c2                	sub    %eax,%edx
  110cd0:	66 89 54 24 38       	mov    %dx,0x38(%esp)
    obj_area.y1 -= ext_size;
  110cd5:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110cda:	0f bf 74 24 3a       	movswl 0x3a(%esp),%esi
  110cdf:	29 c6                	sub    %eax,%esi
  110ce1:	66 89 74 24 3a       	mov    %si,0x3a(%esp)
    obj_area.x2 += ext_size;
  110ce6:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110ceb:	0f bf 7c 24 3c       	movswl 0x3c(%esp),%edi
  110cf0:	01 c7                	add    %eax,%edi
  110cf2:	66 89 7c 24 3c       	mov    %di,0x3c(%esp)
    obj_area.y2 += ext_size;
  110cf7:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110cfc:	0f bf 5c 24 3e       	movswl 0x3e(%esp),%ebx
  110d01:	01 c3                	add    %eax,%ebx
  110d03:	66 89 5c 24 3e       	mov    %bx,0x3e(%esp)
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
  110d08:	8b 45 0c             	mov    0xc(%ebp),%eax
  110d0b:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  110d0f:	89 0c 24             	mov    %ecx,(%esp)
  110d12:	89 44 24 04          	mov    %eax,0x4(%esp)
  110d16:	8d 44 24 38          	lea    0x38(%esp),%eax
  110d1a:	89 44 24 08          	mov    %eax,0x8(%esp)
  110d1e:	e8 dd 6e 00 00       	call   117c00 <lv_area_intersect>
  110d23:	24 01                	and    $0x1,%al
  110d25:	88 44 24 53          	mov    %al,0x53(%esp)
    if(union_ok != false) {
  110d29:	8a 44 24 53          	mov    0x53(%esp),%al
  110d2d:	24 01                	and    $0x1,%al
  110d2f:	0f b6 c8             	movzbl %al,%ecx
  110d32:	83 f9 00             	cmp    $0x0,%ecx
  110d35:	0f 84 78 01 00 00    	je     110eb3 <lv_refr_obj+0x243>
  110d3b:	31 c0                	xor    %eax,%eax
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
  110d3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  110d40:	8b 49 20             	mov    0x20(%ecx),%ecx
  110d43:	8b 55 08             	mov    0x8(%ebp),%edx
  110d46:	89 14 24             	mov    %edx,(%esp)
  110d49:	8d 54 24 40          	lea    0x40(%esp),%edx
  110d4d:	89 54 24 04          	mov    %edx,0x4(%esp)
  110d51:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  110d58:	00 
  110d59:	89 44 24 14          	mov    %eax,0x14(%esp)
  110d5d:	ff d1                	call   *%ecx
        lv_obj_get_coords(obj, &obj_area);
  110d5f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  110d62:	89 0c 24             	mov    %ecx,(%esp)
  110d65:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  110d69:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110d6d:	88 44 24 13          	mov    %al,0x13(%esp)
  110d71:	e8 ca e1 ff ff       	call   10ef40 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
  110d76:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  110d79:	8d 54 24 48          	lea    0x48(%esp),%edx
  110d7d:	89 14 24             	mov    %edx,(%esp)
  110d80:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110d84:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  110d88:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  110d8c:	e8 6f 6e 00 00       	call   117c00 <lv_area_intersect>
  110d91:	24 01                	and    $0x1,%al
  110d93:	88 44 24 53          	mov    %al,0x53(%esp)
        if(union_ok != false) {
  110d97:	8a 44 24 53          	mov    0x53(%esp),%al
  110d9b:	24 01                	and    $0x1,%al
  110d9d:	0f b6 c8             	movzbl %al,%ecx
  110da0:	83 f9 00             	cmp    $0x0,%ecx
  110da3:	0f 84 ec 00 00 00    	je     110e95 <lv_refr_obj+0x225>
            LV_LL_READ_BACK(obj->child_ll, child_p)
  110da9:	8b 45 08             	mov    0x8(%ebp),%eax
  110dac:	83 c0 04             	add    $0x4,%eax
  110daf:	89 04 24             	mov    %eax,(%esp)
  110db2:	e8 09 83 00 00       	call   1190c0 <lv_ll_get_tail>
  110db7:	89 44 24 24          	mov    %eax,0x24(%esp)
  110dbb:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  110dc0:	0f 84 ca 00 00 00    	je     110e90 <lv_refr_obj+0x220>
                lv_obj_get_coords(child_p, &child_area);
  110dc6:	8b 44 24 24          	mov    0x24(%esp),%eax
  110dca:	89 04 24             	mov    %eax,(%esp)
  110dcd:	8d 44 24 18          	lea    0x18(%esp),%eax
  110dd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  110dd5:	e8 66 e1 ff ff       	call   10ef40 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
  110dda:	8b 44 24 24          	mov    0x24(%esp),%eax
  110dde:	66 8b 48 30          	mov    0x30(%eax),%cx
  110de2:	66 89 4c 24 36       	mov    %cx,0x36(%esp)
                child_area.x1 -= ext_size;
  110de7:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110dec:	0f bf 54 24 18       	movswl 0x18(%esp),%edx
  110df1:	29 c2                	sub    %eax,%edx
  110df3:	66 89 54 24 18       	mov    %dx,0x18(%esp)
                child_area.y1 -= ext_size;
  110df8:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110dfd:	0f bf 74 24 1a       	movswl 0x1a(%esp),%esi
  110e02:	29 c6                	sub    %eax,%esi
  110e04:	66 89 74 24 1a       	mov    %si,0x1a(%esp)
                child_area.x2 += ext_size;
  110e09:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110e0e:	0f bf 7c 24 1c       	movswl 0x1c(%esp),%edi
  110e13:	01 c7                	add    %eax,%edi
  110e15:	66 89 7c 24 1c       	mov    %di,0x1c(%esp)
                child_area.y2 += ext_size;
  110e1a:	0f bf 44 24 36       	movswl 0x36(%esp),%eax
  110e1f:	0f bf 5c 24 1e       	movswl 0x1e(%esp),%ebx
  110e24:	01 c3                	add    %eax,%ebx
  110e26:	66 89 5c 24 1e       	mov    %bx,0x1e(%esp)
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
  110e2b:	8d 44 24 28          	lea    0x28(%esp),%eax
  110e2f:	89 04 24             	mov    %eax,(%esp)
  110e32:	8d 44 24 48          	lea    0x48(%esp),%eax
  110e36:	89 44 24 04          	mov    %eax,0x4(%esp)
  110e3a:	8d 44 24 18          	lea    0x18(%esp),%eax
  110e3e:	89 44 24 08          	mov    %eax,0x8(%esp)
  110e42:	e8 b9 6d 00 00       	call   117c00 <lv_area_intersect>
  110e47:	24 01                	and    $0x1,%al
  110e49:	88 44 24 53          	mov    %al,0x53(%esp)
                if(union_ok) {
  110e4d:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  110e52:	0f 84 14 00 00 00    	je     110e6c <lv_refr_obj+0x1fc>
                    lv_refr_obj(child_p, &mask_child);
  110e58:	8b 44 24 24          	mov    0x24(%esp),%eax
  110e5c:	89 04 24             	mov    %eax,(%esp)
  110e5f:	8d 44 24 28          	lea    0x28(%esp),%eax
  110e63:	89 44 24 04          	mov    %eax,0x4(%esp)
  110e67:	e8 04 fe ff ff       	call   110c70 <lv_refr_obj>
            }
  110e6c:	e9 00 00 00 00       	jmp    110e71 <lv_refr_obj+0x201>
            LV_LL_READ_BACK(obj->child_ll, child_p)
  110e71:	8b 45 08             	mov    0x8(%ebp),%eax
  110e74:	83 c0 04             	add    $0x4,%eax
  110e77:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  110e7b:	89 04 24             	mov    %eax,(%esp)
  110e7e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110e82:	e8 59 7f 00 00       	call   118de0 <lv_ll_get_prev>
  110e87:	89 44 24 24          	mov    %eax,0x24(%esp)
  110e8b:	e9 2b ff ff ff       	jmp    110dbb <lv_refr_obj+0x14b>
        }
  110e90:	e9 00 00 00 00       	jmp    110e95 <lv_refr_obj+0x225>
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
  110e95:	8b 45 08             	mov    0x8(%ebp),%eax
  110e98:	8b 40 20             	mov    0x20(%eax),%eax
  110e9b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  110e9e:	89 0c 24             	mov    %ecx,(%esp)
  110ea1:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  110ea5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  110ea9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  110eb0:	00 
  110eb1:	ff d0                	call   *%eax
}
  110eb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110eb6:	5e                   	pop    %esi
  110eb7:	5f                   	pop    %edi
  110eb8:	5b                   	pop    %ebx
  110eb9:	5d                   	pop    %ebp
  110eba:	c3                   	ret    
  110ebb:	66 90                	xchg   %ax,%ax
  110ebd:	66 90                	xchg   %ax,%ax
  110ebf:	90                   	nop

00110ec0 <lv_style_init>:

/**
 *  Init the basic styles
 */
void lv_style_init(void)
{
  110ec0:	55                   	push   %ebp
  110ec1:	89 e5                	mov    %esp,%ebp
  110ec3:	83 e4 f8             	and    $0xfffffff8,%esp
  110ec6:	81 ec b0 01 00 00    	sub    $0x1b0,%esp
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
  110ecc:	a0 50 51 13 00       	mov    0x135150,%al
  110ed1:	24 fe                	and    $0xfe,%al
  110ed3:	a2 50 51 13 00       	mov    %al,0x135150
    lv_style_scr.body.opa            = LV_OPA_COVER;
  110ed8:	c6 05 5e 51 13 00 ff 	movb   $0xff,0x13515e
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
  110edf:	c6 84 24 a8 01 00 00 	movb   $0xff,0x1a8(%esp)
  110ee6:	ff 
  110ee7:	c6 84 24 a9 01 00 00 	movb   $0xff,0x1a9(%esp)
  110eee:	ff 
  110eef:	c6 84 24 aa 01 00 00 	movb   $0xff,0x1aa(%esp)
  110ef6:	ff 
  110ef7:	c6 84 24 ab 01 00 00 	movb   $0xff,0x1ab(%esp)
  110efe:	ff 
  110eff:	8b 8c 24 a8 01 00 00 	mov    0x1a8(%esp),%ecx
  110f06:	89 0d 54 51 13 00    	mov    %ecx,0x135154
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
  110f0c:	c6 84 24 a0 01 00 00 	movb   $0xff,0x1a0(%esp)
  110f13:	ff 
  110f14:	c6 84 24 a1 01 00 00 	movb   $0xff,0x1a1(%esp)
  110f1b:	ff 
  110f1c:	c6 84 24 a2 01 00 00 	movb   $0xff,0x1a2(%esp)
  110f23:	ff 
  110f24:	c6 84 24 a3 01 00 00 	movb   $0xff,0x1a3(%esp)
  110f2b:	ff 
  110f2c:	8b 8c 24 a0 01 00 00 	mov    0x1a0(%esp),%ecx
  110f33:	89 0d 58 51 13 00    	mov    %ecx,0x135158
    lv_style_scr.body.radius         = 0;
  110f39:	66 c7 05 5c 51 13 00 	movw   $0x0,0x13515c
  110f40:	00 00 
    lv_style_scr.body.padding.left   = 0;
  110f42:	66 c7 05 74 51 13 00 	movw   $0x0,0x135174
  110f49:	00 00 
    lv_style_scr.body.padding.right  = 0;
  110f4b:	66 c7 05 76 51 13 00 	movw   $0x0,0x135176
  110f52:	00 00 
    lv_style_scr.body.padding.top    = 0;
  110f54:	66 c7 05 70 51 13 00 	movw   $0x0,0x135170
  110f5b:	00 00 
    lv_style_scr.body.padding.bottom = 0;
  110f5d:	66 c7 05 72 51 13 00 	movw   $0x0,0x135172
  110f64:	00 00 
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
  110f66:	66 c7 05 78 51 13 00 	movw   $0x5,0x135178
  110f6d:	05 00 

    lv_style_scr.body.border.color = LV_COLOR_BLACK;
  110f6f:	c6 84 24 98 01 00 00 	movb   $0x0,0x198(%esp)
  110f76:	00 
  110f77:	c6 84 24 99 01 00 00 	movb   $0x0,0x199(%esp)
  110f7e:	00 
  110f7f:	c6 84 24 9a 01 00 00 	movb   $0x0,0x19a(%esp)
  110f86:	00 
  110f87:	c6 84 24 9b 01 00 00 	movb   $0xff,0x19b(%esp)
  110f8e:	ff 
  110f8f:	8b 8c 24 98 01 00 00 	mov    0x198(%esp),%ecx
  110f96:	89 0d 60 51 13 00    	mov    %ecx,0x135160
    lv_style_scr.body.border.opa   = LV_OPA_COVER;
  110f9c:	c6 05 67 51 13 00 ff 	movb   $0xff,0x135167
    lv_style_scr.body.border.width = 0;
  110fa3:	66 c7 05 64 51 13 00 	movw   $0x0,0x135164
  110faa:	00 00 
    lv_style_scr.body.border.part  = LV_BORDER_FULL;
  110fac:	c6 05 66 51 13 00 0f 	movb   $0xf,0x135166

    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
  110fb3:	c6 84 24 90 01 00 00 	movb   $0x80,0x190(%esp)
  110fba:	80 
  110fbb:	c6 84 24 91 01 00 00 	movb   $0x80,0x191(%esp)
  110fc2:	80 
  110fc3:	c6 84 24 92 01 00 00 	movb   $0x80,0x192(%esp)
  110fca:	80 
  110fcb:	c6 84 24 93 01 00 00 	movb   $0xff,0x193(%esp)
  110fd2:	ff 
  110fd3:	8b 8c 24 90 01 00 00 	mov    0x190(%esp),%ecx
  110fda:	89 0d 68 51 13 00    	mov    %ecx,0x135168
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
  110fe0:	c6 05 6e 51 13 00 01 	movb   $0x1,0x13516e
    lv_style_scr.body.shadow.width = 0;
  110fe7:	66 c7 05 6c 51 13 00 	movw   $0x0,0x13516c
  110fee:	00 00 

    lv_style_scr.text.opa          = LV_OPA_COVER;
  110ff0:	c6 05 8c 51 13 00 ff 	movb   $0xff,0x13518c
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
  110ff7:	8d 8c 24 88 01 00 00 	lea    0x188(%esp),%ecx
  110ffe:	89 0c 24             	mov    %ecx,(%esp)
  111001:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  111008:	00 
  111009:	c7 44 24 08 30 00 00 	movl   $0x30,0x8(%esp)
  111010:	00 
  111011:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%esp)
  111018:	00 
  111019:	e8 12 0c 00 00       	call   111c30 <lv_color_make>
  11101e:	83 ec 04             	sub    $0x4,%esp
  111021:	8b 8c 24 88 01 00 00 	mov    0x188(%esp),%ecx
  111028:	89 0d 7c 51 13 00    	mov    %ecx,0x13517c
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
  11102e:	8d 8c 24 80 01 00 00 	lea    0x180(%esp),%ecx
  111035:	89 0c 24             	mov    %ecx,(%esp)
  111038:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  11103f:	00 
  111040:	c7 44 24 08 96 00 00 	movl   $0x96,0x8(%esp)
  111047:	00 
  111048:	c7 44 24 0c d8 00 00 	movl   $0xd8,0xc(%esp)
  11104f:	00 
  111050:	e8 db 0b 00 00       	call   111c30 <lv_color_make>
  111055:	83 ec 04             	sub    $0x4,%esp
  111058:	8b 8c 24 80 01 00 00 	mov    0x180(%esp),%ecx
  11105f:	89 0d 80 51 13 00    	mov    %ecx,0x135180
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
  111065:	8d 0d 58 30 14 00    	lea    0x143058,%ecx
  11106b:	89 0d 84 51 13 00    	mov    %ecx,0x135184
    lv_style_scr.text.letter_space = 0;
  111071:	66 c7 05 88 51 13 00 	movw   $0x0,0x135188
  111078:	00 00 
    lv_style_scr.text.line_space   = 2;
  11107a:	66 c7 05 8a 51 13 00 	movw   $0x2,0x13518a
  111081:	02 00 

    lv_style_scr.image.opa     = LV_OPA_COVER;
  111083:	c6 05 95 51 13 00 ff 	movb   $0xff,0x135195
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
  11108a:	8d 8c 24 78 01 00 00 	lea    0x178(%esp),%ecx
  111091:	89 0c 24             	mov    %ecx,(%esp)
  111094:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  11109b:	00 
  11109c:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  1110a3:	00 
  1110a4:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  1110ab:	00 
  1110ac:	e8 7f 0b 00 00       	call   111c30 <lv_color_make>
  1110b1:	83 ec 04             	sub    $0x4,%esp
  1110b4:	8b 8c 24 78 01 00 00 	mov    0x178(%esp),%ecx
  1110bb:	89 0d 90 51 13 00    	mov    %ecx,0x135190
    lv_style_scr.image.intense = LV_OPA_TRANSP;
  1110c1:	c6 05 94 51 13 00 00 	movb   $0x0,0x135194

    lv_style_scr.line.opa     = LV_OPA_COVER;
  1110c8:	c6 05 9e 51 13 00 ff 	movb   $0xff,0x13519e
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
  1110cf:	8d 8c 24 70 01 00 00 	lea    0x170(%esp),%ecx
  1110d6:	89 0c 24             	mov    %ecx,(%esp)
  1110d9:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  1110e0:	00 
  1110e1:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  1110e8:	00 
  1110e9:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  1110f0:	00 
  1110f1:	e8 3a 0b 00 00       	call   111c30 <lv_color_make>
  1110f6:	83 ec 04             	sub    $0x4,%esp
  1110f9:	8b 8c 24 70 01 00 00 	mov    0x170(%esp),%ecx
  111100:	89 0d 98 51 13 00    	mov    %ecx,0x135198
    lv_style_scr.line.width   = 2;
  111106:	66 c7 05 9c 51 13 00 	movw   $0x2,0x13519c
  11110d:	02 00 
    lv_style_scr.line.rounded = 0;
  11110f:	a0 9f 51 13 00       	mov    0x13519f,%al
  111114:	24 fe                	and    $0xfe,%al
  111116:	a2 9f 51 13 00       	mov    %al,0x13519f

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
  11111b:	8d 0d a0 51 13 00    	lea    0x1351a0,%ecx
  111121:	89 0c 24             	mov    %ecx,(%esp)
  111124:	8d 0d 50 51 13 00    	lea    0x135150,%ecx
  11112a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11112e:	e8 2d 0b 00 00       	call   111c60 <lv_style_copy>
    lv_style_plain.body.padding.left   = LV_DPI / 20;
  111133:	66 c7 05 c4 51 13 00 	movw   $0x5,0x1351c4
  11113a:	05 00 
    lv_style_plain.body.padding.right  = LV_DPI / 20;
  11113c:	66 c7 05 c6 51 13 00 	movw   $0x5,0x1351c6
  111143:	05 00 
    lv_style_plain.body.padding.top    = LV_DPI / 20;
  111145:	66 c7 05 c0 51 13 00 	movw   $0x5,0x1351c0
  11114c:	05 00 
    lv_style_plain.body.padding.bottom = LV_DPI / 20;
  11114e:	66 c7 05 c2 51 13 00 	movw   $0x5,0x1351c2
  111155:	05 00 

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
  111157:	8d 0d f0 51 13 00    	lea    0x1351f0,%ecx
  11115d:	89 0c 24             	mov    %ecx,(%esp)
  111160:	8d 0d a0 51 13 00    	lea    0x1351a0,%ecx
  111166:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11116a:	e8 f1 0a 00 00       	call   111c60 <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
  11116f:	8d 8c 24 68 01 00 00 	lea    0x168(%esp),%ecx
  111176:	89 0c 24             	mov    %ecx,(%esp)
  111179:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
  111180:	00 
  111181:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  111188:	00 
  111189:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  111190:	00 
  111191:	e8 9a 0a 00 00       	call   111c30 <lv_color_make>
  111196:	83 ec 04             	sub    $0x4,%esp
  111199:	8b 8c 24 68 01 00 00 	mov    0x168(%esp),%ecx
  1111a0:	89 0d 1c 52 13 00    	mov    %ecx,0x13521c
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
  1111a6:	8d 8c 24 60 01 00 00 	lea    0x160(%esp),%ecx
  1111ad:	89 0c 24             	mov    %ecx,(%esp)
  1111b0:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
  1111b7:	00 
  1111b8:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  1111bf:	00 
  1111c0:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  1111c7:	00 
  1111c8:	e8 63 0a 00 00       	call   111c30 <lv_color_make>
  1111cd:	83 ec 04             	sub    $0x4,%esp
  1111d0:	8b 8c 24 60 01 00 00 	mov    0x160(%esp),%ecx
  1111d7:	89 0d 30 52 13 00    	mov    %ecx,0x135230
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
  1111dd:	8d 8c 24 58 01 00 00 	lea    0x158(%esp),%ecx
  1111e4:	89 0c 24             	mov    %ecx,(%esp)
  1111e7:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
  1111ee:	00 
  1111ef:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  1111f6:	00 
  1111f7:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  1111fe:	00 
  1111ff:	e8 2c 0a 00 00       	call   111c30 <lv_color_make>
  111204:	83 ec 04             	sub    $0x4,%esp
  111207:	8b 8c 24 58 01 00 00 	mov    0x158(%esp),%ecx
  11120e:	89 0d 38 52 13 00    	mov    %ecx,0x135238
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
  111214:	8d 8c 24 50 01 00 00 	lea    0x150(%esp),%ecx
  11121b:	89 0c 24             	mov    %ecx,(%esp)
  11121e:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  111225:	00 
  111226:	c7 44 24 08 96 00 00 	movl   $0x96,0x8(%esp)
  11122d:	00 
  11122e:	c7 44 24 0c d8 00 00 	movl   $0xd8,0xc(%esp)
  111235:	00 
  111236:	e8 f5 09 00 00       	call   111c30 <lv_color_make>
  11123b:	83 ec 04             	sub    $0x4,%esp
  11123e:	8b 8c 24 50 01 00 00 	mov    0x150(%esp),%ecx
  111245:	89 0d f4 51 13 00    	mov    %ecx,0x1351f4
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
  11124b:	8b 0d f4 51 13 00    	mov    0x1351f4,%ecx
  111251:	89 0d f8 51 13 00    	mov    %ecx,0x1351f8

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
  111257:	8d 0d 40 52 13 00    	lea    0x135240,%ecx
  11125d:	89 0c 24             	mov    %ecx,(%esp)
  111260:	8d 0d a0 51 13 00    	lea    0x1351a0,%ecx
  111266:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11126a:	e8 f1 09 00 00       	call   111c60 <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
  11126f:	8d 8c 24 48 01 00 00 	lea    0x148(%esp),%ecx
  111276:	89 0c 24             	mov    %ecx,(%esp)
  111279:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  111280:	00 
  111281:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  111288:	00 
  111289:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  111290:	00 
  111291:	e8 9a 09 00 00       	call   111c30 <lv_color_make>
  111296:	83 ec 04             	sub    $0x4,%esp
  111299:	8b 8c 24 48 01 00 00 	mov    0x148(%esp),%ecx
  1112a0:	89 0d 6c 52 13 00    	mov    %ecx,0x13526c
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
  1112a6:	8d 8c 24 40 01 00 00 	lea    0x140(%esp),%ecx
  1112ad:	89 0c 24             	mov    %ecx,(%esp)
  1112b0:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  1112b7:	00 
  1112b8:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  1112bf:	00 
  1112c0:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  1112c7:	00 
  1112c8:	e8 63 09 00 00       	call   111c30 <lv_color_make>
  1112cd:	83 ec 04             	sub    $0x4,%esp
  1112d0:	8b 8c 24 40 01 00 00 	mov    0x140(%esp),%ecx
  1112d7:	89 0d 80 52 13 00    	mov    %ecx,0x135280
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
  1112dd:	8d 8c 24 38 01 00 00 	lea    0x138(%esp),%ecx
  1112e4:	89 0c 24             	mov    %ecx,(%esp)
  1112e7:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  1112ee:	00 
  1112ef:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  1112f6:	00 
  1112f7:	c7 44 24 0c 20 00 00 	movl   $0x20,0xc(%esp)
  1112fe:	00 
  1112ff:	e8 2c 09 00 00       	call   111c30 <lv_color_make>
  111304:	83 ec 04             	sub    $0x4,%esp
  111307:	8b 8c 24 38 01 00 00 	mov    0x138(%esp),%ecx
  11130e:	89 0d 88 52 13 00    	mov    %ecx,0x135288
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
  111314:	c6 84 24 30 01 00 00 	movb   $0xff,0x130(%esp)
  11131b:	ff 
  11131c:	c6 84 24 31 01 00 00 	movb   $0xff,0x131(%esp)
  111323:	ff 
  111324:	c6 84 24 32 01 00 00 	movb   $0xff,0x132(%esp)
  11132b:	ff 
  11132c:	c6 84 24 33 01 00 00 	movb   $0xff,0x133(%esp)
  111333:	ff 
  111334:	8b 8c 24 30 01 00 00 	mov    0x130(%esp),%ecx
  11133b:	89 0d 44 52 13 00    	mov    %ecx,0x135244
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
  111341:	c6 84 24 28 01 00 00 	movb   $0xc0,0x128(%esp)
  111348:	c0 
  111349:	c6 84 24 29 01 00 00 	movb   $0xc0,0x129(%esp)
  111350:	c0 
  111351:	c6 84 24 2a 01 00 00 	movb   $0xc0,0x12a(%esp)
  111358:	c0 
  111359:	c6 84 24 2b 01 00 00 	movb   $0xff,0x12b(%esp)
  111360:	ff 
  111361:	8b 8c 24 28 01 00 00 	mov    0x128(%esp),%ecx
  111368:	89 0d 48 52 13 00    	mov    %ecx,0x135248
    lv_style_pretty.body.radius       = LV_DPI / 15;
  11136e:	66 c7 05 4c 52 13 00 	movw   $0x6,0x13524c
  111375:	06 00 
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
  111377:	8d 8c 24 20 01 00 00 	lea    0x120(%esp),%ecx
  11137e:	89 0c 24             	mov    %ecx,(%esp)
  111381:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
  111388:	00 
  111389:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  111390:	00 
  111391:	c7 44 24 0c 40 00 00 	movl   $0x40,0xc(%esp)
  111398:	00 
  111399:	e8 92 08 00 00       	call   111c30 <lv_color_make>
  11139e:	83 ec 04             	sub    $0x4,%esp
  1113a1:	8b 8c 24 20 01 00 00 	mov    0x120(%esp),%ecx
  1113a8:	89 0d 50 52 13 00    	mov    %ecx,0x135250
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
  1113ae:	66 c7 05 54 52 13 00 	movw   $0x2,0x135254
  1113b5:	02 00 
    lv_style_pretty.body.border.opa   = LV_OPA_30;
  1113b7:	c6 05 57 52 13 00 4c 	movb   $0x4c,0x135257

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
  1113be:	8d 0d 90 52 13 00    	lea    0x135290,%ecx
  1113c4:	89 0c 24             	mov    %ecx,(%esp)
  1113c7:	8d 0d 40 52 13 00    	lea    0x135240,%ecx
  1113cd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1113d1:	e8 8a 08 00 00       	call   111c60 <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
  1113d6:	8d 8c 24 18 01 00 00 	lea    0x118(%esp),%ecx
  1113dd:	89 0c 24             	mov    %ecx,(%esp)
  1113e0:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
  1113e7:	00 
  1113e8:	c7 44 24 08 e0 00 00 	movl   $0xe0,0x8(%esp)
  1113ef:	00 
  1113f0:	c7 44 24 0c e0 00 00 	movl   $0xe0,0xc(%esp)
  1113f7:	00 
  1113f8:	e8 33 08 00 00       	call   111c30 <lv_color_make>
  1113fd:	83 ec 04             	sub    $0x4,%esp
  111400:	8b 8c 24 18 01 00 00 	mov    0x118(%esp),%ecx
  111407:	89 0d bc 52 13 00    	mov    %ecx,0x1352bc
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
  11140d:	8d 8c 24 10 01 00 00 	lea    0x110(%esp),%ecx
  111414:	89 0c 24             	mov    %ecx,(%esp)
  111417:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
  11141e:	00 
  11141f:	c7 44 24 08 e0 00 00 	movl   $0xe0,0x8(%esp)
  111426:	00 
  111427:	c7 44 24 0c e0 00 00 	movl   $0xe0,0xc(%esp)
  11142e:	00 
  11142f:	e8 fc 07 00 00       	call   111c30 <lv_color_make>
  111434:	83 ec 04             	sub    $0x4,%esp
  111437:	8b 8c 24 10 01 00 00 	mov    0x110(%esp),%ecx
  11143e:	89 0d d0 52 13 00    	mov    %ecx,0x1352d0
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
  111444:	8d 8c 24 08 01 00 00 	lea    0x108(%esp),%ecx
  11144b:	89 0c 24             	mov    %ecx,(%esp)
  11144e:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  111455:	00 
  111456:	c7 44 24 08 c0 00 00 	movl   $0xc0,0x8(%esp)
  11145d:	00 
  11145e:	c7 44 24 0c c0 00 00 	movl   $0xc0,0xc(%esp)
  111465:	00 
  111466:	e8 c5 07 00 00       	call   111c30 <lv_color_make>
  11146b:	83 ec 04             	sub    $0x4,%esp
  11146e:	8b 8c 24 08 01 00 00 	mov    0x108(%esp),%ecx
  111475:	89 0d d8 52 13 00    	mov    %ecx,0x1352d8
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
  11147b:	8d 8c 24 00 01 00 00 	lea    0x100(%esp),%ecx
  111482:	89 0c 24             	mov    %ecx,(%esp)
  111485:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp)
  11148c:	00 
  11148d:	c7 44 24 08 9a 00 00 	movl   $0x9a,0x8(%esp)
  111494:	00 
  111495:	c7 44 24 0c c7 00 00 	movl   $0xc7,0xc(%esp)
  11149c:	00 
  11149d:	e8 8e 07 00 00       	call   111c30 <lv_color_make>
  1114a2:	83 ec 04             	sub    $0x4,%esp
  1114a5:	8b 8c 24 00 01 00 00 	mov    0x100(%esp),%ecx
  1114ac:	89 0d 94 52 13 00    	mov    %ecx,0x135294
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
  1114b2:	8d 8c 24 f8 00 00 00 	lea    0xf8(%esp),%ecx
  1114b9:	89 0c 24             	mov    %ecx,(%esp)
  1114bc:	c7 44 24 04 2b 00 00 	movl   $0x2b,0x4(%esp)
  1114c3:	00 
  1114c4:	c7 44 24 08 59 00 00 	movl   $0x59,0x8(%esp)
  1114cb:	00 
  1114cc:	c7 44 24 0c 8b 00 00 	movl   $0x8b,0xc(%esp)
  1114d3:	00 
  1114d4:	e8 57 07 00 00       	call   111c30 <lv_color_make>
  1114d9:	83 ec 04             	sub    $0x4,%esp
  1114dc:	8b 8c 24 f8 00 00 00 	mov    0xf8(%esp),%ecx
  1114e3:	89 0d 98 52 13 00    	mov    %ecx,0x135298
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
  1114e9:	8d 8c 24 f0 00 00 00 	lea    0xf0(%esp),%ecx
  1114f0:	89 0c 24             	mov    %ecx,(%esp)
  1114f3:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  1114fa:	00 
  1114fb:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
  111502:	00 
  111503:	c7 44 24 0c 42 00 00 	movl   $0x42,0xc(%esp)
  11150a:	00 
  11150b:	e8 20 07 00 00       	call   111c30 <lv_color_make>
  111510:	83 ec 04             	sub    $0x4,%esp
  111513:	8b 8c 24 f0 00 00 00 	mov    0xf0(%esp),%ecx
  11151a:	89 0d a0 52 13 00    	mov    %ecx,0x1352a0

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
  111520:	8d 0d e0 52 13 00    	lea    0x1352e0,%ecx
  111526:	89 0c 24             	mov    %ecx,(%esp)
  111529:	8d 0d a0 51 13 00    	lea    0x1351a0,%ecx
  11152f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  111533:	e8 28 07 00 00       	call   111c60 <lv_style_copy>
    lv_style_transp.glass             = 1;
  111538:	a0 e0 52 13 00       	mov    0x1352e0,%al
  11153d:	24 fe                	and    $0xfe,%al
  11153f:	0c 01                	or     $0x1,%al
  111541:	a2 e0 52 13 00       	mov    %al,0x1352e0
    lv_style_transp.body.border.width = 0;
  111546:	66 c7 05 f4 52 13 00 	movw   $0x0,0x1352f4
  11154d:	00 00 
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
  11154f:	c6 05 ee 52 13 00 00 	movb   $0x0,0x1352ee

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
  111556:	8d 0d 30 53 13 00    	lea    0x135330,%ecx
  11155c:	89 0c 24             	mov    %ecx,(%esp)
  11155f:	8d 0d e0 52 13 00    	lea    0x1352e0,%ecx
  111565:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  111569:	e8 f2 06 00 00       	call   111c60 <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
  11156e:	66 c7 05 54 53 13 00 	movw   $0x0,0x135354
  111575:	00 00 
    lv_style_transp_fit.body.padding.right  = 0;
  111577:	66 c7 05 56 53 13 00 	movw   $0x0,0x135356
  11157e:	00 00 
    lv_style_transp_fit.body.padding.top    = 0;
  111580:	66 c7 05 50 53 13 00 	movw   $0x0,0x135350
  111587:	00 00 
    lv_style_transp_fit.body.padding.bottom = 0;
  111589:	66 c7 05 52 53 13 00 	movw   $0x0,0x135352
  111590:	00 00 

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
  111592:	8d 0d 80 53 13 00    	lea    0x135380,%ecx
  111598:	89 0c 24             	mov    %ecx,(%esp)
  11159b:	8d 0d 30 53 13 00    	lea    0x135330,%ecx
  1115a1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1115a5:	e8 b6 06 00 00       	call   111c60 <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
  1115aa:	66 c7 05 a8 53 13 00 	movw   $0x0,0x1353a8
  1115b1:	00 00 

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
  1115b3:	8d 0d d0 53 13 00    	lea    0x1353d0,%ecx
  1115b9:	89 0c 24             	mov    %ecx,(%esp)
  1115bc:	8d 0d a0 51 13 00    	lea    0x1351a0,%ecx
  1115c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1115c6:	e8 95 06 00 00       	call   111c60 <lv_style_copy>
    lv_style_btn_rel.body.main_color     = lv_color_make(0x76, 0xa2, 0xd0);
  1115cb:	8d 8c 24 e8 00 00 00 	lea    0xe8(%esp),%ecx
  1115d2:	89 0c 24             	mov    %ecx,(%esp)
  1115d5:	c7 44 24 04 76 00 00 	movl   $0x76,0x4(%esp)
  1115dc:	00 
  1115dd:	c7 44 24 08 a2 00 00 	movl   $0xa2,0x8(%esp)
  1115e4:	00 
  1115e5:	c7 44 24 0c d0 00 00 	movl   $0xd0,0xc(%esp)
  1115ec:	00 
  1115ed:	e8 3e 06 00 00       	call   111c30 <lv_color_make>
  1115f2:	83 ec 04             	sub    $0x4,%esp
  1115f5:	8b 8c 24 e8 00 00 00 	mov    0xe8(%esp),%ecx
  1115fc:	89 0d d4 53 13 00    	mov    %ecx,0x1353d4
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
  111602:	8d 8c 24 e0 00 00 00 	lea    0xe0(%esp),%ecx
  111609:	89 0c 24             	mov    %ecx,(%esp)
  11160c:	c7 44 24 04 19 00 00 	movl   $0x19,0x4(%esp)
  111613:	00 
  111614:	c7 44 24 08 3a 00 00 	movl   $0x3a,0x8(%esp)
  11161b:	00 
  11161c:	c7 44 24 0c 5d 00 00 	movl   $0x5d,0xc(%esp)
  111623:	00 
  111624:	e8 07 06 00 00       	call   111c30 <lv_color_make>
  111629:	83 ec 04             	sub    $0x4,%esp
  11162c:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
  111633:	89 0d d8 53 13 00    	mov    %ecx,0x1353d8
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
  111639:	66 c7 05 dc 53 13 00 	movw   $0x6,0x1353dc
  111640:	06 00 
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
  111642:	66 c7 05 f4 53 13 00 	movw   $0x19,0x1353f4
  111649:	19 00 
    lv_style_btn_rel.body.padding.right  = LV_DPI / 4;
  11164b:	66 c7 05 f6 53 13 00 	movw   $0x19,0x1353f6
  111652:	19 00 
    lv_style_btn_rel.body.padding.top    = LV_DPI / 6;
  111654:	66 c7 05 f0 53 13 00 	movw   $0x10,0x1353f0
  11165b:	10 00 
    lv_style_btn_rel.body.padding.bottom = LV_DPI / 6;
  11165d:	66 c7 05 f2 53 13 00 	movw   $0x10,0x1353f2
  111664:	10 00 
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
  111666:	66 c7 05 f8 53 13 00 	movw   $0xa,0x1353f8
  11166d:	0a 00 
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
  11166f:	8d 8c 24 d8 00 00 00 	lea    0xd8(%esp),%ecx
  111676:	89 0c 24             	mov    %ecx,(%esp)
  111679:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  111680:	00 
  111681:	c7 44 24 08 19 00 00 	movl   $0x19,0x8(%esp)
  111688:	00 
  111689:	c7 44 24 0c 28 00 00 	movl   $0x28,0xc(%esp)
  111690:	00 
  111691:	e8 9a 05 00 00       	call   111c30 <lv_color_make>
  111696:	83 ec 04             	sub    $0x4,%esp
  111699:	8b 8c 24 d8 00 00 00 	mov    0xd8(%esp),%ecx
  1116a0:	89 0d e0 53 13 00    	mov    %ecx,0x1353e0
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
  1116a6:	66 c7 05 e4 53 13 00 	movw   $0x2,0x1353e4
  1116ad:	02 00 
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
  1116af:	c6 05 e7 53 13 00 b2 	movb   $0xb2,0x1353e7
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
  1116b6:	c6 84 24 d0 00 00 00 	movb   $0x80,0xd0(%esp)
  1116bd:	80 
  1116be:	c6 84 24 d1 00 00 00 	movb   $0x80,0xd1(%esp)
  1116c5:	80 
  1116c6:	c6 84 24 d2 00 00 00 	movb   $0x80,0xd2(%esp)
  1116cd:	80 
  1116ce:	c6 84 24 d3 00 00 00 	movb   $0xff,0xd3(%esp)
  1116d5:	ff 
  1116d6:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
  1116dd:	89 0d e8 53 13 00    	mov    %ecx,0x1353e8
    lv_style_btn_rel.body.shadow.width   = 0;
  1116e3:	66 c7 05 ec 53 13 00 	movw   $0x0,0x1353ec
  1116ea:	00 00 
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
  1116ec:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  1116f3:	89 0c 24             	mov    %ecx,(%esp)
  1116f6:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  1116fd:	00 
  1116fe:	c7 44 24 08 ff 00 00 	movl   $0xff,0x8(%esp)
  111705:	00 
  111706:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  11170d:	00 
  11170e:	e8 1d 05 00 00       	call   111c30 <lv_color_make>
  111713:	83 ec 04             	sub    $0x4,%esp
  111716:	8b 8c 24 c8 00 00 00 	mov    0xc8(%esp),%ecx
  11171d:	89 0d fc 53 13 00    	mov    %ecx,0x1353fc
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
  111723:	8d 8c 24 c0 00 00 00 	lea    0xc0(%esp),%ecx
  11172a:	89 0c 24             	mov    %ecx,(%esp)
  11172d:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  111734:	00 
  111735:	c7 44 24 08 ff 00 00 	movl   $0xff,0x8(%esp)
  11173c:	00 
  11173d:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  111744:	00 
  111745:	e8 e6 04 00 00       	call   111c30 <lv_color_make>
  11174a:	83 ec 04             	sub    $0x4,%esp
  11174d:	8b 8c 24 c0 00 00 00 	mov    0xc0(%esp),%ecx
  111754:	89 0d 10 54 13 00    	mov    %ecx,0x135410

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
  11175a:	8d 0d 20 54 13 00    	lea    0x135420,%ecx
  111760:	89 0c 24             	mov    %ecx,(%esp)
  111763:	8d 0d d0 53 13 00    	lea    0x1353d0,%ecx
  111769:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11176d:	e8 ee 04 00 00       	call   111c60 <lv_style_copy>
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
  111772:	8d 8c 24 b8 00 00 00 	lea    0xb8(%esp),%ecx
  111779:	89 0c 24             	mov    %ecx,(%esp)
  11177c:	c7 44 24 04 33 00 00 	movl   $0x33,0x4(%esp)
  111783:	00 
  111784:	c7 44 24 08 62 00 00 	movl   $0x62,0x8(%esp)
  11178b:	00 
  11178c:	c7 44 24 0c 94 00 00 	movl   $0x94,0xc(%esp)
  111793:	00 
  111794:	e8 97 04 00 00       	call   111c30 <lv_color_make>
  111799:	83 ec 04             	sub    $0x4,%esp
  11179c:	8b 8c 24 b8 00 00 00 	mov    0xb8(%esp),%ecx
  1117a3:	89 0d 24 54 13 00    	mov    %ecx,0x135424
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
  1117a9:	8d 8c 24 b0 00 00 00 	lea    0xb0(%esp),%ecx
  1117b0:	89 0c 24             	mov    %ecx,(%esp)
  1117b3:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  1117ba:	00 
  1117bb:	c7 44 24 08 26 00 00 	movl   $0x26,0x8(%esp)
  1117c2:	00 
  1117c3:	c7 44 24 0c 3c 00 00 	movl   $0x3c,0xc(%esp)
  1117ca:	00 
  1117cb:	e8 60 04 00 00       	call   111c30 <lv_color_make>
  1117d0:	83 ec 04             	sub    $0x4,%esp
  1117d3:	8b 8c 24 b0 00 00 00 	mov    0xb0(%esp),%ecx
  1117da:	89 0d 28 54 13 00    	mov    %ecx,0x135428
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
  1117e0:	8d 8c 24 a8 00 00 00 	lea    0xa8(%esp),%ecx
  1117e7:	89 0c 24             	mov    %ecx,(%esp)
  1117ea:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  1117f1:	00 
  1117f2:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  1117f9:	00 
  1117fa:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  111801:	00 
  111802:	e8 29 04 00 00       	call   111c30 <lv_color_make>
  111807:	83 ec 04             	sub    $0x4,%esp
  11180a:	8b 8c 24 a8 00 00 00 	mov    0xa8(%esp),%ecx
  111811:	89 0d 4c 54 13 00    	mov    %ecx,0x13544c
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
  111817:	8d 8c 24 a0 00 00 00 	lea    0xa0(%esp),%ecx
  11181e:	89 0c 24             	mov    %ecx,(%esp)
  111821:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  111828:	00 
  111829:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  111830:	00 
  111831:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  111838:	00 
  111839:	e8 f2 03 00 00       	call   111c30 <lv_color_make>
  11183e:	83 ec 04             	sub    $0x4,%esp
  111841:	8b 8c 24 a0 00 00 00 	mov    0xa0(%esp),%ecx
  111848:	89 0d 60 54 13 00    	mov    %ecx,0x135460
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
  11184e:	8d 8c 24 98 00 00 00 	lea    0x98(%esp),%ecx
  111855:	89 0c 24             	mov    %ecx,(%esp)
  111858:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  11185f:	00 
  111860:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  111867:	00 
  111868:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  11186f:	00 
  111870:	e8 bb 03 00 00       	call   111c30 <lv_color_make>
  111875:	83 ec 04             	sub    $0x4,%esp
  111878:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
  11187f:	89 0d 68 54 13 00    	mov    %ecx,0x135468

    /*Button toggle released style*/
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
  111885:	8d 0d 70 54 13 00    	lea    0x135470,%ecx
  11188b:	89 0c 24             	mov    %ecx,(%esp)
  11188e:	8d 0d d0 53 13 00    	lea    0x1353d0,%ecx
  111894:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  111898:	e8 c3 03 00 00       	call   111c60 <lv_style_copy>
    lv_style_btn_tgl_rel.body.main_color   = lv_color_make(0x0a, 0x11, 0x22);
  11189d:	8d 8c 24 90 00 00 00 	lea    0x90(%esp),%ecx
  1118a4:	89 0c 24             	mov    %ecx,(%esp)
  1118a7:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1118ae:	00 
  1118af:	c7 44 24 08 11 00 00 	movl   $0x11,0x8(%esp)
  1118b6:	00 
  1118b7:	c7 44 24 0c 22 00 00 	movl   $0x22,0xc(%esp)
  1118be:	00 
  1118bf:	e8 6c 03 00 00       	call   111c30 <lv_color_make>
  1118c4:	83 ec 04             	sub    $0x4,%esp
  1118c7:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
  1118ce:	89 0d 74 54 13 00    	mov    %ecx,0x135474
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
  1118d4:	8d 8c 24 88 00 00 00 	lea    0x88(%esp),%ecx
  1118db:	89 0c 24             	mov    %ecx,(%esp)
  1118de:	c7 44 24 04 37 00 00 	movl   $0x37,0x4(%esp)
  1118e5:	00 
  1118e6:	c7 44 24 08 62 00 00 	movl   $0x62,0x8(%esp)
  1118ed:	00 
  1118ee:	c7 44 24 0c 90 00 00 	movl   $0x90,0xc(%esp)
  1118f5:	00 
  1118f6:	e8 35 03 00 00       	call   111c30 <lv_color_make>
  1118fb:	83 ec 04             	sub    $0x4,%esp
  1118fe:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
  111905:	89 0d 78 54 13 00    	mov    %ecx,0x135478
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
  11190b:	8d 8c 24 80 00 00 00 	lea    0x80(%esp),%ecx
  111912:	89 0c 24             	mov    %ecx,(%esp)
  111915:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  11191c:	00 
  11191d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  111924:	00 
  111925:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  11192c:	00 
  11192d:	e8 fe 02 00 00       	call   111c30 <lv_color_make>
  111932:	83 ec 04             	sub    $0x4,%esp
  111935:	8b 8c 24 80 00 00 00 	mov    0x80(%esp),%ecx
  11193c:	89 0d 80 54 13 00    	mov    %ecx,0x135480
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
  111942:	8d 4c 24 78          	lea    0x78(%esp),%ecx
  111946:	89 0c 24             	mov    %ecx,(%esp)
  111949:	c7 44 24 04 c8 00 00 	movl   $0xc8,0x4(%esp)
  111950:	00 
  111951:	c7 44 24 08 dd 00 00 	movl   $0xdd,0x8(%esp)
  111958:	00 
  111959:	c7 44 24 0c f4 00 00 	movl   $0xf4,0xc(%esp)
  111960:	00 
  111961:	e8 ca 02 00 00       	call   111c30 <lv_color_make>
  111966:	83 ec 04             	sub    $0x4,%esp
  111969:	8b 4c 24 78          	mov    0x78(%esp),%ecx
  11196d:	89 0d 9c 54 13 00    	mov    %ecx,0x13549c
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
  111973:	8d 4c 24 70          	lea    0x70(%esp),%ecx
  111977:	89 0c 24             	mov    %ecx,(%esp)
  11197a:	c7 44 24 04 c8 00 00 	movl   $0xc8,0x4(%esp)
  111981:	00 
  111982:	c7 44 24 08 dd 00 00 	movl   $0xdd,0x8(%esp)
  111989:	00 
  11198a:	c7 44 24 0c f4 00 00 	movl   $0xf4,0xc(%esp)
  111991:	00 
  111992:	e8 99 02 00 00       	call   111c30 <lv_color_make>
  111997:	83 ec 04             	sub    $0x4,%esp
  11199a:	8b 4c 24 70          	mov    0x70(%esp),%ecx
  11199e:	89 0d b0 54 13 00    	mov    %ecx,0x1354b0
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
  1119a4:	8d 4c 24 68          	lea    0x68(%esp),%ecx
  1119a8:	89 0c 24             	mov    %ecx,(%esp)
  1119ab:	c7 44 24 04 c8 00 00 	movl   $0xc8,0x4(%esp)
  1119b2:	00 
  1119b3:	c7 44 24 08 dd 00 00 	movl   $0xdd,0x8(%esp)
  1119ba:	00 
  1119bb:	c7 44 24 0c f4 00 00 	movl   $0xf4,0xc(%esp)
  1119c2:	00 
  1119c3:	e8 68 02 00 00       	call   111c30 <lv_color_make>
  1119c8:	83 ec 04             	sub    $0x4,%esp
  1119cb:	8b 4c 24 68          	mov    0x68(%esp),%ecx
  1119cf:	89 0d b8 54 13 00    	mov    %ecx,0x1354b8

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
  1119d5:	8d 0d c0 54 13 00    	lea    0x1354c0,%ecx
  1119db:	89 0c 24             	mov    %ecx,(%esp)
  1119de:	8d 0d 70 54 13 00    	lea    0x135470,%ecx
  1119e4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1119e8:	e8 73 02 00 00       	call   111c60 <lv_style_copy>
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
  1119ed:	8d 4c 24 60          	lea    0x60(%esp),%ecx
  1119f1:	89 0c 24             	mov    %ecx,(%esp)
  1119f4:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1119fb:	00 
  1119fc:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  111a03:	00 
  111a04:	c7 44 24 0c 27 00 00 	movl   $0x27,0xc(%esp)
  111a0b:	00 
  111a0c:	e8 1f 02 00 00       	call   111c30 <lv_color_make>
  111a11:	83 ec 04             	sub    $0x4,%esp
  111a14:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  111a18:	89 0d c4 54 13 00    	mov    %ecx,0x1354c4
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
  111a1e:	8d 4c 24 58          	lea    0x58(%esp),%ecx
  111a22:	89 0c 24             	mov    %ecx,(%esp)
  111a25:	c7 44 24 04 2b 00 00 	movl   $0x2b,0x4(%esp)
  111a2c:	00 
  111a2d:	c7 44 24 08 4c 00 00 	movl   $0x4c,0x8(%esp)
  111a34:	00 
  111a35:	c7 44 24 0c 70 00 00 	movl   $0x70,0xc(%esp)
  111a3c:	00 
  111a3d:	e8 ee 01 00 00       	call   111c30 <lv_color_make>
  111a42:	83 ec 04             	sub    $0x4,%esp
  111a45:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  111a49:	89 0d c8 54 13 00    	mov    %ecx,0x1354c8
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
  111a4f:	8d 4c 24 50          	lea    0x50(%esp),%ecx
  111a53:	89 0c 24             	mov    %ecx,(%esp)
  111a56:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  111a5d:	00 
  111a5e:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  111a65:	00 
  111a66:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  111a6d:	00 
  111a6e:	e8 bd 01 00 00       	call   111c30 <lv_color_make>
  111a73:	83 ec 04             	sub    $0x4,%esp
  111a76:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  111a7a:	89 0d ec 54 13 00    	mov    %ecx,0x1354ec
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
  111a80:	8d 4c 24 48          	lea    0x48(%esp),%ecx
  111a84:	89 0c 24             	mov    %ecx,(%esp)
  111a87:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  111a8e:	00 
  111a8f:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  111a96:	00 
  111a97:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  111a9e:	00 
  111a9f:	e8 8c 01 00 00       	call   111c30 <lv_color_make>
  111aa4:	83 ec 04             	sub    $0x4,%esp
  111aa7:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  111aab:	89 0d 00 55 13 00    	mov    %ecx,0x135500
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
  111ab1:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  111ab5:	89 0c 24             	mov    %ecx,(%esp)
  111ab8:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  111abf:	00 
  111ac0:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
  111ac7:	00 
  111ac8:	c7 44 24 0c c6 00 00 	movl   $0xc6,0xc(%esp)
  111acf:	00 
  111ad0:	e8 5b 01 00 00       	call   111c30 <lv_color_make>
  111ad5:	83 ec 04             	sub    $0x4,%esp
  111ad8:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  111adc:	89 0d 08 55 13 00    	mov    %ecx,0x135508

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
  111ae2:	8d 0d 10 55 13 00    	lea    0x135510,%ecx
  111ae8:	89 0c 24             	mov    %ecx,(%esp)
  111aeb:	8d 0d d0 53 13 00    	lea    0x1353d0,%ecx
  111af1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  111af5:	e8 66 01 00 00       	call   111c60 <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
  111afa:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  111afe:	89 0c 24             	mov    %ecx,(%esp)
  111b01:	c7 44 24 04 d8 00 00 	movl   $0xd8,0x4(%esp)
  111b08:	00 
  111b09:	c7 44 24 08 d8 00 00 	movl   $0xd8,0x8(%esp)
  111b10:	00 
  111b11:	c7 44 24 0c d8 00 00 	movl   $0xd8,0xc(%esp)
  111b18:	00 
  111b19:	e8 12 01 00 00       	call   111c30 <lv_color_make>
  111b1e:	83 ec 04             	sub    $0x4,%esp
  111b21:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  111b25:	89 0d 14 55 13 00    	mov    %ecx,0x135514
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
  111b2b:	8d 4c 24 30          	lea    0x30(%esp),%ecx
  111b2f:	89 0c 24             	mov    %ecx,(%esp)
  111b32:	c7 44 24 04 d8 00 00 	movl   $0xd8,0x4(%esp)
  111b39:	00 
  111b3a:	c7 44 24 08 d8 00 00 	movl   $0xd8,0x8(%esp)
  111b41:	00 
  111b42:	c7 44 24 0c d8 00 00 	movl   $0xd8,0xc(%esp)
  111b49:	00 
  111b4a:	e8 e1 00 00 00       	call   111c30 <lv_color_make>
  111b4f:	83 ec 04             	sub    $0x4,%esp
  111b52:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  111b56:	89 0d 18 55 13 00    	mov    %ecx,0x135518
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
  111b5c:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  111b60:	89 0c 24             	mov    %ecx,(%esp)
  111b63:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  111b6a:	00 
  111b6b:	c7 44 24 08 90 00 00 	movl   $0x90,0x8(%esp)
  111b72:	00 
  111b73:	c7 44 24 0c 90 00 00 	movl   $0x90,0xc(%esp)
  111b7a:	00 
  111b7b:	e8 b0 00 00 00       	call   111c30 <lv_color_make>
  111b80:	83 ec 04             	sub    $0x4,%esp
  111b83:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  111b87:	89 0d 20 55 13 00    	mov    %ecx,0x135520
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
  111b8d:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  111b91:	89 0c 24             	mov    %ecx,(%esp)
  111b94:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
  111b9b:	00 
  111b9c:	c7 44 24 08 70 00 00 	movl   $0x70,0x8(%esp)
  111ba3:	00 
  111ba4:	c7 44 24 0c 70 00 00 	movl   $0x70,0xc(%esp)
  111bab:	00 
  111bac:	e8 7f 00 00 00       	call   111c30 <lv_color_make>
  111bb1:	83 ec 04             	sub    $0x4,%esp
  111bb4:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  111bb8:	89 0d 3c 55 13 00    	mov    %ecx,0x13553c
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
  111bbe:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  111bc2:	89 0c 24             	mov    %ecx,(%esp)
  111bc5:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
  111bcc:	00 
  111bcd:	c7 44 24 08 70 00 00 	movl   $0x70,0x8(%esp)
  111bd4:	00 
  111bd5:	c7 44 24 0c 70 00 00 	movl   $0x70,0xc(%esp)
  111bdc:	00 
  111bdd:	e8 4e 00 00 00       	call   111c30 <lv_color_make>
  111be2:	83 ec 04             	sub    $0x4,%esp
  111be5:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  111be9:	89 0d 50 55 13 00    	mov    %ecx,0x135550
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
  111bef:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  111bf3:	89 0c 24             	mov    %ecx,(%esp)
  111bf6:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
  111bfd:	00 
  111bfe:	c7 44 24 08 70 00 00 	movl   $0x70,0x8(%esp)
  111c05:	00 
  111c06:	c7 44 24 0c 70 00 00 	movl   $0x70,0xc(%esp)
  111c0d:	00 
  111c0e:	e8 1d 00 00 00       	call   111c30 <lv_color_make>
  111c13:	83 ec 04             	sub    $0x4,%esp
  111c16:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  111c1a:	89 0d 58 55 13 00    	mov    %ecx,0x135558
}
  111c20:	89 ec                	mov    %ebp,%esp
  111c22:	5d                   	pop    %ebp
  111c23:	c3                   	ret    
  111c24:	66 90                	xchg   %ax,%ax
  111c26:	66 90                	xchg   %ax,%ax
  111c28:	66 90                	xchg   %ax,%ax
  111c2a:	66 90                	xchg   %ax,%ax
  111c2c:	66 90                	xchg   %ax,%ax
  111c2e:	66 90                	xchg   %ax,%ax

00111c30 <lv_color_make>:
}
#endif
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
  111c30:	55                   	push   %ebp
  111c31:	89 e5                	mov    %esp,%ebp
  111c33:	53                   	push   %ebx
  111c34:	8b 45 08             	mov    0x8(%ebp),%eax
  111c37:	89 c1                	mov    %eax,%ecx
  111c39:	8a 55 14             	mov    0x14(%ebp),%dl
  111c3c:	8a 75 10             	mov    0x10(%ebp),%dh
  111c3f:	8a 5d 0c             	mov    0xc(%ebp),%bl
    lv_color_t color;
    color.ch.blue  = b8;
  111c42:	8a 7d 14             	mov    0x14(%ebp),%bh
  111c45:	88 38                	mov    %bh,(%eax)
    color.ch.green = g8;
  111c47:	8a 7d 10             	mov    0x10(%ebp),%bh
  111c4a:	88 78 01             	mov    %bh,0x1(%eax)
    color.ch.red   = r8;
  111c4d:	8a 7d 0c             	mov    0xc(%ebp),%bh
  111c50:	88 78 02             	mov    %bh,0x2(%eax)
    color.ch.alpha = 0xff;
  111c53:	c6 40 03 ff          	movb   $0xff,0x3(%eax)
    return color;
  111c57:	89 c8                	mov    %ecx,%eax
  111c59:	5b                   	pop    %ebx
  111c5a:	5d                   	pop    %ebp
  111c5b:	c2 04 00             	ret    $0x4
  111c5e:	66 90                	xchg   %ax,%ax

00111c60 <lv_style_copy>:
 * Copy a style to an other
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
  111c60:	55                   	push   %ebp
  111c61:	89 e5                	mov    %esp,%ebp
  111c63:	56                   	push   %esi
  111c64:	83 ec 14             	sub    $0x14,%esp
  111c67:	8b 45 0c             	mov    0xc(%ebp),%eax
  111c6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    memcpy(dest, src, sizeof(lv_style_t));
  111c6d:	8b 55 08             	mov    0x8(%ebp),%edx
  111c70:	8b 75 0c             	mov    0xc(%ebp),%esi
  111c73:	89 14 24             	mov    %edx,(%esp)
  111c76:	89 74 24 04          	mov    %esi,0x4(%esp)
  111c7a:	c7 44 24 08 50 00 00 	movl   $0x50,0x8(%esp)
  111c81:	00 
  111c82:	89 45 f8             	mov    %eax,-0x8(%ebp)
  111c85:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  111c88:	e8 c3 86 ff ff       	call   10a350 <memcpy>
}
  111c8d:	83 c4 14             	add    $0x14,%esp
  111c90:	5e                   	pop    %esi
  111c91:	5d                   	pop    %ebp
  111c92:	c3                   	ret    
  111c93:	66 90                	xchg   %ax,%ax
  111c95:	66 90                	xchg   %ax,%ax
  111c97:	66 90                	xchg   %ax,%ax
  111c99:	66 90                	xchg   %ax,%ax
  111c9b:	66 90                	xchg   %ax,%ax
  111c9d:	66 90                	xchg   %ax,%ax
  111c9f:	90                   	nop

00111ca0 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
  111ca0:	55                   	push   %ebp
  111ca1:	89 e5                	mov    %esp,%ebp
  111ca3:	50                   	push   %eax
  111ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  111ca7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  111caa:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  111cae:	8b 55 08             	mov    0x8(%ebp),%edx
  111cb1:	0f bf 12             	movswl (%edx),%edx
  111cb4:	29 d1                	sub    %edx,%ecx
  111cb6:	83 c1 01             	add    $0x1,%ecx
  111cb9:	0f bf d1             	movswl %cx,%edx
  111cbc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  111cbf:	89 d0                	mov    %edx,%eax
  111cc1:	83 c4 04             	add    $0x4,%esp
  111cc4:	5d                   	pop    %ebp
  111cc5:	c3                   	ret    
  111cc6:	66 90                	xchg   %ax,%ax
  111cc8:	66 90                	xchg   %ax,%ax
  111cca:	66 90                	xchg   %ax,%ax
  111ccc:	66 90                	xchg   %ax,%ax
  111cce:	66 90                	xchg   %ax,%ax

00111cd0 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
  111cd0:	55                   	push   %ebp
  111cd1:	89 e5                	mov    %esp,%ebp
  111cd3:	53                   	push   %ebx
  111cd4:	57                   	push   %edi
  111cd5:	56                   	push   %esi
  111cd6:	83 ec 18             	sub    $0x18,%esp
  111cd9:	8b 45 08             	mov    0x8(%ebp),%eax
  111cdc:	89 c1                	mov    %eax,%ecx
  111cde:	8a 55 14             	mov    0x14(%ebp),%dl
  111ce1:	8d 75 10             	lea    0x10(%ebp),%esi
  111ce4:	8d 7d 0c             	lea    0xc(%ebp),%edi
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
  111ce7:	0f b6 5f 02          	movzbl 0x2(%edi),%ebx
  111ceb:	0f b7 db             	movzwl %bx,%ebx
  111cee:	89 45 f0             	mov    %eax,-0x10(%ebp)
  111cf1:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  111cf5:	0f af d8             	imul   %eax,%ebx
  111cf8:	0f b6 46 02          	movzbl 0x2(%esi),%eax
  111cfc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  111cff:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  111d03:	89 45 e8             	mov    %eax,-0x18(%ebp)
  111d06:	b8 ff 00 00 00       	mov    $0xff,%eax
  111d0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  111d0e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  111d11:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  111d14:	29 c8                	sub    %ecx,%eax
  111d16:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  111d19:	0f af c8             	imul   %eax,%ecx
  111d1c:	01 cb                	add    %ecx,%ebx
  111d1e:	0f b7 c3             	movzwl %bx,%eax
  111d21:	c1 f8 08             	sar    $0x8,%eax
  111d24:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  111d27:	88 41 02             	mov    %al,0x2(%ecx)
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
  111d2a:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  111d2e:	0f b7 c0             	movzwl %ax,%eax
  111d31:	0f b6 5d 14          	movzbl 0x14(%ebp),%ebx
  111d35:	0f af c3             	imul   %ebx,%eax
  111d38:	0f b6 5e 01          	movzbl 0x1(%esi),%ebx
  111d3c:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  111d40:	89 45 dc             	mov    %eax,-0x24(%ebp)
  111d43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  111d46:	29 c8                	sub    %ecx,%eax
  111d48:	0f af d8             	imul   %eax,%ebx
  111d4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  111d4e:	01 d8                	add    %ebx,%eax
  111d50:	0f b7 c8             	movzwl %ax,%ecx
  111d53:	c1 f9 08             	sar    $0x8,%ecx
  111d56:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  111d59:	88 4b 01             	mov    %cl,0x1(%ebx)
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
  111d5c:	0f b6 3f             	movzbl (%edi),%edi
  111d5f:	0f b7 cf             	movzwl %di,%ecx
  111d62:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  111d66:	0f af c8             	imul   %eax,%ecx
  111d69:	0f b6 06             	movzbl (%esi),%eax
  111d6c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  111d70:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  111d73:	29 f7                	sub    %esi,%edi
  111d75:	0f af c7             	imul   %edi,%eax
  111d78:	01 c1                	add    %eax,%ecx
  111d7a:	0f b7 c1             	movzwl %cx,%eax
  111d7d:	c1 f8 08             	sar    $0x8,%eax
  111d80:	88 03                	mov    %al,(%ebx)
#if LV_COLOR_DEPTH == 32
    ret.ch.alpha = 0xFF;
  111d82:	c6 43 03 ff          	movb   $0xff,0x3(%ebx)
  111d86:	8b 45 e0             	mov    -0x20(%ebp),%eax
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
  111d89:	83 c4 18             	add    $0x18,%esp
  111d8c:	5e                   	pop    %esi
  111d8d:	5f                   	pop    %edi
  111d8e:	5b                   	pop    %ebx
  111d8f:	5d                   	pop    %ebp
  111d90:	c2 04 00             	ret    $0x4
  111d93:	66 90                	xchg   %ax,%ax
  111d95:	66 90                	xchg   %ax,%ax
  111d97:	66 90                	xchg   %ax,%ax
  111d99:	66 90                	xchg   %ax,%ax
  111d9b:	66 90                	xchg   %ax,%ax
  111d9d:	66 90                	xchg   %ax,%ax
  111d9f:	90                   	nop

00111da0 <lv_draw_fill>:
 * @param mask_p fill only o this mask  (truncated to VDB area)
 * @param color fill color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_fill(const lv_area_t * cords_p, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
  111da0:	55                   	push   %ebp
  111da1:	89 e5                	mov    %esp,%ebp
  111da3:	53                   	push   %ebx
  111da4:	57                   	push   %edi
  111da5:	56                   	push   %esi
  111da6:	83 e4 f8             	and    $0xfffffff8,%esp
  111da9:	83 ec 48             	sub    $0x48,%esp
  111dac:	8a 45 14             	mov    0x14(%ebp),%al
  111daf:	8d 4d 10             	lea    0x10(%ebp),%ecx
  111db2:	8b 55 0c             	mov    0xc(%ebp),%edx
  111db5:	8b 75 08             	mov    0x8(%ebp),%esi
    if(opa < LV_OPA_MIN) return;
  111db8:	0f b6 7d 14          	movzbl 0x14(%ebp),%edi
  111dbc:	83 ff 10             	cmp    $0x10,%edi
  111dbf:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  111dc3:	0f 8d 05 00 00 00    	jge    111dce <lv_draw_fill+0x2e>
  111dc9:	e9 1f 01 00 00       	jmp    111eed <lv_draw_fill+0x14d>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
  111dce:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  111dd2:	3d fb 00 00 00       	cmp    $0xfb,%eax
  111dd7:	0f 8e 04 00 00 00    	jle    111de1 <lv_draw_fill+0x41>
  111ddd:	c6 45 14 ff          	movb   $0xff,0x14(%ebp)
    bool union_ok;

    /*Get the union of cord and mask*/
    /* The mask is already truncated to the vdb size
     * in 'lv_refr_area_with_vdb' function */
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
  111de1:	8b 45 08             	mov    0x8(%ebp),%eax
  111de4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  111de7:	8d 54 24 38          	lea    0x38(%esp),%edx
  111deb:	89 14 24             	mov    %edx,(%esp)
  111dee:	89 44 24 04          	mov    %eax,0x4(%esp)
  111df2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  111df6:	e8 05 5e 00 00       	call   117c00 <lv_area_intersect>
  111dfb:	24 01                	and    $0x1,%al
  111dfd:	88 44 24 37          	mov    %al,0x37(%esp)

    /*If there are common part of the three area then draw to the vdb*/
    if(union_ok == false) {
  111e01:	8a 44 24 37          	mov    0x37(%esp),%al
  111e05:	24 01                	and    $0x1,%al
  111e07:	0f b6 c8             	movzbl %al,%ecx
  111e0a:	83 f9 00             	cmp    $0x0,%ecx
  111e0d:	0f 85 05 00 00 00    	jne    111e18 <lv_draw_fill+0x78>
        return;
  111e13:	e9 d5 00 00 00       	jmp    111eed <lv_draw_fill+0x14d>
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
  111e18:	e8 b3 e3 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  111e1d:	89 44 24 30          	mov    %eax,0x30(%esp)
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
  111e21:	8b 44 24 30          	mov    0x30(%esp),%eax
  111e25:	89 04 24             	mov    %eax,(%esp)
  111e28:	e8 83 5a 00 00       	call   1178b0 <lv_disp_get_buf>
  111e2d:	89 44 24 2c          	mov    %eax,0x2c(%esp)

    lv_area_t vdb_rel_a; /*Stores relative coordinates on vdb*/
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
  111e31:	0f bf 44 24 38       	movswl 0x38(%esp),%eax
  111e36:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  111e3a:	0f bf 49 10          	movswl 0x10(%ecx),%ecx
  111e3e:	29 c8                	sub    %ecx,%eax
  111e40:	66 89 44 24 20       	mov    %ax,0x20(%esp)
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
  111e45:	0f bf 4c 24 3a       	movswl 0x3a(%esp),%ecx
  111e4a:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  111e4e:	0f bf 52 12          	movswl 0x12(%edx),%edx
  111e52:	29 d1                	sub    %edx,%ecx
  111e54:	66 89 4c 24 22       	mov    %cx,0x22(%esp)
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
  111e59:	0f bf 54 24 3c       	movswl 0x3c(%esp),%edx
  111e5e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  111e62:	0f bf 76 10          	movswl 0x10(%esi),%esi
  111e66:	29 f2                	sub    %esi,%edx
  111e68:	66 89 54 24 24       	mov    %dx,0x24(%esp)
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
  111e6d:	0f bf 74 24 3e       	movswl 0x3e(%esp),%esi
  111e72:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  111e76:	0f bf 7f 12          	movswl 0x12(%edi),%edi
  111e7a:	29 fe                	sub    %edi,%esi
  111e7c:	66 89 74 24 26       	mov    %si,0x26(%esp)

    lv_color_t * vdb_buf_tmp = vdb->buf_act;
  111e81:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  111e85:	8b 7f 08             	mov    0x8(%edi),%edi
  111e88:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
    uint32_t vdb_width       = lv_area_get_width(&vdb->area);
  111e8c:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  111e90:	83 c7 10             	add    $0x10,%edi
  111e93:	89 3c 24             	mov    %edi,(%esp)
  111e96:	e8 05 fe ff ff       	call   111ca0 <lv_area_get_width>
  111e9b:	0f bf f8             	movswl %ax,%edi
  111e9e:	89 7c 24 18          	mov    %edi,0x18(%esp)
    /*Move the vdb_tmp to the first row*/
    vdb_buf_tmp += vdb_width * vdb_rel_a.y1;
  111ea2:	8b 7c 24 18          	mov    0x18(%esp),%edi
  111ea6:	0f bf 5c 24 22       	movswl 0x22(%esp),%ebx
  111eab:	0f af fb             	imul   %ebx,%edi
  111eae:	c1 e7 02             	shl    $0x2,%edi
  111eb1:	03 7c 24 1c          	add    0x1c(%esp),%edi
  111eb5:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
        }
    }
#else
    sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
  111eb9:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  111ebd:	8b 7f 08             	mov    0x8(%edi),%edi
  111ec0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  111ec4:	89 3c 24             	mov    %edi,(%esp)
  111ec7:	0f bf fb             	movswl %bx,%edi
  111eca:	89 7c 24 04          	mov    %edi,0x4(%esp)
  111ece:	8d 7c 24 20          	lea    0x20(%esp),%edi
  111ed2:	89 7c 24 08          	mov    %edi,0x8(%esp)
  111ed6:	8b 7c 24 14          	mov    0x14(%esp),%edi
  111eda:	8b 07                	mov    (%edi),%eax
  111edc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  111ee0:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  111ee4:	89 44 24 10          	mov    %eax,0x10(%esp)
  111ee8:	e8 13 00 00 00       	call   111f00 <sw_color_fill>
#endif
}
  111eed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111ef0:	5e                   	pop    %esi
  111ef1:	5f                   	pop    %edi
  111ef2:	5b                   	pop    %ebx
  111ef3:	5d                   	pop    %ebp
  111ef4:	c3                   	ret    
  111ef5:	66 90                	xchg   %ax,%ax
  111ef7:	66 90                	xchg   %ax,%ax
  111ef9:	66 90                	xchg   %ax,%ax
  111efb:	66 90                	xchg   %ax,%ax
  111efd:	66 90                	xchg   %ax,%ax
  111eff:	90                   	nop

00111f00 <sw_color_fill>:
 * @param color fill color
 * @param opa opacity (0, LV_OPA_TRANSP: transparent ... 255, LV_OPA_COVER, fully cover)
 */
static void sw_color_fill(lv_color_t * mem, lv_coord_t mem_width, const lv_area_t * fill_area, lv_color_t color,
                          lv_opa_t opa)
{
  111f00:	55                   	push   %ebp
  111f01:	89 e5                	mov    %esp,%ebp
  111f03:	53                   	push   %ebx
  111f04:	57                   	push   %edi
  111f05:	56                   	push   %esi
  111f06:	83 e4 f8             	and    $0xfffffff8,%esp
  111f09:	83 ec 58             	sub    $0x58,%esp
  111f0c:	8a 45 18             	mov    0x18(%ebp),%al
  111f0f:	8d 4d 14             	lea    0x14(%ebp),%ecx
  111f12:	8b 55 10             	mov    0x10(%ebp),%edx
  111f15:	66 8b 75 0c          	mov    0xc(%ebp),%si
  111f19:	8b 7d 08             	mov    0x8(%ebp),%edi
  111f1c:	88 44 24 2f          	mov    %al,0x2f(%esp)
  111f20:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  111f24:	89 54 24 24          	mov    %edx,0x24(%esp)
  111f28:	66 89 74 24 22       	mov    %si,0x22(%esp)
  111f2d:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
  111f31:	e8 9a e2 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  111f36:	89 44 24 4c          	mov    %eax,0x4c(%esp)
    if(disp->driver.set_px_cb) {
  111f3a:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  111f3e:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  111f42:	0f 84 bb 00 00 00    	je     112003 <sw_color_fill+0x103>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
  111f48:	8b 45 10             	mov    0x10(%ebp),%eax
  111f4b:	66 8b 08             	mov    (%eax),%cx
  111f4e:	66 89 4c 24 50       	mov    %cx,0x50(%esp)
  111f53:	0f bf 44 24 50       	movswl 0x50(%esp),%eax
  111f58:	8b 4d 10             	mov    0x10(%ebp),%ecx
  111f5b:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  111f5f:	39 c8                	cmp    %ecx,%eax
  111f61:	0f 8f 97 00 00 00    	jg     111ffe <sw_color_fill+0xfe>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
  111f67:	8b 45 10             	mov    0x10(%ebp),%eax
  111f6a:	66 8b 48 02          	mov    0x2(%eax),%cx
  111f6e:	66 89 4c 24 52       	mov    %cx,0x52(%esp)
  111f73:	0f bf 44 24 52       	movswl 0x52(%esp),%eax
  111f78:	8b 4d 10             	mov    0x10(%ebp),%ecx
  111f7b:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  111f7f:	39 c8                	cmp    %ecx,%eax
  111f81:	0f 8f 5f 00 00 00    	jg     111fe6 <sw_color_fill+0xe6>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
  111f87:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  111f8b:	8b 40 14             	mov    0x14(%eax),%eax
  111f8e:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  111f92:	8b 55 08             	mov    0x8(%ebp),%edx
  111f95:	66 8b 75 0c          	mov    0xc(%ebp),%si
  111f99:	66 8b 7c 24 50       	mov    0x50(%esp),%di
  111f9e:	66 8b 5c 24 52       	mov    0x52(%esp),%bx
  111fa3:	89 0c 24             	mov    %ecx,(%esp)
  111fa6:	89 54 24 04          	mov    %edx,0x4(%esp)
  111faa:	0f bf ce             	movswl %si,%ecx
  111fad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  111fb1:	0f bf cf             	movswl %di,%ecx
  111fb4:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  111fb8:	0f bf cb             	movswl %bx,%ecx
  111fbb:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  111fbf:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  111fc3:	8b 11                	mov    (%ecx),%edx
  111fc5:	89 54 24 14          	mov    %edx,0x14(%esp)
  111fc9:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  111fcd:	89 54 24 18          	mov    %edx,0x18(%esp)
  111fd1:	ff d0                	call   *%eax
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
  111fd3:	66 8b 44 24 52       	mov    0x52(%esp),%ax
  111fd8:	66 83 c0 01          	add    $0x1,%ax
  111fdc:	66 89 44 24 52       	mov    %ax,0x52(%esp)
  111fe1:	e9 8d ff ff ff       	jmp    111f73 <sw_color_fill+0x73>
            }
        }
  111fe6:	e9 00 00 00 00       	jmp    111feb <sw_color_fill+0xeb>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
  111feb:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  111ff0:	66 83 c0 01          	add    $0x1,%ax
  111ff4:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  111ff9:	e9 55 ff ff ff       	jmp    111f53 <sw_color_fill+0x53>
    } else {
  111ffe:	e9 4d 02 00 00       	jmp    112250 <sw_color_fill+0x350>
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
  112003:	8b 45 10             	mov    0x10(%ebp),%eax
  112006:	0f bf 40 02          	movswl 0x2(%eax),%eax
  11200a:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  11200e:	0f af c1             	imul   %ecx,%eax
  112011:	c1 e0 02             	shl    $0x2,%eax
  112014:	03 45 08             	add    0x8(%ebp),%eax
  112017:	89 45 08             	mov    %eax,0x8(%ebp)

        /*Run simpler function without opacity*/
        if(opa == LV_OPA_COVER) {
  11201a:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  11201e:	3d ff 00 00 00       	cmp    $0xff,%eax
  112023:	0f 85 eb 00 00 00    	jne    112114 <sw_color_fill+0x214>

            /*Fill the first row with 'color'*/
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
  112029:	8b 45 10             	mov    0x10(%ebp),%eax
  11202c:	66 8b 08             	mov    (%eax),%cx
  11202f:	66 89 4c 24 50       	mov    %cx,0x50(%esp)
  112034:	0f bf 44 24 50       	movswl 0x50(%esp),%eax
  112039:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11203c:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  112040:	39 c8                	cmp    %ecx,%eax
  112042:	0f 8f 24 00 00 00    	jg     11206c <sw_color_fill+0x16c>
                mem[col] = color;
  112048:	8b 45 08             	mov    0x8(%ebp),%eax
  11204b:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  112050:	8b 54 24 28          	mov    0x28(%esp),%edx
  112054:	8b 32                	mov    (%edx),%esi
  112056:	89 34 88             	mov    %esi,(%eax,%ecx,4)
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
  112059:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  11205e:	66 83 c0 01          	add    $0x1,%ax
  112062:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  112067:	e9 c8 ff ff ff       	jmp    112034 <sw_color_fill+0x134>
            }

            /*Copy the first row to all other rows*/
            lv_color_t * mem_first = &mem[fill_area->x1];
  11206c:	8b 45 08             	mov    0x8(%ebp),%eax
  11206f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112072:	0f bf 09             	movswl (%ecx),%ecx
  112075:	c1 e1 02             	shl    $0x2,%ecx
  112078:	01 c8                	add    %ecx,%eax
  11207a:	89 44 24 48          	mov    %eax,0x48(%esp)
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
  11207e:	8b 45 10             	mov    0x10(%ebp),%eax
  112081:	0f bf 40 04          	movswl 0x4(%eax),%eax
  112085:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112088:	0f bf 09             	movswl (%ecx),%ecx
  11208b:	29 c8                	sub    %ecx,%eax
  11208d:	83 c0 01             	add    $0x1,%eax
  112090:	c1 e0 02             	shl    $0x2,%eax
  112093:	66 89 44 24 46       	mov    %ax,0x46(%esp)
            mem += mem_width;
  112098:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  11209c:	c1 e1 02             	shl    $0x2,%ecx
  11209f:	03 4d 08             	add    0x8(%ebp),%ecx
  1120a2:	89 4d 08             	mov    %ecx,0x8(%ebp)

            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
  1120a5:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1120a8:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  1120ac:	83 c1 01             	add    $0x1,%ecx
  1120af:	66 89 4c 24 52       	mov    %cx,0x52(%esp)
  1120b4:	0f bf 44 24 52       	movswl 0x52(%esp),%eax
  1120b9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1120bc:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  1120c0:	39 c8                	cmp    %ecx,%eax
  1120c2:	0f 8f 47 00 00 00    	jg     11210f <sw_color_fill+0x20f>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
  1120c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1120cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1120ce:	0f bf 09             	movswl (%ecx),%ecx
  1120d1:	c1 e1 02             	shl    $0x2,%ecx
  1120d4:	01 c8                	add    %ecx,%eax
  1120d6:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  1120da:	0f bf 54 24 46       	movswl 0x46(%esp),%edx
  1120df:	89 04 24             	mov    %eax,(%esp)
  1120e2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1120e6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1120ea:	e8 61 82 ff ff       	call   10a350 <memcpy>
                mem += mem_width;
  1120ef:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  1120f3:	c1 e1 02             	shl    $0x2,%ecx
  1120f6:	03 4d 08             	add    0x8(%ebp),%ecx
  1120f9:	89 4d 08             	mov    %ecx,0x8(%ebp)
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
  1120fc:	66 8b 44 24 52       	mov    0x52(%esp),%ax
  112101:	66 83 c0 01          	add    $0x1,%ax
  112105:	66 89 44 24 52       	mov    %ax,0x52(%esp)
  11210a:	e9 a5 ff ff ff       	jmp    1120b4 <sw_color_fill+0x1b4>
            }
        }
  11210f:	e9 37 01 00 00       	jmp    11224b <sw_color_fill+0x34b>
        /*Calculate with alpha too*/
        else {
            bool scr_transp = false;
  112114:	c6 44 24 45 00       	movb   $0x0,0x45(%esp)
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            scr_transp = disp->driver.screen_transp;
#endif

            lv_color_t bg_tmp  = LV_COLOR_BLACK;
  112119:	a1 18 36 12 00       	mov    0x123618,%eax
  11211e:	89 44 24 40          	mov    %eax,0x40(%esp)
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
  112122:	8d 44 24 38          	lea    0x38(%esp),%eax
  112126:	89 04 24             	mov    %eax,(%esp)
  112129:	8b 44 24 28          	mov    0x28(%esp),%eax
  11212d:	8b 08                	mov    (%eax),%ecx
  11212f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112133:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  112137:	8b 09                	mov    (%ecx),%ecx
  112139:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11213d:	0f b6 4d 18          	movzbl 0x18(%ebp),%ecx
  112141:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  112145:	e8 86 fb ff ff       	call   111cd0 <lv_color_mix>
  11214a:	83 ec 04             	sub    $0x4,%esp
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
  11214d:	8b 45 10             	mov    0x10(%ebp),%eax
  112150:	66 8b 50 02          	mov    0x2(%eax),%dx
  112154:	66 89 54 24 52       	mov    %dx,0x52(%esp)
  112159:	0f bf 44 24 52       	movswl 0x52(%esp),%eax
  11215e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112161:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  112165:	39 c8                	cmp    %ecx,%eax
  112167:	0f 8f d9 00 00 00    	jg     112246 <sw_color_fill+0x346>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
  11216d:	8b 45 10             	mov    0x10(%ebp),%eax
  112170:	66 8b 08             	mov    (%eax),%cx
  112173:	66 89 4c 24 50       	mov    %cx,0x50(%esp)
  112178:	0f bf 44 24 50       	movswl 0x50(%esp),%eax
  11217d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112180:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  112184:	39 c8                	cmp    %ecx,%eax
  112186:	0f 8f 9a 00 00 00    	jg     112226 <sw_color_fill+0x326>
                    if(scr_transp == false) {
  11218c:	8a 44 24 45          	mov    0x45(%esp),%al
  112190:	24 01                	and    $0x1,%al
  112192:	0f b6 c8             	movzbl %al,%ecx
  112195:	83 f9 00             	cmp    $0x0,%ecx
  112198:	0f 85 6b 00 00 00    	jne    112209 <sw_color_fill+0x309>
                        /*If the bg color changed recalculate the result color*/
                        if(mem[col].full != bg_tmp.full) {
  11219e:	8b 45 08             	mov    0x8(%ebp),%eax
  1121a1:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  1121a6:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1121a9:	3b 44 24 40          	cmp    0x40(%esp),%eax
  1121ad:	0f 84 42 00 00 00    	je     1121f5 <sw_color_fill+0x2f5>
                            bg_tmp  = mem[col];
  1121b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1121b6:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  1121bb:	8b 04 88             	mov    (%eax,%ecx,4),%eax
  1121be:	89 44 24 40          	mov    %eax,0x40(%esp)
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
  1121c2:	8d 44 24 30          	lea    0x30(%esp),%eax
  1121c6:	89 04 24             	mov    %eax,(%esp)
  1121c9:	8b 44 24 28          	mov    0x28(%esp),%eax
  1121cd:	8b 08                	mov    (%eax),%ecx
  1121cf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1121d3:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  1121d7:	8b 09                	mov    (%ecx),%ecx
  1121d9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1121dd:	0f b6 4d 18          	movzbl 0x18(%ebp),%ecx
  1121e1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1121e5:	e8 e6 fa ff ff       	call   111cd0 <lv_color_mix>
  1121ea:	83 ec 04             	sub    $0x4,%esp
  1121ed:	8b 44 24 30          	mov    0x30(%esp),%eax
  1121f1:	89 44 24 38          	mov    %eax,0x38(%esp)
                        }

                        mem[col] = opa_tmp;
  1121f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1121f8:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  1121fd:	8b 54 24 38          	mov    0x38(%esp),%edx
  112201:	89 14 88             	mov    %edx,(%eax,%ecx,4)

                    } else {
  112204:	e9 05 00 00 00       	jmp    11220e <sw_color_fill+0x30e>
  112209:	e9 00 00 00 00       	jmp    11220e <sw_color_fill+0x30e>
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
                        mem[col] = color_mix_2_alpha(mem[col], mem[col].ch.alpha, color, opa);
#endif
                    }
                }
  11220e:	e9 00 00 00 00       	jmp    112213 <sw_color_fill+0x313>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
  112213:	66 8b 44 24 50       	mov    0x50(%esp),%ax
  112218:	66 83 c0 01          	add    $0x1,%ax
  11221c:	66 89 44 24 50       	mov    %ax,0x50(%esp)
  112221:	e9 52 ff ff ff       	jmp    112178 <sw_color_fill+0x278>
                mem += mem_width;
  112226:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  11222a:	c1 e0 02             	shl    $0x2,%eax
  11222d:	03 45 08             	add    0x8(%ebp),%eax
  112230:	89 45 08             	mov    %eax,0x8(%ebp)
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
  112233:	66 8b 44 24 52       	mov    0x52(%esp),%ax
  112238:	66 83 c0 01          	add    $0x1,%ax
  11223c:	66 89 44 24 52       	mov    %ax,0x52(%esp)
  112241:	e9 13 ff ff ff       	jmp    112159 <sw_color_fill+0x259>
  112246:	e9 00 00 00 00       	jmp    11224b <sw_color_fill+0x34b>
  11224b:	e9 00 00 00 00       	jmp    112250 <sw_color_fill+0x350>
            }
        }
    }
}
  112250:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112253:	5e                   	pop    %esi
  112254:	5f                   	pop    %edi
  112255:	5b                   	pop    %ebx
  112256:	5d                   	pop    %ebp
  112257:	c3                   	ret    
  112258:	66 90                	xchg   %ax,%ax
  11225a:	66 90                	xchg   %ax,%ax
  11225c:	66 90                	xchg   %ax,%ax
  11225e:	66 90                	xchg   %ax,%ax

00112260 <lv_draw_letter>:
{
  112260:	55                   	push   %ebp
  112261:	89 e5                	mov    %esp,%ebp
  112263:	53                   	push   %ebx
  112264:	57                   	push   %edi
  112265:	56                   	push   %esi
  112266:	83 e4 f8             	and    $0xfffffff8,%esp
  112269:	81 ec c0 00 00 00    	sub    $0xc0,%esp
  11226f:	8a 45 1c             	mov    0x1c(%ebp),%al
  112272:	8d 4d 18             	lea    0x18(%ebp),%ecx
  112275:	8b 55 14             	mov    0x14(%ebp),%edx
  112278:	8b 75 10             	mov    0x10(%ebp),%esi
  11227b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11227e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  112281:	88 44 24 4f          	mov    %al,0x4f(%esp)
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
  112285:	66 a1 a0 3f 12 00    	mov    0x123fa0,%ax
  11228b:	66 89 84 24 ba 00 00 	mov    %ax,0xba(%esp)
  112292:	00 
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
  112293:	a1 14 36 12 00       	mov    0x123614,%eax
  112298:	89 84 24 b6 00 00 00 	mov    %eax,0xb6(%esp)
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
  11229f:	a1 a2 3f 12 00       	mov    0x123fa2,%eax
  1122a4:	89 84 24 a6 00 00 00 	mov    %eax,0xa6(%esp)
  1122ab:	a1 a6 3f 12 00       	mov    0x123fa6,%eax
  1122b0:	89 84 24 aa 00 00 00 	mov    %eax,0xaa(%esp)
  1122b7:	a1 aa 3f 12 00       	mov    0x123faa,%eax
  1122bc:	89 84 24 ae 00 00 00 	mov    %eax,0xae(%esp)
  1122c3:	a1 ae 3f 12 00       	mov    0x123fae,%eax
  1122c8:	89 84 24 b2 00 00 00 	mov    %eax,0xb2(%esp)
    if(opa < LV_OPA_MIN) return;
  1122cf:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1122d3:	83 f8 10             	cmp    $0x10,%eax
  1122d6:	89 4c 24 48          	mov    %ecx,0x48(%esp)
  1122da:	0f 8d 05 00 00 00    	jge    1122e5 <lv_draw_letter+0x85>
  1122e0:	e9 ff 07 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
  1122e5:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1122e9:	3d fb 00 00 00       	cmp    $0xfb,%eax
  1122ee:	0f 8e 04 00 00 00    	jle    1122f8 <lv_draw_letter+0x98>
  1122f4:	c6 45 1c ff          	movb   $0xff,0x1c(%ebp)
    if(font_p == NULL) {
  1122f8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1122fc:	0f 85 2d 00 00 00    	jne    11232f <lv_draw_letter+0xcf>
        LV_LOG_WARN("Font: character's bitmap not found");
  112302:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  112309:	8d 05 b2 3f 12 00    	lea    0x123fb2,%eax
  11230f:	89 44 24 04          	mov    %eax,0x4(%esp)
  112313:	c7 44 24 08 f7 00 00 	movl   $0xf7,0x8(%esp)
  11231a:	00 
  11231b:	8d 05 fd 3f 12 00    	lea    0x123ffd,%eax
  112321:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112325:	e8 16 77 00 00       	call   119a40 <lv_log_add>
        return;
  11232a:	e9 b5 07 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
  11232f:	31 c0                	xor    %eax,%eax
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
  112331:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112334:	8b 55 14             	mov    0x14(%ebp),%edx
  112337:	89 0c 24             	mov    %ecx,(%esp)
  11233a:	8d 8c 24 98 00 00 00 	lea    0x98(%esp),%ecx
  112341:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112345:	89 54 24 08          	mov    %edx,0x8(%esp)
  112349:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  112350:	00 
  112351:	89 44 24 44          	mov    %eax,0x44(%esp)
  112355:	e8 56 9a 00 00       	call   11bdb0 <lv_font_get_glyph_dsc>
  11235a:	24 01                	and    $0x1,%al
  11235c:	88 84 24 97 00 00 00 	mov    %al,0x97(%esp)
    if(g_ret == false) return;
  112363:	8a 84 24 97 00 00 00 	mov    0x97(%esp),%al
  11236a:	24 01                	and    $0x1,%al
  11236c:	0f b6 c8             	movzbl %al,%ecx
  11236f:	83 f9 00             	cmp    $0x0,%ecx
  112372:	0f 85 05 00 00 00    	jne    11237d <lv_draw_letter+0x11d>
  112378:	e9 67 07 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
    lv_coord_t pos_x = pos_p->x + g.ofs_x;
  11237d:	8b 45 08             	mov    0x8(%ebp),%eax
  112380:	0f b7 00             	movzwl (%eax),%eax
  112383:	0f be 8c 24 9c 00 00 	movsbl 0x9c(%esp),%ecx
  11238a:	00 
  11238b:	01 c8                	add    %ecx,%eax
  11238d:	66 89 84 24 94 00 00 	mov    %ax,0x94(%esp)
  112394:	00 
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
  112395:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112398:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  11239c:	8b 55 10             	mov    0x10(%ebp),%edx
  11239f:	0f b6 72 08          	movzbl 0x8(%edx),%esi
  1123a3:	0f b6 52 09          	movzbl 0x9(%edx),%edx
  1123a7:	29 d6                	sub    %edx,%esi
  1123a9:	01 f1                	add    %esi,%ecx
  1123ab:	0f b6 94 24 9b 00 00 	movzbl 0x9b(%esp),%edx
  1123b2:	00 
  1123b3:	29 d1                	sub    %edx,%ecx
  1123b5:	0f be 94 24 9d 00 00 	movsbl 0x9d(%esp),%edx
  1123bc:	00 
  1123bd:	29 d1                	sub    %edx,%ecx
  1123bf:	66 89 8c 24 92 00 00 	mov    %cx,0x92(%esp)
  1123c6:	00 
    switch(g.bpp) {
  1123c7:	0f b6 94 24 9e 00 00 	movzbl 0x9e(%esp),%edx
  1123ce:	00 
  1123cf:	4a                   	dec    %edx
  1123d0:	89 d6                	mov    %edx,%esi
  1123d2:	83 ee 07             	sub    $0x7,%esi
  1123d5:	89 54 24 40          	mov    %edx,0x40(%esp)
  1123d9:	0f 87 76 00 00 00    	ja     112455 <lv_draw_letter+0x1f5>
  1123df:	8b 44 24 40          	mov    0x40(%esp),%eax
  1123e3:	8b 0c 85 f4 35 12 00 	mov    0x1235f4(,%eax,4),%ecx
  1123ea:	ff e1                	jmp    *%ecx
  1123ec:	8d 84 24 ba 00 00 00 	lea    0xba(%esp),%eax
            bpp_opa_table = bpp1_opa_table;
  1123f3:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
            bitmask_init  = 0x80;
  1123fa:	c6 84 24 8b 00 00 00 	movb   $0x80,0x8b(%esp)
  112401:	80 
            break;
  112402:	e9 53 00 00 00       	jmp    11245a <lv_draw_letter+0x1fa>
  112407:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
            bpp_opa_table = bpp2_opa_table;
  11240e:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
            bitmask_init  = 0xC0;
  112415:	c6 84 24 8b 00 00 00 	movb   $0xc0,0x8b(%esp)
  11241c:	c0 
            break;
  11241d:	e9 38 00 00 00       	jmp    11245a <lv_draw_letter+0x1fa>
  112422:	8d 84 24 a6 00 00 00 	lea    0xa6(%esp),%eax
            bpp_opa_table = bpp4_opa_table;
  112429:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
            bitmask_init  = 0xF0;
  112430:	c6 84 24 8b 00 00 00 	movb   $0xf0,0x8b(%esp)
  112437:	f0 
            break;
  112438:	e9 1d 00 00 00       	jmp    11245a <lv_draw_letter+0x1fa>
            bpp_opa_table = NULL;
  11243d:	c7 84 24 8c 00 00 00 	movl   $0x0,0x8c(%esp)
  112444:	00 00 00 00 
            bitmask_init  = 0xFF;
  112448:	c6 84 24 8b 00 00 00 	movb   $0xff,0x8b(%esp)
  11244f:	ff 
            break;       /*No opa table, pixel value will be used directly*/
  112450:	e9 05 00 00 00       	jmp    11245a <lv_draw_letter+0x1fa>
        default: return; /*Invalid bpp. Can't render the letter*/
  112455:	e9 8a 06 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
  11245a:	8b 45 10             	mov    0x10(%ebp),%eax
  11245d:	8b 4d 14             	mov    0x14(%ebp),%ecx
  112460:	89 04 24             	mov    %eax,(%esp)
  112463:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112467:	e8 14 99 00 00       	call   11bd80 <lv_font_get_glyph_bitmap>
  11246c:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
    if(map_p == NULL) return;
  112473:	83 bc 24 84 00 00 00 	cmpl   $0x0,0x84(%esp)
  11247a:	00 
  11247b:	0f 85 05 00 00 00    	jne    112486 <lv_draw_letter+0x226>
  112481:	e9 5e 06 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
  112486:	0f bf 84 24 94 00 00 	movswl 0x94(%esp),%eax
  11248d:	00 
  11248e:	0f b6 8c 24 9a 00 00 	movzbl 0x9a(%esp),%ecx
  112495:	00 
  112496:	01 c8                	add    %ecx,%eax
  112498:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11249b:	0f bf 09             	movswl (%ecx),%ecx
  11249e:	39 c8                	cmp    %ecx,%eax
  1124a0:	0f 8c 4f 00 00 00    	jl     1124f5 <lv_draw_letter+0x295>
  1124a6:	0f bf 84 24 94 00 00 	movswl 0x94(%esp),%eax
  1124ad:	00 
  1124ae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1124b1:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  1124b5:	39 c8                	cmp    %ecx,%eax
  1124b7:	0f 8f 38 00 00 00    	jg     1124f5 <lv_draw_letter+0x295>
  1124bd:	0f bf 84 24 92 00 00 	movswl 0x92(%esp),%eax
  1124c4:	00 
  1124c5:	0f b6 8c 24 9b 00 00 	movzbl 0x9b(%esp),%ecx
  1124cc:	00 
  1124cd:	01 c8                	add    %ecx,%eax
  1124cf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1124d2:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  1124d6:	39 c8                	cmp    %ecx,%eax
  1124d8:	0f 8c 17 00 00 00    	jl     1124f5 <lv_draw_letter+0x295>
  1124de:	0f bf 84 24 92 00 00 	movswl 0x92(%esp),%eax
  1124e5:	00 
  1124e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1124e9:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  1124ed:	39 c8                	cmp    %ecx,%eax
  1124ef:	0f 8e 05 00 00 00    	jle    1124fa <lv_draw_letter+0x29a>
  1124f5:	e9 ea 05 00 00       	jmp    112ae4 <lv_draw_letter+0x884>
    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
  1124fa:	e8 d1 dc ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  1124ff:	89 84 24 80 00 00 00 	mov    %eax,0x80(%esp)
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
  112506:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  11250d:	89 04 24             	mov    %eax,(%esp)
  112510:	e8 9b 53 00 00       	call   1178b0 <lv_disp_get_buf>
  112515:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    lv_coord_t vdb_width     = lv_area_get_width(&vdb->area);
  112519:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  11251d:	83 c0 10             	add    $0x10,%eax
  112520:	89 04 24             	mov    %eax,(%esp)
  112523:	e8 78 f7 ff ff       	call   111ca0 <lv_area_get_width>
  112528:	66 89 44 24 7a       	mov    %ax,0x7a(%esp)
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
  11252d:	8b 4c 24 7c          	mov    0x7c(%esp),%ecx
  112531:	8b 49 08             	mov    0x8(%ecx),%ecx
  112534:	89 4c 24 74          	mov    %ecx,0x74(%esp)
    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
  112538:	0f b6 8c 24 9a 00 00 	movzbl 0x9a(%esp),%ecx
  11253f:	00 
  112540:	c1 f9 03             	sar    $0x3,%ecx
  112543:	88 4c 24 6f          	mov    %cl,0x6f(%esp)
    if(g.box_w & 0x7) width_byte_scr++;
  112547:	0f b6 94 24 9a 00 00 	movzbl 0x9a(%esp),%edx
  11254e:	00 
  11254f:	83 e2 07             	and    $0x7,%edx
  112552:	83 fa 00             	cmp    $0x0,%edx
  112555:	0f 84 0a 00 00 00    	je     112565 <lv_draw_letter+0x305>
  11255b:	8a 44 24 6f          	mov    0x6f(%esp),%al
  11255f:	04 01                	add    $0x1,%al
  112561:	88 44 24 6f          	mov    %al,0x6f(%esp)
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
  112565:	0f b6 84 24 9a 00 00 	movzbl 0x9a(%esp),%eax
  11256c:	00 
  11256d:	0f b6 8c 24 9e 00 00 	movzbl 0x9e(%esp),%ecx
  112574:	00 
  112575:	0f af c1             	imul   %ecx,%eax
  112578:	66 89 44 24 6c       	mov    %ax,0x6c(%esp)
    lv_coord_t col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
  11257d:	0f bf 8c 24 94 00 00 	movswl 0x94(%esp),%ecx
  112584:	00 
  112585:	8b 55 0c             	mov    0xc(%ebp),%edx
  112588:	0f bf 12             	movswl (%edx),%edx
  11258b:	39 d1                	cmp    %edx,%ecx
  11258d:	0f 8c 0b 00 00 00    	jl     11259e <lv_draw_letter+0x33e>
  112593:	31 c0                	xor    %eax,%eax
  112595:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  112599:	e9 14 00 00 00       	jmp    1125b2 <lv_draw_letter+0x352>
  11259e:	8b 45 0c             	mov    0xc(%ebp),%eax
  1125a1:	0f bf 00             	movswl (%eax),%eax
  1125a4:	0f bf 8c 24 94 00 00 	movswl 0x94(%esp),%ecx
  1125ab:	00 
  1125ac:	29 c8                	sub    %ecx,%eax
  1125ae:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1125b2:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  1125b6:	66 89 44 24 6a       	mov    %ax,0x6a(%esp)
    lv_coord_t col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
  1125bb:	0f bf 8c 24 94 00 00 	movswl 0x94(%esp),%ecx
  1125c2:	00 
  1125c3:	0f b6 94 24 9a 00 00 	movzbl 0x9a(%esp),%edx
  1125ca:	00 
  1125cb:	01 d1                	add    %edx,%ecx
  1125cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1125d0:	0f bf 52 04          	movswl 0x4(%edx),%edx
  1125d4:	39 d1                	cmp    %edx,%ecx
  1125d6:	0f 8f 11 00 00 00    	jg     1125ed <lv_draw_letter+0x38d>
  1125dc:	0f b6 84 24 9a 00 00 	movzbl 0x9a(%esp),%eax
  1125e3:	00 
  1125e4:	89 44 24 38          	mov    %eax,0x38(%esp)
  1125e8:	e9 18 00 00 00       	jmp    112605 <lv_draw_letter+0x3a5>
  1125ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  1125f0:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1125f4:	0f bf 8c 24 94 00 00 	movswl 0x94(%esp),%ecx
  1125fb:	00 
  1125fc:	29 c8                	sub    %ecx,%eax
  1125fe:	83 c0 01             	add    $0x1,%eax
  112601:	89 44 24 38          	mov    %eax,0x38(%esp)
  112605:	8b 44 24 38          	mov    0x38(%esp),%eax
  112609:	66 89 44 24 68       	mov    %ax,0x68(%esp)
    lv_coord_t row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
  11260e:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  112615:	00 
  112616:	8b 55 0c             	mov    0xc(%ebp),%edx
  112619:	0f bf 52 02          	movswl 0x2(%edx),%edx
  11261d:	39 d1                	cmp    %edx,%ecx
  11261f:	0f 8c 0b 00 00 00    	jl     112630 <lv_draw_letter+0x3d0>
  112625:	31 c0                	xor    %eax,%eax
  112627:	89 44 24 34          	mov    %eax,0x34(%esp)
  11262b:	e9 15 00 00 00       	jmp    112645 <lv_draw_letter+0x3e5>
  112630:	8b 45 0c             	mov    0xc(%ebp),%eax
  112633:	0f bf 40 02          	movswl 0x2(%eax),%eax
  112637:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  11263e:	00 
  11263f:	29 c8                	sub    %ecx,%eax
  112641:	89 44 24 34          	mov    %eax,0x34(%esp)
  112645:	8b 44 24 34          	mov    0x34(%esp),%eax
  112649:	66 89 44 24 66       	mov    %ax,0x66(%esp)
    lv_coord_t row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
  11264e:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  112655:	00 
  112656:	0f b6 94 24 9b 00 00 	movzbl 0x9b(%esp),%edx
  11265d:	00 
  11265e:	01 d1                	add    %edx,%ecx
  112660:	8b 55 0c             	mov    0xc(%ebp),%edx
  112663:	0f bf 52 06          	movswl 0x6(%edx),%edx
  112667:	39 d1                	cmp    %edx,%ecx
  112669:	0f 8f 11 00 00 00    	jg     112680 <lv_draw_letter+0x420>
  11266f:	0f b6 84 24 9b 00 00 	movzbl 0x9b(%esp),%eax
  112676:	00 
  112677:	89 44 24 30          	mov    %eax,0x30(%esp)
  11267b:	e9 18 00 00 00       	jmp    112698 <lv_draw_letter+0x438>
  112680:	8b 45 0c             	mov    0xc(%ebp),%eax
  112683:	0f bf 40 06          	movswl 0x6(%eax),%eax
  112687:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  11268e:	00 
  11268f:	29 c8                	sub    %ecx,%eax
  112691:	83 c0 01             	add    $0x1,%eax
  112694:	89 44 24 30          	mov    %eax,0x30(%esp)
  112698:	8b 44 24 30          	mov    0x30(%esp),%eax
  11269c:	66 89 44 24 64       	mov    %ax,0x64(%esp)
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
  1126a1:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  1126a8:	00 
  1126a9:	8b 54 24 7c          	mov    0x7c(%esp),%edx
  1126ad:	0f bf 52 12          	movswl 0x12(%edx),%edx
  1126b1:	29 d1                	sub    %edx,%ecx
  1126b3:	0f bf 54 24 7a       	movswl 0x7a(%esp),%edx
  1126b8:	0f af ca             	imul   %edx,%ecx
  1126bb:	0f bf 94 24 94 00 00 	movswl 0x94(%esp),%edx
  1126c2:	00 
  1126c3:	01 d1                	add    %edx,%ecx
  1126c5:	8b 54 24 7c          	mov    0x7c(%esp),%edx
  1126c9:	0f bf 52 10          	movswl 0x10(%edx),%edx
  1126cd:	29 d1                	sub    %edx,%ecx
  1126cf:	c1 e1 02             	shl    $0x2,%ecx
  1126d2:	03 4c 24 74          	add    0x74(%esp),%ecx
  1126d6:	89 4c 24 74          	mov    %ecx,0x74(%esp)
    vdb_buf_tmp += (row_start * vdb_width) + col_start;
  1126da:	0f bf 4c 24 66       	movswl 0x66(%esp),%ecx
  1126df:	0f bf 54 24 7a       	movswl 0x7a(%esp),%edx
  1126e4:	0f af ca             	imul   %edx,%ecx
  1126e7:	0f bf 54 24 6a       	movswl 0x6a(%esp),%edx
  1126ec:	01 d1                	add    %edx,%ecx
  1126ee:	c1 e1 02             	shl    $0x2,%ecx
  1126f1:	03 4c 24 74          	add    0x74(%esp),%ecx
  1126f5:	89 4c 24 74          	mov    %ecx,0x74(%esp)
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
  1126f9:	0f bf 4c 24 66       	movswl 0x66(%esp),%ecx
  1126fe:	0f b7 54 24 6c       	movzwl 0x6c(%esp),%edx
  112703:	0f af ca             	imul   %edx,%ecx
  112706:	0f bf 54 24 6a       	movswl 0x6a(%esp),%edx
  11270b:	0f b6 b4 24 9e 00 00 	movzbl 0x9e(%esp),%esi
  112712:	00 
  112713:	0f af d6             	imul   %esi,%edx
  112716:	01 d1                	add    %edx,%ecx
  112718:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    map_p += bit_ofs >> 3;
  11271c:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  112720:	c1 e9 03             	shr    $0x3,%ecx
  112723:	03 8c 24 84 00 00 00 	add    0x84(%esp),%ecx
  11272a:	89 8c 24 84 00 00 00 	mov    %ecx,0x84(%esp)
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
  112731:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  112735:	83 e1 07             	and    $0x7,%ecx
  112738:	66 89 4c 24 5c       	mov    %cx,0x5c(%esp)
    bool scr_transp = false;
  11273d:	c6 44 24 5b 00       	movb   $0x0,0x5b(%esp)
    for(row = row_start; row < row_end; row++) {
  112742:	66 8b 44 24 66       	mov    0x66(%esp),%ax
  112747:	66 89 44 24 70       	mov    %ax,0x70(%esp)
  11274c:	0f bf 44 24 70       	movswl 0x70(%esp),%eax
  112751:	0f bf 4c 24 64       	movswl 0x64(%esp),%ecx
  112756:	39 c8                	cmp    %ecx,%eax
  112758:	0f 8d 86 03 00 00    	jge    112ae4 <lv_draw_letter+0x884>
        bitmask = bitmask_init >> col_bit;
  11275e:	0f b6 84 24 8b 00 00 	movzbl 0x8b(%esp),%eax
  112765:	00 
  112766:	0f b7 4c 24 5c       	movzwl 0x5c(%esp),%ecx
  11276b:	d3 f8                	sar    %cl,%eax
  11276d:	88 84 24 8a 00 00 00 	mov    %al,0x8a(%esp)
        for(col = col_start; col < col_end; col++) {
  112774:	66 8b 54 24 6a       	mov    0x6a(%esp),%dx
  112779:	66 89 54 24 72       	mov    %dx,0x72(%esp)
  11277e:	0f bf 44 24 72       	movswl 0x72(%esp),%eax
  112783:	0f bf 4c 24 68       	movswl 0x68(%esp),%ecx
  112788:	39 c8                	cmp    %ecx,%eax
  11278a:	0f 8d d3 02 00 00    	jge    112a63 <lv_draw_letter+0x803>
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
  112790:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
  112797:	0f b6 00             	movzbl (%eax),%eax
  11279a:	0f b6 8c 24 8a 00 00 	movzbl 0x8a(%esp),%ecx
  1127a1:	00 
  1127a2:	21 c8                	and    %ecx,%eax
  1127a4:	0f b7 4c 24 5c       	movzwl 0x5c(%esp),%ecx
  1127a9:	ba 08 00 00 00       	mov    $0x8,%edx
  1127ae:	29 ca                	sub    %ecx,%edx
  1127b0:	0f b6 8c 24 9e 00 00 	movzbl 0x9e(%esp),%ecx
  1127b7:	00 
  1127b8:	29 ca                	sub    %ecx,%edx
  1127ba:	89 d1                	mov    %edx,%ecx
  1127bc:	d3 f8                	sar    %cl,%eax
  1127be:	88 44 24 5f          	mov    %al,0x5f(%esp)
            if(letter_px != 0) {
  1127c2:	0f b6 54 24 5f       	movzbl 0x5f(%esp),%edx
  1127c7:	83 fa 00             	cmp    $0x0,%edx
  1127ca:	0f 84 fc 01 00 00    	je     1129cc <lv_draw_letter+0x76c>
                if(opa == LV_OPA_COVER) {
  1127d0:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1127d4:	3d ff 00 00 00       	cmp    $0xff,%eax
  1127d9:	0f 85 40 00 00 00    	jne    11281f <lv_draw_letter+0x5bf>
                    px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
  1127df:	0f b6 84 24 9e 00 00 	movzbl 0x9e(%esp),%eax
  1127e6:	00 
  1127e7:	83 f8 08             	cmp    $0x8,%eax
  1127ea:	0f 85 0e 00 00 00    	jne    1127fe <lv_draw_letter+0x59e>
  1127f0:	0f b6 44 24 5f       	movzbl 0x5f(%esp),%eax
  1127f5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  1127f9:	e9 14 00 00 00       	jmp    112812 <lv_draw_letter+0x5b2>
  1127fe:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  112805:	0f b6 4c 24 5f       	movzbl 0x5f(%esp),%ecx
  11280a:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  11280e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  112812:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  112816:	88 44 24 5e          	mov    %al,0x5e(%esp)
                } else {
  11281a:	e9 5b 00 00 00       	jmp    11287a <lv_draw_letter+0x61a>
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
  11281f:	0f b6 84 24 9e 00 00 	movzbl 0x9e(%esp),%eax
  112826:	00 
  112827:	83 f8 08             	cmp    $0x8,%eax
  11282a:	0f 85 1e 00 00 00    	jne    11284e <lv_draw_letter+0x5ee>
  112830:	0f b6 44 24 5f       	movzbl 0x5f(%esp),%eax
  112835:	0f b7 c8             	movzwl %ax,%ecx
  112838:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  11283c:	0f af ca             	imul   %edx,%ecx
  11283f:	0f b7 d1             	movzwl %cx,%edx
  112842:	c1 fa 08             	sar    $0x8,%edx
  112845:	89 54 24 28          	mov    %edx,0x28(%esp)
  112849:	e9 24 00 00 00       	jmp    112872 <lv_draw_letter+0x612>
                                        : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
  11284e:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  112855:	0f b6 4c 24 5f       	movzbl 0x5f(%esp),%ecx
  11285a:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  11285e:	0f b7 c8             	movzwl %ax,%ecx
  112861:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  112865:	0f af ca             	imul   %edx,%ecx
  112868:	0f b7 d1             	movzwl %cx,%edx
  11286b:	c1 fa 08             	sar    $0x8,%edx
  11286e:	89 54 24 28          	mov    %edx,0x28(%esp)
  112872:	8b 44 24 28          	mov    0x28(%esp),%eax
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
  112876:	88 44 24 5e          	mov    %al,0x5e(%esp)
                if(disp->driver.set_px_cb) {
  11287a:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  112881:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  112885:	0f 84 8d 00 00 00    	je     112918 <lv_draw_letter+0x6b8>
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
  11288b:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
  112892:	8b 40 14             	mov    0x14(%eax),%eax
  112895:	8b 8c 24 80 00 00 00 	mov    0x80(%esp),%ecx
  11289c:	8b 54 24 7c          	mov    0x7c(%esp),%edx
  1128a0:	8b 52 08             	mov    0x8(%edx),%edx
  1128a3:	66 8b 74 24 7a       	mov    0x7a(%esp),%si
                                           (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
  1128a8:	0f bf 7c 24 72       	movswl 0x72(%esp),%edi
  1128ad:	0f bf 9c 24 94 00 00 	movswl 0x94(%esp),%ebx
  1128b4:	00 
  1128b5:	01 df                	add    %ebx,%edi
  1128b7:	8b 5c 24 7c          	mov    0x7c(%esp),%ebx
  1128bb:	0f bf 5b 10          	movswl 0x10(%ebx),%ebx
  1128bf:	29 df                	sub    %ebx,%edi
  1128c1:	0f bf 5c 24 70       	movswl 0x70(%esp),%ebx
  1128c6:	89 44 24 24          	mov    %eax,0x24(%esp)
  1128ca:	0f bf 84 24 92 00 00 	movswl 0x92(%esp),%eax
  1128d1:	00 
  1128d2:	01 c3                	add    %eax,%ebx
  1128d4:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  1128d8:	0f bf 40 12          	movswl 0x12(%eax),%eax
  1128dc:	29 c3                	sub    %eax,%ebx
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
  1128de:	89 0c 24             	mov    %ecx,(%esp)
  1128e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1128e5:	0f bf c6             	movswl %si,%eax
  1128e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  1128ec:	0f bf c7             	movswl %di,%eax
  1128ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1128f3:	0f bf c3             	movswl %bx,%eax
  1128f6:	89 44 24 10          	mov    %eax,0x10(%esp)
  1128fa:	8b 44 24 48          	mov    0x48(%esp),%eax
  1128fe:	8b 08                	mov    (%eax),%ecx
  112900:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  112904:	0f b6 4c 24 5e       	movzbl 0x5e(%esp),%ecx
  112909:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  11290d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  112911:	ff d1                	call   *%ecx
                } else if(vdb_buf_tmp->full != color.full) {
  112913:	e9 af 00 00 00       	jmp    1129c7 <lv_draw_letter+0x767>
  112918:	8b 44 24 74          	mov    0x74(%esp),%eax
  11291c:	8b 00                	mov    (%eax),%eax
  11291e:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  112922:	3b 01                	cmp    (%ecx),%eax
  112924:	0f 84 98 00 00 00    	je     1129c2 <lv_draw_letter+0x762>
                    if(px_opa > LV_OPA_MAX)
  11292a:	0f b6 44 24 5e       	movzbl 0x5e(%esp),%eax
  11292f:	3d fb 00 00 00       	cmp    $0xfb,%eax
  112934:	0f 8e 11 00 00 00    	jle    11294b <lv_draw_letter+0x6eb>
                        *vdb_buf_tmp = color;
  11293a:	8b 44 24 74          	mov    0x74(%esp),%eax
  11293e:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  112942:	8b 11                	mov    (%ecx),%edx
  112944:	89 10                	mov    %edx,(%eax)
  112946:	e9 72 00 00 00       	jmp    1129bd <lv_draw_letter+0x75d>
                    else if(px_opa > LV_OPA_MIN) {
  11294b:	0f b6 44 24 5e       	movzbl 0x5e(%esp),%eax
  112950:	83 f8 10             	cmp    $0x10,%eax
  112953:	0f 8e 5f 00 00 00    	jle    1129b8 <lv_draw_letter+0x758>
                        if(scr_transp == false) {
  112959:	8a 44 24 5b          	mov    0x5b(%esp),%al
  11295d:	24 01                	and    $0x1,%al
  11295f:	0f b6 c8             	movzbl %al,%ecx
  112962:	83 f9 00             	cmp    $0x0,%ecx
  112965:	0f 85 43 00 00 00    	jne    1129ae <lv_draw_letter+0x74e>
                            *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
  11296b:	8b 44 24 74          	mov    0x74(%esp),%eax
  11296f:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  112973:	8d 54 24 50          	lea    0x50(%esp),%edx
  112977:	89 14 24             	mov    %edx,(%esp)
  11297a:	8b 54 24 48          	mov    0x48(%esp),%edx
  11297e:	8b 32                	mov    (%edx),%esi
  112980:	89 74 24 04          	mov    %esi,0x4(%esp)
  112984:	8b 09                	mov    (%ecx),%ecx
  112986:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11298a:	0f b6 4c 24 5e       	movzbl 0x5e(%esp),%ecx
  11298f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  112993:	89 44 24 20          	mov    %eax,0x20(%esp)
  112997:	e8 34 f3 ff ff       	call   111cd0 <lv_color_mix>
  11299c:	83 ec 04             	sub    $0x4,%esp
  11299f:	8b 44 24 50          	mov    0x50(%esp),%eax
  1129a3:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  1129a7:	89 01                	mov    %eax,(%ecx)
                        } else {
  1129a9:	e9 05 00 00 00       	jmp    1129b3 <lv_draw_letter+0x753>
  1129ae:	e9 00 00 00 00       	jmp    1129b3 <lv_draw_letter+0x753>
                    }
  1129b3:	e9 00 00 00 00       	jmp    1129b8 <lv_draw_letter+0x758>
  1129b8:	e9 00 00 00 00       	jmp    1129bd <lv_draw_letter+0x75d>
                }
  1129bd:	e9 00 00 00 00       	jmp    1129c2 <lv_draw_letter+0x762>
  1129c2:	e9 00 00 00 00       	jmp    1129c7 <lv_draw_letter+0x767>
            }
  1129c7:	e9 00 00 00 00       	jmp    1129cc <lv_draw_letter+0x76c>
            vdb_buf_tmp++;
  1129cc:	8b 44 24 74          	mov    0x74(%esp),%eax
  1129d0:	83 c0 04             	add    $0x4,%eax
  1129d3:	89 44 24 74          	mov    %eax,0x74(%esp)
            if(col_bit < 8 - g.bpp) {
  1129d7:	0f b7 44 24 5c       	movzwl 0x5c(%esp),%eax
  1129dc:	0f b6 8c 24 9e 00 00 	movzbl 0x9e(%esp),%ecx
  1129e3:	00 
  1129e4:	ba 08 00 00 00       	mov    $0x8,%edx
  1129e9:	29 ca                	sub    %ecx,%edx
  1129eb:	39 d0                	cmp    %edx,%eax
  1129ed:	0f 8d 32 00 00 00    	jge    112a25 <lv_draw_letter+0x7c5>
                col_bit += g.bpp;
  1129f3:	0f b6 84 24 9e 00 00 	movzbl 0x9e(%esp),%eax
  1129fa:	00 
  1129fb:	0f b7 4c 24 5c       	movzwl 0x5c(%esp),%ecx
  112a00:	01 c1                	add    %eax,%ecx
  112a02:	66 89 4c 24 5c       	mov    %cx,0x5c(%esp)
                bitmask = bitmask >> g.bpp;
  112a07:	0f b6 84 24 8a 00 00 	movzbl 0x8a(%esp),%eax
  112a0e:	00 
  112a0f:	0f b6 8c 24 9e 00 00 	movzbl 0x9e(%esp),%ecx
  112a16:	00 
  112a17:	d3 f8                	sar    %cl,%eax
  112a19:	88 84 24 8a 00 00 00 	mov    %al,0x8a(%esp)
            } else {
  112a20:	e9 26 00 00 00       	jmp    112a4b <lv_draw_letter+0x7eb>
                col_bit = 0;
  112a25:	66 c7 44 24 5c 00 00 	movw   $0x0,0x5c(%esp)
                bitmask = bitmask_init;
  112a2c:	8a 84 24 8b 00 00 00 	mov    0x8b(%esp),%al
  112a33:	88 84 24 8a 00 00 00 	mov    %al,0x8a(%esp)
                map_p++;
  112a3a:	8b 8c 24 84 00 00 00 	mov    0x84(%esp),%ecx
  112a41:	83 c1 01             	add    $0x1,%ecx
  112a44:	89 8c 24 84 00 00 00 	mov    %ecx,0x84(%esp)
        }
  112a4b:	e9 00 00 00 00       	jmp    112a50 <lv_draw_letter+0x7f0>
        for(col = col_start; col < col_end; col++) {
  112a50:	66 8b 44 24 72       	mov    0x72(%esp),%ax
  112a55:	66 83 c0 01          	add    $0x1,%ax
  112a59:	66 89 44 24 72       	mov    %ax,0x72(%esp)
  112a5e:	e9 1b fd ff ff       	jmp    11277e <lv_draw_letter+0x51e>
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
  112a63:	0f b6 84 24 9a 00 00 	movzbl 0x9a(%esp),%eax
  112a6a:	00 
  112a6b:	0f bf 4c 24 68       	movswl 0x68(%esp),%ecx
  112a70:	29 c8                	sub    %ecx,%eax
  112a72:	0f bf 4c 24 6a       	movswl 0x6a(%esp),%ecx
  112a77:	01 c8                	add    %ecx,%eax
  112a79:	0f b6 8c 24 9e 00 00 	movzbl 0x9e(%esp),%ecx
  112a80:	00 
  112a81:	0f af c1             	imul   %ecx,%eax
  112a84:	0f b7 4c 24 5c       	movzwl 0x5c(%esp),%ecx
  112a89:	01 c1                	add    %eax,%ecx
  112a8b:	66 89 4c 24 5c       	mov    %cx,0x5c(%esp)
        map_p += (col_bit >> 3);
  112a90:	0f b7 44 24 5c       	movzwl 0x5c(%esp),%eax
  112a95:	c1 f8 03             	sar    $0x3,%eax
  112a98:	03 84 24 84 00 00 00 	add    0x84(%esp),%eax
  112a9f:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
        col_bit = col_bit & 0x7;
  112aa6:	0f b7 44 24 5c       	movzwl 0x5c(%esp),%eax
  112aab:	83 e0 07             	and    $0x7,%eax
  112aae:	66 89 44 24 5c       	mov    %ax,0x5c(%esp)
        vdb_buf_tmp += vdb_width - (col_end - col_start); /*Next row in VDB*/
  112ab3:	0f bf 54 24 7a       	movswl 0x7a(%esp),%edx
  112ab8:	0f bf 74 24 68       	movswl 0x68(%esp),%esi
  112abd:	0f bf 7c 24 6a       	movswl 0x6a(%esp),%edi
  112ac2:	29 fe                	sub    %edi,%esi
  112ac4:	29 f2                	sub    %esi,%edx
  112ac6:	c1 e2 02             	shl    $0x2,%edx
  112ac9:	03 54 24 74          	add    0x74(%esp),%edx
  112acd:	89 54 24 74          	mov    %edx,0x74(%esp)
    for(row = row_start; row < row_end; row++) {
  112ad1:	66 8b 44 24 70       	mov    0x70(%esp),%ax
  112ad6:	66 83 c0 01          	add    $0x1,%ax
  112ada:	66 89 44 24 70       	mov    %ax,0x70(%esp)
  112adf:	e9 68 fc ff ff       	jmp    11274c <lv_draw_letter+0x4ec>
}
  112ae4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112ae7:	5e                   	pop    %esi
  112ae8:	5f                   	pop    %edi
  112ae9:	5b                   	pop    %ebx
  112aea:	5d                   	pop    %ebp
  112aeb:	c3                   	ret    
  112aec:	66 90                	xchg   %ax,%ax
  112aee:	66 90                	xchg   %ax,%ax

00112af0 <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
  112af0:	55                   	push   %ebp
  112af1:	89 e5                	mov    %esp,%ebp
  112af3:	50                   	push   %eax
    if(LV_GC_ROOT(_lv_draw_buf)) {
  112af4:	83 3d b4 55 13 00 00 	cmpl   $0x0,0x1355b4
  112afb:	0f 84 21 00 00 00    	je     112b22 <lv_draw_free_buf+0x32>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
  112b01:	a1 b4 55 13 00       	mov    0x1355b4,%eax
  112b06:	89 04 24             	mov    %eax,(%esp)
  112b09:	e8 52 5d 00 00       	call   118860 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
  112b0e:	c7 05 b4 55 13 00 00 	movl   $0x0,0x1355b4
  112b15:	00 00 00 
        draw_buf_size = 0;
  112b18:	c7 05 60 55 13 00 00 	movl   $0x0,0x135560
  112b1f:	00 00 00 
    }
}
  112b22:	83 c4 04             	add    $0x4,%esp
  112b25:	5d                   	pop    %ebp
  112b26:	c3                   	ret    
  112b27:	66 90                	xchg   %ax,%ax
  112b29:	66 90                	xchg   %ax,%ax
  112b2b:	66 90                	xchg   %ax,%ax
  112b2d:	66 90                	xchg   %ax,%ax
  112b2f:	90                   	nop

00112b30 <lv_draw_rect>:
 * @param mask the rectangle will be drawn only in this mask
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale)
{
  112b30:	55                   	push   %ebp
  112b31:	89 e5                	mov    %esp,%ebp
  112b33:	57                   	push   %edi
  112b34:	56                   	push   %esi
  112b35:	83 ec 20             	sub    $0x20,%esp
  112b38:	8a 45 14             	mov    0x14(%ebp),%al
  112b3b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112b3e:	8b 55 0c             	mov    0xc(%ebp),%edx
  112b41:	8b 75 08             	mov    0x8(%ebp),%esi
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
  112b44:	8b 7d 08             	mov    0x8(%ebp),%edi
  112b47:	89 3c 24             	mov    %edi,(%esp)
  112b4a:	88 45 f7             	mov    %al,-0x9(%ebp)
  112b4d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  112b50:	89 55 ec             	mov    %edx,-0x14(%ebp)
  112b53:	89 75 e8             	mov    %esi,-0x18(%ebp)
  112b56:	e8 45 01 00 00       	call   112ca0 <lv_area_get_height>
  112b5b:	0f bf c8             	movswl %ax,%ecx
  112b5e:	83 f9 01             	cmp    $0x1,%ecx
  112b61:	0f 8c 17 00 00 00    	jl     112b7e <lv_draw_rect+0x4e>
  112b67:	8b 45 08             	mov    0x8(%ebp),%eax
  112b6a:	89 04 24             	mov    %eax,(%esp)
  112b6d:	e8 5e 01 00 00       	call   112cd0 <lv_area_get_width>
  112b72:	0f bf c8             	movswl %ax,%ecx
  112b75:	83 f9 01             	cmp    $0x1,%ecx
  112b78:	0f 8d 05 00 00 00    	jge    112b83 <lv_draw_rect+0x53>
  112b7e:	e9 13 01 00 00       	jmp    112c96 <lv_draw_rect+0x166>
    }
#endif

    /* If the object is out of the mask there is nothing to draw.
     * Draw shadow before it because the shadow is out of `coords`*/
    if(lv_area_is_on(coords, mask) == false) return;
  112b83:	8b 45 08             	mov    0x8(%ebp),%eax
  112b86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112b89:	89 04 24             	mov    %eax,(%esp)
  112b8c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112b90:	e8 ab 52 00 00       	call   117e40 <lv_area_is_on>
  112b95:	24 01                	and    $0x1,%al
  112b97:	0f b6 c8             	movzbl %al,%ecx
  112b9a:	83 f9 00             	cmp    $0x0,%ecx
  112b9d:	0f 85 05 00 00 00    	jne    112ba8 <lv_draw_rect+0x78>
  112ba3:	e9 ee 00 00 00       	jmp    112c96 <lv_draw_rect+0x166>

    if(style->body.opa > LV_OPA_MIN) {
  112ba8:	8b 45 10             	mov    0x10(%ebp),%eax
  112bab:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  112baf:	83 f8 10             	cmp    $0x10,%eax
  112bb2:	0f 8e 57 00 00 00    	jle    112c0f <lv_draw_rect+0xdf>
        lv_draw_rect_main_mid(coords, mask, style, opa_scale);
  112bb8:	8b 45 08             	mov    0x8(%ebp),%eax
  112bbb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112bbe:	8b 55 10             	mov    0x10(%ebp),%edx
  112bc1:	89 04 24             	mov    %eax,(%esp)
  112bc4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112bc8:	89 54 24 08          	mov    %edx,0x8(%esp)
  112bcc:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  112bd0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112bd4:	e8 27 01 00 00       	call   112d00 <lv_draw_rect_main_mid>

        if(style->body.radius != 0) {
  112bd9:	8b 45 10             	mov    0x10(%ebp),%eax
  112bdc:	0f bf 40 0c          	movswl 0xc(%eax),%eax
  112be0:	83 f8 00             	cmp    $0x0,%eax
  112be3:	0f 84 21 00 00 00    	je     112c0a <lv_draw_rect+0xda>
            lv_draw_rect_main_corner(coords, mask, style, opa_scale);
  112be9:	8b 45 08             	mov    0x8(%ebp),%eax
  112bec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112bef:	8b 55 10             	mov    0x10(%ebp),%edx
  112bf2:	89 04 24             	mov    %eax,(%esp)
  112bf5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112bf9:	89 54 24 08          	mov    %edx,0x8(%esp)
  112bfd:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  112c01:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112c05:	e8 36 04 00 00       	call   113040 <lv_draw_rect_main_corner>
        }
    }
  112c0a:	e9 00 00 00 00       	jmp    112c0f <lv_draw_rect+0xdf>

    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
  112c0f:	8b 45 10             	mov    0x10(%ebp),%eax
  112c12:	0f bf 40 14          	movswl 0x14(%eax),%eax
  112c16:	83 f8 00             	cmp    $0x0,%eax
  112c19:	0f 84 77 00 00 00    	je     112c96 <lv_draw_rect+0x166>
  112c1f:	8b 45 10             	mov    0x10(%ebp),%eax
  112c22:	0f b6 40 16          	movzbl 0x16(%eax),%eax
  112c26:	83 f8 00             	cmp    $0x0,%eax
  112c29:	0f 84 67 00 00 00    	je     112c96 <lv_draw_rect+0x166>
       style->body.border.opa >= LV_OPA_MIN) {
  112c2f:	8b 45 10             	mov    0x10(%ebp),%eax
  112c32:	0f b6 40 17          	movzbl 0x17(%eax),%eax
  112c36:	83 f8 10             	cmp    $0x10,%eax
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
  112c39:	0f 8c 57 00 00 00    	jl     112c96 <lv_draw_rect+0x166>
        lv_draw_rect_border_straight(coords, mask, style, opa_scale);
  112c3f:	8b 45 08             	mov    0x8(%ebp),%eax
  112c42:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112c45:	8b 55 10             	mov    0x10(%ebp),%edx
  112c48:	89 04 24             	mov    %eax,(%esp)
  112c4b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112c4f:	89 54 24 08          	mov    %edx,0x8(%esp)
  112c53:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  112c57:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112c5b:	e8 00 11 00 00       	call   113d60 <lv_draw_rect_border_straight>

        if(style->body.radius != 0) {
  112c60:	8b 45 10             	mov    0x10(%ebp),%eax
  112c63:	0f bf 40 0c          	movswl 0xc(%eax),%eax
  112c67:	83 f8 00             	cmp    $0x0,%eax
  112c6a:	0f 84 21 00 00 00    	je     112c91 <lv_draw_rect+0x161>
            lv_draw_rect_border_corner(coords, mask, style, opa_scale);
  112c70:	8b 45 08             	mov    0x8(%ebp),%eax
  112c73:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112c76:	8b 55 10             	mov    0x10(%ebp),%edx
  112c79:	89 04 24             	mov    %eax,(%esp)
  112c7c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112c80:	89 54 24 08          	mov    %edx,0x8(%esp)
  112c84:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  112c88:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112c8c:	e8 bf 1b 00 00       	call   114850 <lv_draw_rect_border_corner>
        }
    }
  112c91:	e9 00 00 00 00       	jmp    112c96 <lv_draw_rect+0x166>
}
  112c96:	83 c4 20             	add    $0x20,%esp
  112c99:	5e                   	pop    %esi
  112c9a:	5f                   	pop    %edi
  112c9b:	5d                   	pop    %ebp
  112c9c:	c3                   	ret    
  112c9d:	66 90                	xchg   %ax,%ax
  112c9f:	90                   	nop

00112ca0 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
  112ca0:	55                   	push   %ebp
  112ca1:	89 e5                	mov    %esp,%ebp
  112ca3:	50                   	push   %eax
  112ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->y2 - area_p->y1 + 1;
  112ca7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112caa:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  112cae:	8b 55 08             	mov    0x8(%ebp),%edx
  112cb1:	0f bf 52 02          	movswl 0x2(%edx),%edx
  112cb5:	29 d1                	sub    %edx,%ecx
  112cb7:	83 c1 01             	add    $0x1,%ecx
  112cba:	0f bf d1             	movswl %cx,%edx
  112cbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  112cc0:	89 d0                	mov    %edx,%eax
  112cc2:	83 c4 04             	add    $0x4,%esp
  112cc5:	5d                   	pop    %ebp
  112cc6:	c3                   	ret    
  112cc7:	66 90                	xchg   %ax,%ax
  112cc9:	66 90                	xchg   %ax,%ax
  112ccb:	66 90                	xchg   %ax,%ax
  112ccd:	66 90                	xchg   %ax,%ax
  112ccf:	90                   	nop

00112cd0 <lv_area_get_width>:
{
  112cd0:	55                   	push   %ebp
  112cd1:	89 e5                	mov    %esp,%ebp
  112cd3:	50                   	push   %eax
  112cd4:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  112cd7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112cda:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  112cde:	8b 55 08             	mov    0x8(%ebp),%edx
  112ce1:	0f bf 12             	movswl (%edx),%edx
  112ce4:	29 d1                	sub    %edx,%ecx
  112ce6:	83 c1 01             	add    $0x1,%ecx
  112ce9:	0f bf d1             	movswl %cx,%edx
  112cec:	89 45 fc             	mov    %eax,-0x4(%ebp)
  112cef:	89 d0                	mov    %edx,%eax
  112cf1:	83 c4 04             	add    $0x4,%esp
  112cf4:	5d                   	pop    %ebp
  112cf5:	c3                   	ret    
  112cf6:	66 90                	xchg   %ax,%ax
  112cf8:	66 90                	xchg   %ax,%ax
  112cfa:	66 90                	xchg   %ax,%ax
  112cfc:	66 90                	xchg   %ax,%ax
  112cfe:	66 90                	xchg   %ax,%ax

00112d00 <lv_draw_rect_main_mid>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_mid(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
  112d00:	55                   	push   %ebp
  112d01:	89 e5                	mov    %esp,%ebp
  112d03:	53                   	push   %ebx
  112d04:	57                   	push   %edi
  112d05:	56                   	push   %esi
  112d06:	83 e4 f8             	and    $0xfffffff8,%esp
  112d09:	83 ec 68             	sub    $0x68,%esp
  112d0c:	8a 45 14             	mov    0x14(%ebp),%al
  112d0f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112d12:	8b 55 0c             	mov    0xc(%ebp),%edx
  112d15:	8b 75 08             	mov    0x8(%ebp),%esi
    uint16_t radius = style->body.radius;
  112d18:	8b 7d 10             	mov    0x10(%ebp),%edi
  112d1b:	66 8b 5f 0c          	mov    0xc(%edi),%bx
  112d1f:	66 89 5c 24 62       	mov    %bx,0x62(%esp)
  112d24:	88 44 24 27          	mov    %al,0x27(%esp)
  112d28:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  112d2c:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  112d30:	89 74 24 18          	mov    %esi,0x18(%esp)
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
  112d34:	e8 97 d4 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  112d39:	89 04 24             	mov    %eax,(%esp)
  112d3c:	e8 2f 4b 00 00       	call   117870 <lv_disp_get_antialiasing>
  112d41:	24 01                	and    $0x1,%al
  112d43:	88 44 24 61          	mov    %al,0x61(%esp)

    lv_color_t mcolor = style->body.main_color;
  112d47:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112d4a:	8b 49 04             	mov    0x4(%ecx),%ecx
  112d4d:	89 4c 24 58          	mov    %ecx,0x58(%esp)
    lv_color_t gcolor = style->body.grad_color;
  112d51:	8b 4d 10             	mov    0x10(%ebp),%ecx
  112d54:	8b 49 08             	mov    0x8(%ecx),%ecx
  112d57:	89 4c 24 50          	mov    %ecx,0x50(%esp)
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
  112d5b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112d5e:	89 0c 24             	mov    %ecx,(%esp)
  112d61:	e8 3a ff ff ff       	call   112ca0 <lv_area_get_height>
  112d66:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
    lv_coord_t width  = lv_area_get_width(coords);
  112d6b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112d6e:	89 0c 24             	mov    %ecx,(%esp)
  112d71:	e8 5a ff ff ff       	call   112cd0 <lv_area_get_width>
  112d76:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
  112d7b:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  112d7f:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  112d85:	0f 85 10 00 00 00    	jne    112d9b <lv_draw_rect_main_mid+0x9b>
  112d8b:	8b 45 10             	mov    0x10(%ebp),%eax
  112d8e:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  112d92:	89 44 24 14          	mov    %eax,0x14(%esp)
  112d96:	e9 1b 00 00 00       	jmp    112db6 <lv_draw_rect_main_mid+0xb6>
  112d9b:	8b 45 10             	mov    0x10(%ebp),%eax
  112d9e:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  112da2:	0f b7 c8             	movzwl %ax,%ecx
  112da5:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  112da9:	0f af ca             	imul   %edx,%ecx
  112dac:	0f b7 d1             	movzwl %cx,%edx
  112daf:	c1 fa 08             	sar    $0x8,%edx
  112db2:	89 54 24 14          	mov    %edx,0x14(%esp)
  112db6:	8b 44 24 14          	mov    0x14(%esp),%eax
  112dba:	88 44 24 49          	mov    %al,0x49(%esp)

    radius = lv_draw_cont_radius_corr(radius, width, height);
  112dbe:	66 8b 4c 24 62       	mov    0x62(%esp),%cx
  112dc3:	66 8b 54 24 4a       	mov    0x4a(%esp),%dx
  112dc8:	0f b7 f1             	movzwl %cx,%esi
  112dcb:	89 34 24             	mov    %esi,(%esp)
  112dce:	0f bf f2             	movswl %dx,%esi
  112dd1:	89 74 24 04          	mov    %esi,0x4(%esp)
  112dd5:	0f bf 74 24 4c       	movswl 0x4c(%esp),%esi
  112dda:	89 74 24 08          	mov    %esi,0x8(%esp)
  112dde:	e8 0d 22 00 00       	call   114ff0 <lv_draw_cont_radius_corr>
  112de3:	66 89 44 24 62       	mov    %ax,0x62(%esp)

    /*If the radius is too big then there is no body*/
    if(radius > height / 2) return;
  112de8:	0f b7 74 24 62       	movzwl 0x62(%esp),%esi
  112ded:	0f bf 44 24 4c       	movswl 0x4c(%esp),%eax
  112df2:	99                   	cltd   
  112df3:	bf 02 00 00 00       	mov    $0x2,%edi
  112df8:	f7 ff                	idiv   %edi
  112dfa:	39 c6                	cmp    %eax,%esi
  112dfc:	0f 8e 05 00 00 00    	jle    112e07 <lv_draw_rect_main_mid+0x107>
  112e02:	e9 26 02 00 00       	jmp    11302d <lv_draw_rect_main_mid+0x32d>

    lv_area_t work_area;
    work_area.x1 = coords->x1;
  112e07:	8b 45 08             	mov    0x8(%ebp),%eax
  112e0a:	66 8b 08             	mov    (%eax),%cx
  112e0d:	66 89 4c 24 40       	mov    %cx,0x40(%esp)
    work_area.x2 = coords->x2;
  112e12:	8b 45 08             	mov    0x8(%ebp),%eax
  112e15:	66 8b 48 04          	mov    0x4(%eax),%cx
  112e19:	66 89 4c 24 44       	mov    %cx,0x44(%esp)

    if(mcolor.full == gcolor.full) {
  112e1e:	8b 44 24 58          	mov    0x58(%esp),%eax
  112e22:	3b 44 24 50          	cmp    0x50(%esp),%eax
  112e26:	0f 85 aa 00 00 00    	jne    112ed6 <lv_draw_rect_main_mid+0x1d6>
        work_area.y1 = coords->y1 + radius;
  112e2c:	8b 45 08             	mov    0x8(%ebp),%eax
  112e2f:	0f bf 40 02          	movswl 0x2(%eax),%eax
  112e33:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  112e38:	01 c8                	add    %ecx,%eax
  112e3a:	66 89 44 24 42       	mov    %ax,0x42(%esp)
        work_area.y2 = coords->y2 - radius;
  112e3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112e42:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  112e46:	0f b7 54 24 62       	movzwl 0x62(%esp),%edx
  112e4b:	29 d1                	sub    %edx,%ecx
  112e4d:	66 89 4c 24 46       	mov    %cx,0x46(%esp)

        if(style->body.radius != 0) {
  112e52:	8b 55 10             	mov    0x10(%ebp),%edx
  112e55:	0f bf 52 0c          	movswl 0xc(%edx),%edx
  112e59:	83 fa 00             	cmp    $0x0,%edx
  112e5c:	0f 84 49 00 00 00    	je     112eab <lv_draw_rect_main_mid+0x1ab>

            if(aa) {
  112e62:	f6 44 24 61 01       	testb  $0x1,0x61(%esp)
  112e67:	0f 84 1f 00 00 00    	je     112e8c <lv_draw_rect_main_mid+0x18c>
                work_area.y1 += 2;
  112e6d:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
  112e72:	83 c0 02             	add    $0x2,%eax
  112e75:	66 89 44 24 42       	mov    %ax,0x42(%esp)
                work_area.y2 -= 2;
  112e7a:	0f bf 4c 24 46       	movswl 0x46(%esp),%ecx
  112e7f:	83 e9 02             	sub    $0x2,%ecx
  112e82:	66 89 4c 24 46       	mov    %cx,0x46(%esp)
            } else {
  112e87:	e9 1a 00 00 00       	jmp    112ea6 <lv_draw_rect_main_mid+0x1a6>
                work_area.y1 += 1;
  112e8c:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
  112e91:	83 c0 01             	add    $0x1,%eax
  112e94:	66 89 44 24 42       	mov    %ax,0x42(%esp)
                work_area.y2 -= 1;
  112e99:	0f bf 4c 24 46       	movswl 0x46(%esp),%ecx
  112e9e:	83 e9 01             	sub    $0x1,%ecx
  112ea1:	66 89 4c 24 46       	mov    %cx,0x46(%esp)
            }
        }
  112ea6:	e9 00 00 00 00       	jmp    112eab <lv_draw_rect_main_mid+0x1ab>

        lv_draw_fill(&work_area, mask, mcolor, opa);
  112eab:	8b 45 0c             	mov    0xc(%ebp),%eax
  112eae:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  112eb2:	89 0c 24             	mov    %ecx,(%esp)
  112eb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  112eb9:	8d 44 24 58          	lea    0x58(%esp),%eax
  112ebd:	8b 00                	mov    (%eax),%eax
  112ebf:	89 44 24 08          	mov    %eax,0x8(%esp)
  112ec3:	0f b6 44 24 49       	movzbl 0x49(%esp),%eax
  112ec8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  112ecc:	e8 cf ee ff ff       	call   111da0 <lv_draw_fill>
    } else {
  112ed1:	e9 57 01 00 00       	jmp    11302d <lv_draw_rect_main_mid+0x32d>
        lv_coord_t row;
        lv_coord_t row_start = coords->y1 + radius;
  112ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  112ed9:	0f bf 40 02          	movswl 0x2(%eax),%eax
  112edd:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  112ee2:	01 c8                	add    %ecx,%eax
  112ee4:	66 89 44 24 3c       	mov    %ax,0x3c(%esp)
        lv_coord_t row_end   = coords->y2 - radius;
  112ee9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112eec:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  112ef0:	0f b7 54 24 62       	movzwl 0x62(%esp),%edx
  112ef5:	29 d1                	sub    %edx,%ecx
  112ef7:	66 89 4c 24 3a       	mov    %cx,0x3a(%esp)
        lv_color_t act_color;

        if(style->body.radius != 0) {
  112efc:	8b 55 10             	mov    0x10(%ebp),%edx
  112eff:	0f bf 52 0c          	movswl 0xc(%edx),%edx
  112f03:	83 fa 00             	cmp    $0x0,%edx
  112f06:	0f 84 49 00 00 00    	je     112f55 <lv_draw_rect_main_mid+0x255>
            if(aa) {
  112f0c:	f6 44 24 61 01       	testb  $0x1,0x61(%esp)
  112f11:	0f 84 1f 00 00 00    	je     112f36 <lv_draw_rect_main_mid+0x236>
                row_start += 2;
  112f17:	0f bf 44 24 3c       	movswl 0x3c(%esp),%eax
  112f1c:	83 c0 02             	add    $0x2,%eax
  112f1f:	66 89 44 24 3c       	mov    %ax,0x3c(%esp)
                row_end -= 2;
  112f24:	0f bf 4c 24 3a       	movswl 0x3a(%esp),%ecx
  112f29:	83 e9 02             	sub    $0x2,%ecx
  112f2c:	66 89 4c 24 3a       	mov    %cx,0x3a(%esp)
            } else {
  112f31:	e9 1a 00 00 00       	jmp    112f50 <lv_draw_rect_main_mid+0x250>
                row_start += 1;
  112f36:	0f bf 44 24 3c       	movswl 0x3c(%esp),%eax
  112f3b:	83 c0 01             	add    $0x1,%eax
  112f3e:	66 89 44 24 3c       	mov    %ax,0x3c(%esp)
                row_end -= 1;
  112f43:	0f bf 4c 24 3a       	movswl 0x3a(%esp),%ecx
  112f48:	83 e9 01             	sub    $0x1,%ecx
  112f4b:	66 89 4c 24 3a       	mov    %cx,0x3a(%esp)
            }
        }
  112f50:	e9 00 00 00 00       	jmp    112f55 <lv_draw_rect_main_mid+0x255>
        if(row_start < 0) row_start = 0;
  112f55:	0f bf 44 24 3c       	movswl 0x3c(%esp),%eax
  112f5a:	83 f8 00             	cmp    $0x0,%eax
  112f5d:	0f 8d 07 00 00 00    	jge    112f6a <lv_draw_rect_main_mid+0x26a>
  112f63:	66 c7 44 24 3c 00 00 	movw   $0x0,0x3c(%esp)

        for(row = row_start; row <= row_end; row++) {
  112f6a:	66 8b 44 24 3c       	mov    0x3c(%esp),%ax
  112f6f:	66 89 44 24 3e       	mov    %ax,0x3e(%esp)
  112f74:	0f bf 44 24 3e       	movswl 0x3e(%esp),%eax
  112f79:	0f bf 4c 24 3a       	movswl 0x3a(%esp),%ecx
  112f7e:	39 c8                	cmp    %ecx,%eax
  112f80:	0f 8f a2 00 00 00    	jg     113028 <lv_draw_rect_main_mid+0x328>
            work_area.y1 = row;
  112f86:	66 8b 44 24 3e       	mov    0x3e(%esp),%ax
  112f8b:	66 89 44 24 42       	mov    %ax,0x42(%esp)
            work_area.y2 = row;
  112f90:	66 8b 44 24 3e       	mov    0x3e(%esp),%ax
  112f95:	66 89 44 24 46       	mov    %ax,0x46(%esp)
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
  112f9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  112f9d:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  112fa1:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  112fa6:	29 d1                	sub    %edx,%ecx
  112fa8:	69 c1 ff 00 00 00    	imul   $0xff,%ecx,%eax
  112fae:	0f bf 4c 24 4c       	movswl 0x4c(%esp),%ecx
  112fb3:	31 d2                	xor    %edx,%edx
  112fb5:	f7 f1                	div    %ecx
  112fb7:	88 44 24 4f          	mov    %al,0x4f(%esp)
            act_color    = lv_color_mix(mcolor, gcolor, mix);
  112fbb:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  112fbf:	89 0c 24             	mov    %ecx,(%esp)
  112fc2:	8d 4c 24 58          	lea    0x58(%esp),%ecx
  112fc6:	8b 09                	mov    (%ecx),%ecx
  112fc8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112fcc:	8d 4c 24 50          	lea    0x50(%esp),%ecx
  112fd0:	8b 09                	mov    (%ecx),%ecx
  112fd2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  112fd6:	0f b6 4c 24 4f       	movzbl 0x4f(%esp),%ecx
  112fdb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  112fdf:	e8 ec 20 00 00       	call   1150d0 <lv_color_mix>
  112fe4:	83 ec 04             	sub    $0x4,%esp
  112fe7:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  112feb:	89 4c 24 30          	mov    %ecx,0x30(%esp)

            lv_draw_fill(&work_area, mask, act_color, opa);
  112fef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  112ff2:	8d 74 24 40          	lea    0x40(%esp),%esi
  112ff6:	89 34 24             	mov    %esi,(%esp)
  112ff9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  112ffd:	8d 4c 24 30          	lea    0x30(%esp),%ecx
  113001:	8b 09                	mov    (%ecx),%ecx
  113003:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113007:	0f b6 4c 24 49       	movzbl 0x49(%esp),%ecx
  11300c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113010:	e8 8b ed ff ff       	call   111da0 <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
  113015:	66 8b 44 24 3e       	mov    0x3e(%esp),%ax
  11301a:	66 83 c0 01          	add    $0x1,%ax
  11301e:	66 89 44 24 3e       	mov    %ax,0x3e(%esp)
  113023:	e9 4c ff ff ff       	jmp    112f74 <lv_draw_rect_main_mid+0x274>
  113028:	e9 00 00 00 00       	jmp    11302d <lv_draw_rect_main_mid+0x32d>
        }
    }
}
  11302d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113030:	5e                   	pop    %esi
  113031:	5f                   	pop    %edi
  113032:	5b                   	pop    %ebx
  113033:	5d                   	pop    %ebp
  113034:	c3                   	ret    
  113035:	66 90                	xchg   %ax,%ax
  113037:	66 90                	xchg   %ax,%ax
  113039:	66 90                	xchg   %ax,%ax
  11303b:	66 90                	xchg   %ax,%ax
  11303d:	66 90                	xchg   %ax,%ax
  11303f:	90                   	nop

00113040 <lv_draw_rect_main_corner>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                     lv_opa_t opa_scale)
{
  113040:	55                   	push   %ebp
  113041:	89 e5                	mov    %esp,%ebp
  113043:	53                   	push   %ebx
  113044:	57                   	push   %edi
  113045:	56                   	push   %esi
  113046:	83 e4 f8             	and    $0xfffffff8,%esp
  113049:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  11304f:	8a 45 14             	mov    0x14(%ebp),%al
  113052:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113055:	8b 55 0c             	mov    0xc(%ebp),%edx
  113058:	8b 75 08             	mov    0x8(%ebp),%esi
    uint16_t radius = style->body.radius;
  11305b:	8b 7d 10             	mov    0x10(%ebp),%edi
  11305e:	66 8b 5f 0c          	mov    0xc(%edi),%bx
  113062:	66 89 9c 24 da 00 00 	mov    %bx,0xda(%esp)
  113069:	00 
  11306a:	88 44 24 27          	mov    %al,0x27(%esp)
  11306e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  113072:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  113076:	89 74 24 18          	mov    %esi,0x18(%esp)
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
  11307a:	e8 51 d1 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  11307f:	89 04 24             	mov    %eax,(%esp)
  113082:	e8 e9 47 00 00       	call   117870 <lv_disp_get_antialiasing>
  113087:	24 01                	and    $0x1,%al
  113089:	88 84 24 d9 00 00 00 	mov    %al,0xd9(%esp)

    lv_color_t mcolor = style->body.main_color;
  113090:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113093:	8b 49 04             	mov    0x4(%ecx),%ecx
  113096:	89 8c 24 d0 00 00 00 	mov    %ecx,0xd0(%esp)
    lv_color_t gcolor = style->body.grad_color;
  11309d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1130a0:	8b 49 08             	mov    0x8(%ecx),%ecx
  1130a3:	89 8c 24 c8 00 00 00 	mov    %ecx,0xc8(%esp)
    lv_color_t act_color;
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
  1130aa:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  1130ae:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  1130b4:	0f 85 10 00 00 00    	jne    1130ca <lv_draw_rect_main_corner+0x8a>
  1130ba:	8b 45 10             	mov    0x10(%ebp),%eax
  1130bd:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  1130c1:	89 44 24 14          	mov    %eax,0x14(%esp)
  1130c5:	e9 1b 00 00 00       	jmp    1130e5 <lv_draw_rect_main_corner+0xa5>
  1130ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1130cd:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
  1130d1:	0f b7 c8             	movzwl %ax,%ecx
  1130d4:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  1130d8:	0f af ca             	imul   %edx,%ecx
  1130db:	0f b7 d1             	movzwl %cx,%edx
  1130de:	c1 fa 08             	sar    $0x8,%edx
  1130e1:	89 54 24 14          	mov    %edx,0x14(%esp)
  1130e5:	8b 44 24 14          	mov    0x14(%esp),%eax
  1130e9:	88 84 24 bf 00 00 00 	mov    %al,0xbf(%esp)
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
  1130f0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1130f3:	89 0c 24             	mov    %ecx,(%esp)
  1130f6:	e8 a5 fb ff ff       	call   112ca0 <lv_area_get_height>
  1130fb:	66 89 84 24 bc 00 00 	mov    %ax,0xbc(%esp)
  113102:	00 
    lv_coord_t width  = lv_area_get_width(coords);
  113103:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113106:	89 0c 24             	mov    %ecx,(%esp)
  113109:	e8 c2 fb ff ff       	call   112cd0 <lv_area_get_width>
  11310e:	66 89 84 24 ba 00 00 	mov    %ax,0xba(%esp)
  113115:	00 

    radius = lv_draw_cont_radius_corr(radius, width, height);
  113116:	66 8b 84 24 da 00 00 	mov    0xda(%esp),%ax
  11311d:	00 
  11311e:	66 8b 94 24 ba 00 00 	mov    0xba(%esp),%dx
  113125:	00 
  113126:	0f b7 c8             	movzwl %ax,%ecx
  113129:	89 0c 24             	mov    %ecx,(%esp)
  11312c:	0f bf ca             	movswl %dx,%ecx
  11312f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113133:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  11313a:	00 
  11313b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11313f:	e8 ac 1e 00 00       	call   114ff0 <lv_draw_cont_radius_corr>
  113144:	66 89 84 24 da 00 00 	mov    %ax,0xda(%esp)
  11314b:	00 
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
  11314c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11314f:	0f bf 09             	movswl (%ecx),%ecx
  113152:	0f b7 b4 24 da 00 00 	movzwl 0xda(%esp),%esi
  113159:	00 
  11315a:	01 f1                	add    %esi,%ecx
  11315c:	8a 9c 24 d9 00 00 00 	mov    0xd9(%esp),%bl
  113163:	80 e3 01             	and    $0x1,%bl
  113166:	0f b6 f3             	movzbl %bl,%esi
  113169:	01 f1                	add    %esi,%ecx
  11316b:	66 89 8c 24 b0 00 00 	mov    %cx,0xb0(%esp)
  113172:	00 
    lt_origo.y = coords->y1 + radius + aa;
  113173:	8b 75 08             	mov    0x8(%ebp),%esi
  113176:	0f bf 76 02          	movswl 0x2(%esi),%esi
  11317a:	0f b7 bc 24 da 00 00 	movzwl 0xda(%esp),%edi
  113181:	00 
  113182:	01 fe                	add    %edi,%esi
  113184:	8a 9c 24 d9 00 00 00 	mov    0xd9(%esp),%bl
  11318b:	80 e3 01             	and    $0x1,%bl
  11318e:	0f b6 fb             	movzbl %bl,%edi
  113191:	01 fe                	add    %edi,%esi
  113193:	66 89 b4 24 b2 00 00 	mov    %si,0xb2(%esp)
  11319a:	00 

    lb_origo.x = coords->x1 + radius + aa;
  11319b:	8b 7d 08             	mov    0x8(%ebp),%edi
  11319e:	0f bf 3f             	movswl (%edi),%edi
  1131a1:	0f b7 9c 24 da 00 00 	movzwl 0xda(%esp),%ebx
  1131a8:	00 
  1131a9:	01 df                	add    %ebx,%edi
  1131ab:	8a 84 24 d9 00 00 00 	mov    0xd9(%esp),%al
  1131b2:	24 01                	and    $0x1,%al
  1131b4:	0f b6 d8             	movzbl %al,%ebx
  1131b7:	01 df                	add    %ebx,%edi
  1131b9:	66 89 bc 24 a8 00 00 	mov    %di,0xa8(%esp)
  1131c0:	00 
    lb_origo.y = coords->y2 - radius - aa;
  1131c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1131c4:	0f bf 5b 06          	movswl 0x6(%ebx),%ebx
  1131c8:	0f b7 84 24 da 00 00 	movzwl 0xda(%esp),%eax
  1131cf:	00 
  1131d0:	29 c3                	sub    %eax,%ebx
  1131d2:	8a 84 24 d9 00 00 00 	mov    0xd9(%esp),%al
  1131d9:	24 01                	and    $0x1,%al
  1131db:	0f b6 c0             	movzbl %al,%eax
  1131de:	29 c3                	sub    %eax,%ebx
  1131e0:	66 89 9c 24 aa 00 00 	mov    %bx,0xaa(%esp)
  1131e7:	00 

    rt_origo.x = coords->x2 - radius - aa;
  1131e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1131eb:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1131ef:	0f b7 8c 24 da 00 00 	movzwl 0xda(%esp),%ecx
  1131f6:	00 
  1131f7:	29 c8                	sub    %ecx,%eax
  1131f9:	8a 8c 24 d9 00 00 00 	mov    0xd9(%esp),%cl
  113200:	80 e1 01             	and    $0x1,%cl
  113203:	0f b6 c9             	movzbl %cl,%ecx
  113206:	29 c8                	sub    %ecx,%eax
  113208:	66 89 84 24 a0 00 00 	mov    %ax,0xa0(%esp)
  11320f:	00 
    rt_origo.y = coords->y1 + radius + aa;
  113210:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113213:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  113217:	0f b7 84 24 da 00 00 	movzwl 0xda(%esp),%eax
  11321e:	00 
  11321f:	01 c1                	add    %eax,%ecx
  113221:	8a 84 24 d9 00 00 00 	mov    0xd9(%esp),%al
  113228:	24 01                	and    $0x1,%al
  11322a:	0f b6 c0             	movzbl %al,%eax
  11322d:	01 c1                	add    %eax,%ecx
  11322f:	66 89 8c 24 a2 00 00 	mov    %cx,0xa2(%esp)
  113236:	00 

    rb_origo.x = coords->x2 - radius - aa;
  113237:	8b 45 08             	mov    0x8(%ebp),%eax
  11323a:	0f bf 40 04          	movswl 0x4(%eax),%eax
  11323e:	0f b7 8c 24 da 00 00 	movzwl 0xda(%esp),%ecx
  113245:	00 
  113246:	29 c8                	sub    %ecx,%eax
  113248:	8a 8c 24 d9 00 00 00 	mov    0xd9(%esp),%cl
  11324f:	80 e1 01             	and    $0x1,%cl
  113252:	0f b6 c9             	movzbl %cl,%ecx
  113255:	29 c8                	sub    %ecx,%eax
  113257:	66 89 84 24 98 00 00 	mov    %ax,0x98(%esp)
  11325e:	00 
    rb_origo.y = coords->y2 - radius - aa;
  11325f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113262:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  113266:	0f b7 84 24 da 00 00 	movzwl 0xda(%esp),%eax
  11326d:	00 
  11326e:	29 c1                	sub    %eax,%ecx
  113270:	8a 84 24 d9 00 00 00 	mov    0xd9(%esp),%al
  113277:	24 01                	and    $0x1,%al
  113279:	0f b6 c0             	movzbl %al,%eax
  11327c:	29 c1                	sub    %eax,%ecx
  11327e:	66 89 8c 24 9a 00 00 	mov    %cx,0x9a(%esp)
  113285:	00 
    lv_area_t mid_bot_area;
    lv_area_t edge_bot_area;

    lv_point_t cir;
    lv_coord_t cir_tmp;
    lv_circ_init(&cir, &cir_tmp, radius);
  113286:	8d 44 24 70          	lea    0x70(%esp),%eax
  11328a:	89 04 24             	mov    %eax,(%esp)
  11328d:	8d 44 24 6e          	lea    0x6e(%esp),%eax
  113291:	89 44 24 04          	mov    %eax,0x4(%esp)
  113295:	0f bf 84 24 da 00 00 	movswl 0xda(%esp),%eax
  11329c:	00 
  11329d:	89 44 24 08          	mov    %eax,0x8(%esp)
  1132a1:	e8 aa 47 00 00       	call   117a50 <lv_circ_init>
  1132a6:	31 c0                	xor    %eax,%eax

    /*Init the areas*/
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
  1132a8:	0f bf 8c 24 a8 00 00 	movswl 0xa8(%esp),%ecx
  1132af:	00 
  1132b0:	0f bf 54 24 70       	movswl 0x70(%esp),%edx
  1132b5:	29 d0                	sub    %edx,%eax
  1132b7:	01 c1                	add    %eax,%ecx
  1132b9:	0f bf 84 24 aa 00 00 	movswl 0xaa(%esp),%eax
  1132c0:	00 
  1132c1:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  1132c6:	01 d0                	add    %edx,%eax
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
  1132c8:	0f bf 94 24 98 00 00 	movswl 0x98(%esp),%edx
  1132cf:	00 
  1132d0:	0f bf 74 24 70       	movswl 0x70(%esp),%esi
  1132d5:	01 f2                	add    %esi,%edx
  1132d7:	0f bf b4 24 9a 00 00 	movswl 0x9a(%esp),%esi
  1132de:	00 
  1132df:	0f bf 7c 24 72       	movswl 0x72(%esp),%edi
  1132e4:	01 fe                	add    %edi,%esi
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
  1132e6:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
  1132ed:	89 3c 24             	mov    %edi,(%esp)
  1132f0:	0f bf f9             	movswl %cx,%edi
  1132f3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1132f7:	0f bf f8             	movswl %ax,%edi
  1132fa:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1132fe:	0f bf fa             	movswl %dx,%edi
  113301:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  113305:	0f bf fe             	movswl %si,%edi
  113308:	89 7c 24 10          	mov    %edi,0x10(%esp)
  11330c:	e8 4f 48 00 00       	call   117b60 <lv_area_set>
  113311:	31 ff                	xor    %edi,%edi

    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
  113313:	0f bf 84 24 a8 00 00 	movswl 0xa8(%esp),%eax
  11331a:	00 
  11331b:	0f bf 4c 24 72       	movswl 0x72(%esp),%ecx
  113320:	29 cf                	sub    %ecx,%edi
  113322:	01 f8                	add    %edi,%eax
  113324:	0f bf 8c 24 aa 00 00 	movswl 0xaa(%esp),%ecx
  11332b:	00 
  11332c:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  113331:	01 f9                	add    %edi,%ecx
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
  113333:	0f bf bc 24 98 00 00 	movswl 0x98(%esp),%edi
  11333a:	00 
  11333b:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  113340:	01 d7                	add    %edx,%edi
  113342:	0f bf 94 24 9a 00 00 	movswl 0x9a(%esp),%edx
  113349:	00 
  11334a:	0f bf 74 24 70       	movswl 0x70(%esp),%esi
  11334f:	01 f2                	add    %esi,%edx
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
  113351:	8d 74 24 78          	lea    0x78(%esp),%esi
  113355:	89 34 24             	mov    %esi,(%esp)
  113358:	0f bf f0             	movswl %ax,%esi
  11335b:	89 74 24 04          	mov    %esi,0x4(%esp)
  11335f:	0f bf f1             	movswl %cx,%esi
  113362:	89 74 24 08          	mov    %esi,0x8(%esp)
  113366:	0f bf f7             	movswl %di,%esi
  113369:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11336d:	0f bf f2             	movswl %dx,%esi
  113370:	89 74 24 10          	mov    %esi,0x10(%esp)
  113374:	e8 e7 47 00 00       	call   117b60 <lv_area_set>
  113379:	31 f6                	xor    %esi,%esi

    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
  11337b:	0f bf 84 24 b0 00 00 	movswl 0xb0(%esp),%eax
  113382:	00 
  113383:	0f bf 4c 24 70       	movswl 0x70(%esp),%ecx
  113388:	89 f2                	mov    %esi,%edx
  11338a:	29 ca                	sub    %ecx,%edx
  11338c:	01 d0                	add    %edx,%eax
  11338e:	0f bf 8c 24 b2 00 00 	movswl 0xb2(%esp),%ecx
  113395:	00 
  113396:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  11339b:	89 f7                	mov    %esi,%edi
  11339d:	29 d7                	sub    %edx,%edi
  11339f:	01 f9                	add    %edi,%ecx
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
  1133a1:	0f bf 94 24 a0 00 00 	movswl 0xa0(%esp),%edx
  1133a8:	00 
  1133a9:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  1133ae:	01 fa                	add    %edi,%edx
  1133b0:	0f bf bc 24 a2 00 00 	movswl 0xa2(%esp),%edi
  1133b7:	00 
  1133b8:	0f bf 5c 24 72       	movswl 0x72(%esp),%ebx
  1133bd:	29 de                	sub    %ebx,%esi
  1133bf:	01 f7                	add    %esi,%edi
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
  1133c1:	8d b4 24 88 00 00 00 	lea    0x88(%esp),%esi
  1133c8:	89 34 24             	mov    %esi,(%esp)
  1133cb:	0f bf f0             	movswl %ax,%esi
  1133ce:	89 74 24 04          	mov    %esi,0x4(%esp)
  1133d2:	0f bf f1             	movswl %cx,%esi
  1133d5:	89 74 24 08          	mov    %esi,0x8(%esp)
  1133d9:	0f bf f2             	movswl %dx,%esi
  1133dc:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1133e0:	0f bf f7             	movswl %di,%esi
  1133e3:	89 74 24 10          	mov    %esi,0x10(%esp)
  1133e7:	e8 74 47 00 00       	call   117b60 <lv_area_set>
  1133ec:	31 f6                	xor    %esi,%esi

    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
  1133ee:	0f bf 9c 24 b0 00 00 	movswl 0xb0(%esp),%ebx
  1133f5:	00 
  1133f6:	0f bf 44 24 72       	movswl 0x72(%esp),%eax
  1133fb:	89 f1                	mov    %esi,%ecx
  1133fd:	29 c1                	sub    %eax,%ecx
  1133ff:	01 cb                	add    %ecx,%ebx
  113401:	0f bf 84 24 b2 00 00 	movswl 0xb2(%esp),%eax
  113408:	00 
  113409:	0f bf 4c 24 70       	movswl 0x70(%esp),%ecx
  11340e:	89 f2                	mov    %esi,%edx
  113410:	29 ca                	sub    %ecx,%edx
  113412:	01 d0                	add    %edx,%eax
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
  113414:	0f bf 8c 24 a0 00 00 	movswl 0xa0(%esp),%ecx
  11341b:	00 
  11341c:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  113421:	01 d1                	add    %edx,%ecx
  113423:	0f bf 94 24 a2 00 00 	movswl 0xa2(%esp),%edx
  11342a:	00 
  11342b:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  113430:	29 fe                	sub    %edi,%esi
  113432:	01 f2                	add    %esi,%edx
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
  113434:	8d b4 24 90 00 00 00 	lea    0x90(%esp),%esi
  11343b:	89 34 24             	mov    %esi,(%esp)
  11343e:	0f bf f3             	movswl %bx,%esi
  113441:	89 74 24 04          	mov    %esi,0x4(%esp)
  113445:	0f bf f0             	movswl %ax,%esi
  113448:	89 74 24 08          	mov    %esi,0x8(%esp)
  11344c:	0f bf f1             	movswl %cx,%esi
  11344f:	89 74 24 0c          	mov    %esi,0xc(%esp)
  113453:	0f bf f2             	movswl %dx,%esi
  113456:	89 74 24 10          	mov    %esi,0x10(%esp)
  11345a:	e8 01 47 00 00       	call   117b60 <lv_area_set>
    lv_color_t aa_color_hor_top;
    lv_color_t aa_color_hor_bottom;
    lv_color_t aa_color_ver;
#endif

    while(lv_circ_cont(&cir)) {
  11345f:	8d 44 24 70          	lea    0x70(%esp),%eax
  113463:	89 04 24             	mov    %eax,(%esp)
  113466:	e8 25 46 00 00       	call   117a90 <lv_circ_cont>
  11346b:	a8 01                	test   $0x1,%al
  11346d:	0f 85 05 00 00 00    	jne    113478 <lv_draw_rect_main_corner+0x438>
  113473:	e9 ad 05 00 00       	jmp    113a25 <lv_draw_rect_main_corner+0x9e5>
                out_x_last      = cir.x;
                out_y_seg_start = out_y_seg_end;
            }
        }
#endif
        uint8_t edge_top_refr = 0;
  113478:	c6 44 24 6d 00       	movb   $0x0,0x6d(%esp)
        uint8_t mid_top_refr  = 0;
  11347d:	c6 44 24 6c 00       	movb   $0x0,0x6c(%esp)
        uint8_t mid_bot_refr  = 0;
  113482:	c6 44 24 6b 00       	movb   $0x0,0x6b(%esp)
        uint8_t edge_bot_refr = 0;
  113487:	c6 44 24 6a 00       	movb   $0x0,0x6a(%esp)

        /* If a new row coming draw the previous
         * The y coordinate can remain the same so wait for a new*/
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
  11348c:	0f bf 84 24 82 00 00 	movswl 0x82(%esp),%eax
  113493:	00 
  113494:	0f bf 4c 24 72       	movswl 0x72(%esp),%ecx
  113499:	0f bf 94 24 aa 00 00 	movswl 0xaa(%esp),%edx
  1134a0:	00 
  1134a1:	01 d1                	add    %edx,%ecx
  1134a3:	39 c8                	cmp    %ecx,%eax
  1134a5:	0f 84 05 00 00 00    	je     1134b0 <lv_draw_rect_main_corner+0x470>
  1134ab:	c6 44 24 6b 01       	movb   $0x1,0x6b(%esp)

        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
  1134b0:	0f bf 44 24 7a       	movswl 0x7a(%esp),%eax
  1134b5:	0f bf 4c 24 70       	movswl 0x70(%esp),%ecx
  1134ba:	0f bf 94 24 aa 00 00 	movswl 0xaa(%esp),%edx
  1134c1:	00 
  1134c2:	01 d1                	add    %edx,%ecx
  1134c4:	39 c8                	cmp    %ecx,%eax
  1134c6:	0f 84 05 00 00 00    	je     1134d1 <lv_draw_rect_main_corner+0x491>
  1134cc:	c6 44 24 6a 01       	movb   $0x1,0x6a(%esp)
  1134d1:	31 c0                	xor    %eax,%eax

        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
  1134d3:	0f bf 8c 24 8a 00 00 	movswl 0x8a(%esp),%ecx
  1134da:	00 
  1134db:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  1134e0:	29 d0                	sub    %edx,%eax
  1134e2:	0f bf 94 24 b2 00 00 	movswl 0xb2(%esp),%edx
  1134e9:	00 
  1134ea:	01 d0                	add    %edx,%eax
  1134ec:	39 c1                	cmp    %eax,%ecx
  1134ee:	0f 84 05 00 00 00    	je     1134f9 <lv_draw_rect_main_corner+0x4b9>
  1134f4:	c6 44 24 6c 01       	movb   $0x1,0x6c(%esp)
  1134f9:	31 c0                	xor    %eax,%eax

        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
  1134fb:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  113502:	00 
  113503:	0f bf 54 24 70       	movswl 0x70(%esp),%edx
  113508:	29 d0                	sub    %edx,%eax
  11350a:	0f bf 94 24 b2 00 00 	movswl 0xb2(%esp),%edx
  113511:	00 
  113512:	01 d0                	add    %edx,%eax
  113514:	39 c1                	cmp    %eax,%ecx
  113516:	0f 84 05 00 00 00    	je     113521 <lv_draw_rect_main_corner+0x4e1>
  11351c:	c6 44 24 6d 01       	movb   $0x1,0x6d(%esp)

        /*Draw the areas which are not disabled*/
        if(edge_top_refr != 0) {
  113521:	0f b6 44 24 6d       	movzbl 0x6d(%esp),%eax
  113526:	83 f8 00             	cmp    $0x0,%eax
  113529:	0f 84 c0 00 00 00    	je     1135ef <lv_draw_rect_main_corner+0x5af>
            if(mcolor.full == gcolor.full)
  11352f:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113536:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  11353d:	0f 85 13 00 00 00    	jne    113556 <lv_draw_rect_main_corner+0x516>
                act_color = mcolor;
  113543:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  11354a:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  113551:	e9 6a 00 00 00       	jmp    1135c0 <lv_draw_rect_main_corner+0x580>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
  113556:	8b 45 08             	mov    0x8(%ebp),%eax
  113559:	0f bf 40 06          	movswl 0x6(%eax),%eax
  11355d:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  113564:	00 
  113565:	29 c8                	sub    %ecx,%eax
  113567:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  11356d:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113574:	00 
  113575:	31 d2                	xor    %edx,%edx
  113577:	f7 f1                	div    %ecx
  113579:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
                act_color = lv_color_mix(mcolor, gcolor, mix);
  113580:	8d 4c 24 60          	lea    0x60(%esp),%ecx
  113584:	89 0c 24             	mov    %ecx,(%esp)
  113587:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  11358e:	8b 09                	mov    (%ecx),%ecx
  113590:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113594:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  11359b:	8b 09                	mov    (%ecx),%ecx
  11359d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1135a1:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  1135a8:	00 
  1135a9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1135ad:	e8 1e 1b 00 00       	call   1150d0 <lv_color_mix>
  1135b2:	83 ec 04             	sub    $0x4,%esp
  1135b5:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  1135b9:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
            }
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
  1135c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1135c3:	8d 8c 24 90 00 00 00 	lea    0x90(%esp),%ecx
  1135ca:	89 0c 24             	mov    %ecx,(%esp)
  1135cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1135d1:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  1135d8:	8b 00                	mov    (%eax),%eax
  1135da:	89 44 24 08          	mov    %eax,0x8(%esp)
  1135de:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  1135e5:	00 
  1135e6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1135ea:	e8 b1 e7 ff ff       	call   111da0 <lv_draw_fill>
        }

        if(mid_top_refr != 0) {
  1135ef:	0f b6 44 24 6c       	movzbl 0x6c(%esp),%eax
  1135f4:	83 f8 00             	cmp    $0x0,%eax
  1135f7:	0f 84 c0 00 00 00    	je     1136bd <lv_draw_rect_main_corner+0x67d>
            if(mcolor.full == gcolor.full)
  1135fd:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113604:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  11360b:	0f 85 13 00 00 00    	jne    113624 <lv_draw_rect_main_corner+0x5e4>
                act_color = mcolor;
  113611:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113618:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  11361f:	e9 6a 00 00 00       	jmp    11368e <lv_draw_rect_main_corner+0x64e>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
  113624:	8b 45 08             	mov    0x8(%ebp),%eax
  113627:	0f bf 40 06          	movswl 0x6(%eax),%eax
  11362b:	0f bf 8c 24 8a 00 00 	movswl 0x8a(%esp),%ecx
  113632:	00 
  113633:	29 c8                	sub    %ecx,%eax
  113635:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  11363b:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113642:	00 
  113643:	31 d2                	xor    %edx,%edx
  113645:	f7 f1                	div    %ecx
  113647:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
                act_color = lv_color_mix(mcolor, gcolor, mix);
  11364e:	8d 4c 24 58          	lea    0x58(%esp),%ecx
  113652:	89 0c 24             	mov    %ecx,(%esp)
  113655:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  11365c:	8b 09                	mov    (%ecx),%ecx
  11365e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113662:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113669:	8b 09                	mov    (%ecx),%ecx
  11366b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11366f:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113676:	00 
  113677:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11367b:	e8 50 1a 00 00       	call   1150d0 <lv_color_mix>
  113680:	83 ec 04             	sub    $0x4,%esp
  113683:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  113687:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
            }
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
  11368e:	8b 45 0c             	mov    0xc(%ebp),%eax
  113691:	8d 8c 24 88 00 00 00 	lea    0x88(%esp),%ecx
  113698:	89 0c 24             	mov    %ecx,(%esp)
  11369b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11369f:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  1136a6:	8b 00                	mov    (%eax),%eax
  1136a8:	89 44 24 08          	mov    %eax,0x8(%esp)
  1136ac:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  1136b3:	00 
  1136b4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1136b8:	e8 e3 e6 ff ff       	call   111da0 <lv_draw_fill>
        }

        if(mid_bot_refr != 0) {
  1136bd:	0f b6 44 24 6b       	movzbl 0x6b(%esp),%eax
  1136c2:	83 f8 00             	cmp    $0x0,%eax
  1136c5:	0f 84 c0 00 00 00    	je     11378b <lv_draw_rect_main_corner+0x74b>
            if(mcolor.full == gcolor.full)
  1136cb:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  1136d2:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  1136d9:	0f 85 13 00 00 00    	jne    1136f2 <lv_draw_rect_main_corner+0x6b2>
                act_color = mcolor;
  1136df:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  1136e6:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  1136ed:	e9 6a 00 00 00       	jmp    11375c <lv_draw_rect_main_corner+0x71c>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
  1136f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1136f5:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1136f9:	0f bf 8c 24 82 00 00 	movswl 0x82(%esp),%ecx
  113700:	00 
  113701:	29 c8                	sub    %ecx,%eax
  113703:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  113709:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113710:	00 
  113711:	31 d2                	xor    %edx,%edx
  113713:	f7 f1                	div    %ecx
  113715:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
                act_color = lv_color_mix(mcolor, gcolor, mix);
  11371c:	8d 4c 24 50          	lea    0x50(%esp),%ecx
  113720:	89 0c 24             	mov    %ecx,(%esp)
  113723:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  11372a:	8b 09                	mov    (%ecx),%ecx
  11372c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113730:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113737:	8b 09                	mov    (%ecx),%ecx
  113739:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11373d:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113744:	00 
  113745:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113749:	e8 82 19 00 00       	call   1150d0 <lv_color_mix>
  11374e:	83 ec 04             	sub    $0x4,%esp
  113751:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  113755:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
            }
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
  11375c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11375f:	8d 8c 24 80 00 00 00 	lea    0x80(%esp),%ecx
  113766:	89 0c 24             	mov    %ecx,(%esp)
  113769:	89 44 24 04          	mov    %eax,0x4(%esp)
  11376d:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  113774:	8b 00                	mov    (%eax),%eax
  113776:	89 44 24 08          	mov    %eax,0x8(%esp)
  11377a:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113781:	00 
  113782:	89 44 24 0c          	mov    %eax,0xc(%esp)
  113786:	e8 15 e6 ff ff       	call   111da0 <lv_draw_fill>
        }

        if(edge_bot_refr != 0) {
  11378b:	0f b6 44 24 6a       	movzbl 0x6a(%esp),%eax
  113790:	83 f8 00             	cmp    $0x0,%eax
  113793:	0f 84 ba 00 00 00    	je     113853 <lv_draw_rect_main_corner+0x813>

            if(mcolor.full == gcolor.full)
  113799:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  1137a0:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  1137a7:	0f 85 13 00 00 00    	jne    1137c0 <lv_draw_rect_main_corner+0x780>
                act_color = mcolor;
  1137ad:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  1137b4:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  1137bb:	e9 67 00 00 00       	jmp    113827 <lv_draw_rect_main_corner+0x7e7>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
  1137c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1137c3:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1137c7:	0f bf 4c 24 7a       	movswl 0x7a(%esp),%ecx
  1137cc:	29 c8                	sub    %ecx,%eax
  1137ce:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  1137d4:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  1137db:	00 
  1137dc:	31 d2                	xor    %edx,%edx
  1137de:	f7 f1                	div    %ecx
  1137e0:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
                act_color = lv_color_mix(mcolor, gcolor, mix);
  1137e7:	8d 4c 24 48          	lea    0x48(%esp),%ecx
  1137eb:	89 0c 24             	mov    %ecx,(%esp)
  1137ee:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  1137f5:	8b 09                	mov    (%ecx),%ecx
  1137f7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1137fb:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113802:	8b 09                	mov    (%ecx),%ecx
  113804:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113808:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  11380f:	00 
  113810:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113814:	e8 b7 18 00 00       	call   1150d0 <lv_color_mix>
  113819:	83 ec 04             	sub    $0x4,%esp
  11381c:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  113820:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
            }
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
  113827:	8b 45 0c             	mov    0xc(%ebp),%eax
  11382a:	8d 4c 24 78          	lea    0x78(%esp),%ecx
  11382e:	89 0c 24             	mov    %ecx,(%esp)
  113831:	89 44 24 04          	mov    %eax,0x4(%esp)
  113835:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  11383c:	8b 00                	mov    (%eax),%eax
  11383e:	89 44 24 08          	mov    %eax,0x8(%esp)
  113842:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113849:	00 
  11384a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11384e:	e8 4d e5 ff ff       	call   111da0 <lv_draw_fill>
  113853:	31 c0                	xor    %eax,%eax
        }

        /*Save the current coordinates*/
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
  113855:	0f bf 8c 24 a8 00 00 	movswl 0xa8(%esp),%ecx
  11385c:	00 
  11385d:	0f bf 54 24 70       	movswl 0x70(%esp),%edx
  113862:	29 d0                	sub    %edx,%eax
  113864:	01 c1                	add    %eax,%ecx
  113866:	0f bf 84 24 aa 00 00 	movswl 0xaa(%esp),%eax
  11386d:	00 
  11386e:	0f bf 54 24 72       	movswl 0x72(%esp),%edx
  113873:	01 d0                	add    %edx,%eax
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
  113875:	0f bf 94 24 98 00 00 	movswl 0x98(%esp),%edx
  11387c:	00 
  11387d:	0f bf 74 24 70       	movswl 0x70(%esp),%esi
  113882:	01 f2                	add    %esi,%edx
  113884:	0f bf b4 24 9a 00 00 	movswl 0x9a(%esp),%esi
  11388b:	00 
  11388c:	0f bf 7c 24 72       	movswl 0x72(%esp),%edi
  113891:	01 fe                	add    %edi,%esi
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
  113893:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
  11389a:	89 3c 24             	mov    %edi,(%esp)
  11389d:	0f bf f9             	movswl %cx,%edi
  1138a0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1138a4:	0f bf f8             	movswl %ax,%edi
  1138a7:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1138ab:	0f bf fa             	movswl %dx,%edi
  1138ae:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1138b2:	0f bf fe             	movswl %si,%edi
  1138b5:	89 7c 24 10          	mov    %edi,0x10(%esp)
  1138b9:	e8 a2 42 00 00       	call   117b60 <lv_area_set>
  1138be:	31 ff                	xor    %edi,%edi

        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
  1138c0:	0f bf 9c 24 a8 00 00 	movswl 0xa8(%esp),%ebx
  1138c7:	00 
  1138c8:	0f bf 44 24 72       	movswl 0x72(%esp),%eax
  1138cd:	29 c7                	sub    %eax,%edi
  1138cf:	01 fb                	add    %edi,%ebx
  1138d1:	0f bf 84 24 aa 00 00 	movswl 0xaa(%esp),%eax
  1138d8:	00 
  1138d9:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  1138de:	01 f8                	add    %edi,%eax
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
  1138e0:	0f bf bc 24 98 00 00 	movswl 0x98(%esp),%edi
  1138e7:	00 
  1138e8:	0f bf 4c 24 72       	movswl 0x72(%esp),%ecx
  1138ed:	01 cf                	add    %ecx,%edi
  1138ef:	0f bf 8c 24 9a 00 00 	movswl 0x9a(%esp),%ecx
  1138f6:	00 
  1138f7:	0f bf 54 24 70       	movswl 0x70(%esp),%edx
  1138fc:	01 d1                	add    %edx,%ecx
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
  1138fe:	8d 54 24 78          	lea    0x78(%esp),%edx
  113902:	89 14 24             	mov    %edx,(%esp)
  113905:	0f bf d3             	movswl %bx,%edx
  113908:	89 54 24 04          	mov    %edx,0x4(%esp)
  11390c:	0f bf d0             	movswl %ax,%edx
  11390f:	89 54 24 08          	mov    %edx,0x8(%esp)
  113913:	0f bf d7             	movswl %di,%edx
  113916:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11391a:	0f bf d1             	movswl %cx,%edx
  11391d:	89 54 24 10          	mov    %edx,0x10(%esp)
  113921:	e8 3a 42 00 00       	call   117b60 <lv_area_set>
  113926:	31 d2                	xor    %edx,%edx

        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
  113928:	0f bf 84 24 b0 00 00 	movswl 0xb0(%esp),%eax
  11392f:	00 
  113930:	0f bf 4c 24 70       	movswl 0x70(%esp),%ecx
  113935:	89 d6                	mov    %edx,%esi
  113937:	29 ce                	sub    %ecx,%esi
  113939:	01 f0                	add    %esi,%eax
  11393b:	0f bf 8c 24 b2 00 00 	movswl 0xb2(%esp),%ecx
  113942:	00 
  113943:	0f bf 74 24 72       	movswl 0x72(%esp),%esi
  113948:	89 d7                	mov    %edx,%edi
  11394a:	29 f7                	sub    %esi,%edi
  11394c:	01 f9                	add    %edi,%ecx
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
  11394e:	0f bf b4 24 a0 00 00 	movswl 0xa0(%esp),%esi
  113955:	00 
  113956:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  11395b:	01 fe                	add    %edi,%esi
  11395d:	0f bf bc 24 a2 00 00 	movswl 0xa2(%esp),%edi
  113964:	00 
  113965:	0f bf 5c 24 72       	movswl 0x72(%esp),%ebx
  11396a:	29 da                	sub    %ebx,%edx
  11396c:	01 d7                	add    %edx,%edi
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
  11396e:	8d 94 24 88 00 00 00 	lea    0x88(%esp),%edx
  113975:	89 14 24             	mov    %edx,(%esp)
  113978:	0f bf d0             	movswl %ax,%edx
  11397b:	89 54 24 04          	mov    %edx,0x4(%esp)
  11397f:	0f bf d1             	movswl %cx,%edx
  113982:	89 54 24 08          	mov    %edx,0x8(%esp)
  113986:	0f bf d6             	movswl %si,%edx
  113989:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11398d:	0f bf d7             	movswl %di,%edx
  113990:	89 54 24 10          	mov    %edx,0x10(%esp)
  113994:	e8 c7 41 00 00       	call   117b60 <lv_area_set>
  113999:	31 d2                	xor    %edx,%edx

        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
  11399b:	0f bf 9c 24 b0 00 00 	movswl 0xb0(%esp),%ebx
  1139a2:	00 
  1139a3:	0f bf 44 24 72       	movswl 0x72(%esp),%eax
  1139a8:	89 d1                	mov    %edx,%ecx
  1139aa:	29 c1                	sub    %eax,%ecx
  1139ac:	01 cb                	add    %ecx,%ebx
  1139ae:	0f bf 84 24 b2 00 00 	movswl 0xb2(%esp),%eax
  1139b5:	00 
  1139b6:	0f bf 4c 24 70       	movswl 0x70(%esp),%ecx
  1139bb:	89 d6                	mov    %edx,%esi
  1139bd:	29 ce                	sub    %ecx,%esi
  1139bf:	01 f0                	add    %esi,%eax
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
  1139c1:	0f bf 8c 24 a0 00 00 	movswl 0xa0(%esp),%ecx
  1139c8:	00 
  1139c9:	0f bf 74 24 72       	movswl 0x72(%esp),%esi
  1139ce:	01 f1                	add    %esi,%ecx
  1139d0:	0f bf b4 24 a2 00 00 	movswl 0xa2(%esp),%esi
  1139d7:	00 
  1139d8:	0f bf 7c 24 70       	movswl 0x70(%esp),%edi
  1139dd:	29 fa                	sub    %edi,%edx
  1139df:	01 d6                	add    %edx,%esi
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
  1139e1:	8d 94 24 90 00 00 00 	lea    0x90(%esp),%edx
  1139e8:	89 14 24             	mov    %edx,(%esp)
  1139eb:	0f bf d3             	movswl %bx,%edx
  1139ee:	89 54 24 04          	mov    %edx,0x4(%esp)
  1139f2:	0f bf d0             	movswl %ax,%edx
  1139f5:	89 54 24 08          	mov    %edx,0x8(%esp)
  1139f9:	0f bf d1             	movswl %cx,%edx
  1139fc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  113a00:	0f bf d6             	movswl %si,%edx
  113a03:	89 54 24 10          	mov    %edx,0x10(%esp)
  113a07:	e8 54 41 00 00       	call   117b60 <lv_area_set>

        lv_circ_next(&cir, &cir_tmp);
  113a0c:	8d 54 24 70          	lea    0x70(%esp),%edx
  113a10:	89 14 24             	mov    %edx,(%esp)
  113a13:	8d 54 24 6e          	lea    0x6e(%esp),%edx
  113a17:	89 54 24 04          	mov    %edx,0x4(%esp)
  113a1b:	e8 c0 40 00 00       	call   117ae0 <lv_circ_next>
    while(lv_circ_cont(&cir)) {
  113a20:	e9 3a fa ff ff       	jmp    11345f <lv_draw_rect_main_corner+0x41f>
    }

    if(mcolor.full == gcolor.full)
  113a25:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113a2c:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  113a33:	0f 85 13 00 00 00    	jne    113a4c <lv_draw_rect_main_corner+0xa0c>
        act_color = mcolor;
  113a39:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113a40:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  113a47:	e9 6a 00 00 00       	jmp    113ab6 <lv_draw_rect_main_corner+0xa76>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
  113a4c:	8b 45 08             	mov    0x8(%ebp),%eax
  113a4f:	0f bf 40 06          	movswl 0x6(%eax),%eax
  113a53:	0f bf 8c 24 92 00 00 	movswl 0x92(%esp),%ecx
  113a5a:	00 
  113a5b:	29 c8                	sub    %ecx,%eax
  113a5d:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  113a63:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113a6a:	00 
  113a6b:	31 d2                	xor    %edx,%edx
  113a6d:	f7 f1                	div    %ecx
  113a6f:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
        act_color = lv_color_mix(mcolor, gcolor, mix);
  113a76:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  113a7a:	89 0c 24             	mov    %ecx,(%esp)
  113a7d:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  113a84:	8b 09                	mov    (%ecx),%ecx
  113a86:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113a8a:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113a91:	8b 09                	mov    (%ecx),%ecx
  113a93:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113a97:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113a9e:	00 
  113a9f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113aa3:	e8 28 16 00 00       	call   1150d0 <lv_color_mix>
  113aa8:	83 ec 04             	sub    $0x4,%esp
  113aab:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  113aaf:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
    }
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
  113ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
  113ab9:	8d 8c 24 90 00 00 00 	lea    0x90(%esp),%ecx
  113ac0:	89 0c 24             	mov    %ecx,(%esp)
  113ac3:	89 44 24 04          	mov    %eax,0x4(%esp)
  113ac7:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  113ace:	8b 00                	mov    (%eax),%eax
  113ad0:	89 44 24 08          	mov    %eax,0x8(%esp)
  113ad4:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113adb:	00 
  113adc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  113ae0:	e8 bb e2 ff ff       	call   111da0 <lv_draw_fill>

    if(edge_top_area.y1 != mid_top_area.y1) {
  113ae5:	0f bf 84 24 92 00 00 	movswl 0x92(%esp),%eax
  113aec:	00 
  113aed:	0f bf 8c 24 8a 00 00 	movswl 0x8a(%esp),%ecx
  113af4:	00 
  113af5:	39 c8                	cmp    %ecx,%eax
  113af7:	0f 84 c0 00 00 00    	je     113bbd <lv_draw_rect_main_corner+0xb7d>

        if(mcolor.full == gcolor.full)
  113afd:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113b04:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  113b0b:	0f 85 13 00 00 00    	jne    113b24 <lv_draw_rect_main_corner+0xae4>
            act_color = mcolor;
  113b11:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113b18:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  113b1f:	e9 6a 00 00 00       	jmp    113b8e <lv_draw_rect_main_corner+0xb4e>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
  113b24:	8b 45 08             	mov    0x8(%ebp),%eax
  113b27:	0f bf 40 06          	movswl 0x6(%eax),%eax
  113b2b:	0f bf 8c 24 8a 00 00 	movswl 0x8a(%esp),%ecx
  113b32:	00 
  113b33:	29 c8                	sub    %ecx,%eax
  113b35:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  113b3b:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113b42:	00 
  113b43:	31 d2                	xor    %edx,%edx
  113b45:	f7 f1                	div    %ecx
  113b47:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
            act_color = lv_color_mix(mcolor, gcolor, mix);
  113b4e:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  113b52:	89 0c 24             	mov    %ecx,(%esp)
  113b55:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  113b5c:	8b 09                	mov    (%ecx),%ecx
  113b5e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113b62:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113b69:	8b 09                	mov    (%ecx),%ecx
  113b6b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113b6f:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113b76:	00 
  113b77:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113b7b:	e8 50 15 00 00       	call   1150d0 <lv_color_mix>
  113b80:	83 ec 04             	sub    $0x4,%esp
  113b83:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  113b87:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
        }
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
  113b8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  113b91:	8d 8c 24 88 00 00 00 	lea    0x88(%esp),%ecx
  113b98:	89 0c 24             	mov    %ecx,(%esp)
  113b9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  113b9f:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  113ba6:	8b 00                	mov    (%eax),%eax
  113ba8:	89 44 24 08          	mov    %eax,0x8(%esp)
  113bac:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113bb3:	00 
  113bb4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  113bb8:	e8 e3 e1 ff ff       	call   111da0 <lv_draw_fill>
    }

    if(mcolor.full == gcolor.full)
  113bbd:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113bc4:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  113bcb:	0f 85 13 00 00 00    	jne    113be4 <lv_draw_rect_main_corner+0xba4>
        act_color = mcolor;
  113bd1:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113bd8:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  113bdf:	e9 6a 00 00 00       	jmp    113c4e <lv_draw_rect_main_corner+0xc0e>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
  113be4:	8b 45 08             	mov    0x8(%ebp),%eax
  113be7:	0f bf 40 06          	movswl 0x6(%eax),%eax
  113beb:	0f bf 8c 24 82 00 00 	movswl 0x82(%esp),%ecx
  113bf2:	00 
  113bf3:	29 c8                	sub    %ecx,%eax
  113bf5:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  113bfb:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113c02:	00 
  113c03:	31 d2                	xor    %edx,%edx
  113c05:	f7 f1                	div    %ecx
  113c07:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
        act_color = lv_color_mix(mcolor, gcolor, mix);
  113c0e:	8d 4c 24 30          	lea    0x30(%esp),%ecx
  113c12:	89 0c 24             	mov    %ecx,(%esp)
  113c15:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  113c1c:	8b 09                	mov    (%ecx),%ecx
  113c1e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113c22:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113c29:	8b 09                	mov    (%ecx),%ecx
  113c2b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113c2f:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113c36:	00 
  113c37:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113c3b:	e8 90 14 00 00       	call   1150d0 <lv_color_mix>
  113c40:	83 ec 04             	sub    $0x4,%esp
  113c43:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  113c47:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
    }
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
  113c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
  113c51:	8d 8c 24 80 00 00 00 	lea    0x80(%esp),%ecx
  113c58:	89 0c 24             	mov    %ecx,(%esp)
  113c5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  113c5f:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  113c66:	8b 00                	mov    (%eax),%eax
  113c68:	89 44 24 08          	mov    %eax,0x8(%esp)
  113c6c:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113c73:	00 
  113c74:	89 44 24 0c          	mov    %eax,0xc(%esp)
  113c78:	e8 23 e1 ff ff       	call   111da0 <lv_draw_fill>

    if(edge_bot_area.y1 != mid_bot_area.y1) {
  113c7d:	0f bf 44 24 7a       	movswl 0x7a(%esp),%eax
  113c82:	0f bf 8c 24 82 00 00 	movswl 0x82(%esp),%ecx
  113c89:	00 
  113c8a:	39 c8                	cmp    %ecx,%eax
  113c8c:	0f 84 ba 00 00 00    	je     113d4c <lv_draw_rect_main_corner+0xd0c>

        if(mcolor.full == gcolor.full)
  113c92:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113c99:	3b 84 24 c8 00 00 00 	cmp    0xc8(%esp),%eax
  113ca0:	0f 85 13 00 00 00    	jne    113cb9 <lv_draw_rect_main_corner+0xc79>
            act_color = mcolor;
  113ca6:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
  113cad:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
  113cb4:	e9 67 00 00 00       	jmp    113d20 <lv_draw_rect_main_corner+0xce0>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
  113cb9:	8b 45 08             	mov    0x8(%ebp),%eax
  113cbc:	0f bf 40 06          	movswl 0x6(%eax),%eax
  113cc0:	0f bf 4c 24 7a       	movswl 0x7a(%esp),%ecx
  113cc5:	29 c8                	sub    %ecx,%eax
  113cc7:	69 c0 ff 00 00 00    	imul   $0xff,%eax,%eax
  113ccd:	0f bf 8c 24 bc 00 00 	movswl 0xbc(%esp),%ecx
  113cd4:	00 
  113cd5:	31 d2                	xor    %edx,%edx
  113cd7:	f7 f1                	div    %ecx
  113cd9:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
            act_color = lv_color_mix(mcolor, gcolor, mix);
  113ce0:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  113ce4:	89 0c 24             	mov    %ecx,(%esp)
  113ce7:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
  113cee:	8b 09                	mov    (%ecx),%ecx
  113cf0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113cf4:	8d 8c 24 c8 00 00 00 	lea    0xc8(%esp),%ecx
  113cfb:	8b 09                	mov    (%ecx),%ecx
  113cfd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113d01:	0f b6 8c 24 be 00 00 	movzbl 0xbe(%esp),%ecx
  113d08:	00 
  113d09:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  113d0d:	e8 be 13 00 00       	call   1150d0 <lv_color_mix>
  113d12:	83 ec 04             	sub    $0x4,%esp
  113d15:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  113d19:	89 8c 24 c0 00 00 00 	mov    %ecx,0xc0(%esp)
        }
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
  113d20:	8b 45 0c             	mov    0xc(%ebp),%eax
  113d23:	8d 4c 24 78          	lea    0x78(%esp),%ecx
  113d27:	89 0c 24             	mov    %ecx,(%esp)
  113d2a:	89 44 24 04          	mov    %eax,0x4(%esp)
  113d2e:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
  113d35:	8b 00                	mov    (%eax),%eax
  113d37:	89 44 24 08          	mov    %eax,0x8(%esp)
  113d3b:	0f b6 84 24 bf 00 00 	movzbl 0xbf(%esp),%eax
  113d42:	00 
  113d43:	89 44 24 0c          	mov    %eax,0xc(%esp)
  113d47:	e8 54 e0 ff ff       	call   111da0 <lv_draw_fill>
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask, aa_color_hor_top,
                       aa_opa);
        }
    }
#endif
}
  113d4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113d4f:	5e                   	pop    %esi
  113d50:	5f                   	pop    %edi
  113d51:	5b                   	pop    %ebx
  113d52:	5d                   	pop    %ebp
  113d53:	c3                   	ret    
  113d54:	66 90                	xchg   %ax,%ax
  113d56:	66 90                	xchg   %ax,%ax
  113d58:	66 90                	xchg   %ax,%ax
  113d5a:	66 90                	xchg   %ax,%ax
  113d5c:	66 90                	xchg   %ax,%ax
  113d5e:	66 90                	xchg   %ax,%ax

00113d60 <lv_draw_rect_border_straight>:
 * @param rstyle pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         lv_opa_t opa_scale)
{
  113d60:	55                   	push   %ebp
  113d61:	89 e5                	mov    %esp,%ebp
  113d63:	53                   	push   %ebx
  113d64:	57                   	push   %edi
  113d65:	56                   	push   %esi
  113d66:	83 e4 f8             	and    $0xfffffff8,%esp
  113d69:	83 ec 68             	sub    $0x68,%esp
  113d6c:	8a 45 14             	mov    0x14(%ebp),%al
  113d6f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113d72:	8b 55 0c             	mov    0xc(%ebp),%edx
  113d75:	8b 75 08             	mov    0x8(%ebp),%esi
    uint16_t radius = style->body.radius;
  113d78:	8b 7d 10             	mov    0x10(%ebp),%edi
  113d7b:	66 8b 5f 0c          	mov    0xc(%edi),%bx
  113d7f:	66 89 5c 24 62       	mov    %bx,0x62(%esp)
  113d84:	88 44 24 43          	mov    %al,0x43(%esp)
  113d88:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
  113d8c:	89 54 24 38          	mov    %edx,0x38(%esp)
  113d90:	89 74 24 34          	mov    %esi,0x34(%esp)
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
  113d94:	e8 37 c4 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  113d99:	89 04 24             	mov    %eax,(%esp)
  113d9c:	e8 cf 3a 00 00       	call   117870 <lv_disp_get_antialiasing>
  113da1:	24 01                	and    $0x1,%al
  113da3:	88 44 24 61          	mov    %al,0x61(%esp)

    lv_coord_t width  = lv_area_get_width(coords);
  113da7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113daa:	89 0c 24             	mov    %ecx,(%esp)
  113dad:	e8 1e ef ff ff       	call   112cd0 <lv_area_get_width>
  113db2:	66 89 44 24 5e       	mov    %ax,0x5e(%esp)
    lv_coord_t height = lv_area_get_height(coords);
  113db7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113dba:	89 0c 24             	mov    %ecx,(%esp)
  113dbd:	e8 de ee ff ff       	call   112ca0 <lv_area_get_height>
  113dc2:	66 89 44 24 5c       	mov    %ax,0x5c(%esp)
    lv_coord_t bwidth = style->body.border.width;
  113dc7:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113dca:	66 8b 41 14          	mov    0x14(%ecx),%ax
  113dce:	66 89 44 24 5a       	mov    %ax,0x5a(%esp)
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
  113dd3:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  113dd7:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  113ddd:	0f 85 10 00 00 00    	jne    113df3 <lv_draw_rect_border_straight+0x93>
  113de3:	8b 45 10             	mov    0x10(%ebp),%eax
  113de6:	0f b6 40 17          	movzbl 0x17(%eax),%eax
  113dea:	89 44 24 30          	mov    %eax,0x30(%esp)
  113dee:	e9 1b 00 00 00       	jmp    113e0e <lv_draw_rect_border_straight+0xae>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
  113df3:	8b 45 10             	mov    0x10(%ebp),%eax
  113df6:	0f b6 40 17          	movzbl 0x17(%eax),%eax
  113dfa:	0f b7 c8             	movzwl %ax,%ecx
  113dfd:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  113e01:	0f af ca             	imul   %edx,%ecx
  113e04:	0f b7 d1             	movzwl %cx,%edx
  113e07:	c1 fa 08             	sar    $0x8,%edx
  113e0a:	89 54 24 30          	mov    %edx,0x30(%esp)
  113e0e:	8b 44 24 30          	mov    0x30(%esp),%eax
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
  113e12:	88 44 24 59          	mov    %al,0x59(%esp)
    lv_border_part_t part = style->body.border.part;
  113e16:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113e19:	8a 41 16             	mov    0x16(%ecx),%al
  113e1c:	88 44 24 58          	mov    %al,0x58(%esp)
    lv_color_t color      = style->body.border.color;
  113e20:	8b 4d 10             	mov    0x10(%ebp),%ecx
  113e23:	8b 49 10             	mov    0x10(%ecx),%ecx
  113e26:	89 4c 24 50          	mov    %ecx,0x50(%esp)
    lv_area_t work_area;
    lv_coord_t length_corr = 0;
  113e2a:	66 c7 44 24 46 00 00 	movw   $0x0,0x46(%esp)
    lv_coord_t corner_size = 0;
  113e31:	66 c7 44 24 44 00 00 	movw   $0x0,0x44(%esp)

    /*the 0 px border width drawn as 1 px, so decrement the b_width*/
    bwidth--;
  113e38:	66 8b 54 24 5a       	mov    0x5a(%esp),%dx
  113e3d:	66 83 c2 ff          	add    $0xffff,%dx
  113e41:	66 89 54 24 5a       	mov    %dx,0x5a(%esp)

    radius = lv_draw_cont_radius_corr(radius, width, height);
  113e46:	66 8b 54 24 62       	mov    0x62(%esp),%dx
  113e4b:	66 8b 74 24 5e       	mov    0x5e(%esp),%si
  113e50:	0f b7 ca             	movzwl %dx,%ecx
  113e53:	89 0c 24             	mov    %ecx,(%esp)
  113e56:	0f bf ce             	movswl %si,%ecx
  113e59:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  113e5d:	0f bf 4c 24 5c       	movswl 0x5c(%esp),%ecx
  113e62:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  113e66:	e8 85 11 00 00       	call   114ff0 <lv_draw_cont_radius_corr>
  113e6b:	66 89 44 24 62       	mov    %ax,0x62(%esp)

    if(radius < bwidth) {
  113e70:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  113e75:	0f bf 7c 24 5a       	movswl 0x5a(%esp),%edi
  113e7a:	39 f9                	cmp    %edi,%ecx
  113e7c:	0f 8d 2c 00 00 00    	jge    113eae <lv_draw_rect_border_straight+0x14e>
        length_corr = bwidth - radius - aa;
  113e82:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  113e87:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  113e8c:	29 c8                	sub    %ecx,%eax
  113e8e:	8a 54 24 61          	mov    0x61(%esp),%dl
  113e92:	80 e2 01             	and    $0x1,%dl
  113e95:	0f b6 ca             	movzbl %dl,%ecx
  113e98:	29 c8                	sub    %ecx,%eax
  113e9a:	66 89 44 24 46       	mov    %ax,0x46(%esp)
        corner_size = bwidth;
  113e9f:	66 8b 44 24 5a       	mov    0x5a(%esp),%ax
  113ea4:	66 89 44 24 44       	mov    %ax,0x44(%esp)
    } else {
  113ea9:	e9 16 00 00 00       	jmp    113ec4 <lv_draw_rect_border_straight+0x164>
        corner_size = radius + aa;
  113eae:	0f b7 44 24 62       	movzwl 0x62(%esp),%eax
  113eb3:	8a 4c 24 61          	mov    0x61(%esp),%cl
  113eb7:	80 e1 01             	and    $0x1,%cl
  113eba:	0f b6 d1             	movzbl %cl,%edx
  113ebd:	01 d0                	add    %edx,%eax
  113ebf:	66 89 44 24 44       	mov    %ax,0x44(%esp)
    }

    /*If radius == 0 is a special case*/
    if(style->body.radius == 0) {
  113ec4:	8b 45 10             	mov    0x10(%ebp),%eax
  113ec7:	0f bf 40 0c          	movswl 0xc(%eax),%eax
  113ecb:	83 f8 00             	cmp    $0x0,%eax
  113ece:	0f 85 a5 02 00 00    	jne    114179 <lv_draw_rect_border_straight+0x419>
        /*Left top corner*/
        if(part & LV_BORDER_TOP) {
  113ed4:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  113ed9:	83 e0 02             	and    $0x2,%eax
  113edc:	83 f8 00             	cmp    $0x0,%eax
  113edf:	0f 84 5c 00 00 00    	je     113f41 <lv_draw_rect_border_straight+0x1e1>
            work_area.x1 = coords->x1;
  113ee5:	8b 45 08             	mov    0x8(%ebp),%eax
  113ee8:	66 8b 08             	mov    (%eax),%cx
  113eeb:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x2;
  113ef0:	8b 45 08             	mov    0x8(%ebp),%eax
  113ef3:	66 8b 48 04          	mov    0x4(%eax),%cx
  113ef7:	66 89 4c 24 4c       	mov    %cx,0x4c(%esp)
            work_area.y1 = coords->y1;
  113efc:	8b 45 08             	mov    0x8(%ebp),%eax
  113eff:	66 8b 48 02          	mov    0x2(%eax),%cx
  113f03:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
            work_area.y2 = coords->y1 + bwidth;
  113f08:	8b 45 08             	mov    0x8(%ebp),%eax
  113f0b:	0f bf 40 02          	movswl 0x2(%eax),%eax
  113f0f:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  113f14:	01 d0                	add    %edx,%eax
  113f16:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  113f1b:	8b 55 0c             	mov    0xc(%ebp),%edx
  113f1e:	8d 74 24 48          	lea    0x48(%esp),%esi
  113f22:	89 34 24             	mov    %esi,(%esp)
  113f25:	89 54 24 04          	mov    %edx,0x4(%esp)
  113f29:	8d 54 24 50          	lea    0x50(%esp),%edx
  113f2d:	8b 12                	mov    (%edx),%edx
  113f2f:	89 54 24 08          	mov    %edx,0x8(%esp)
  113f33:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  113f38:	89 54 24 0c          	mov    %edx,0xc(%esp)
  113f3c:	e8 5f de ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & LV_BORDER_RIGHT) {
  113f41:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  113f46:	83 e0 08             	and    $0x8,%eax
  113f49:	83 f8 00             	cmp    $0x0,%eax
  113f4c:	0f 84 d3 00 00 00    	je     114025 <lv_draw_rect_border_straight+0x2c5>
            work_area.x1 = coords->x2 - bwidth;
  113f52:	8b 45 08             	mov    0x8(%ebp),%eax
  113f55:	0f bf 40 04          	movswl 0x4(%eax),%eax
  113f59:	0f bf 4c 24 5a       	movswl 0x5a(%esp),%ecx
  113f5e:	29 c8                	sub    %ecx,%eax
  113f60:	66 89 44 24 48       	mov    %ax,0x48(%esp)
            work_area.x2 = coords->x2;
  113f65:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113f68:	66 8b 41 04          	mov    0x4(%ecx),%ax
  113f6c:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
  113f71:	8b 4d 08             	mov    0x8(%ebp),%ecx
  113f74:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  113f78:	0f b6 54 24 58       	movzbl 0x58(%esp),%edx
  113f7d:	83 e2 02             	and    $0x2,%edx
  113f80:	83 fa 00             	cmp    $0x0,%edx
  113f83:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
  113f87:	0f 84 11 00 00 00    	je     113f9e <lv_draw_rect_border_straight+0x23e>
  113f8d:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  113f92:	83 c0 01             	add    $0x1,%eax
  113f95:	89 44 24 28          	mov    %eax,0x28(%esp)
  113f99:	e9 0b 00 00 00       	jmp    113fa9 <lv_draw_rect_border_straight+0x249>
  113f9e:	31 c0                	xor    %eax,%eax
  113fa0:	89 44 24 28          	mov    %eax,0x28(%esp)
  113fa4:	e9 00 00 00 00       	jmp    113fa9 <lv_draw_rect_border_straight+0x249>
  113fa9:	8b 44 24 28          	mov    0x28(%esp),%eax
  113fad:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  113fb1:	01 c1                	add    %eax,%ecx
  113fb3:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
  113fb8:	8b 45 08             	mov    0x8(%ebp),%eax
  113fbb:	0f bf 40 06          	movswl 0x6(%eax),%eax
  113fbf:	0f b6 54 24 58       	movzbl 0x58(%esp),%edx
  113fc4:	83 e2 01             	and    $0x1,%edx
  113fc7:	83 fa 00             	cmp    $0x0,%edx
  113fca:	89 44 24 24          	mov    %eax,0x24(%esp)
  113fce:	0f 84 11 00 00 00    	je     113fe5 <lv_draw_rect_border_straight+0x285>
  113fd4:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  113fd9:	83 c0 01             	add    $0x1,%eax
  113fdc:	89 44 24 20          	mov    %eax,0x20(%esp)
  113fe0:	e9 0b 00 00 00       	jmp    113ff0 <lv_draw_rect_border_straight+0x290>
  113fe5:	31 c0                	xor    %eax,%eax
  113fe7:	89 44 24 20          	mov    %eax,0x20(%esp)
  113feb:	e9 00 00 00 00       	jmp    113ff0 <lv_draw_rect_border_straight+0x290>
  113ff0:	8b 44 24 20          	mov    0x20(%esp),%eax
  113ff4:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  113ff8:	29 c1                	sub    %eax,%ecx
  113ffa:	66 89 4c 24 4e       	mov    %cx,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  113fff:	8b 45 0c             	mov    0xc(%ebp),%eax
  114002:	8d 54 24 48          	lea    0x48(%esp),%edx
  114006:	89 14 24             	mov    %edx,(%esp)
  114009:	89 44 24 04          	mov    %eax,0x4(%esp)
  11400d:	8d 44 24 50          	lea    0x50(%esp),%eax
  114011:	8b 00                	mov    (%eax),%eax
  114013:	89 44 24 08          	mov    %eax,0x8(%esp)
  114017:	0f b6 44 24 59       	movzbl 0x59(%esp),%eax
  11401c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114020:	e8 7b dd ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & LV_BORDER_LEFT) {
  114025:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11402a:	83 e0 04             	and    $0x4,%eax
  11402d:	83 f8 00             	cmp    $0x0,%eax
  114030:	0f 84 d1 00 00 00    	je     114107 <lv_draw_rect_border_straight+0x3a7>
            work_area.x1 = coords->x1;
  114036:	8b 45 08             	mov    0x8(%ebp),%eax
  114039:	66 8b 08             	mov    (%eax),%cx
  11403c:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x1 + bwidth;
  114041:	8b 45 08             	mov    0x8(%ebp),%eax
  114044:	0f bf 00             	movswl (%eax),%eax
  114047:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  11404c:	01 d0                	add    %edx,%eax
  11404e:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
  114053:	8b 55 08             	mov    0x8(%ebp),%edx
  114056:	0f bf 52 02          	movswl 0x2(%edx),%edx
  11405a:	0f b6 74 24 58       	movzbl 0x58(%esp),%esi
  11405f:	83 e6 02             	and    $0x2,%esi
  114062:	83 fe 00             	cmp    $0x0,%esi
  114065:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  114069:	0f 84 11 00 00 00    	je     114080 <lv_draw_rect_border_straight+0x320>
  11406f:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  114074:	83 c0 01             	add    $0x1,%eax
  114077:	89 44 24 18          	mov    %eax,0x18(%esp)
  11407b:	e9 0b 00 00 00       	jmp    11408b <lv_draw_rect_border_straight+0x32b>
  114080:	31 c0                	xor    %eax,%eax
  114082:	89 44 24 18          	mov    %eax,0x18(%esp)
  114086:	e9 00 00 00 00       	jmp    11408b <lv_draw_rect_border_straight+0x32b>
  11408b:	8b 44 24 18          	mov    0x18(%esp),%eax
  11408f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  114093:	01 c1                	add    %eax,%ecx
  114095:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
  11409a:	8b 45 08             	mov    0x8(%ebp),%eax
  11409d:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1140a1:	0f b6 54 24 58       	movzbl 0x58(%esp),%edx
  1140a6:	83 e2 01             	and    $0x1,%edx
  1140a9:	83 fa 00             	cmp    $0x0,%edx
  1140ac:	89 44 24 14          	mov    %eax,0x14(%esp)
  1140b0:	0f 84 11 00 00 00    	je     1140c7 <lv_draw_rect_border_straight+0x367>
  1140b6:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  1140bb:	83 c0 01             	add    $0x1,%eax
  1140be:	89 44 24 10          	mov    %eax,0x10(%esp)
  1140c2:	e9 0b 00 00 00       	jmp    1140d2 <lv_draw_rect_border_straight+0x372>
  1140c7:	31 c0                	xor    %eax,%eax
  1140c9:	89 44 24 10          	mov    %eax,0x10(%esp)
  1140cd:	e9 00 00 00 00       	jmp    1140d2 <lv_draw_rect_border_straight+0x372>
  1140d2:	8b 44 24 10          	mov    0x10(%esp),%eax
  1140d6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  1140da:	29 c1                	sub    %eax,%ecx
  1140dc:	66 89 4c 24 4e       	mov    %cx,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  1140e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1140e4:	8d 54 24 48          	lea    0x48(%esp),%edx
  1140e8:	89 14 24             	mov    %edx,(%esp)
  1140eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1140ef:	8d 44 24 50          	lea    0x50(%esp),%eax
  1140f3:	8b 00                	mov    (%eax),%eax
  1140f5:	89 44 24 08          	mov    %eax,0x8(%esp)
  1140f9:	0f b6 44 24 59       	movzbl 0x59(%esp),%eax
  1140fe:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114102:	e8 99 dc ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & LV_BORDER_BOTTOM) {
  114107:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11410c:	83 e0 01             	and    $0x1,%eax
  11410f:	83 f8 00             	cmp    $0x0,%eax
  114112:	0f 84 5c 00 00 00    	je     114174 <lv_draw_rect_border_straight+0x414>
            work_area.x1 = coords->x1;
  114118:	8b 45 08             	mov    0x8(%ebp),%eax
  11411b:	66 8b 08             	mov    (%eax),%cx
  11411e:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x2;
  114123:	8b 45 08             	mov    0x8(%ebp),%eax
  114126:	66 8b 48 04          	mov    0x4(%eax),%cx
  11412a:	66 89 4c 24 4c       	mov    %cx,0x4c(%esp)
            work_area.y1 = coords->y2 - bwidth;
  11412f:	8b 45 08             	mov    0x8(%ebp),%eax
  114132:	0f bf 40 06          	movswl 0x6(%eax),%eax
  114136:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  11413b:	29 d0                	sub    %edx,%eax
  11413d:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
            work_area.y2 = coords->y2;
  114142:	8b 55 08             	mov    0x8(%ebp),%edx
  114145:	66 8b 42 06          	mov    0x6(%edx),%ax
  114149:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  11414e:	8b 55 0c             	mov    0xc(%ebp),%edx
  114151:	8d 74 24 48          	lea    0x48(%esp),%esi
  114155:	89 34 24             	mov    %esi,(%esp)
  114158:	89 54 24 04          	mov    %edx,0x4(%esp)
  11415c:	8d 54 24 50          	lea    0x50(%esp),%edx
  114160:	8b 12                	mov    (%edx),%edx
  114162:	89 54 24 08          	mov    %edx,0x8(%esp)
  114166:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  11416b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11416f:	e8 2c dc ff ff       	call   111da0 <lv_draw_fill>
        }
        return;
  114174:	e9 c6 06 00 00       	jmp    11483f <lv_draw_rect_border_straight+0xadf>
    }

    /* Modify the corner_size if corner is drawn */
    corner_size++;
  114179:	66 8b 44 24 44       	mov    0x44(%esp),%ax
  11417e:	66 83 c0 01          	add    $0x1,%ax
  114182:	66 89 44 24 44       	mov    %ax,0x44(%esp)

    /*Depending one which part's are drawn modify the area lengths */
    if(part & LV_BORDER_TOP)
  114187:	0f b6 4c 24 58       	movzbl 0x58(%esp),%ecx
  11418c:	83 e1 02             	and    $0x2,%ecx
  11418f:	83 f9 00             	cmp    $0x0,%ecx
  114192:	0f 84 18 00 00 00    	je     1141b0 <lv_draw_rect_border_straight+0x450>
        work_area.y1 = coords->y1 + corner_size;
  114198:	8b 45 08             	mov    0x8(%ebp),%eax
  11419b:	0f bf 40 02          	movswl 0x2(%eax),%eax
  11419f:	0f bf 4c 24 44       	movswl 0x44(%esp),%ecx
  1141a4:	01 c8                	add    %ecx,%eax
  1141a6:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
  1141ab:	e9 13 00 00 00       	jmp    1141c3 <lv_draw_rect_border_straight+0x463>
    else
        work_area.y1 = coords->y1 + radius;
  1141b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1141b3:	0f bf 40 02          	movswl 0x2(%eax),%eax
  1141b7:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  1141bc:	01 c8                	add    %ecx,%eax
  1141be:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)

    if(part & LV_BORDER_BOTTOM)
  1141c3:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1141c8:	83 e0 01             	and    $0x1,%eax
  1141cb:	83 f8 00             	cmp    $0x0,%eax
  1141ce:	0f 84 18 00 00 00    	je     1141ec <lv_draw_rect_border_straight+0x48c>
        work_area.y2 = coords->y2 - corner_size;
  1141d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1141d7:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1141db:	0f bf 4c 24 44       	movswl 0x44(%esp),%ecx
  1141e0:	29 c8                	sub    %ecx,%eax
  1141e2:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
  1141e7:	e9 13 00 00 00       	jmp    1141ff <lv_draw_rect_border_straight+0x49f>
    else
        work_area.y2 = coords->y2 - radius;
  1141ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1141ef:	0f bf 40 06          	movswl 0x6(%eax),%eax
  1141f3:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  1141f8:	29 c8                	sub    %ecx,%eax
  1141fa:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)

    /*Left border*/
    if(part & LV_BORDER_LEFT) {
  1141ff:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114204:	83 e0 04             	and    $0x4,%eax
  114207:	83 f8 00             	cmp    $0x0,%eax
  11420a:	0f 84 42 00 00 00    	je     114252 <lv_draw_rect_border_straight+0x4f2>
        work_area.x1 = coords->x1;
  114210:	8b 45 08             	mov    0x8(%ebp),%eax
  114213:	66 8b 08             	mov    (%eax),%cx
  114216:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
        work_area.x2 = work_area.x1 + bwidth;
  11421b:	0f bf 44 24 48       	movswl 0x48(%esp),%eax
  114220:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  114225:	01 d0                	add    %edx,%eax
  114227:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
        lv_draw_fill(&work_area, mask, color, opa);
  11422c:	8b 55 0c             	mov    0xc(%ebp),%edx
  11422f:	8d 74 24 48          	lea    0x48(%esp),%esi
  114233:	89 34 24             	mov    %esi,(%esp)
  114236:	89 54 24 04          	mov    %edx,0x4(%esp)
  11423a:	8d 54 24 50          	lea    0x50(%esp),%edx
  11423e:	8b 12                	mov    (%edx),%edx
  114240:	89 54 24 08          	mov    %edx,0x8(%esp)
  114244:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  114249:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11424d:	e8 4e db ff ff       	call   111da0 <lv_draw_fill>
    }

    /*Right border*/
    if(part & LV_BORDER_RIGHT) {
  114252:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114257:	83 e0 08             	and    $0x8,%eax
  11425a:	83 f8 00             	cmp    $0x0,%eax
  11425d:	0f 84 43 00 00 00    	je     1142a6 <lv_draw_rect_border_straight+0x546>
        work_area.x2 = coords->x2;
  114263:	8b 45 08             	mov    0x8(%ebp),%eax
  114266:	66 8b 48 04          	mov    0x4(%eax),%cx
  11426a:	66 89 4c 24 4c       	mov    %cx,0x4c(%esp)
        work_area.x1 = work_area.x2 - bwidth;
  11426f:	0f bf 44 24 4c       	movswl 0x4c(%esp),%eax
  114274:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  114279:	29 d0                	sub    %edx,%eax
  11427b:	66 89 44 24 48       	mov    %ax,0x48(%esp)
        lv_draw_fill(&work_area, mask, color, opa);
  114280:	8b 55 0c             	mov    0xc(%ebp),%edx
  114283:	8d 74 24 48          	lea    0x48(%esp),%esi
  114287:	89 34 24             	mov    %esi,(%esp)
  11428a:	89 54 24 04          	mov    %edx,0x4(%esp)
  11428e:	8d 54 24 50          	lea    0x50(%esp),%edx
  114292:	8b 12                	mov    (%edx),%edx
  114294:	89 54 24 08          	mov    %edx,0x8(%esp)
  114298:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  11429d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1142a1:	e8 fa da ff ff       	call   111da0 <lv_draw_fill>
    }

    work_area.x1 = coords->x1 + corner_size - length_corr;
  1142a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1142a9:	0f bf 00             	movswl (%eax),%eax
  1142ac:	0f bf 4c 24 44       	movswl 0x44(%esp),%ecx
  1142b1:	01 c8                	add    %ecx,%eax
  1142b3:	0f bf 4c 24 46       	movswl 0x46(%esp),%ecx
  1142b8:	29 c8                	sub    %ecx,%eax
  1142ba:	66 89 44 24 48       	mov    %ax,0x48(%esp)
    work_area.x2 = coords->x2 - corner_size + length_corr;
  1142bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1142c2:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  1142c6:	0f bf 54 24 44       	movswl 0x44(%esp),%edx
  1142cb:	29 d1                	sub    %edx,%ecx
  1142cd:	0f bf 54 24 46       	movswl 0x46(%esp),%edx
  1142d2:	01 d1                	add    %edx,%ecx
  1142d4:	66 89 4c 24 4c       	mov    %cx,0x4c(%esp)

    /*Upper border*/
    if(part & LV_BORDER_TOP) {
  1142d9:	0f b6 54 24 58       	movzbl 0x58(%esp),%edx
  1142de:	83 e2 02             	and    $0x2,%edx
  1142e1:	83 fa 00             	cmp    $0x0,%edx
  1142e4:	0f 84 45 00 00 00    	je     11432f <lv_draw_rect_border_straight+0x5cf>
        work_area.y1 = coords->y1;
  1142ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1142ed:	66 8b 48 02          	mov    0x2(%eax),%cx
  1142f1:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
        work_area.y2 = coords->y1 + bwidth;
  1142f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1142f9:	0f bf 40 02          	movswl 0x2(%eax),%eax
  1142fd:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  114302:	01 d0                	add    %edx,%eax
  114304:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
        lv_draw_fill(&work_area, mask, color, opa);
  114309:	8b 55 0c             	mov    0xc(%ebp),%edx
  11430c:	8d 74 24 48          	lea    0x48(%esp),%esi
  114310:	89 34 24             	mov    %esi,(%esp)
  114313:	89 54 24 04          	mov    %edx,0x4(%esp)
  114317:	8d 54 24 50          	lea    0x50(%esp),%edx
  11431b:	8b 12                	mov    (%edx),%edx
  11431d:	89 54 24 08          	mov    %edx,0x8(%esp)
  114321:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  114326:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11432a:	e8 71 da ff ff       	call   111da0 <lv_draw_fill>
    }

    /*Lower border*/
    if(part & LV_BORDER_BOTTOM) {
  11432f:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114334:	83 e0 01             	and    $0x1,%eax
  114337:	83 f8 00             	cmp    $0x0,%eax
  11433a:	0f 84 43 00 00 00    	je     114383 <lv_draw_rect_border_straight+0x623>
        work_area.y2 = coords->y2;
  114340:	8b 45 08             	mov    0x8(%ebp),%eax
  114343:	66 8b 48 06          	mov    0x6(%eax),%cx
  114347:	66 89 4c 24 4e       	mov    %cx,0x4e(%esp)
        work_area.y1 = work_area.y2 - bwidth;
  11434c:	0f bf 44 24 4e       	movswl 0x4e(%esp),%eax
  114351:	0f bf 54 24 5a       	movswl 0x5a(%esp),%edx
  114356:	29 d0                	sub    %edx,%eax
  114358:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
        lv_draw_fill(&work_area, mask, color, opa);
  11435d:	8b 55 0c             	mov    0xc(%ebp),%edx
  114360:	8d 74 24 48          	lea    0x48(%esp),%esi
  114364:	89 34 24             	mov    %esi,(%esp)
  114367:	89 54 24 04          	mov    %edx,0x4(%esp)
  11436b:	8d 54 24 50          	lea    0x50(%esp),%edx
  11436f:	8b 12                	mov    (%edx),%edx
  114371:	89 54 24 08          	mov    %edx,0x8(%esp)
  114375:	0f b6 54 24 59       	movzbl 0x59(%esp),%edx
  11437a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11437e:	e8 1d da ff ff       	call   111da0 <lv_draw_fill>
    }

    /*Draw the a remaining rectangles if the radius is smaller then bwidth */
    if(length_corr != 0) {
  114383:	0f bf 44 24 46       	movswl 0x46(%esp),%eax
  114388:	83 f8 00             	cmp    $0x0,%eax
  11438b:	0f 84 a1 02 00 00    	je     114632 <lv_draw_rect_border_straight+0x8d2>
        /*Left top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
  114391:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114396:	83 e0 02             	and    $0x2,%eax
  114399:	83 f8 00             	cmp    $0x0,%eax
  11439c:	0f 84 95 00 00 00    	je     114437 <lv_draw_rect_border_straight+0x6d7>
  1143a2:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1143a7:	83 e0 04             	and    $0x4,%eax
  1143aa:	83 f8 00             	cmp    $0x0,%eax
  1143ad:	0f 84 84 00 00 00    	je     114437 <lv_draw_rect_border_straight+0x6d7>
            work_area.x1 = coords->x1;
  1143b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1143b6:	66 8b 08             	mov    (%eax),%cx
  1143b9:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x1 + radius + aa;
  1143be:	8b 45 08             	mov    0x8(%ebp),%eax
  1143c1:	0f bf 00             	movswl (%eax),%eax
  1143c4:	0f b7 54 24 62       	movzwl 0x62(%esp),%edx
  1143c9:	01 d0                	add    %edx,%eax
  1143cb:	8a 5c 24 61          	mov    0x61(%esp),%bl
  1143cf:	80 e3 01             	and    $0x1,%bl
  1143d2:	0f b6 d3             	movzbl %bl,%edx
  1143d5:	01 d0                	add    %edx,%eax
  1143d7:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1 + radius + 1 + aa;
  1143dc:	8b 55 08             	mov    0x8(%ebp),%edx
  1143df:	0f bf 52 02          	movswl 0x2(%edx),%edx
  1143e3:	0f b7 74 24 62       	movzwl 0x62(%esp),%esi
  1143e8:	01 f2                	add    %esi,%edx
  1143ea:	83 c2 01             	add    $0x1,%edx
  1143ed:	8a 5c 24 61          	mov    0x61(%esp),%bl
  1143f1:	80 e3 01             	and    $0x1,%bl
  1143f4:	0f b6 f3             	movzbl %bl,%esi
  1143f7:	01 f2                	add    %esi,%edx
  1143f9:	66 89 54 24 4a       	mov    %dx,0x4a(%esp)
            work_area.y2 = coords->y1 + bwidth;
  1143fe:	8b 75 08             	mov    0x8(%ebp),%esi
  114401:	0f bf 76 02          	movswl 0x2(%esi),%esi
  114405:	0f bf 7c 24 5a       	movswl 0x5a(%esp),%edi
  11440a:	01 fe                	add    %edi,%esi
  11440c:	66 89 74 24 4e       	mov    %si,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114411:	8b 7d 0c             	mov    0xc(%ebp),%edi
  114414:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  114418:	89 1c 24             	mov    %ebx,(%esp)
  11441b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11441f:	8d 7c 24 50          	lea    0x50(%esp),%edi
  114423:	8b 3f                	mov    (%edi),%edi
  114425:	89 7c 24 08          	mov    %edi,0x8(%esp)
  114429:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  11442e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  114432:	e8 69 d9 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
  114437:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11443c:	83 e0 02             	and    $0x2,%eax
  11443f:	83 f8 00             	cmp    $0x0,%eax
  114442:	0f 84 97 00 00 00    	je     1144df <lv_draw_rect_border_straight+0x77f>
  114448:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11444d:	83 e0 08             	and    $0x8,%eax
  114450:	83 f8 00             	cmp    $0x0,%eax
  114453:	0f 84 86 00 00 00    	je     1144df <lv_draw_rect_border_straight+0x77f>
            work_area.x1 = coords->x2 - radius - aa;
  114459:	8b 45 08             	mov    0x8(%ebp),%eax
  11445c:	0f bf 40 04          	movswl 0x4(%eax),%eax
  114460:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  114465:	29 c8                	sub    %ecx,%eax
  114467:	8a 54 24 61          	mov    0x61(%esp),%dl
  11446b:	80 e2 01             	and    $0x1,%dl
  11446e:	0f b6 ca             	movzbl %dl,%ecx
  114471:	29 c8                	sub    %ecx,%eax
  114473:	66 89 44 24 48       	mov    %ax,0x48(%esp)
            work_area.x2 = coords->x2;
  114478:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11447b:	66 8b 41 04          	mov    0x4(%ecx),%ax
  11447f:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1 + radius + 1 + aa;
  114484:	8b 4d 08             	mov    0x8(%ebp),%ecx
  114487:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  11448b:	0f b7 74 24 62       	movzwl 0x62(%esp),%esi
  114490:	01 f1                	add    %esi,%ecx
  114492:	83 c1 01             	add    $0x1,%ecx
  114495:	8a 54 24 61          	mov    0x61(%esp),%dl
  114499:	80 e2 01             	and    $0x1,%dl
  11449c:	0f b6 f2             	movzbl %dl,%esi
  11449f:	01 f1                	add    %esi,%ecx
  1144a1:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
            work_area.y2 = coords->y1 + bwidth;
  1144a6:	8b 75 08             	mov    0x8(%ebp),%esi
  1144a9:	0f bf 76 02          	movswl 0x2(%esi),%esi
  1144ad:	0f bf 7c 24 5a       	movswl 0x5a(%esp),%edi
  1144b2:	01 fe                	add    %edi,%esi
  1144b4:	66 89 74 24 4e       	mov    %si,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  1144b9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1144bc:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  1144c0:	89 1c 24             	mov    %ebx,(%esp)
  1144c3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1144c7:	8d 7c 24 50          	lea    0x50(%esp),%edi
  1144cb:	8b 3f                	mov    (%edi),%edi
  1144cd:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1144d1:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  1144d6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1144da:	e8 c1 d8 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Left bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
  1144df:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1144e4:	83 e0 01             	and    $0x1,%eax
  1144e7:	83 f8 00             	cmp    $0x0,%eax
  1144ea:	0f 84 95 00 00 00    	je     114585 <lv_draw_rect_border_straight+0x825>
  1144f0:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1144f5:	83 e0 04             	and    $0x4,%eax
  1144f8:	83 f8 00             	cmp    $0x0,%eax
  1144fb:	0f 84 84 00 00 00    	je     114585 <lv_draw_rect_border_straight+0x825>
            work_area.x1 = coords->x1;
  114501:	8b 45 08             	mov    0x8(%ebp),%eax
  114504:	66 8b 08             	mov    (%eax),%cx
  114507:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x1 + radius + aa;
  11450c:	8b 45 08             	mov    0x8(%ebp),%eax
  11450f:	0f bf 00             	movswl (%eax),%eax
  114512:	0f b7 54 24 62       	movzwl 0x62(%esp),%edx
  114517:	01 d0                	add    %edx,%eax
  114519:	8a 5c 24 61          	mov    0x61(%esp),%bl
  11451d:	80 e3 01             	and    $0x1,%bl
  114520:	0f b6 d3             	movzbl %bl,%edx
  114523:	01 d0                	add    %edx,%eax
  114525:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y2 - bwidth;
  11452a:	8b 55 08             	mov    0x8(%ebp),%edx
  11452d:	0f bf 52 06          	movswl 0x6(%edx),%edx
  114531:	0f bf 74 24 5a       	movswl 0x5a(%esp),%esi
  114536:	29 f2                	sub    %esi,%edx
  114538:	66 89 54 24 4a       	mov    %dx,0x4a(%esp)
            work_area.y2 = coords->y2 - radius - 1 - aa;
  11453d:	8b 75 08             	mov    0x8(%ebp),%esi
  114540:	0f bf 76 06          	movswl 0x6(%esi),%esi
  114544:	0f b7 7c 24 62       	movzwl 0x62(%esp),%edi
  114549:	29 fe                	sub    %edi,%esi
  11454b:	83 ee 01             	sub    $0x1,%esi
  11454e:	8a 5c 24 61          	mov    0x61(%esp),%bl
  114552:	80 e3 01             	and    $0x1,%bl
  114555:	0f b6 fb             	movzbl %bl,%edi
  114558:	29 fe                	sub    %edi,%esi
  11455a:	66 89 74 24 4e       	mov    %si,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  11455f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  114562:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  114566:	89 1c 24             	mov    %ebx,(%esp)
  114569:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11456d:	8d 7c 24 50          	lea    0x50(%esp),%edi
  114571:	8b 3f                	mov    (%edi),%edi
  114573:	89 7c 24 08          	mov    %edi,0x8(%esp)
  114577:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  11457c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  114580:	e8 1b d8 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
  114585:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11458a:	83 e0 01             	and    $0x1,%eax
  11458d:	83 f8 00             	cmp    $0x0,%eax
  114590:	0f 84 97 00 00 00    	je     11462d <lv_draw_rect_border_straight+0x8cd>
  114596:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  11459b:	83 e0 08             	and    $0x8,%eax
  11459e:	83 f8 00             	cmp    $0x0,%eax
  1145a1:	0f 84 86 00 00 00    	je     11462d <lv_draw_rect_border_straight+0x8cd>
            work_area.x1 = coords->x2 - radius - aa;
  1145a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1145aa:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1145ae:	0f b7 4c 24 62       	movzwl 0x62(%esp),%ecx
  1145b3:	29 c8                	sub    %ecx,%eax
  1145b5:	8a 54 24 61          	mov    0x61(%esp),%dl
  1145b9:	80 e2 01             	and    $0x1,%dl
  1145bc:	0f b6 ca             	movzbl %dl,%ecx
  1145bf:	29 c8                	sub    %ecx,%eax
  1145c1:	66 89 44 24 48       	mov    %ax,0x48(%esp)
            work_area.x2 = coords->x2;
  1145c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1145c9:	66 8b 41 04          	mov    0x4(%ecx),%ax
  1145cd:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y2 - bwidth;
  1145d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1145d5:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  1145d9:	0f bf 74 24 5a       	movswl 0x5a(%esp),%esi
  1145de:	29 f1                	sub    %esi,%ecx
  1145e0:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)
            work_area.y2 = coords->y2 - radius - 1 - aa;
  1145e5:	8b 75 08             	mov    0x8(%ebp),%esi
  1145e8:	0f bf 76 06          	movswl 0x6(%esi),%esi
  1145ec:	0f b7 7c 24 62       	movzwl 0x62(%esp),%edi
  1145f1:	29 fe                	sub    %edi,%esi
  1145f3:	83 ee 01             	sub    $0x1,%esi
  1145f6:	8a 54 24 61          	mov    0x61(%esp),%dl
  1145fa:	80 e2 01             	and    $0x1,%dl
  1145fd:	0f b6 fa             	movzbl %dl,%edi
  114600:	29 fe                	sub    %edi,%esi
  114602:	66 89 74 24 4e       	mov    %si,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114607:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11460a:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  11460e:	89 1c 24             	mov    %ebx,(%esp)
  114611:	89 7c 24 04          	mov    %edi,0x4(%esp)
  114615:	8d 7c 24 50          	lea    0x50(%esp),%edi
  114619:	8b 3f                	mov    (%edi),%edi
  11461b:	89 7c 24 08          	mov    %edi,0x8(%esp)
  11461f:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  114624:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  114628:	e8 73 d7 ff ff       	call   111da0 <lv_draw_fill>
        }
    }
  11462d:	e9 00 00 00 00       	jmp    114632 <lv_draw_rect_border_straight+0x8d2>

    /*If radius == 0 one px on the corners are not drawn by main drawer*/
    if(style->body.radius == 0) {
  114632:	8b 45 10             	mov    0x10(%ebp),%eax
  114635:	0f bf 40 0c          	movswl 0xc(%eax),%eax
  114639:	83 f8 00             	cmp    $0x0,%eax
  11463c:	0f 85 fd 01 00 00    	jne    11483f <lv_draw_rect_border_straight+0xadf>
        /*Left top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
  114642:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114647:	83 e0 06             	and    $0x6,%eax
  11464a:	83 f8 00             	cmp    $0x0,%eax
  11464d:	0f 84 6c 00 00 00    	je     1146bf <lv_draw_rect_border_straight+0x95f>
            work_area.x1 = coords->x1;
  114653:	8b 45 08             	mov    0x8(%ebp),%eax
  114656:	66 8b 08             	mov    (%eax),%cx
  114659:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x1 + aa;
  11465e:	8b 45 08             	mov    0x8(%ebp),%eax
  114661:	0f bf 00             	movswl (%eax),%eax
  114664:	8a 54 24 61          	mov    0x61(%esp),%dl
  114668:	80 e2 01             	and    $0x1,%dl
  11466b:	0f b6 f2             	movzbl %dl,%esi
  11466e:	01 f0                	add    %esi,%eax
  114670:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1;
  114675:	8b 75 08             	mov    0x8(%ebp),%esi
  114678:	66 8b 46 02          	mov    0x2(%esi),%ax
  11467c:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
            work_area.y2 = coords->y1 + aa;
  114681:	8b 75 08             	mov    0x8(%ebp),%esi
  114684:	0f bf 76 02          	movswl 0x2(%esi),%esi
  114688:	8a 54 24 61          	mov    0x61(%esp),%dl
  11468c:	80 e2 01             	and    $0x1,%dl
  11468f:	0f b6 fa             	movzbl %dl,%edi
  114692:	01 fe                	add    %edi,%esi
  114694:	66 89 74 24 4e       	mov    %si,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114699:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11469c:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  1146a0:	89 1c 24             	mov    %ebx,(%esp)
  1146a3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1146a7:	8d 7c 24 50          	lea    0x50(%esp),%edi
  1146ab:	8b 3f                	mov    (%edi),%edi
  1146ad:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1146b1:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  1146b6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1146ba:	e8 e1 d6 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
  1146bf:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1146c4:	83 e0 0a             	and    $0xa,%eax
  1146c7:	83 f8 00             	cmp    $0x0,%eax
  1146ca:	0f 84 6e 00 00 00    	je     11473e <lv_draw_rect_border_straight+0x9de>
            work_area.x1 = coords->x2 - aa;
  1146d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1146d3:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1146d7:	8a 4c 24 61          	mov    0x61(%esp),%cl
  1146db:	80 e1 01             	and    $0x1,%cl
  1146de:	0f b6 d1             	movzbl %cl,%edx
  1146e1:	29 d0                	sub    %edx,%eax
  1146e3:	66 89 44 24 48       	mov    %ax,0x48(%esp)
            work_area.x2 = coords->x2;
  1146e8:	8b 55 08             	mov    0x8(%ebp),%edx
  1146eb:	66 8b 42 04          	mov    0x4(%edx),%ax
  1146ef:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y1;
  1146f4:	8b 55 08             	mov    0x8(%ebp),%edx
  1146f7:	66 8b 42 02          	mov    0x2(%edx),%ax
  1146fb:	66 89 44 24 4a       	mov    %ax,0x4a(%esp)
            work_area.y2 = coords->y1 + aa;
  114700:	8b 55 08             	mov    0x8(%ebp),%edx
  114703:	0f bf 52 02          	movswl 0x2(%edx),%edx
  114707:	8a 4c 24 61          	mov    0x61(%esp),%cl
  11470b:	80 e1 01             	and    $0x1,%cl
  11470e:	0f b6 f1             	movzbl %cl,%esi
  114711:	01 f2                	add    %esi,%edx
  114713:	66 89 54 24 4e       	mov    %dx,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114718:	8b 75 0c             	mov    0xc(%ebp),%esi
  11471b:	8d 7c 24 48          	lea    0x48(%esp),%edi
  11471f:	89 3c 24             	mov    %edi,(%esp)
  114722:	89 74 24 04          	mov    %esi,0x4(%esp)
  114726:	8d 74 24 50          	lea    0x50(%esp),%esi
  11472a:	8b 36                	mov    (%esi),%esi
  11472c:	89 74 24 08          	mov    %esi,0x8(%esp)
  114730:	0f b6 74 24 59       	movzbl 0x59(%esp),%esi
  114735:	89 74 24 0c          	mov    %esi,0xc(%esp)
  114739:	e8 62 d6 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
  11473e:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  114743:	83 e0 05             	and    $0x5,%eax
  114746:	83 f8 00             	cmp    $0x0,%eax
  114749:	0f 84 6c 00 00 00    	je     1147bb <lv_draw_rect_border_straight+0xa5b>
            work_area.x1 = coords->x1;
  11474f:	8b 45 08             	mov    0x8(%ebp),%eax
  114752:	66 8b 08             	mov    (%eax),%cx
  114755:	66 89 4c 24 48       	mov    %cx,0x48(%esp)
            work_area.x2 = coords->x1 + aa;
  11475a:	8b 45 08             	mov    0x8(%ebp),%eax
  11475d:	0f bf 00             	movswl (%eax),%eax
  114760:	8a 54 24 61          	mov    0x61(%esp),%dl
  114764:	80 e2 01             	and    $0x1,%dl
  114767:	0f b6 f2             	movzbl %dl,%esi
  11476a:	01 f0                	add    %esi,%eax
  11476c:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y2 - aa;
  114771:	8b 75 08             	mov    0x8(%ebp),%esi
  114774:	0f bf 76 06          	movswl 0x6(%esi),%esi
  114778:	8a 54 24 61          	mov    0x61(%esp),%dl
  11477c:	80 e2 01             	and    $0x1,%dl
  11477f:	0f b6 fa             	movzbl %dl,%edi
  114782:	29 fe                	sub    %edi,%esi
  114784:	66 89 74 24 4a       	mov    %si,0x4a(%esp)
            work_area.y2 = coords->y2;
  114789:	8b 7d 08             	mov    0x8(%ebp),%edi
  11478c:	66 8b 47 06          	mov    0x6(%edi),%ax
  114790:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114795:	8b 7d 0c             	mov    0xc(%ebp),%edi
  114798:	8d 5c 24 48          	lea    0x48(%esp),%ebx
  11479c:	89 1c 24             	mov    %ebx,(%esp)
  11479f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1147a3:	8d 7c 24 50          	lea    0x50(%esp),%edi
  1147a7:	8b 3f                	mov    (%edi),%edi
  1147a9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1147ad:	0f b6 7c 24 59       	movzbl 0x59(%esp),%edi
  1147b2:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1147b6:	e8 e5 d5 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
  1147bb:	0f b6 44 24 58       	movzbl 0x58(%esp),%eax
  1147c0:	83 e0 09             	and    $0x9,%eax
  1147c3:	83 f8 00             	cmp    $0x0,%eax
  1147c6:	0f 84 6e 00 00 00    	je     11483a <lv_draw_rect_border_straight+0xada>
            work_area.x1 = coords->x2 - aa;
  1147cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1147cf:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1147d3:	8a 4c 24 61          	mov    0x61(%esp),%cl
  1147d7:	80 e1 01             	and    $0x1,%cl
  1147da:	0f b6 d1             	movzbl %cl,%edx
  1147dd:	29 d0                	sub    %edx,%eax
  1147df:	66 89 44 24 48       	mov    %ax,0x48(%esp)
            work_area.x2 = coords->x2;
  1147e4:	8b 55 08             	mov    0x8(%ebp),%edx
  1147e7:	66 8b 42 04          	mov    0x4(%edx),%ax
  1147eb:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
            work_area.y1 = coords->y2 - aa;
  1147f0:	8b 55 08             	mov    0x8(%ebp),%edx
  1147f3:	0f bf 52 06          	movswl 0x6(%edx),%edx
  1147f7:	8a 4c 24 61          	mov    0x61(%esp),%cl
  1147fb:	80 e1 01             	and    $0x1,%cl
  1147fe:	0f b6 f1             	movzbl %cl,%esi
  114801:	29 f2                	sub    %esi,%edx
  114803:	66 89 54 24 4a       	mov    %dx,0x4a(%esp)
            work_area.y2 = coords->y2;
  114808:	8b 75 08             	mov    0x8(%ebp),%esi
  11480b:	66 8b 46 06          	mov    0x6(%esi),%ax
  11480f:	66 89 44 24 4e       	mov    %ax,0x4e(%esp)
            lv_draw_fill(&work_area, mask, color, opa);
  114814:	8b 75 0c             	mov    0xc(%ebp),%esi
  114817:	8d 7c 24 48          	lea    0x48(%esp),%edi
  11481b:	89 3c 24             	mov    %edi,(%esp)
  11481e:	89 74 24 04          	mov    %esi,0x4(%esp)
  114822:	8d 74 24 50          	lea    0x50(%esp),%esi
  114826:	8b 36                	mov    (%esi),%esi
  114828:	89 74 24 08          	mov    %esi,0x8(%esp)
  11482c:	0f b6 74 24 59       	movzbl 0x59(%esp),%esi
  114831:	89 74 24 0c          	mov    %esi,0xc(%esp)
  114835:	e8 66 d5 ff ff       	call   111da0 <lv_draw_fill>
        }
    }
  11483a:	e9 00 00 00 00       	jmp    11483f <lv_draw_rect_border_straight+0xadf>
}
  11483f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114842:	5e                   	pop    %esi
  114843:	5f                   	pop    %edi
  114844:	5b                   	pop    %ebx
  114845:	5d                   	pop    %ebp
  114846:	c3                   	ret    
  114847:	66 90                	xchg   %ax,%ax
  114849:	66 90                	xchg   %ax,%ax
  11484b:	66 90                	xchg   %ax,%ax
  11484d:	66 90                	xchg   %ax,%ax
  11484f:	90                   	nop

00114850 <lv_draw_rect_border_corner>:
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                       lv_opa_t opa_scale)
{
  114850:	55                   	push   %ebp
  114851:	89 e5                	mov    %esp,%ebp
  114853:	53                   	push   %ebx
  114854:	57                   	push   %edi
  114855:	56                   	push   %esi
  114856:	83 e4 f8             	and    $0xfffffff8,%esp
  114859:	81 ec 80 00 00 00    	sub    $0x80,%esp
  11485f:	8a 45 14             	mov    0x14(%ebp),%al
  114862:	8b 4d 10             	mov    0x10(%ebp),%ecx
  114865:	8b 55 0c             	mov    0xc(%ebp),%edx
  114868:	8b 75 08             	mov    0x8(%ebp),%esi
    uint16_t radius       = style->body.radius;
  11486b:	8b 7d 10             	mov    0x10(%ebp),%edi
  11486e:	66 8b 5f 0c          	mov    0xc(%edi),%bx
  114872:	66 89 5c 24 7a       	mov    %bx,0x7a(%esp)
  114877:	88 44 24 23          	mov    %al,0x23(%esp)
  11487b:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  11487f:	89 54 24 18          	mov    %edx,0x18(%esp)
  114883:	89 74 24 14          	mov    %esi,0x14(%esp)
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
  114887:	e8 44 b9 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  11488c:	89 04 24             	mov    %eax,(%esp)
  11488f:	e8 dc 2f 00 00       	call   117870 <lv_disp_get_antialiasing>
  114894:	24 01                	and    $0x1,%al
  114896:	88 44 24 79          	mov    %al,0x79(%esp)
    lv_coord_t bwidth     = style->body.border.width;
  11489a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11489d:	66 8b 59 14          	mov    0x14(%ecx),%bx
  1148a1:	66 89 5c 24 76       	mov    %bx,0x76(%esp)
    lv_color_t color      = style->body.border.color;
  1148a6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1148a9:	8b 49 10             	mov    0x10(%ecx),%ecx
  1148ac:	89 4c 24 70          	mov    %ecx,0x70(%esp)
    lv_border_part_t part = style->body.border.part;
  1148b0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1148b3:	8a 41 16             	mov    0x16(%ecx),%al
  1148b6:	88 44 24 6f          	mov    %al,0x6f(%esp)
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
  1148ba:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  1148be:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  1148c4:	0f 85 10 00 00 00    	jne    1148da <lv_draw_rect_border_corner+0x8a>
  1148ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1148cd:	0f b6 40 17          	movzbl 0x17(%eax),%eax
  1148d1:	89 44 24 10          	mov    %eax,0x10(%esp)
  1148d5:	e9 1b 00 00 00       	jmp    1148f5 <lv_draw_rect_border_corner+0xa5>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
  1148da:	8b 45 10             	mov    0x10(%ebp),%eax
  1148dd:	0f b6 40 17          	movzbl 0x17(%eax),%eax
  1148e1:	0f b7 c8             	movzwl %ax,%ecx
  1148e4:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  1148e8:	0f af ca             	imul   %edx,%ecx
  1148eb:	0f b7 d1             	movzwl %cx,%edx
  1148ee:	c1 fa 08             	sar    $0x8,%edx
  1148f1:	89 54 24 10          	mov    %edx,0x10(%esp)
  1148f5:	8b 44 24 10          	mov    0x10(%esp),%eax
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
  1148f9:	88 44 24 6e          	mov    %al,0x6e(%esp)
    /*0 px border width drawn as 1 px, so decrement the bwidth*/
    bwidth--;
  1148fd:	66 8b 4c 24 76       	mov    0x76(%esp),%cx
  114902:	66 83 c1 ff          	add    $0xffff,%cx
  114906:	66 89 4c 24 76       	mov    %cx,0x76(%esp)

#if LV_ANTIALIAS
    if(aa) bwidth--; /*Because of anti-aliasing the border seems one pixel ticker*/
#endif

    lv_coord_t width  = lv_area_get_width(coords);
  11490b:	8b 55 08             	mov    0x8(%ebp),%edx
  11490e:	89 14 24             	mov    %edx,(%esp)
  114911:	e8 ba e3 ff ff       	call   112cd0 <lv_area_get_width>
  114916:	66 89 44 24 6c       	mov    %ax,0x6c(%esp)
    lv_coord_t height = lv_area_get_height(coords);
  11491b:	8b 55 08             	mov    0x8(%ebp),%edx
  11491e:	89 14 24             	mov    %edx,(%esp)
  114921:	e8 7a e3 ff ff       	call   112ca0 <lv_area_get_height>
  114926:	66 89 44 24 6a       	mov    %ax,0x6a(%esp)

    radius = lv_draw_cont_radius_corr(radius, width, height);
  11492b:	66 8b 44 24 7a       	mov    0x7a(%esp),%ax
  114930:	66 8b 4c 24 6c       	mov    0x6c(%esp),%cx
  114935:	0f b7 d0             	movzwl %ax,%edx
  114938:	89 14 24             	mov    %edx,(%esp)
  11493b:	0f bf d1             	movswl %cx,%edx
  11493e:	89 54 24 04          	mov    %edx,0x4(%esp)
  114942:	0f bf 54 24 6a       	movswl 0x6a(%esp),%edx
  114947:	89 54 24 08          	mov    %edx,0x8(%esp)
  11494b:	e8 a0 06 00 00       	call   114ff0 <lv_draw_cont_radius_corr>
  114950:	66 89 44 24 7a       	mov    %ax,0x7a(%esp)
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
  114955:	8b 55 08             	mov    0x8(%ebp),%edx
  114958:	0f bf 12             	movswl (%edx),%edx
  11495b:	0f b7 74 24 7a       	movzwl 0x7a(%esp),%esi
  114960:	01 f2                	add    %esi,%edx
  114962:	8a 5c 24 79          	mov    0x79(%esp),%bl
  114966:	80 e3 01             	and    $0x1,%bl
  114969:	0f b6 f3             	movzbl %bl,%esi
  11496c:	01 f2                	add    %esi,%edx
  11496e:	66 89 54 24 60       	mov    %dx,0x60(%esp)
    lt_origo.y = coords->y1 + radius + aa;
  114973:	8b 75 08             	mov    0x8(%ebp),%esi
  114976:	0f bf 76 02          	movswl 0x2(%esi),%esi
  11497a:	0f b7 7c 24 7a       	movzwl 0x7a(%esp),%edi
  11497f:	01 fe                	add    %edi,%esi
  114981:	8a 5c 24 79          	mov    0x79(%esp),%bl
  114985:	80 e3 01             	and    $0x1,%bl
  114988:	0f b6 fb             	movzbl %bl,%edi
  11498b:	01 fe                	add    %edi,%esi
  11498d:	66 89 74 24 62       	mov    %si,0x62(%esp)

    lb_origo.x = coords->x1 + radius + aa;
  114992:	8b 7d 08             	mov    0x8(%ebp),%edi
  114995:	0f bf 3f             	movswl (%edi),%edi
  114998:	0f b7 5c 24 7a       	movzwl 0x7a(%esp),%ebx
  11499d:	01 df                	add    %ebx,%edi
  11499f:	8a 44 24 79          	mov    0x79(%esp),%al
  1149a3:	24 01                	and    $0x1,%al
  1149a5:	0f b6 d8             	movzbl %al,%ebx
  1149a8:	01 df                	add    %ebx,%edi
  1149aa:	66 89 7c 24 58       	mov    %di,0x58(%esp)
    lb_origo.y = coords->y2 - radius - aa;
  1149af:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1149b2:	0f bf 5b 06          	movswl 0x6(%ebx),%ebx
  1149b6:	0f b7 44 24 7a       	movzwl 0x7a(%esp),%eax
  1149bb:	29 c3                	sub    %eax,%ebx
  1149bd:	8a 44 24 79          	mov    0x79(%esp),%al
  1149c1:	24 01                	and    $0x1,%al
  1149c3:	0f b6 c0             	movzbl %al,%eax
  1149c6:	29 c3                	sub    %eax,%ebx
  1149c8:	66 89 5c 24 5a       	mov    %bx,0x5a(%esp)

    rt_origo.x = coords->x2 - radius - aa;
  1149cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1149d0:	0f bf 40 04          	movswl 0x4(%eax),%eax
  1149d4:	0f b7 4c 24 7a       	movzwl 0x7a(%esp),%ecx
  1149d9:	29 c8                	sub    %ecx,%eax
  1149db:	8a 4c 24 79          	mov    0x79(%esp),%cl
  1149df:	80 e1 01             	and    $0x1,%cl
  1149e2:	0f b6 c9             	movzbl %cl,%ecx
  1149e5:	29 c8                	sub    %ecx,%eax
  1149e7:	66 89 44 24 50       	mov    %ax,0x50(%esp)
    rt_origo.y = coords->y1 + radius + aa;
  1149ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1149ef:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  1149f3:	0f b7 44 24 7a       	movzwl 0x7a(%esp),%eax
  1149f8:	01 c1                	add    %eax,%ecx
  1149fa:	8a 44 24 79          	mov    0x79(%esp),%al
  1149fe:	24 01                	and    $0x1,%al
  114a00:	0f b6 c0             	movzbl %al,%eax
  114a03:	01 c1                	add    %eax,%ecx
  114a05:	66 89 4c 24 52       	mov    %cx,0x52(%esp)

    rb_origo.x = coords->x2 - radius - aa;
  114a0a:	8b 45 08             	mov    0x8(%ebp),%eax
  114a0d:	0f bf 40 04          	movswl 0x4(%eax),%eax
  114a11:	0f b7 4c 24 7a       	movzwl 0x7a(%esp),%ecx
  114a16:	29 c8                	sub    %ecx,%eax
  114a18:	8a 4c 24 79          	mov    0x79(%esp),%cl
  114a1c:	80 e1 01             	and    $0x1,%cl
  114a1f:	0f b6 c9             	movzbl %cl,%ecx
  114a22:	29 c8                	sub    %ecx,%eax
  114a24:	66 89 44 24 48       	mov    %ax,0x48(%esp)
    rb_origo.y = coords->y2 - radius - aa;
  114a29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  114a2c:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  114a30:	0f b7 44 24 7a       	movzwl 0x7a(%esp),%eax
  114a35:	29 c1                	sub    %eax,%ecx
  114a37:	8a 44 24 79          	mov    0x79(%esp),%al
  114a3b:	24 01                	and    $0x1,%al
  114a3d:	0f b6 c0             	movzbl %al,%eax
  114a40:	29 c1                	sub    %eax,%ecx
  114a42:	66 89 4c 24 4a       	mov    %cx,0x4a(%esp)

    lv_point_t cir_out;
    lv_coord_t tmp_out;
    lv_circ_init(&cir_out, &tmp_out, radius);
  114a47:	8d 44 24 40          	lea    0x40(%esp),%eax
  114a4b:	89 04 24             	mov    %eax,(%esp)
  114a4e:	8d 44 24 3e          	lea    0x3e(%esp),%eax
  114a52:	89 44 24 04          	mov    %eax,0x4(%esp)
  114a56:	0f bf 44 24 7a       	movswl 0x7a(%esp),%eax
  114a5b:	89 44 24 08          	mov    %eax,0x8(%esp)
  114a5f:	e8 ec 2f 00 00       	call   117a50 <lv_circ_init>

    lv_point_t cir_in;
    lv_coord_t tmp_in;
    lv_coord_t radius_in = radius - bwidth;
  114a64:	0f b7 44 24 7a       	movzwl 0x7a(%esp),%eax
  114a69:	0f bf 4c 24 76       	movswl 0x76(%esp),%ecx
  114a6e:	29 c8                	sub    %ecx,%eax
  114a70:	66 89 44 24 34       	mov    %ax,0x34(%esp)

    if(radius_in < 0) {
  114a75:	0f bf 4c 24 34       	movswl 0x34(%esp),%ecx
  114a7a:	83 f9 00             	cmp    $0x0,%ecx
  114a7d:	0f 8d 07 00 00 00    	jge    114a8a <lv_draw_rect_border_corner+0x23a>
        radius_in = 0;
  114a83:	66 c7 44 24 34 00 00 	movw   $0x0,0x34(%esp)
    }

    lv_circ_init(&cir_in, &tmp_in, radius_in);
  114a8a:	8d 44 24 38          	lea    0x38(%esp),%eax
  114a8e:	89 04 24             	mov    %eax,(%esp)
  114a91:	8d 44 24 36          	lea    0x36(%esp),%eax
  114a95:	89 44 24 04          	mov    %eax,0x4(%esp)
  114a99:	0f bf 44 24 34       	movswl 0x34(%esp),%eax
  114a9e:	89 44 24 08          	mov    %eax,0x8(%esp)
  114aa2:	e8 a9 2f 00 00       	call   117a50 <lv_circ_init>
    lv_coord_t in_y_seg_start = 0;
    lv_coord_t in_y_seg_end   = 0;
    lv_coord_t in_x_last      = radius - bwidth;
#endif

    while(cir_out.y <= cir_out.x) {
  114aa7:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
  114aac:	0f bf 4c 24 40       	movswl 0x40(%esp),%ecx
  114ab1:	39 c8                	cmp    %ecx,%eax
  114ab3:	0f 8f 2c 05 00 00    	jg     114fe5 <lv_draw_rect_border_corner+0x795>

        /*Calculate the actual width to avoid overwriting pixels*/
        if(cir_in.y < cir_in.x) {
  114ab9:	0f bf 44 24 3a       	movswl 0x3a(%esp),%eax
  114abe:	0f bf 4c 24 38       	movswl 0x38(%esp),%ecx
  114ac3:	39 c8                	cmp    %ecx,%eax
  114ac5:	0f 8d 20 00 00 00    	jge    114aeb <lv_draw_rect_border_corner+0x29b>
            act_w1 = cir_out.x - cir_in.x;
  114acb:	0f bf 44 24 40       	movswl 0x40(%esp),%eax
  114ad0:	0f bf 4c 24 38       	movswl 0x38(%esp),%ecx
  114ad5:	29 c8                	sub    %ecx,%eax
  114ad7:	66 89 44 24 26       	mov    %ax,0x26(%esp)
            act_w2 = act_w1;
  114adc:	66 8b 44 24 26       	mov    0x26(%esp),%ax
  114ae1:	66 89 44 24 24       	mov    %ax,0x24(%esp)
        } else {
  114ae6:	e9 1e 00 00 00       	jmp    114b09 <lv_draw_rect_border_corner+0x2b9>
            act_w1 = cir_out.x - cir_out.y;
  114aeb:	0f bf 44 24 40       	movswl 0x40(%esp),%eax
  114af0:	0f bf 4c 24 42       	movswl 0x42(%esp),%ecx
  114af5:	29 c8                	sub    %ecx,%eax
  114af7:	66 89 44 24 26       	mov    %ax,0x26(%esp)
            act_w2 = act_w1 - 1;
  114afc:	0f bf 4c 24 26       	movswl 0x26(%esp),%ecx
  114b01:	83 e9 01             	sub    $0x1,%ecx
  114b04:	66 89 4c 24 24       	mov    %cx,0x24(%esp)
            }
        }
#endif

        /*Draw the octets to the right bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
  114b09:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114b0e:	83 e0 01             	and    $0x1,%eax
  114b11:	83 f8 00             	cmp    $0x0,%eax
  114b14:	0f 84 f3 00 00 00    	je     114c0d <lv_draw_rect_border_corner+0x3bd>
  114b1a:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114b1f:	83 e0 08             	and    $0x8,%eax
  114b22:	83 f8 00             	cmp    $0x0,%eax
  114b25:	0f 84 e2 00 00 00    	je     114c0d <lv_draw_rect_border_corner+0x3bd>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
  114b2b:	0f bf 44 24 48       	movswl 0x48(%esp),%eax
  114b30:	0f bf 4c 24 40       	movswl 0x40(%esp),%ecx
  114b35:	01 c8                	add    %ecx,%eax
  114b37:	0f bf 4c 24 24       	movswl 0x24(%esp),%ecx
  114b3c:	29 c8                	sub    %ecx,%eax
  114b3e:	66 89 44 24 28       	mov    %ax,0x28(%esp)
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
  114b43:	0f bf 4c 24 48       	movswl 0x48(%esp),%ecx
  114b48:	0f bf 54 24 40       	movswl 0x40(%esp),%edx
  114b4d:	01 d1                	add    %edx,%ecx
  114b4f:	66 89 4c 24 2c       	mov    %cx,0x2c(%esp)
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
  114b54:	0f bf 54 24 4a       	movswl 0x4a(%esp),%edx
  114b59:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  114b5e:	01 f2                	add    %esi,%edx
  114b60:	66 89 54 24 2a       	mov    %dx,0x2a(%esp)
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
  114b65:	0f bf 74 24 4a       	movswl 0x4a(%esp),%esi
  114b6a:	0f bf 7c 24 42       	movswl 0x42(%esp),%edi
  114b6f:	01 fe                	add    %edi,%esi
  114b71:	66 89 74 24 2e       	mov    %si,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114b76:	8b 7d 0c             	mov    0xc(%ebp),%edi
  114b79:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114b7d:	89 1c 24             	mov    %ebx,(%esp)
  114b80:	89 7c 24 04          	mov    %edi,0x4(%esp)
  114b84:	8d 7c 24 70          	lea    0x70(%esp),%edi
  114b88:	8b 3f                	mov    (%edi),%edi
  114b8a:	89 7c 24 08          	mov    %edi,0x8(%esp)
  114b8e:	0f b6 7c 24 6e       	movzbl 0x6e(%esp),%edi
  114b93:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  114b97:	e8 04 d2 ff ff       	call   111da0 <lv_draw_fill>

            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
  114b9c:	0f bf 7c 24 48       	movswl 0x48(%esp),%edi
  114ba1:	0f bf 5c 24 42       	movswl 0x42(%esp),%ebx
  114ba6:	01 df                	add    %ebx,%edi
  114ba8:	66 89 7c 24 28       	mov    %di,0x28(%esp)
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
  114bad:	0f bf 5c 24 48       	movswl 0x48(%esp),%ebx
  114bb2:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
  114bb7:	01 c3                	add    %eax,%ebx
  114bb9:	66 89 5c 24 2c       	mov    %bx,0x2c(%esp)
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
  114bbe:	0f bf 44 24 4a       	movswl 0x4a(%esp),%eax
  114bc3:	0f bf 4c 24 40       	movswl 0x40(%esp),%ecx
  114bc8:	01 c8                	add    %ecx,%eax
  114bca:	0f bf 4c 24 26       	movswl 0x26(%esp),%ecx
  114bcf:	29 c8                	sub    %ecx,%eax
  114bd1:	66 89 44 24 2a       	mov    %ax,0x2a(%esp)
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
  114bd6:	0f bf 4c 24 4a       	movswl 0x4a(%esp),%ecx
  114bdb:	0f bf 44 24 40       	movswl 0x40(%esp),%eax
  114be0:	01 c1                	add    %eax,%ecx
  114be2:	66 89 4c 24 2e       	mov    %cx,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114be7:	8b 45 0c             	mov    0xc(%ebp),%eax
  114bea:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  114bee:	89 0c 24             	mov    %ecx,(%esp)
  114bf1:	89 44 24 04          	mov    %eax,0x4(%esp)
  114bf5:	8d 44 24 70          	lea    0x70(%esp),%eax
  114bf9:	8b 00                	mov    (%eax),%eax
  114bfb:	89 44 24 08          	mov    %eax,0x8(%esp)
  114bff:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114c04:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114c08:	e8 93 d1 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Draw the octets to the left bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
  114c0d:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114c12:	83 e0 01             	and    $0x1,%eax
  114c15:	83 f8 00             	cmp    $0x0,%eax
  114c18:	0f 84 03 01 00 00    	je     114d21 <lv_draw_rect_border_corner+0x4d1>
  114c1e:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114c23:	83 e0 04             	and    $0x4,%eax
  114c26:	83 f8 00             	cmp    $0x0,%eax
  114c29:	0f 84 f2 00 00 00    	je     114d21 <lv_draw_rect_border_corner+0x4d1>
  114c2f:	31 c0                	xor    %eax,%eax
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
  114c31:	0f bf 4c 24 58       	movswl 0x58(%esp),%ecx
  114c36:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  114c3b:	89 c6                	mov    %eax,%esi
  114c3d:	29 d6                	sub    %edx,%esi
  114c3f:	01 f1                	add    %esi,%ecx
  114c41:	66 89 4c 24 28       	mov    %cx,0x28(%esp)
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
  114c46:	0f bf 54 24 58       	movswl 0x58(%esp),%edx
  114c4b:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  114c50:	29 f0                	sub    %esi,%eax
  114c52:	01 c2                	add    %eax,%edx
  114c54:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
  114c59:	0f bf 44 24 5a       	movswl 0x5a(%esp),%eax
  114c5e:	0f bf 74 24 40       	movswl 0x40(%esp),%esi
  114c63:	01 f0                	add    %esi,%eax
  114c65:	0f bf 74 24 24       	movswl 0x24(%esp),%esi
  114c6a:	29 f0                	sub    %esi,%eax
  114c6c:	66 89 44 24 2a       	mov    %ax,0x2a(%esp)
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
  114c71:	0f bf 74 24 5a       	movswl 0x5a(%esp),%esi
  114c76:	0f bf 7c 24 40       	movswl 0x40(%esp),%edi
  114c7b:	01 fe                	add    %edi,%esi
  114c7d:	66 89 74 24 2e       	mov    %si,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114c82:	8b 7d 0c             	mov    0xc(%ebp),%edi
  114c85:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114c89:	89 1c 24             	mov    %ebx,(%esp)
  114c8c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  114c90:	8d 7c 24 70          	lea    0x70(%esp),%edi
  114c94:	8b 3f                	mov    (%edi),%edi
  114c96:	89 7c 24 08          	mov    %edi,0x8(%esp)
  114c9a:	0f b6 7c 24 6e       	movzbl 0x6e(%esp),%edi
  114c9f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  114ca3:	e8 f8 d0 ff ff       	call   111da0 <lv_draw_fill>
  114ca8:	31 ff                	xor    %edi,%edi

            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
  114caa:	0f bf 5c 24 58       	movswl 0x58(%esp),%ebx
  114caf:	0f bf 44 24 40       	movswl 0x40(%esp),%eax
  114cb4:	89 f9                	mov    %edi,%ecx
  114cb6:	29 c1                	sub    %eax,%ecx
  114cb8:	01 cb                	add    %ecx,%ebx
  114cba:	66 89 5c 24 28       	mov    %bx,0x28(%esp)
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
  114cbf:	0f bf 44 24 58       	movswl 0x58(%esp),%eax
  114cc4:	0f bf 4c 24 40       	movswl 0x40(%esp),%ecx
  114cc9:	29 cf                	sub    %ecx,%edi
  114ccb:	01 f8                	add    %edi,%eax
  114ccd:	0f bf 4c 24 26       	movswl 0x26(%esp),%ecx
  114cd2:	01 c8                	add    %ecx,%eax
  114cd4:	66 89 44 24 2c       	mov    %ax,0x2c(%esp)
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
  114cd9:	0f bf 4c 24 5a       	movswl 0x5a(%esp),%ecx
  114cde:	0f bf 7c 24 42       	movswl 0x42(%esp),%edi
  114ce3:	01 f9                	add    %edi,%ecx
  114ce5:	66 89 4c 24 2a       	mov    %cx,0x2a(%esp)
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
  114cea:	0f bf 7c 24 5a       	movswl 0x5a(%esp),%edi
  114cef:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
  114cf4:	01 c7                	add    %eax,%edi
  114cf6:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114cfb:	8b 45 0c             	mov    0xc(%ebp),%eax
  114cfe:	8d 4c 24 28          	lea    0x28(%esp),%ecx
  114d02:	89 0c 24             	mov    %ecx,(%esp)
  114d05:	89 44 24 04          	mov    %eax,0x4(%esp)
  114d09:	8d 44 24 70          	lea    0x70(%esp),%eax
  114d0d:	8b 00                	mov    (%eax),%eax
  114d0f:	89 44 24 08          	mov    %eax,0x8(%esp)
  114d13:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114d18:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114d1c:	e8 7f d0 ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Draw the octets to the left top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
  114d21:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114d26:	83 e0 02             	and    $0x2,%eax
  114d29:	83 f8 00             	cmp    $0x0,%eax
  114d2c:	0f 84 37 01 00 00    	je     114e69 <lv_draw_rect_border_corner+0x619>
  114d32:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114d37:	83 e0 04             	and    $0x4,%eax
  114d3a:	83 f8 00             	cmp    $0x0,%eax
  114d3d:	0f 84 26 01 00 00    	je     114e69 <lv_draw_rect_border_corner+0x619>
  114d43:	31 c0                	xor    %eax,%eax
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
  114d45:	0f bf 4c 24 5a       	movswl 0x5a(%esp),%ecx
  114d4a:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  114d4f:	01 d1                	add    %edx,%ecx
  114d51:	0f bf 54 24 62       	movswl 0x62(%esp),%edx
  114d56:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  114d5b:	29 f0                	sub    %esi,%eax
  114d5d:	01 c2                	add    %eax,%edx
  114d5f:	39 d1                	cmp    %edx,%ecx
  114d61:	0f 8e 81 00 00 00    	jle    114de8 <lv_draw_rect_border_corner+0x598>
  114d67:	31 c0                	xor    %eax,%eax
                /*Don't draw if the lines are common in the middle*/
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
  114d69:	0f bf 4c 24 60       	movswl 0x60(%esp),%ecx
  114d6e:	0f bf 54 24 40       	movswl 0x40(%esp),%edx
  114d73:	89 c6                	mov    %eax,%esi
  114d75:	29 d6                	sub    %edx,%esi
  114d77:	01 f1                	add    %esi,%ecx
  114d79:	66 89 4c 24 28       	mov    %cx,0x28(%esp)
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
  114d7e:	0f bf 54 24 60       	movswl 0x60(%esp),%edx
  114d83:	0f bf 74 24 40       	movswl 0x40(%esp),%esi
  114d88:	89 c7                	mov    %eax,%edi
  114d8a:	29 f7                	sub    %esi,%edi
  114d8c:	01 fa                	add    %edi,%edx
  114d8e:	0f bf 74 24 24       	movswl 0x24(%esp),%esi
  114d93:	01 f2                	add    %esi,%edx
  114d95:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
  114d9a:	0f bf 74 24 62       	movswl 0x62(%esp),%esi
  114d9f:	0f bf 7c 24 42       	movswl 0x42(%esp),%edi
  114da4:	89 c3                	mov    %eax,%ebx
  114da6:	29 fb                	sub    %edi,%ebx
  114da8:	01 de                	add    %ebx,%esi
  114daa:	66 89 74 24 2a       	mov    %si,0x2a(%esp)
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
  114daf:	0f bf 7c 24 62       	movswl 0x62(%esp),%edi
  114db4:	0f bf 5c 24 42       	movswl 0x42(%esp),%ebx
  114db9:	29 d8                	sub    %ebx,%eax
  114dbb:	01 c7                	add    %eax,%edi
  114dbd:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
                lv_draw_fill(&circ_area, mask, color, opa);
  114dc2:	8b 45 0c             	mov    0xc(%ebp),%eax
  114dc5:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114dc9:	89 1c 24             	mov    %ebx,(%esp)
  114dcc:	89 44 24 04          	mov    %eax,0x4(%esp)
  114dd0:	8d 44 24 70          	lea    0x70(%esp),%eax
  114dd4:	8b 00                	mov    (%eax),%eax
  114dd6:	89 44 24 08          	mov    %eax,0x8(%esp)
  114dda:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114ddf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114de3:	e8 b8 cf ff ff       	call   111da0 <lv_draw_fill>
  114de8:	31 c0                	xor    %eax,%eax
            }

            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
  114dea:	0f bf 4c 24 60       	movswl 0x60(%esp),%ecx
  114def:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  114df4:	89 c6                	mov    %eax,%esi
  114df6:	29 d6                	sub    %edx,%esi
  114df8:	01 f1                	add    %esi,%ecx
  114dfa:	66 89 4c 24 28       	mov    %cx,0x28(%esp)
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
  114dff:	0f bf 54 24 60       	movswl 0x60(%esp),%edx
  114e04:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  114e09:	89 c7                	mov    %eax,%edi
  114e0b:	29 f7                	sub    %esi,%edi
  114e0d:	01 fa                	add    %edi,%edx
  114e0f:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
  114e14:	0f bf 74 24 62       	movswl 0x62(%esp),%esi
  114e19:	0f bf 7c 24 40       	movswl 0x40(%esp),%edi
  114e1e:	89 c3                	mov    %eax,%ebx
  114e20:	29 fb                	sub    %edi,%ebx
  114e22:	01 de                	add    %ebx,%esi
  114e24:	66 89 74 24 2a       	mov    %si,0x2a(%esp)
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
  114e29:	0f bf 7c 24 62       	movswl 0x62(%esp),%edi
  114e2e:	0f bf 5c 24 40       	movswl 0x40(%esp),%ebx
  114e33:	29 d8                	sub    %ebx,%eax
  114e35:	01 c7                	add    %eax,%edi
  114e37:	0f bf 44 24 26       	movswl 0x26(%esp),%eax
  114e3c:	01 c7                	add    %eax,%edi
  114e3e:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114e43:	8b 45 0c             	mov    0xc(%ebp),%eax
  114e46:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114e4a:	89 1c 24             	mov    %ebx,(%esp)
  114e4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  114e51:	8d 44 24 70          	lea    0x70(%esp),%eax
  114e55:	8b 00                	mov    (%eax),%eax
  114e57:	89 44 24 08          	mov    %eax,0x8(%esp)
  114e5b:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114e60:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114e64:	e8 37 cf ff ff       	call   111da0 <lv_draw_fill>
        }

        /*Draw the octets to the right top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
  114e69:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114e6e:	83 e0 02             	and    $0x2,%eax
  114e71:	83 f8 00             	cmp    $0x0,%eax
  114e74:	0f 84 2c 01 00 00    	je     114fa6 <lv_draw_rect_border_corner+0x756>
  114e7a:	0f b6 44 24 6f       	movzbl 0x6f(%esp),%eax
  114e7f:	83 e0 08             	and    $0x8,%eax
  114e82:	83 f8 00             	cmp    $0x0,%eax
  114e85:	0f 84 1b 01 00 00    	je     114fa6 <lv_draw_rect_border_corner+0x756>
  114e8b:	31 c0                	xor    %eax,%eax
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
  114e8d:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  114e92:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  114e97:	01 d1                	add    %edx,%ecx
  114e99:	66 89 4c 24 28       	mov    %cx,0x28(%esp)
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
  114e9e:	0f bf 54 24 50       	movswl 0x50(%esp),%edx
  114ea3:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  114ea8:	01 f2                	add    %esi,%edx
  114eaa:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
  114eaf:	0f bf 74 24 52       	movswl 0x52(%esp),%esi
  114eb4:	0f bf 7c 24 40       	movswl 0x40(%esp),%edi
  114eb9:	89 c3                	mov    %eax,%ebx
  114ebb:	29 fb                	sub    %edi,%ebx
  114ebd:	01 de                	add    %ebx,%esi
  114ebf:	66 89 74 24 2a       	mov    %si,0x2a(%esp)
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
  114ec4:	0f bf 7c 24 52       	movswl 0x52(%esp),%edi
  114ec9:	0f bf 5c 24 40       	movswl 0x40(%esp),%ebx
  114ece:	29 d8                	sub    %ebx,%eax
  114ed0:	01 c7                	add    %eax,%edi
  114ed2:	0f bf 44 24 24       	movswl 0x24(%esp),%eax
  114ed7:	01 c7                	add    %eax,%edi
  114ed9:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
            lv_draw_fill(&circ_area, mask, color, opa);
  114ede:	8b 45 0c             	mov    0xc(%ebp),%eax
  114ee1:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114ee5:	89 1c 24             	mov    %ebx,(%esp)
  114ee8:	89 44 24 04          	mov    %eax,0x4(%esp)
  114eec:	8d 44 24 70          	lea    0x70(%esp),%eax
  114ef0:	8b 00                	mov    (%eax),%eax
  114ef2:	89 44 24 08          	mov    %eax,0x8(%esp)
  114ef6:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114efb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114eff:	e8 9c ce ff ff       	call   111da0 <lv_draw_fill>
  114f04:	31 c0                	xor    %eax,%eax

            /*Don't draw if the lines are common in the middle*/
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
  114f06:	0f bf 5c 24 4a       	movswl 0x4a(%esp),%ebx
  114f0b:	0f bf 4c 24 42       	movswl 0x42(%esp),%ecx
  114f10:	01 cb                	add    %ecx,%ebx
  114f12:	0f bf 4c 24 52       	movswl 0x52(%esp),%ecx
  114f17:	0f bf 54 24 42       	movswl 0x42(%esp),%edx
  114f1c:	29 d0                	sub    %edx,%eax
  114f1e:	01 c1                	add    %eax,%ecx
  114f20:	39 cb                	cmp    %ecx,%ebx
  114f22:	0f 8e 79 00 00 00    	jle    114fa1 <lv_draw_rect_border_corner+0x751>
  114f28:	31 c0                	xor    %eax,%eax
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
  114f2a:	0f bf 4c 24 50       	movswl 0x50(%esp),%ecx
  114f2f:	0f bf 54 24 40       	movswl 0x40(%esp),%edx
  114f34:	01 d1                	add    %edx,%ecx
  114f36:	0f bf 54 24 26       	movswl 0x26(%esp),%edx
  114f3b:	29 d1                	sub    %edx,%ecx
  114f3d:	66 89 4c 24 28       	mov    %cx,0x28(%esp)
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
  114f42:	0f bf 54 24 50       	movswl 0x50(%esp),%edx
  114f47:	0f bf 74 24 40       	movswl 0x40(%esp),%esi
  114f4c:	01 f2                	add    %esi,%edx
  114f4e:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
  114f53:	0f bf 74 24 52       	movswl 0x52(%esp),%esi
  114f58:	0f bf 7c 24 42       	movswl 0x42(%esp),%edi
  114f5d:	89 c3                	mov    %eax,%ebx
  114f5f:	29 fb                	sub    %edi,%ebx
  114f61:	01 de                	add    %ebx,%esi
  114f63:	66 89 74 24 2a       	mov    %si,0x2a(%esp)
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
  114f68:	0f bf 7c 24 52       	movswl 0x52(%esp),%edi
  114f6d:	0f bf 5c 24 42       	movswl 0x42(%esp),%ebx
  114f72:	29 d8                	sub    %ebx,%eax
  114f74:	01 c7                	add    %eax,%edi
  114f76:	66 89 7c 24 2e       	mov    %di,0x2e(%esp)
                lv_draw_fill(&circ_area, mask, color, opa);
  114f7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  114f7e:	8d 5c 24 28          	lea    0x28(%esp),%ebx
  114f82:	89 1c 24             	mov    %ebx,(%esp)
  114f85:	89 44 24 04          	mov    %eax,0x4(%esp)
  114f89:	8d 44 24 70          	lea    0x70(%esp),%eax
  114f8d:	8b 00                	mov    (%eax),%eax
  114f8f:	89 44 24 08          	mov    %eax,0x8(%esp)
  114f93:	0f b6 44 24 6e       	movzbl 0x6e(%esp),%eax
  114f98:	89 44 24 0c          	mov    %eax,0xc(%esp)
  114f9c:	e8 ff cd ff ff       	call   111da0 <lv_draw_fill>
            }
        }
  114fa1:	e9 00 00 00 00       	jmp    114fa6 <lv_draw_rect_border_corner+0x756>
        lv_circ_next(&cir_out, &tmp_out);
  114fa6:	8d 44 24 40          	lea    0x40(%esp),%eax
  114faa:	89 04 24             	mov    %eax,(%esp)
  114fad:	8d 44 24 3e          	lea    0x3e(%esp),%eax
  114fb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  114fb5:	e8 26 2b 00 00       	call   117ae0 <lv_circ_next>

        /*The internal circle will be ready faster
         * so check it! */
        if(cir_in.y < cir_in.x) {
  114fba:	0f bf 44 24 3a       	movswl 0x3a(%esp),%eax
  114fbf:	0f bf 4c 24 38       	movswl 0x38(%esp),%ecx
  114fc4:	39 c8                	cmp    %ecx,%eax
  114fc6:	0f 8d 14 00 00 00    	jge    114fe0 <lv_draw_rect_border_corner+0x790>
            lv_circ_next(&cir_in, &tmp_in);
  114fcc:	8d 44 24 38          	lea    0x38(%esp),%eax
  114fd0:	89 04 24             	mov    %eax,(%esp)
  114fd3:	8d 44 24 36          	lea    0x36(%esp),%eax
  114fd7:	89 44 24 04          	mov    %eax,0x4(%esp)
  114fdb:	e8 00 2b 00 00       	call   117ae0 <lv_circ_next>
    while(cir_out.y <= cir_out.x) {
  114fe0:	e9 c2 fa ff ff       	jmp    114aa7 <lv_draw_rect_border_corner+0x257>
                }
            }
        }
    }
#endif
}
  114fe5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114fe8:	5e                   	pop    %esi
  114fe9:	5f                   	pop    %edi
  114fea:	5b                   	pop    %ebx
  114feb:	5d                   	pop    %ebp
  114fec:	c3                   	ret    
  114fed:	66 90                	xchg   %ax,%ax
  114fef:	90                   	nop

00114ff0 <lv_draw_cont_radius_corr>:
}

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
  114ff0:	55                   	push   %ebp
  114ff1:	89 e5                	mov    %esp,%ebp
  114ff3:	57                   	push   %edi
  114ff4:	56                   	push   %esi
  114ff5:	83 ec 0c             	sub    $0xc,%esp
  114ff8:	66 8b 45 10          	mov    0x10(%ebp),%ax
  114ffc:	66 8b 4d 0c          	mov    0xc(%ebp),%cx
  115000:	66 8b 55 08          	mov    0x8(%ebp),%dx
  115004:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  115008:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
  11500c:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
  115010:	e8 bb b1 ff ff       	call   1101d0 <lv_refr_get_disp_refreshing>
  115015:	89 04 24             	mov    %eax,(%esp)
  115018:	e8 53 28 00 00       	call   117870 <lv_disp_get_antialiasing>
  11501d:	24 01                	and    $0x1,%al
  11501f:	88 45 f7             	mov    %al,-0x9(%ebp)

    if(r >= (w >> 1)) {
  115022:	0f b7 75 08          	movzwl 0x8(%ebp),%esi
  115026:	0f bf 7d 0c          	movswl 0xc(%ebp),%edi
  11502a:	c1 ff 01             	sar    $0x1,%edi
  11502d:	39 fe                	cmp    %edi,%esi
  11502f:	0f 8c 29 00 00 00    	jl     11505e <lv_draw_cont_radius_corr+0x6e>
        r = (w >> 1);
  115035:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  115039:	c1 f8 01             	sar    $0x1,%eax
  11503c:	66 89 45 08          	mov    %ax,0x8(%ebp)
        if(r != 0) r--;
  115040:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
  115044:	83 f9 00             	cmp    $0x0,%ecx
  115047:	0f 84 0c 00 00 00    	je     115059 <lv_draw_cont_radius_corr+0x69>
  11504d:	66 8b 45 08          	mov    0x8(%ebp),%ax
  115051:	66 83 c0 ff          	add    $0xffff,%ax
  115055:	66 89 45 08          	mov    %ax,0x8(%ebp)
    }
  115059:	e9 00 00 00 00       	jmp    11505e <lv_draw_cont_radius_corr+0x6e>
    if(r >= (h >> 1)) {
  11505e:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  115062:	0f bf 4d 10          	movswl 0x10(%ebp),%ecx
  115066:	c1 f9 01             	sar    $0x1,%ecx
  115069:	39 c8                	cmp    %ecx,%eax
  11506b:	0f 8c 29 00 00 00    	jl     11509a <lv_draw_cont_radius_corr+0xaa>
        r = (h >> 1);
  115071:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  115075:	c1 f8 01             	sar    $0x1,%eax
  115078:	66 89 45 08          	mov    %ax,0x8(%ebp)
        if(r != 0) r--;
  11507c:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
  115080:	83 f9 00             	cmp    $0x0,%ecx
  115083:	0f 84 0c 00 00 00    	je     115095 <lv_draw_cont_radius_corr+0xa5>
  115089:	66 8b 45 08          	mov    0x8(%ebp),%ax
  11508d:	66 83 c0 ff          	add    $0xffff,%ax
  115091:	66 89 45 08          	mov    %ax,0x8(%ebp)
    }
  115095:	e9 00 00 00 00       	jmp    11509a <lv_draw_cont_radius_corr+0xaa>

    if(r > 0) r -= aa;
  11509a:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  11509e:	83 f8 00             	cmp    $0x0,%eax
  1150a1:	0f 8e 12 00 00 00    	jle    1150b9 <lv_draw_cont_radius_corr+0xc9>
  1150a7:	8a 45 f7             	mov    -0x9(%ebp),%al
  1150aa:	24 01                	and    $0x1,%al
  1150ac:	0f b6 c8             	movzbl %al,%ecx
  1150af:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
  1150b3:	29 ca                	sub    %ecx,%edx
  1150b5:	66 89 55 08          	mov    %dx,0x8(%ebp)

    return r;
  1150b9:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1150bd:	83 c4 0c             	add    $0xc,%esp
  1150c0:	5e                   	pop    %esi
  1150c1:	5f                   	pop    %edi
  1150c2:	5d                   	pop    %ebp
  1150c3:	c3                   	ret    
  1150c4:	66 90                	xchg   %ax,%ax
  1150c6:	66 90                	xchg   %ax,%ax
  1150c8:	66 90                	xchg   %ax,%ax
  1150ca:	66 90                	xchg   %ax,%ax
  1150cc:	66 90                	xchg   %ax,%ax
  1150ce:	66 90                	xchg   %ax,%ax

001150d0 <lv_color_mix>:
{
  1150d0:	55                   	push   %ebp
  1150d1:	89 e5                	mov    %esp,%ebp
  1150d3:	53                   	push   %ebx
  1150d4:	57                   	push   %edi
  1150d5:	56                   	push   %esi
  1150d6:	83 ec 18             	sub    $0x18,%esp
  1150d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1150dc:	89 c1                	mov    %eax,%ecx
  1150de:	8a 55 14             	mov    0x14(%ebp),%dl
  1150e1:	8d 75 10             	lea    0x10(%ebp),%esi
  1150e4:	8d 7d 0c             	lea    0xc(%ebp),%edi
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
  1150e7:	0f b6 5f 02          	movzbl 0x2(%edi),%ebx
  1150eb:	0f b7 db             	movzwl %bx,%ebx
  1150ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1150f1:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  1150f5:	0f af d8             	imul   %eax,%ebx
  1150f8:	0f b6 46 02          	movzbl 0x2(%esi),%eax
  1150fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1150ff:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  115103:	89 45 e8             	mov    %eax,-0x18(%ebp)
  115106:	b8 ff 00 00 00       	mov    $0xff,%eax
  11510b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11510e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  115111:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  115114:	29 c8                	sub    %ecx,%eax
  115116:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  115119:	0f af c8             	imul   %eax,%ecx
  11511c:	01 cb                	add    %ecx,%ebx
  11511e:	0f b7 c3             	movzwl %bx,%eax
  115121:	c1 f8 08             	sar    $0x8,%eax
  115124:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  115127:	88 41 02             	mov    %al,0x2(%ecx)
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
  11512a:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  11512e:	0f b7 c0             	movzwl %ax,%eax
  115131:	0f b6 5d 14          	movzbl 0x14(%ebp),%ebx
  115135:	0f af c3             	imul   %ebx,%eax
  115138:	0f b6 5e 01          	movzbl 0x1(%esi),%ebx
  11513c:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  115140:	89 45 dc             	mov    %eax,-0x24(%ebp)
  115143:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  115146:	29 c8                	sub    %ecx,%eax
  115148:	0f af d8             	imul   %eax,%ebx
  11514b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11514e:	01 d8                	add    %ebx,%eax
  115150:	0f b7 c8             	movzwl %ax,%ecx
  115153:	c1 f9 08             	sar    $0x8,%ecx
  115156:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  115159:	88 4b 01             	mov    %cl,0x1(%ebx)
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
  11515c:	0f b6 3f             	movzbl (%edi),%edi
  11515f:	0f b7 cf             	movzwl %di,%ecx
  115162:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  115166:	0f af c8             	imul   %eax,%ecx
  115169:	0f b6 06             	movzbl (%esi),%eax
  11516c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  115170:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  115173:	29 f7                	sub    %esi,%edi
  115175:	0f af c7             	imul   %edi,%eax
  115178:	01 c1                	add    %eax,%ecx
  11517a:	0f b7 c1             	movzwl %cx,%eax
  11517d:	c1 f8 08             	sar    $0x8,%eax
  115180:	88 03                	mov    %al,(%ebx)
    ret.ch.alpha = 0xFF;
  115182:	c6 43 03 ff          	movb   $0xff,0x3(%ebx)
  115186:	8b 45 e0             	mov    -0x20(%ebp),%eax
    return ret;
  115189:	83 c4 18             	add    $0x18,%esp
  11518c:	5e                   	pop    %esi
  11518d:	5f                   	pop    %edi
  11518e:	5b                   	pop    %ebx
  11518f:	5d                   	pop    %ebp
  115190:	c2 04 00             	ret    $0x4
  115193:	66 90                	xchg   %ax,%ax
  115195:	66 90                	xchg   %ax,%ax
  115197:	66 90                	xchg   %ax,%ax
  115199:	66 90                	xchg   %ax,%ax
  11519b:	66 90                	xchg   %ax,%ax
  11519d:	66 90                	xchg   %ax,%ax
  11519f:	90                   	nop

001151a0 <lv_draw_label>:
 * @param sel_end end index of selected area (`LV_LABEL_TXT_SEL_OFF` if none)
 */
void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale,
                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset, uint16_t sel_start, uint16_t sel_end,
                   lv_draw_label_hint_t * hint)
{
  1151a0:	55                   	push   %ebp
  1151a1:	89 e5                	mov    %esp,%ebp
  1151a3:	53                   	push   %ebx
  1151a4:	57                   	push   %edi
  1151a5:	56                   	push   %esi
  1151a6:	83 e4 f8             	and    $0xfffffff8,%esp
  1151a9:	81 ec 18 01 00 00    	sub    $0x118,%esp
  1151af:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1151b2:	66 8b 4d 28          	mov    0x28(%ebp),%cx
  1151b6:	66 8b 55 24          	mov    0x24(%ebp),%dx
  1151ba:	8b 75 20             	mov    0x20(%ebp),%esi
  1151bd:	8a 5d 1c             	mov    0x1c(%ebp),%bl
  1151c0:	8b 7d 18             	mov    0x18(%ebp),%edi
  1151c3:	8a 7d 14             	mov    0x14(%ebp),%bh
  1151c6:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  1151ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1151cd:	89 44 24 48          	mov    %eax,0x48(%esp)
  1151d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1151d4:	89 44 24 44          	mov    %eax,0x44(%esp)
  1151d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1151db:	89 44 24 40          	mov    %eax,0x40(%esp)
    const lv_font_t * font = style->text.font;
  1151df:	8b 45 10             	mov    0x10(%ebp),%eax
  1151e2:	8b 40 34             	mov    0x34(%eax),%eax
  1151e5:	89 84 24 10 01 00 00 	mov    %eax,0x110(%esp)
    lv_coord_t w;
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
  1151ec:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1151f0:	83 e0 02             	and    $0x2,%eax
  1151f3:	83 f8 00             	cmp    $0x0,%eax
  1151f6:	0f 85 18 00 00 00    	jne    115214 <lv_draw_label+0x74>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
  1151fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1151ff:	89 04 24             	mov    %eax,(%esp)
  115202:	e8 59 0b 00 00       	call   115d60 <lv_area_get_width>
  115207:	66 89 84 24 0e 01 00 	mov    %ax,0x10e(%esp)
  11520e:	00 
    } else {
  11520f:	e9 5c 00 00 00       	jmp    115270 <lv_draw_label+0xd0>
        /*If EXAPND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
  115214:	8b 45 18             	mov    0x18(%ebp),%eax
  115217:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11521a:	8b 49 34             	mov    0x34(%ecx),%ecx
  11521d:	8b 55 10             	mov    0x10(%ebp),%edx
  115220:	66 8b 72 38          	mov    0x38(%edx),%si
  115224:	8b 55 10             	mov    0x10(%ebp),%edx
  115227:	66 8b 7a 3a          	mov    0x3a(%edx),%di
  11522b:	8d 94 24 08 01 00 00 	lea    0x108(%esp),%edx
  115232:	89 14 24             	mov    %edx,(%esp)
  115235:	89 44 24 04          	mov    %eax,0x4(%esp)
  115239:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11523d:	0f bf c6             	movswl %si,%eax
  115240:	89 44 24 0c          	mov    %eax,0xc(%esp)
  115244:	0f bf c7             	movswl %di,%eax
  115247:	89 44 24 10          	mov    %eax,0x10(%esp)
  11524b:	c7 44 24 14 18 7c 00 	movl   $0x7c18,0x14(%esp)
  115252:	00 
  115253:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115257:	89 44 24 18          	mov    %eax,0x18(%esp)
  11525b:	e8 c0 40 00 00       	call   119320 <lv_txt_get_size>
                        flag);
        w = p.x;
  115260:	66 8b b4 24 08 01 00 	mov    0x108(%esp),%si
  115267:	00 
  115268:	66 89 b4 24 0e 01 00 	mov    %si,0x10e(%esp)
  11526f:	00 
    }

    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
  115270:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
  115277:	89 04 24             	mov    %eax,(%esp)
  11527a:	e8 11 0b 00 00       	call   115d90 <lv_font_get_line_height>
  11527f:	0f b6 c8             	movzbl %al,%ecx
  115282:	8b 55 10             	mov    0x10(%ebp),%edx
  115285:	0f bf 52 3a          	movswl 0x3a(%edx),%edx
  115289:	01 d1                	add    %edx,%ecx
  11528b:	66 89 8c 24 06 01 00 	mov    %cx,0x106(%esp)
  115292:	00 

    /*Init variables for the first line*/
    lv_coord_t line_width = 0;
  115293:	66 c7 84 24 04 01 00 	movw   $0x0,0x104(%esp)
  11529a:	00 00 00 
    lv_point_t pos;
    pos.x = coords->x1;
  11529d:	8b 55 08             	mov    0x8(%ebp),%edx
  1152a0:	66 8b 0a             	mov    (%edx),%cx
  1152a3:	66 89 8c 24 00 01 00 	mov    %cx,0x100(%esp)
  1152aa:	00 
    pos.y = coords->y1;
  1152ab:	8b 55 08             	mov    0x8(%ebp),%edx
  1152ae:	66 8b 4a 02          	mov    0x2(%edx),%cx
  1152b2:	66 89 8c 24 02 01 00 	mov    %cx,0x102(%esp)
  1152b9:	00 

    lv_coord_t x_ofs = 0;
  1152ba:	66 c7 84 24 fe 00 00 	movw   $0x0,0xfe(%esp)
  1152c1:	00 00 00 
    lv_coord_t y_ofs = 0;
  1152c4:	66 c7 84 24 fc 00 00 	movw   $0x0,0xfc(%esp)
  1152cb:	00 00 00 
    if(offset != NULL) {
  1152ce:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  1152d2:	0f 84 37 00 00 00    	je     11530f <lv_draw_label+0x16f>
        x_ofs = offset->x;
  1152d8:	8b 45 20             	mov    0x20(%ebp),%eax
  1152db:	66 8b 08             	mov    (%eax),%cx
  1152de:	66 89 8c 24 fe 00 00 	mov    %cx,0xfe(%esp)
  1152e5:	00 
        y_ofs = offset->y;
  1152e6:	8b 45 20             	mov    0x20(%ebp),%eax
  1152e9:	66 8b 48 02          	mov    0x2(%eax),%cx
  1152ed:	66 89 8c 24 fc 00 00 	mov    %cx,0xfc(%esp)
  1152f4:	00 
        pos.y += y_ofs;
  1152f5:	0f bf 84 24 fc 00 00 	movswl 0xfc(%esp),%eax
  1152fc:	00 
  1152fd:	0f bf 94 24 02 01 00 	movswl 0x102(%esp),%edx
  115304:	00 
  115305:	01 c2                	add    %eax,%edx
  115307:	66 89 94 24 02 01 00 	mov    %dx,0x102(%esp)
  11530e:	00 
    }

    uint32_t line_start     = 0;
  11530f:	c7 84 24 f8 00 00 00 	movl   $0x0,0xf8(%esp)
  115316:	00 00 00 00 
    int32_t last_line_start = -1;
  11531a:	c7 84 24 f4 00 00 00 	movl   $0xffffffff,0xf4(%esp)
  115321:	ff ff ff ff 

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0 && coords->y1 < 0) {
  115325:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
  115329:	0f 84 9b 00 00 00    	je     1153ca <lv_draw_label+0x22a>
  11532f:	0f bf 84 24 fc 00 00 	movswl 0xfc(%esp),%eax
  115336:	00 
  115337:	83 f8 00             	cmp    $0x0,%eax
  11533a:	0f 85 8a 00 00 00    	jne    1153ca <lv_draw_label+0x22a>
  115340:	8b 45 08             	mov    0x8(%ebp),%eax
  115343:	0f bf 40 02          	movswl 0x2(%eax),%eax
  115347:	83 f8 00             	cmp    $0x0,%eax
  11534a:	0f 8d 7a 00 00 00    	jge    1153ca <lv_draw_label+0x22a>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
  115350:	8b 45 2c             	mov    0x2c(%ebp),%eax
  115353:	8b 40 08             	mov    0x8(%eax),%eax
  115356:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115359:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  11535d:	29 c8                	sub    %ecx,%eax
  11535f:	83 f8 00             	cmp    $0x0,%eax
  115362:	0f 8e 18 00 00 00    	jle    115380 <lv_draw_label+0x1e0>
  115368:	8b 45 2c             	mov    0x2c(%ebp),%eax
  11536b:	8b 40 08             	mov    0x8(%eax),%eax
  11536e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115371:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  115375:	29 c8                	sub    %ecx,%eax
  115377:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  11537b:	e9 17 00 00 00       	jmp    115397 <lv_draw_label+0x1f7>
  115380:	31 c0                	xor    %eax,%eax
  115382:	8b 4d 2c             	mov    0x2c(%ebp),%ecx
  115385:	8b 49 08             	mov    0x8(%ecx),%ecx
  115388:	8b 55 08             	mov    0x8(%ebp),%edx
  11538b:	0f bf 52 02          	movswl 0x2(%edx),%edx
  11538f:	29 d1                	sub    %edx,%ecx
  115391:	29 c8                	sub    %ecx,%eax
  115393:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  115397:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11539b:	0f bf 8c 24 06 01 00 	movswl 0x106(%esp),%ecx
  1153a2:	00 
  1153a3:	c1 e1 01             	shl    $0x1,%ecx
  1153a6:	ba 00 04 00 00       	mov    $0x400,%edx
  1153ab:	29 ca                	sub    %ecx,%edx
  1153ad:	39 d0                	cmp    %edx,%eax
  1153af:	0f 8e 09 00 00 00    	jle    1153be <lv_draw_label+0x21e>
            hint->line_start = -1;
  1153b5:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1153b8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
        }
        last_line_start = hint->line_start;
  1153be:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1153c1:	8b 00                	mov    (%eax),%eax
  1153c3:	89 84 24 f4 00 00 00 	mov    %eax,0xf4(%esp)
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
  1153ca:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
  1153ce:	0f 84 34 00 00 00    	je     115408 <lv_draw_label+0x268>
  1153d4:	83 bc 24 f4 00 00 00 	cmpl   $0x0,0xf4(%esp)
  1153db:	00 
  1153dc:	0f 8c 26 00 00 00    	jl     115408 <lv_draw_label+0x268>
        line_start = last_line_start;
  1153e2:	8b 84 24 f4 00 00 00 	mov    0xf4(%esp),%eax
  1153e9:	89 84 24 f8 00 00 00 	mov    %eax,0xf8(%esp)
        pos.y += hint->y;
  1153f0:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1153f3:	8b 40 04             	mov    0x4(%eax),%eax
  1153f6:	0f bf 8c 24 02 01 00 	movswl 0x102(%esp),%ecx
  1153fd:	00 
  1153fe:	01 c1                	add    %eax,%ecx
  115400:	66 89 8c 24 02 01 00 	mov    %cx,0x102(%esp)
  115407:	00 
    }

    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
  115408:	8b 84 24 f8 00 00 00 	mov    0xf8(%esp),%eax
  11540f:	8b 4d 18             	mov    0x18(%ebp),%ecx
  115412:	03 8c 24 f8 00 00 00 	add    0xf8(%esp),%ecx
  115419:	8b 94 24 10 01 00 00 	mov    0x110(%esp),%edx
  115420:	8b 75 10             	mov    0x10(%ebp),%esi
  115423:	66 8b 7e 38          	mov    0x38(%esi),%di
  115427:	66 8b 9c 24 0e 01 00 	mov    0x10e(%esp),%bx
  11542e:	00 
  11542f:	89 0c 24             	mov    %ecx,(%esp)
  115432:	89 54 24 04          	mov    %edx,0x4(%esp)
  115436:	0f bf cf             	movswl %di,%ecx
  115439:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11543d:	0f bf cb             	movswl %bx,%ecx
  115440:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  115444:	0f b6 4d 1c          	movzbl 0x1c(%ebp),%ecx
  115448:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11544c:	89 44 24 38          	mov    %eax,0x38(%esp)
  115450:	e8 eb 40 00 00       	call   119540 <lv_txt_get_next_line>
  115455:	0f b7 c8             	movzwl %ax,%ecx
  115458:	8b 54 24 38          	mov    0x38(%esp),%edx
  11545c:	01 ca                	add    %ecx,%edx
  11545e:	89 94 24 f0 00 00 00 	mov    %edx,0xf0(%esp)

    /*Go the first visible line*/
    while(pos.y + line_height < mask->y1) {
  115465:	0f bf 84 24 02 01 00 	movswl 0x102(%esp),%eax
  11546c:	00 
  11546d:	0f bf 8c 24 06 01 00 	movswl 0x106(%esp),%ecx
  115474:	00 
  115475:	01 c8                	add    %ecx,%eax
  115477:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11547a:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  11547e:	39 c8                	cmp    %ecx,%eax
  115480:	0f 8d f5 00 00 00    	jge    11557b <lv_draw_label+0x3db>
        /*Go to next line*/
        line_start = line_end;
  115486:	8b 84 24 f0 00 00 00 	mov    0xf0(%esp),%eax
  11548d:	89 84 24 f8 00 00 00 	mov    %eax,0xf8(%esp)
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
  115494:	8b 45 18             	mov    0x18(%ebp),%eax
  115497:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  11549e:	8b 8c 24 10 01 00 00 	mov    0x110(%esp),%ecx
  1154a5:	8b 55 10             	mov    0x10(%ebp),%edx
  1154a8:	66 8b 72 38          	mov    0x38(%edx),%si
  1154ac:	66 8b bc 24 0e 01 00 	mov    0x10e(%esp),%di
  1154b3:	00 
  1154b4:	89 04 24             	mov    %eax,(%esp)
  1154b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1154bb:	0f bf c6             	movswl %si,%eax
  1154be:	89 44 24 08          	mov    %eax,0x8(%esp)
  1154c2:	0f bf c7             	movswl %di,%eax
  1154c5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1154c9:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1154cd:	89 44 24 10          	mov    %eax,0x10(%esp)
  1154d1:	e8 6a 40 00 00       	call   119540 <lv_txt_get_next_line>
  1154d6:	0f b7 c8             	movzwl %ax,%ecx
  1154d9:	03 8c 24 f0 00 00 00 	add    0xf0(%esp),%ecx
  1154e0:	89 8c 24 f0 00 00 00 	mov    %ecx,0xf0(%esp)
        pos.y += line_height;
  1154e7:	0f bf 8c 24 06 01 00 	movswl 0x106(%esp),%ecx
  1154ee:	00 
  1154ef:	0f bf 94 24 02 01 00 	movswl 0x102(%esp),%edx
  1154f6:	00 
  1154f7:	01 ca                	add    %ecx,%edx
  1154f9:	66 89 94 24 02 01 00 	mov    %dx,0x102(%esp)
  115500:	00 

        /*Save at the threshold coordinate*/
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
  115501:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
  115505:	0f 84 4f 00 00 00    	je     11555a <lv_draw_label+0x3ba>
  11550b:	0f bf 84 24 02 01 00 	movswl 0x102(%esp),%eax
  115512:	00 
  115513:	3d 00 fc ff ff       	cmp    $0xfffffc00,%eax
  115518:	0f 8c 3c 00 00 00    	jl     11555a <lv_draw_label+0x3ba>
  11551e:	8b 45 2c             	mov    0x2c(%ebp),%eax
  115521:	83 38 00             	cmpl   $0x0,(%eax)
  115524:	0f 8d 30 00 00 00    	jge    11555a <lv_draw_label+0x3ba>
            hint->line_start = line_start;
  11552a:	8b 84 24 f8 00 00 00 	mov    0xf8(%esp),%eax
  115531:	8b 4d 2c             	mov    0x2c(%ebp),%ecx
  115534:	89 01                	mov    %eax,(%ecx)
            hint->y          = pos.y - coords->y1;
  115536:	0f bf 84 24 02 01 00 	movswl 0x102(%esp),%eax
  11553d:	00 
  11553e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115541:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  115545:	29 c8                	sub    %ecx,%eax
  115547:	8b 4d 2c             	mov    0x2c(%ebp),%ecx
  11554a:	89 41 04             	mov    %eax,0x4(%ecx)
            hint->coord_y    = coords->y1;
  11554d:	8b 45 08             	mov    0x8(%ebp),%eax
  115550:	0f bf 40 02          	movswl 0x2(%eax),%eax
  115554:	8b 4d 2c             	mov    0x2c(%ebp),%ecx
  115557:	89 41 08             	mov    %eax,0x8(%ecx)
        }

        if(txt[line_start] == '\0') return;
  11555a:	8b 45 18             	mov    0x18(%ebp),%eax
  11555d:	8b 8c 24 f8 00 00 00 	mov    0xf8(%esp),%ecx
  115564:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  115568:	83 f8 00             	cmp    $0x0,%eax
  11556b:	0f 85 05 00 00 00    	jne    115576 <lv_draw_label+0x3d6>
  115571:	e9 dd 07 00 00       	jmp    115d53 <lv_draw_label+0xbb3>
    while(pos.y + line_height < mask->y1) {
  115576:	e9 ea fe ff ff       	jmp    115465 <lv_draw_label+0x2c5>
    }

    /*Align to middle*/
    if(flag & LV_TXT_FLAG_CENTER) {
  11557b:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  11557f:	83 e0 04             	and    $0x4,%eax
  115582:	83 f8 00             	cmp    $0x0,%eax
  115585:	0f 84 89 00 00 00    	je     115614 <lv_draw_label+0x474>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
  11558b:	8b 45 18             	mov    0x18(%ebp),%eax
  11558e:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  115595:	8b 8c 24 f0 00 00 00 	mov    0xf0(%esp),%ecx
  11559c:	2b 8c 24 f8 00 00 00 	sub    0xf8(%esp),%ecx
  1155a3:	8b 94 24 10 01 00 00 	mov    0x110(%esp),%edx
  1155aa:	8b 75 10             	mov    0x10(%ebp),%esi
  1155ad:	66 8b 7e 38          	mov    0x38(%esi),%di
  1155b1:	89 04 24             	mov    %eax,(%esp)
  1155b4:	0f b7 c1             	movzwl %cx,%eax
  1155b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1155bb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1155bf:	0f bf c7             	movswl %di,%eax
  1155c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1155c6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1155ca:	89 44 24 10          	mov    %eax,0x10(%esp)
  1155ce:	e8 ad 41 00 00       	call   119780 <lv_txt_get_width>
  1155d3:	66 89 84 24 04 01 00 	mov    %ax,0x104(%esp)
  1155da:	00 

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
  1155db:	8b 55 08             	mov    0x8(%ebp),%edx
  1155de:	89 14 24             	mov    %edx,(%esp)
  1155e1:	e8 7a 07 00 00       	call   115d60 <lv_area_get_width>
  1155e6:	0f bf d0             	movswl %ax,%edx
  1155e9:	0f bf b4 24 04 01 00 	movswl 0x104(%esp),%esi
  1155f0:	00 
  1155f1:	29 f2                	sub    %esi,%edx
  1155f3:	89 d0                	mov    %edx,%eax
  1155f5:	99                   	cltd   
  1155f6:	be 02 00 00 00       	mov    $0x2,%esi
  1155fb:	f7 fe                	idiv   %esi
  1155fd:	0f bf b4 24 00 01 00 	movswl 0x100(%esp),%esi
  115604:	00 
  115605:	01 c6                	add    %eax,%esi
  115607:	66 89 b4 24 00 01 00 	mov    %si,0x100(%esp)
  11560e:	00 

    }
  11560f:	e9 8f 00 00 00       	jmp    1156a3 <lv_draw_label+0x503>
    /*Align to the right*/
    else if(flag & LV_TXT_FLAG_RIGHT) {
  115614:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115618:	83 e0 08             	and    $0x8,%eax
  11561b:	83 f8 00             	cmp    $0x0,%eax
  11561e:	0f 84 7a 00 00 00    	je     11569e <lv_draw_label+0x4fe>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
  115624:	8b 45 18             	mov    0x18(%ebp),%eax
  115627:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  11562e:	8b 8c 24 f0 00 00 00 	mov    0xf0(%esp),%ecx
  115635:	2b 8c 24 f8 00 00 00 	sub    0xf8(%esp),%ecx
  11563c:	8b 94 24 10 01 00 00 	mov    0x110(%esp),%edx
  115643:	8b 75 10             	mov    0x10(%ebp),%esi
  115646:	66 8b 7e 38          	mov    0x38(%esi),%di
  11564a:	89 04 24             	mov    %eax,(%esp)
  11564d:	0f b7 c1             	movzwl %cx,%eax
  115650:	89 44 24 04          	mov    %eax,0x4(%esp)
  115654:	89 54 24 08          	mov    %edx,0x8(%esp)
  115658:	0f bf c7             	movswl %di,%eax
  11565b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11565f:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115663:	89 44 24 10          	mov    %eax,0x10(%esp)
  115667:	e8 14 41 00 00       	call   119780 <lv_txt_get_width>
  11566c:	66 89 84 24 04 01 00 	mov    %ax,0x104(%esp)
  115673:	00 
        pos.x += lv_area_get_width(coords) - line_width;
  115674:	8b 55 08             	mov    0x8(%ebp),%edx
  115677:	89 14 24             	mov    %edx,(%esp)
  11567a:	e8 e1 06 00 00       	call   115d60 <lv_area_get_width>
  11567f:	0f bf d0             	movswl %ax,%edx
  115682:	0f bf b4 24 04 01 00 	movswl 0x104(%esp),%esi
  115689:	00 
  11568a:	29 f2                	sub    %esi,%edx
  11568c:	0f bf b4 24 00 01 00 	movswl 0x100(%esp),%esi
  115693:	00 
  115694:	01 d6                	add    %edx,%esi
  115696:	66 89 b4 24 00 01 00 	mov    %si,0x100(%esp)
  11569d:	00 
  11569e:	e9 00 00 00 00       	jmp    1156a3 <lv_draw_label+0x503>
    }

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
  1156a3:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  1156a7:	3d ff 00 00 00       	cmp    $0xff,%eax
  1156ac:	0f 85 10 00 00 00    	jne    1156c2 <lv_draw_label+0x522>
  1156b2:	8b 45 10             	mov    0x10(%ebp),%eax
  1156b5:	0f b6 40 3c          	movzbl 0x3c(%eax),%eax
  1156b9:	89 44 24 34          	mov    %eax,0x34(%esp)
  1156bd:	e9 1b 00 00 00       	jmp    1156dd <lv_draw_label+0x53d>
  1156c2:	8b 45 10             	mov    0x10(%ebp),%eax
  1156c5:	0f b6 40 3c          	movzbl 0x3c(%eax),%eax
  1156c9:	0f b7 c8             	movzwl %ax,%ecx
  1156cc:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  1156d0:	0f af ca             	imul   %edx,%ecx
  1156d3:	0f b7 d1             	movzwl %cx,%edx
  1156d6:	c1 fa 08             	sar    $0x8,%edx
  1156d9:	89 54 24 34          	mov    %edx,0x34(%esp)
  1156dd:	8b 44 24 34          	mov    0x34(%esp),%eax
  1156e1:	88 84 24 ef 00 00 00 	mov    %al,0xef(%esp)

    cmd_state_t cmd_state = CMD_STATE_WAIT;
  1156e8:	c6 84 24 ee 00 00 00 	movb   $0x0,0xee(%esp)
  1156ef:	00 
    uint32_t i;
    uint16_t par_start = 0;
  1156f0:	66 c7 84 24 e6 00 00 	movw   $0x0,0xe6(%esp)
  1156f7:	00 00 00 
    lv_color_t recolor;
    lv_coord_t letter_w;
    lv_style_t sel_style;
    lv_style_copy(&sel_style, &lv_style_plain_color);
  1156fa:	8d 8c 24 88 00 00 00 	lea    0x88(%esp),%ecx
  115701:	89 0c 24             	mov    %ecx,(%esp)
  115704:	8d 0d f0 51 13 00    	lea    0x1351f0,%ecx
  11570a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11570e:	e8 4d c5 ff ff       	call   111c60 <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
  115713:	8b 4d 10             	mov    0x10(%ebp),%ecx
  115716:	8b 49 30             	mov    0x30(%ecx),%ecx
  115719:	89 8c 24 90 00 00 00 	mov    %ecx,0x90(%esp)
  115720:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
  115727:	89 8c 24 8c 00 00 00 	mov    %ecx,0x8c(%esp)

    /*Write out all lines*/
    while(txt[line_start] != '\0') {
  11572e:	8b 45 18             	mov    0x18(%ebp),%eax
  115731:	8b 8c 24 f8 00 00 00 	mov    0xf8(%esp),%ecx
  115738:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  11573c:	83 f8 00             	cmp    $0x0,%eax
  11573f:	0f 84 0e 06 00 00    	je     115d53 <lv_draw_label+0xbb3>
        if(offset != NULL) {
  115745:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  115749:	0f 84 1a 00 00 00    	je     115769 <lv_draw_label+0x5c9>
            pos.x += x_ofs;
  11574f:	0f bf 84 24 fe 00 00 	movswl 0xfe(%esp),%eax
  115756:	00 
  115757:	0f bf 8c 24 00 01 00 	movswl 0x100(%esp),%ecx
  11575e:	00 
  11575f:	01 c1                	add    %eax,%ecx
  115761:	66 89 8c 24 00 01 00 	mov    %cx,0x100(%esp)
  115768:	00 
        }
        /*Write all letter of a line*/
        cmd_state = CMD_STATE_WAIT;
  115769:	c6 84 24 ee 00 00 00 	movb   $0x0,0xee(%esp)
  115770:	00 
        i         = line_start;
  115771:	8b 84 24 f8 00 00 00 	mov    0xf8(%esp),%eax
  115778:	89 84 24 e8 00 00 00 	mov    %eax,0xe8(%esp)
        uint32_t letter;
        uint32_t letter_next;
        while(i < line_end) {
  11577f:	8b 84 24 e8 00 00 00 	mov    0xe8(%esp),%eax
  115786:	3b 84 24 f0 00 00 00 	cmp    0xf0(%esp),%eax
  11578d:	0f 83 ee 03 00 00    	jae    115b81 <lv_draw_label+0x9e1>
            letter      = lv_txt_encoded_next(txt, &i);
  115793:	a1 44 30 14 00       	mov    0x143044,%eax
  115798:	8b 4d 18             	mov    0x18(%ebp),%ecx
  11579b:	89 0c 24             	mov    %ecx,(%esp)
  11579e:	8d 8c 24 e8 00 00 00 	lea    0xe8(%esp),%ecx
  1157a5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1157a9:	ff d0                	call   *%eax
  1157ab:	31 c9                	xor    %ecx,%ecx
  1157ad:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
  1157b4:	a1 44 30 14 00       	mov    0x143044,%eax
  1157b9:	8b 55 18             	mov    0x18(%ebp),%edx
  1157bc:	03 94 24 e8 00 00 00 	add    0xe8(%esp),%edx
  1157c3:	89 14 24             	mov    %edx,(%esp)
  1157c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1157cd:	00 
  1157ce:	89 4c 24 30          	mov    %ecx,0x30(%esp)
  1157d2:	ff d0                	call   *%eax
  1157d4:	89 84 24 80 00 00 00 	mov    %eax,0x80(%esp)

            /*Handle the re-color command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
  1157db:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  1157df:	83 e0 01             	and    $0x1,%eax
  1157e2:	83 f8 00             	cmp    $0x0,%eax
  1157e5:	0f 84 e7 01 00 00    	je     1159d2 <lv_draw_label+0x832>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
  1157eb:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
  1157f2:	0f be 0d 20 40 12 00 	movsbl 0x124020,%ecx
  1157f9:	39 c8                	cmp    %ecx,%eax
  1157fb:	0f 85 78 00 00 00    	jne    115879 <lv_draw_label+0x6d9>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
  115801:	0f b6 84 24 ee 00 00 	movzbl 0xee(%esp),%eax
  115808:	00 
  115809:	83 f8 00             	cmp    $0x0,%eax
  11580c:	0f 85 1c 00 00 00    	jne    11582e <lv_draw_label+0x68e>
                        par_start = i;
  115812:	8b 84 24 e8 00 00 00 	mov    0xe8(%esp),%eax
  115819:	66 89 84 24 e6 00 00 	mov    %ax,0xe6(%esp)
  115820:	00 
                        cmd_state = CMD_STATE_PAR;
  115821:	c6 84 24 ee 00 00 00 	movb   $0x1,0xee(%esp)
  115828:	01 
                        continue;
  115829:	e9 51 ff ff ff       	jmp    11577f <lv_draw_label+0x5df>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
  11582e:	0f b6 84 24 ee 00 00 	movzbl 0xee(%esp),%eax
  115835:	00 
  115836:	83 f8 01             	cmp    $0x1,%eax
  115839:	0f 85 0d 00 00 00    	jne    11584c <lv_draw_label+0x6ac>
                        cmd_state = CMD_STATE_WAIT;
  11583f:	c6 84 24 ee 00 00 00 	movb   $0x0,0xee(%esp)
  115846:	00 
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
  115847:	e9 23 00 00 00       	jmp    11586f <lv_draw_label+0x6cf>
  11584c:	0f b6 84 24 ee 00 00 	movzbl 0xee(%esp),%eax
  115853:	00 
  115854:	83 f8 02             	cmp    $0x2,%eax
  115857:	0f 85 0d 00 00 00    	jne    11586a <lv_draw_label+0x6ca>
                        cmd_state = CMD_STATE_WAIT;
  11585d:	c6 84 24 ee 00 00 00 	movb   $0x0,0xee(%esp)
  115864:	00 
                        continue;
  115865:	e9 15 ff ff ff       	jmp    11577f <lv_draw_label+0x5df>
  11586a:	e9 00 00 00 00       	jmp    11586f <lv_draw_label+0x6cf>
  11586f:	e9 00 00 00 00       	jmp    115874 <lv_draw_label+0x6d4>
                    }
                }
  115874:	e9 00 00 00 00       	jmp    115879 <lv_draw_label+0x6d9>

                /*Skip the color parameter and wait the space after it*/
                if(cmd_state == CMD_STATE_PAR) {
  115879:	0f b6 84 24 ee 00 00 	movzbl 0xee(%esp),%eax
  115880:	00 
  115881:	83 f8 01             	cmp    $0x1,%eax
  115884:	0f 85 43 01 00 00    	jne    1159cd <lv_draw_label+0x82d>
                    if(letter == ' ') {
  11588a:	83 bc 24 84 00 00 00 	cmpl   $0x20,0x84(%esp)
  115891:	20 
  115892:	0f 85 30 01 00 00    	jne    1159c8 <lv_draw_label+0x828>
                        /*Get the parameter*/
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
  115898:	8b 84 24 e8 00 00 00 	mov    0xe8(%esp),%eax
  11589f:	0f b7 8c 24 e6 00 00 	movzwl 0xe6(%esp),%ecx
  1158a6:	00 
  1158a7:	29 c8                	sub    %ecx,%eax
  1158a9:	83 f8 07             	cmp    $0x7,%eax
  1158ac:	0f 85 01 01 00 00    	jne    1159b3 <lv_draw_label+0x813>
  1158b2:	8d 44 24 79          	lea    0x79(%esp),%eax
                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];
                            memcpy(buf, &txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
  1158b6:	8b 4d 18             	mov    0x18(%ebp),%ecx
  1158b9:	0f b7 94 24 e6 00 00 	movzwl 0xe6(%esp),%edx
  1158c0:	00 
  1158c1:	01 d1                	add    %edx,%ecx
  1158c3:	89 04 24             	mov    %eax,(%esp)
  1158c6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1158ca:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  1158d1:	00 
  1158d2:	e8 79 4a ff ff       	call   10a350 <memcpy>
                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\0';
  1158d7:	c6 44 24 7f 00       	movb   $0x0,0x7f(%esp)
                            int r, g, b;
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
  1158dc:	0f be 4c 24 79       	movsbl 0x79(%esp),%ecx
  1158e1:	89 0c 24             	mov    %ecx,(%esp)
  1158e4:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  1158e8:	e8 c3 04 00 00       	call   115db0 <hex_char_to_num>
  1158ed:	0f b6 c8             	movzbl %al,%ecx
  1158f0:	c1 e1 04             	shl    $0x4,%ecx
  1158f3:	0f be 54 24 7a       	movsbl 0x7a(%esp),%edx
  1158f8:	89 14 24             	mov    %edx,(%esp)
  1158fb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  1158ff:	e8 ac 04 00 00       	call   115db0 <hex_char_to_num>
  115904:	0f b6 c8             	movzbl %al,%ecx
  115907:	8b 54 24 28          	mov    0x28(%esp),%edx
  11590b:	01 ca                	add    %ecx,%edx
  11590d:	89 54 24 74          	mov    %edx,0x74(%esp)
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
  115911:	0f be 4c 24 7b       	movsbl 0x7b(%esp),%ecx
  115916:	89 0c 24             	mov    %ecx,(%esp)
  115919:	e8 92 04 00 00       	call   115db0 <hex_char_to_num>
  11591e:	0f b6 c8             	movzbl %al,%ecx
  115921:	c1 e1 04             	shl    $0x4,%ecx
  115924:	0f be 54 24 7c       	movsbl 0x7c(%esp),%edx
  115929:	89 14 24             	mov    %edx,(%esp)
  11592c:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  115930:	e8 7b 04 00 00       	call   115db0 <hex_char_to_num>
  115935:	0f b6 c8             	movzbl %al,%ecx
  115938:	8b 54 24 24          	mov    0x24(%esp),%edx
  11593c:	01 ca                	add    %ecx,%edx
  11593e:	89 54 24 70          	mov    %edx,0x70(%esp)
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
  115942:	0f be 4c 24 7d       	movsbl 0x7d(%esp),%ecx
  115947:	89 0c 24             	mov    %ecx,(%esp)
  11594a:	e8 61 04 00 00       	call   115db0 <hex_char_to_num>
  11594f:	0f b6 c8             	movzbl %al,%ecx
  115952:	c1 e1 04             	shl    $0x4,%ecx
  115955:	0f be 54 24 7e       	movsbl 0x7e(%esp),%edx
  11595a:	89 14 24             	mov    %edx,(%esp)
  11595d:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  115961:	e8 4a 04 00 00       	call   115db0 <hex_char_to_num>
  115966:	0f b6 c8             	movzbl %al,%ecx
  115969:	8b 54 24 20          	mov    0x20(%esp),%edx
  11596d:	01 ca                	add    %ecx,%edx
  11596f:	89 54 24 6c          	mov    %edx,0x6c(%esp)
                            recolor = lv_color_make(r, g, b);
  115973:	8b 4c 24 74          	mov    0x74(%esp),%ecx
  115977:	8b 54 24 70          	mov    0x70(%esp),%edx
  11597b:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
  11597f:	8d 74 24 68          	lea    0x68(%esp),%esi
  115983:	89 34 24             	mov    %esi,(%esp)
  115986:	0f b6 f1             	movzbl %cl,%esi
  115989:	89 74 24 04          	mov    %esi,0x4(%esp)
  11598d:	0f b6 f2             	movzbl %dl,%esi
  115990:	89 74 24 08          	mov    %esi,0x8(%esp)
  115994:	0f b6 f3             	movzbl %bl,%esi
  115997:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11599b:	e8 d0 04 00 00       	call   115e70 <lv_color_make>
  1159a0:	83 ec 04             	sub    $0x4,%esp
  1159a3:	8b 74 24 68          	mov    0x68(%esp),%esi
  1159a7:	89 b4 24 e0 00 00 00 	mov    %esi,0xe0(%esp)
                        } else {
  1159ae:	e9 0d 00 00 00       	jmp    1159c0 <lv_draw_label+0x820>
                            recolor.full = style->text.color.full;
  1159b3:	8b 45 10             	mov    0x10(%ebp),%eax
  1159b6:	8b 40 2c             	mov    0x2c(%eax),%eax
  1159b9:	89 84 24 e0 00 00 00 	mov    %eax,0xe0(%esp)
                        }
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
  1159c0:	c6 84 24 ee 00 00 00 	movb   $0x2,0xee(%esp)
  1159c7:	02 
                    }
                    continue;
  1159c8:	e9 b2 fd ff ff       	jmp    11577f <lv_draw_label+0x5df>
                }
            }
  1159cd:	e9 00 00 00 00       	jmp    1159d2 <lv_draw_label+0x832>

            lv_color_t color = style->text.color;
  1159d2:	8b 45 10             	mov    0x10(%ebp),%eax
  1159d5:	8b 40 2c             	mov    0x2c(%eax),%eax
  1159d8:	89 44 24 60          	mov    %eax,0x60(%esp)

            if(cmd_state == CMD_STATE_IN) color = recolor;
  1159dc:	0f b6 84 24 ee 00 00 	movzbl 0xee(%esp),%eax
  1159e3:	00 
  1159e4:	83 f8 02             	cmp    $0x2,%eax
  1159e7:	0f 85 0b 00 00 00    	jne    1159f8 <lv_draw_label+0x858>
  1159ed:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
  1159f4:	89 44 24 60          	mov    %eax,0x60(%esp)

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
  1159f8:	8b 84 24 10 01 00 00 	mov    0x110(%esp),%eax
  1159ff:	8b 8c 24 84 00 00 00 	mov    0x84(%esp),%ecx
  115a06:	8b 94 24 80 00 00 00 	mov    0x80(%esp),%edx
  115a0d:	89 04 24             	mov    %eax,(%esp)
  115a10:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  115a14:	89 54 24 08          	mov    %edx,0x8(%esp)
  115a18:	e8 f3 63 00 00       	call   11be10 <lv_font_get_glyph_width>
  115a1d:	66 89 84 24 de 00 00 	mov    %ax,0xde(%esp)
  115a24:	00 

            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
  115a25:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
  115a29:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  115a2f:	0f 84 d1 00 00 00    	je     115b06 <lv_draw_label+0x966>
  115a35:	0f b7 45 28          	movzwl 0x28(%ebp),%eax
  115a39:	3d ff ff 00 00       	cmp    $0xffff,%eax
  115a3e:	0f 84 c2 00 00 00    	je     115b06 <lv_draw_label+0x966>
                int char_ind = lv_encoded_get_char_id(txt, i);
  115a44:	a1 50 30 14 00       	mov    0x143050,%eax
  115a49:	8b 4d 18             	mov    0x18(%ebp),%ecx
  115a4c:	8b 94 24 e8 00 00 00 	mov    0xe8(%esp),%edx
  115a53:	89 0c 24             	mov    %ecx,(%esp)
  115a56:	89 54 24 04          	mov    %edx,0x4(%esp)
  115a5a:	ff d0                	call   *%eax
  115a5c:	89 44 24 5c          	mov    %eax,0x5c(%esp)
                /*Do not draw the rectangle on the character at `sel_start`.*/
                if(char_ind > sel_start && char_ind <= sel_end) {
  115a60:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  115a64:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
  115a68:	39 c8                	cmp    %ecx,%eax
  115a6a:	0f 8e 91 00 00 00    	jle    115b01 <lv_draw_label+0x961>
  115a70:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  115a74:	0f b7 4d 28          	movzwl 0x28(%ebp),%ecx
  115a78:	39 c8                	cmp    %ecx,%eax
  115a7a:	0f 8f 81 00 00 00    	jg     115b01 <lv_draw_label+0x961>
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
  115a80:	66 8b 84 24 00 01 00 	mov    0x100(%esp),%ax
  115a87:	00 
  115a88:	66 89 44 24 50       	mov    %ax,0x50(%esp)
                    sel_coords.y1 = pos.y;
  115a8d:	66 8b 84 24 02 01 00 	mov    0x102(%esp),%ax
  115a94:	00 
  115a95:	66 89 44 24 52       	mov    %ax,0x52(%esp)
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
  115a9a:	0f bf 8c 24 00 01 00 	movswl 0x100(%esp),%ecx
  115aa1:	00 
  115aa2:	0f bf 94 24 de 00 00 	movswl 0xde(%esp),%edx
  115aa9:	00 
  115aaa:	01 d1                	add    %edx,%ecx
  115aac:	8b 55 10             	mov    0x10(%ebp),%edx
  115aaf:	0f bf 52 38          	movswl 0x38(%edx),%edx
  115ab3:	01 d1                	add    %edx,%ecx
  115ab5:	83 e9 01             	sub    $0x1,%ecx
  115ab8:	66 89 4c 24 54       	mov    %cx,0x54(%esp)
                    sel_coords.y2 = pos.y + line_height - 1;
  115abd:	0f bf 94 24 02 01 00 	movswl 0x102(%esp),%edx
  115ac4:	00 
  115ac5:	0f bf b4 24 06 01 00 	movswl 0x106(%esp),%esi
  115acc:	00 
  115acd:	01 f2                	add    %esi,%edx
  115acf:	83 ea 01             	sub    $0x1,%edx
  115ad2:	66 89 54 24 56       	mov    %dx,0x56(%esp)
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
  115ad7:	8b 75 0c             	mov    0xc(%ebp),%esi
  115ada:	8d 7c 24 50          	lea    0x50(%esp),%edi
  115ade:	89 3c 24             	mov    %edi,(%esp)
  115ae1:	89 74 24 04          	mov    %esi,0x4(%esp)
  115ae5:	8d b4 24 88 00 00 00 	lea    0x88(%esp),%esi
  115aec:	89 74 24 08          	mov    %esi,0x8(%esp)
  115af0:	0f b6 b4 24 ef 00 00 	movzbl 0xef(%esp),%esi
  115af7:	00 
  115af8:	89 74 24 0c          	mov    %esi,0xc(%esp)
  115afc:	e8 2f d0 ff ff       	call   112b30 <lv_draw_rect>
                }
            }
  115b01:	e9 00 00 00 00       	jmp    115b06 <lv_draw_label+0x966>
            lv_draw_letter(&pos, mask, font, letter, color, opa);
  115b06:	8b 45 0c             	mov    0xc(%ebp),%eax
  115b09:	8b 8c 24 10 01 00 00 	mov    0x110(%esp),%ecx
  115b10:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
  115b17:	8d b4 24 00 01 00 00 	lea    0x100(%esp),%esi
  115b1e:	89 34 24             	mov    %esi,(%esp)
  115b21:	89 44 24 04          	mov    %eax,0x4(%esp)
  115b25:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  115b29:	89 54 24 0c          	mov    %edx,0xc(%esp)
  115b2d:	8d 44 24 60          	lea    0x60(%esp),%eax
  115b31:	8b 00                	mov    (%eax),%eax
  115b33:	89 44 24 10          	mov    %eax,0x10(%esp)
  115b37:	0f b6 84 24 ef 00 00 	movzbl 0xef(%esp),%eax
  115b3e:	00 
  115b3f:	89 44 24 14          	mov    %eax,0x14(%esp)
  115b43:	e8 18 c7 ff ff       	call   112260 <lv_draw_letter>

            if(letter_w > 0) {
  115b48:	0f bf 84 24 de 00 00 	movswl 0xde(%esp),%eax
  115b4f:	00 
  115b50:	83 f8 00             	cmp    $0x0,%eax
  115b53:	0f 8e 23 00 00 00    	jle    115b7c <lv_draw_label+0x9dc>
                pos.x += letter_w + style->text.letter_space;
  115b59:	0f bf 84 24 de 00 00 	movswl 0xde(%esp),%eax
  115b60:	00 
  115b61:	8b 4d 10             	mov    0x10(%ebp),%ecx
  115b64:	0f bf 49 38          	movswl 0x38(%ecx),%ecx
  115b68:	01 c8                	add    %ecx,%eax
  115b6a:	0f bf 8c 24 00 01 00 	movswl 0x100(%esp),%ecx
  115b71:	00 
  115b72:	01 c1                	add    %eax,%ecx
  115b74:	66 89 8c 24 00 01 00 	mov    %cx,0x100(%esp)
  115b7b:	00 
        while(i < line_end) {
  115b7c:	e9 fe fb ff ff       	jmp    11577f <lv_draw_label+0x5df>
            }
        }
        /*Go to next line*/
        line_start = line_end;
  115b81:	8b 84 24 f0 00 00 00 	mov    0xf0(%esp),%eax
  115b88:	89 84 24 f8 00 00 00 	mov    %eax,0xf8(%esp)
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
  115b8f:	8b 45 18             	mov    0x18(%ebp),%eax
  115b92:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  115b99:	8b 8c 24 10 01 00 00 	mov    0x110(%esp),%ecx
  115ba0:	8b 55 10             	mov    0x10(%ebp),%edx
  115ba3:	66 8b 72 38          	mov    0x38(%edx),%si
  115ba7:	66 8b bc 24 0e 01 00 	mov    0x10e(%esp),%di
  115bae:	00 
  115baf:	89 04 24             	mov    %eax,(%esp)
  115bb2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  115bb6:	0f bf c6             	movswl %si,%eax
  115bb9:	89 44 24 08          	mov    %eax,0x8(%esp)
  115bbd:	0f bf c7             	movswl %di,%eax
  115bc0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  115bc4:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115bc8:	89 44 24 10          	mov    %eax,0x10(%esp)
  115bcc:	e8 6f 39 00 00       	call   119540 <lv_txt_get_next_line>
  115bd1:	0f b7 c8             	movzwl %ax,%ecx
  115bd4:	03 8c 24 f0 00 00 00 	add    0xf0(%esp),%ecx
  115bdb:	89 8c 24 f0 00 00 00 	mov    %ecx,0xf0(%esp)

        pos.x = coords->x1;
  115be2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115be5:	66 8b 01             	mov    (%ecx),%ax
  115be8:	66 89 84 24 00 01 00 	mov    %ax,0x100(%esp)
  115bef:	00 
        /*Align to middle*/
        if(flag & LV_TXT_FLAG_CENTER) {
  115bf0:	0f b6 4d 1c          	movzbl 0x1c(%ebp),%ecx
  115bf4:	83 e1 04             	and    $0x4,%ecx
  115bf7:	83 f9 00             	cmp    $0x0,%ecx
  115bfa:	0f 84 89 00 00 00    	je     115c89 <lv_draw_label+0xae9>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
  115c00:	8b 45 18             	mov    0x18(%ebp),%eax
  115c03:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  115c0a:	8b 8c 24 f0 00 00 00 	mov    0xf0(%esp),%ecx
  115c11:	2b 8c 24 f8 00 00 00 	sub    0xf8(%esp),%ecx
  115c18:	8b 94 24 10 01 00 00 	mov    0x110(%esp),%edx
  115c1f:	8b 75 10             	mov    0x10(%ebp),%esi
  115c22:	66 8b 7e 38          	mov    0x38(%esi),%di
  115c26:	89 04 24             	mov    %eax,(%esp)
  115c29:	0f b7 c1             	movzwl %cx,%eax
  115c2c:	89 44 24 04          	mov    %eax,0x4(%esp)
  115c30:	89 54 24 08          	mov    %edx,0x8(%esp)
  115c34:	0f bf c7             	movswl %di,%eax
  115c37:	89 44 24 0c          	mov    %eax,0xc(%esp)
  115c3b:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115c3f:	89 44 24 10          	mov    %eax,0x10(%esp)
  115c43:	e8 38 3b 00 00       	call   119780 <lv_txt_get_width>
            line_width =
  115c48:	66 89 84 24 04 01 00 	mov    %ax,0x104(%esp)
  115c4f:	00 

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
  115c50:	8b 55 08             	mov    0x8(%ebp),%edx
  115c53:	89 14 24             	mov    %edx,(%esp)
  115c56:	e8 05 01 00 00       	call   115d60 <lv_area_get_width>
  115c5b:	0f bf d0             	movswl %ax,%edx
  115c5e:	0f bf b4 24 04 01 00 	movswl 0x104(%esp),%esi
  115c65:	00 
  115c66:	29 f2                	sub    %esi,%edx
  115c68:	89 d0                	mov    %edx,%eax
  115c6a:	99                   	cltd   
  115c6b:	be 02 00 00 00       	mov    $0x2,%esi
  115c70:	f7 fe                	idiv   %esi
  115c72:	0f bf b4 24 00 01 00 	movswl 0x100(%esp),%esi
  115c79:	00 
  115c7a:	01 c6                	add    %eax,%esi
  115c7c:	66 89 b4 24 00 01 00 	mov    %si,0x100(%esp)
  115c83:	00 

        }
  115c84:	e9 8f 00 00 00       	jmp    115d18 <lv_draw_label+0xb78>
        /*Align to the right*/
        else if(flag & LV_TXT_FLAG_RIGHT) {
  115c89:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115c8d:	83 e0 08             	and    $0x8,%eax
  115c90:	83 f8 00             	cmp    $0x0,%eax
  115c93:	0f 84 7a 00 00 00    	je     115d13 <lv_draw_label+0xb73>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
  115c99:	8b 45 18             	mov    0x18(%ebp),%eax
  115c9c:	03 84 24 f8 00 00 00 	add    0xf8(%esp),%eax
  115ca3:	8b 8c 24 f0 00 00 00 	mov    0xf0(%esp),%ecx
  115caa:	2b 8c 24 f8 00 00 00 	sub    0xf8(%esp),%ecx
  115cb1:	8b 94 24 10 01 00 00 	mov    0x110(%esp),%edx
  115cb8:	8b 75 10             	mov    0x10(%ebp),%esi
  115cbb:	66 8b 7e 38          	mov    0x38(%esi),%di
  115cbf:	89 04 24             	mov    %eax,(%esp)
  115cc2:	0f b7 c1             	movzwl %cx,%eax
  115cc5:	89 44 24 04          	mov    %eax,0x4(%esp)
  115cc9:	89 54 24 08          	mov    %edx,0x8(%esp)
  115ccd:	0f bf c7             	movswl %di,%eax
  115cd0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  115cd4:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  115cd8:	89 44 24 10          	mov    %eax,0x10(%esp)
  115cdc:	e8 9f 3a 00 00       	call   119780 <lv_txt_get_width>
            line_width =
  115ce1:	66 89 84 24 04 01 00 	mov    %ax,0x104(%esp)
  115ce8:	00 
            pos.x += lv_area_get_width(coords) - line_width;
  115ce9:	8b 55 08             	mov    0x8(%ebp),%edx
  115cec:	89 14 24             	mov    %edx,(%esp)
  115cef:	e8 6c 00 00 00       	call   115d60 <lv_area_get_width>
  115cf4:	0f bf d0             	movswl %ax,%edx
  115cf7:	0f bf b4 24 04 01 00 	movswl 0x104(%esp),%esi
  115cfe:	00 
  115cff:	29 f2                	sub    %esi,%edx
  115d01:	0f bf b4 24 00 01 00 	movswl 0x100(%esp),%esi
  115d08:	00 
  115d09:	01 d6                	add    %edx,%esi
  115d0b:	66 89 b4 24 00 01 00 	mov    %si,0x100(%esp)
  115d12:	00 
  115d13:	e9 00 00 00 00       	jmp    115d18 <lv_draw_label+0xb78>
        }

        /*Go the next line position*/
        pos.y += line_height;
  115d18:	0f bf 84 24 06 01 00 	movswl 0x106(%esp),%eax
  115d1f:	00 
  115d20:	0f bf 8c 24 02 01 00 	movswl 0x102(%esp),%ecx
  115d27:	00 
  115d28:	01 c1                	add    %eax,%ecx
  115d2a:	66 89 8c 24 02 01 00 	mov    %cx,0x102(%esp)
  115d31:	00 

        if(pos.y > mask->y2) return;
  115d32:	0f bf 84 24 02 01 00 	movswl 0x102(%esp),%eax
  115d39:	00 
  115d3a:	8b 55 0c             	mov    0xc(%ebp),%edx
  115d3d:	0f bf 52 06          	movswl 0x6(%edx),%edx
  115d41:	39 d0                	cmp    %edx,%eax
  115d43:	0f 8e 05 00 00 00    	jle    115d4e <lv_draw_label+0xbae>
  115d49:	e9 05 00 00 00       	jmp    115d53 <lv_draw_label+0xbb3>
    while(txt[line_start] != '\0') {
  115d4e:	e9 db f9 ff ff       	jmp    11572e <lv_draw_label+0x58e>
    }
}
  115d53:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115d56:	5e                   	pop    %esi
  115d57:	5f                   	pop    %edi
  115d58:	5b                   	pop    %ebx
  115d59:	5d                   	pop    %ebp
  115d5a:	c3                   	ret    
  115d5b:	66 90                	xchg   %ax,%ax
  115d5d:	66 90                	xchg   %ax,%ax
  115d5f:	90                   	nop

00115d60 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
  115d60:	55                   	push   %ebp
  115d61:	89 e5                	mov    %esp,%ebp
  115d63:	50                   	push   %eax
  115d64:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  115d67:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115d6a:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  115d6e:	8b 55 08             	mov    0x8(%ebp),%edx
  115d71:	0f bf 12             	movswl (%edx),%edx
  115d74:	29 d1                	sub    %edx,%ecx
  115d76:	83 c1 01             	add    $0x1,%ecx
  115d79:	0f bf d1             	movswl %cx,%edx
  115d7c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  115d7f:	89 d0                	mov    %edx,%eax
  115d81:	83 c4 04             	add    $0x4,%esp
  115d84:	5d                   	pop    %ebp
  115d85:	c3                   	ret    
  115d86:	66 90                	xchg   %ax,%ax
  115d88:	66 90                	xchg   %ax,%ax
  115d8a:	66 90                	xchg   %ax,%ax
  115d8c:	66 90                	xchg   %ax,%ax
  115d8e:	66 90                	xchg   %ax,%ax

00115d90 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
  115d90:	55                   	push   %ebp
  115d91:	89 e5                	mov    %esp,%ebp
  115d93:	50                   	push   %eax
  115d94:	8b 45 08             	mov    0x8(%ebp),%eax
    return font_p->line_height;
  115d97:	8b 4d 08             	mov    0x8(%ebp),%ecx
  115d9a:	0f b6 49 08          	movzbl 0x8(%ecx),%ecx
  115d9e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  115da1:	89 c8                	mov    %ecx,%eax
  115da3:	83 c4 04             	add    $0x4,%esp
  115da6:	5d                   	pop    %ebp
  115da7:	c3                   	ret    
  115da8:	66 90                	xchg   %ax,%ax
  115daa:	66 90                	xchg   %ax,%ax
  115dac:	66 90                	xchg   %ax,%ax
  115dae:	66 90                	xchg   %ax,%ax

00115db0 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
  115db0:	55                   	push   %ebp
  115db1:	89 e5                	mov    %esp,%ebp
  115db3:	83 ec 08             	sub    $0x8,%esp
  115db6:	8a 45 08             	mov    0x8(%ebp),%al
    uint8_t result = 0;
  115db9:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)

    if(hex >= '0' && hex <= '9') {
  115dbd:	0f be 4d 08          	movsbl 0x8(%ebp),%ecx
  115dc1:	83 f9 30             	cmp    $0x30,%ecx
  115dc4:	0f 8c 1c 00 00 00    	jl     115de6 <hex_char_to_num+0x36>
  115dca:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  115dce:	83 f8 39             	cmp    $0x39,%eax
  115dd1:	0f 8f 0f 00 00 00    	jg     115de6 <hex_char_to_num+0x36>
        result = hex - '0';
  115dd7:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  115ddb:	83 e8 30             	sub    $0x30,%eax
  115dde:	88 45 ff             	mov    %al,-0x1(%ebp)
    } else {
  115de1:	e9 77 00 00 00       	jmp    115e5d <hex_char_to_num+0xad>
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
  115de6:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  115dea:	83 f8 61             	cmp    $0x61,%eax
  115ded:	0f 8c 0a 00 00 00    	jl     115dfd <hex_char_to_num+0x4d>
  115df3:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  115df7:	83 e8 20             	sub    $0x20,%eax
  115dfa:	88 45 08             	mov    %al,0x8(%ebp)

        switch(hex) {
  115dfd:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  115e01:	83 c0 bf             	add    $0xffffffbf,%eax
  115e04:	89 c1                	mov    %eax,%ecx
  115e06:	83 e9 05             	sub    $0x5,%ecx
  115e09:	89 45 f8             	mov    %eax,-0x8(%ebp)
  115e0c:	0f 87 42 00 00 00    	ja     115e54 <hex_char_to_num+0xa4>
  115e12:	8b 45 f8             	mov    -0x8(%ebp),%eax
  115e15:	8b 0c 85 1c 36 12 00 	mov    0x12361c(,%eax,4),%ecx
  115e1c:	ff e1                	jmp    *%ecx
            case 'A': result = 10; break;
  115e1e:	c6 45 ff 0a          	movb   $0xa,-0x1(%ebp)
  115e22:	e9 31 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            case 'B': result = 11; break;
  115e27:	c6 45 ff 0b          	movb   $0xb,-0x1(%ebp)
  115e2b:	e9 28 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            case 'C': result = 12; break;
  115e30:	c6 45 ff 0c          	movb   $0xc,-0x1(%ebp)
  115e34:	e9 1f 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            case 'D': result = 13; break;
  115e39:	c6 45 ff 0d          	movb   $0xd,-0x1(%ebp)
  115e3d:	e9 16 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            case 'E': result = 14; break;
  115e42:	c6 45 ff 0e          	movb   $0xe,-0x1(%ebp)
  115e46:	e9 0d 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            case 'F': result = 15; break;
  115e4b:	c6 45 ff 0f          	movb   $0xf,-0x1(%ebp)
  115e4f:	e9 04 00 00 00       	jmp    115e58 <hex_char_to_num+0xa8>
            default: result = 0; break;
  115e54:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
  115e58:	e9 00 00 00 00       	jmp    115e5d <hex_char_to_num+0xad>
        }
    }

    return result;
  115e5d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  115e61:	83 c4 08             	add    $0x8,%esp
  115e64:	5d                   	pop    %ebp
  115e65:	c3                   	ret    
  115e66:	66 90                	xchg   %ax,%ax
  115e68:	66 90                	xchg   %ax,%ax
  115e6a:	66 90                	xchg   %ax,%ax
  115e6c:	66 90                	xchg   %ax,%ax
  115e6e:	66 90                	xchg   %ax,%ax

00115e70 <lv_color_make>:
}
#endif
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
  115e70:	55                   	push   %ebp
  115e71:	89 e5                	mov    %esp,%ebp
  115e73:	53                   	push   %ebx
  115e74:	8b 45 08             	mov    0x8(%ebp),%eax
  115e77:	89 c1                	mov    %eax,%ecx
  115e79:	8a 55 14             	mov    0x14(%ebp),%dl
  115e7c:	8a 75 10             	mov    0x10(%ebp),%dh
  115e7f:	8a 5d 0c             	mov    0xc(%ebp),%bl
    lv_color_t color;
    color.ch.blue  = b8;
  115e82:	8a 7d 14             	mov    0x14(%ebp),%bh
  115e85:	88 38                	mov    %bh,(%eax)
    color.ch.green = g8;
  115e87:	8a 7d 10             	mov    0x10(%ebp),%bh
  115e8a:	88 78 01             	mov    %bh,0x1(%eax)
    color.ch.red   = r8;
  115e8d:	8a 7d 0c             	mov    0xc(%ebp),%bh
  115e90:	88 78 02             	mov    %bh,0x2(%eax)
    color.ch.alpha = 0xff;
  115e93:	c6 40 03 ff          	movb   $0xff,0x3(%eax)
    return color;
  115e97:	89 c8                	mov    %ecx,%eax
  115e99:	5b                   	pop    %ebx
  115e9a:	5d                   	pop    %ebp
  115e9b:	c2 04 00             	ret    $0x4
  115e9e:	66 90                	xchg   %ax,%ax

00115ea0 <lv_img_color_format_get_px_size>:
 * Get the pixel size of a color format in bits
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return the pixel size in bits
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
  115ea0:	55                   	push   %ebp
  115ea1:	89 e5                	mov    %esp,%ebp
  115ea3:	83 ec 08             	sub    $0x8,%esp
  115ea6:	8a 45 08             	mov    0x8(%ebp),%al
    uint8_t px_size = 0;
  115ea9:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)

    switch(cf) {
  115ead:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
  115eb1:	89 ca                	mov    %ecx,%edx
  115eb3:	83 ea 0e             	sub    $0xe,%edx
  115eb6:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  115eb9:	0f 87 4b 00 00 00    	ja     115f0a <lv_img_color_format_get_px_size+0x6a>
  115ebf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  115ec2:	8b 0c 85 34 36 12 00 	mov    0x123634(,%eax,4),%ecx
  115ec9:	ff e1                	jmp    *%ecx
        case LV_IMG_CF_UNKNOWN:
        case LV_IMG_CF_RAW: px_size = 0; break;
  115ecb:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
  115ecf:	e9 3a 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_TRUE_COLOR:
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: px_size = LV_COLOR_SIZE; break;
  115ed4:	c6 45 ff 20          	movb   $0x20,-0x1(%ebp)
  115ed8:	e9 31 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_TRUE_COLOR_ALPHA: px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3; break;
  115edd:	c6 45 ff 20          	movb   $0x20,-0x1(%ebp)
  115ee1:	e9 28 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_ALPHA_1BIT: px_size = 1; break;
  115ee6:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  115eea:	e9 1f 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_ALPHA_2BIT: px_size = 2; break;
  115eef:	c6 45 ff 02          	movb   $0x2,-0x1(%ebp)
  115ef3:	e9 16 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_ALPHA_4BIT: px_size = 4; break;
  115ef8:	c6 45 ff 04          	movb   $0x4,-0x1(%ebp)
  115efc:	e9 0d 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
  115f01:	c6 45 ff 08          	movb   $0x8,-0x1(%ebp)
  115f05:	e9 04 00 00 00       	jmp    115f0e <lv_img_color_format_get_px_size+0x6e>
        default: px_size = 0; break;
  115f0a:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
    }

    return px_size;
  115f0e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  115f12:	83 c4 08             	add    $0x8,%esp
  115f15:	5d                   	pop    %ebp
  115f16:	c3                   	ret    
  115f17:	66 90                	xchg   %ax,%ax
  115f19:	66 90                	xchg   %ax,%ax
  115f1b:	66 90                	xchg   %ax,%ax
  115f1d:	66 90                	xchg   %ax,%ax
  115f1f:	90                   	nop

00115f20 <lv_img_src_get_type>:
 *  - a path to a file (e.g. "S:/folder/image.bin")
 *  - or a symbol (e.g. LV_SYMBOL_CLOSE)
 * @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
  115f20:	55                   	push   %ebp
  115f21:	89 e5                	mov    %esp,%ebp
  115f23:	83 ec 18             	sub    $0x18,%esp
  115f26:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;
  115f29:	c6 45 fe 03          	movb   $0x3,-0x2(%ebp)

    if(src == NULL) return img_src_type;
  115f2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  115f31:	0f 85 0b 00 00 00    	jne    115f42 <lv_img_src_get_type+0x22>
  115f37:	8a 45 fe             	mov    -0x2(%ebp),%al
  115f3a:	88 45 ff             	mov    %al,-0x1(%ebp)
  115f3d:	e9 8f 00 00 00       	jmp    115fd1 <lv_img_src_get_type+0xb1>
    const uint8_t * u8_p = src;
  115f42:	8b 45 08             	mov    0x8(%ebp),%eax
  115f45:	89 45 f8             	mov    %eax,-0x8(%ebp)

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
  115f48:	8b 45 f8             	mov    -0x8(%ebp),%eax
  115f4b:	0f b6 00             	movzbl (%eax),%eax
  115f4e:	83 f8 20             	cmp    $0x20,%eax
  115f51:	0f 8c 18 00 00 00    	jl     115f6f <lv_img_src_get_type+0x4f>
  115f57:	8b 45 f8             	mov    -0x8(%ebp),%eax
  115f5a:	0f b6 00             	movzbl (%eax),%eax
  115f5d:	83 f8 7f             	cmp    $0x7f,%eax
  115f60:	0f 8f 09 00 00 00    	jg     115f6f <lv_img_src_get_type+0x4f>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
  115f66:	c6 45 fe 01          	movb   $0x1,-0x2(%ebp)
    } else if(u8_p[0] >= 0x80) {
  115f6a:	e9 23 00 00 00       	jmp    115f92 <lv_img_src_get_type+0x72>
  115f6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  115f72:	0f b6 00             	movzbl (%eax),%eax
  115f75:	3d 80 00 00 00       	cmp    $0x80,%eax
  115f7a:	0f 8c 09 00 00 00    	jl     115f89 <lv_img_src_get_type+0x69>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
  115f80:	c6 45 fe 02          	movb   $0x2,-0x2(%ebp)
    } else {
  115f84:	e9 04 00 00 00       	jmp    115f8d <lv_img_src_get_type+0x6d>
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
  115f89:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)
  115f8d:	e9 00 00 00 00       	jmp    115f92 <lv_img_src_get_type+0x72>
    }

    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
  115f92:	0f b6 45 fe          	movzbl -0x2(%ebp),%eax
  115f96:	b9 03 00 00 00       	mov    $0x3,%ecx
  115f9b:	39 c1                	cmp    %eax,%ecx
  115f9d:	0f 85 28 00 00 00    	jne    115fcb <lv_img_src_get_type+0xab>
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
  115fa3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  115faa:	8d 05 22 40 12 00    	lea    0x124022,%eax
  115fb0:	89 44 24 04          	mov    %eax,0x4(%esp)
  115fb4:	c7 44 24 08 cd 01 00 	movl   $0x1cd,0x8(%esp)
  115fbb:	00 
  115fbc:	8d 05 7a 41 12 00    	lea    0x12417a,%eax
  115fc2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  115fc6:	e8 75 3a 00 00       	call   119a40 <lv_log_add>
    }

    return img_src_type;
  115fcb:	8a 45 fe             	mov    -0x2(%ebp),%al
  115fce:	88 45 ff             	mov    %al,-0x1(%ebp)
}
  115fd1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  115fd5:	83 c4 18             	add    $0x18,%esp
  115fd8:	5d                   	pop    %ebp
  115fd9:	c3                   	ret    
  115fda:	66 90                	xchg   %ax,%ax
  115fdc:	66 90                	xchg   %ax,%ax
  115fde:	66 90                	xchg   %ax,%ax

00115fe0 <lv_img_decoder_init>:

/**
 * Initialize the image decoder module
 * */
void lv_img_decoder_init(void)
{
  115fe0:	55                   	push   %ebp
  115fe1:	89 e5                	mov    %esp,%ebp
  115fe3:	83 ec 14             	sub    $0x14,%esp
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
  115fe6:	8d 05 a0 55 13 00    	lea    0x1355a0,%eax
  115fec:	89 04 24             	mov    %eax,(%esp)
  115fef:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  115ff6:	00 
  115ff7:	e8 74 2a 00 00       	call   118a70 <lv_ll_init>

    lv_img_decoder_t * decoder;

    /*Create a decoder for the built in color format*/
    decoder = lv_img_decoder_create();
  115ffc:	e8 cf 00 00 00       	call   1160d0 <lv_img_decoder_create>
  116001:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(decoder == NULL) {
  116004:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  116008:	0f 85 64 00 00 00    	jne    116072 <lv_img_decoder_init+0x92>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
  11600e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116015:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11601b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11601f:	c7 44 24 08 46 00 00 	movl   $0x46,0x8(%esp)
  116026:	00 
  116027:	8d 05 0d 42 12 00    	lea    0x12420d,%eax
  11602d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116031:	e8 0a 3a 00 00       	call   119a40 <lv_log_add>
        lv_mem_assert(decoder);
  116036:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  11603a:	0f 85 2d 00 00 00    	jne    11606d <lv_img_decoder_init+0x8d>
  116040:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  116047:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11604d:	89 44 24 04          	mov    %eax,0x4(%esp)
  116051:	c7 44 24 08 47 00 00 	movl   $0x47,0x8(%esp)
  116058:	00 
  116059:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  11605f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116063:	e8 d8 39 00 00       	call   119a40 <lv_log_add>
  116068:	e9 fb ff ff ff       	jmp    116068 <lv_img_decoder_init+0x88>
        return;
  11606d:	e9 54 00 00 00       	jmp    1160c6 <lv_img_decoder_init+0xe6>
    }

    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
  116072:	8b 45 fc             	mov    -0x4(%ebp),%eax
  116075:	89 04 24             	mov    %eax,(%esp)
  116078:	8d 05 90 61 11 00    	lea    0x116190,%eax
  11607e:	89 44 24 04          	mov    %eax,0x4(%esp)
  116082:	e8 e9 00 00 00       	call   116170 <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
  116087:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11608a:	89 04 24             	mov    %eax,(%esp)
  11608d:	8d 05 00 63 11 00    	lea    0x116300,%eax
  116093:	89 44 24 04          	mov    %eax,0x4(%esp)
  116097:	e8 44 02 00 00       	call   1162e0 <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
  11609c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11609f:	89 04 24             	mov    %eax,(%esp)
  1160a2:	8d 05 e0 66 11 00    	lea    0x1166e0,%eax
  1160a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1160ac:	e8 0f 06 00 00       	call   1166c0 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
  1160b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1160b4:	89 04 24             	mov    %eax,(%esp)
  1160b7:	8d 05 00 69 11 00    	lea    0x116900,%eax
  1160bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1160c1:	e8 1a 08 00 00       	call   1168e0 <lv_img_decoder_set_close_cb>
}
  1160c6:	83 c4 14             	add    $0x14,%esp
  1160c9:	5d                   	pop    %ebp
  1160ca:	c3                   	ret    
  1160cb:	66 90                	xchg   %ax,%ax
  1160cd:	66 90                	xchg   %ax,%ax
  1160cf:	90                   	nop

001160d0 <lv_img_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_img_decoder_t * lv_img_decoder_create(void)
{
  1160d0:	55                   	push   %ebp
  1160d1:	89 e5                	mov    %esp,%ebp
  1160d3:	83 ec 1c             	sub    $0x1c,%esp
    lv_img_decoder_t * decoder;
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
  1160d6:	8d 05 a0 55 13 00    	lea    0x1355a0,%eax
  1160dc:	89 04 24             	mov    %eax,(%esp)
  1160df:	e8 dc 29 00 00       	call   118ac0 <lv_ll_ins_head>
  1160e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    lv_mem_assert(decoder);
  1160e7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1160eb:	0f 85 2d 00 00 00    	jne    11611e <lv_img_decoder_create+0x4e>
  1160f1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1160f8:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  1160fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  116102:	c7 44 24 08 bd 00 00 	movl   $0xbd,0x8(%esp)
  116109:	00 
  11610a:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  116110:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116114:	e8 27 39 00 00       	call   119a40 <lv_log_add>
  116119:	e9 fb ff ff ff       	jmp    116119 <lv_img_decoder_create+0x49>
    if(decoder == NULL) return NULL;
  11611e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  116122:	0f 85 0c 00 00 00    	jne    116134 <lv_img_decoder_create+0x64>
  116128:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  11612f:	e9 26 00 00 00       	jmp    11615a <lv_img_decoder_create+0x8a>
  116134:	31 c0                	xor    %eax,%eax

    memset(decoder, 0, sizeof(lv_img_decoder_t));
  116136:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  116139:	89 0c 24             	mov    %ecx,(%esp)
  11613c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  116143:	00 
  116144:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  11614b:	00 
  11614c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11614f:	e8 1c 43 ff ff       	call   10a470 <memset>

    return decoder;
  116154:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  116157:	89 4d fc             	mov    %ecx,-0x4(%ebp)
}
  11615a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11615d:	83 c4 1c             	add    $0x1c,%esp
  116160:	5d                   	pop    %ebp
  116161:	c3                   	ret    
  116162:	66 90                	xchg   %ax,%ax
  116164:	66 90                	xchg   %ax,%ax
  116166:	66 90                	xchg   %ax,%ax
  116168:	66 90                	xchg   %ax,%ax
  11616a:	66 90                	xchg   %ax,%ax
  11616c:	66 90                	xchg   %ax,%ax
  11616e:	66 90                	xchg   %ax,%ax

00116170 <lv_img_decoder_set_info_cb>:
 * Set a callback to get information about the image
 * @param decoder pointer to an image decoder
 * @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)
 */
void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)
{
  116170:	55                   	push   %ebp
  116171:	89 e5                	mov    %esp,%ebp
  116173:	56                   	push   %esi
  116174:	8b 45 0c             	mov    0xc(%ebp),%eax
  116177:	8b 4d 08             	mov    0x8(%ebp),%ecx
    decoder->info_cb = info_cb;
  11617a:	8b 55 0c             	mov    0xc(%ebp),%edx
  11617d:	8b 75 08             	mov    0x8(%ebp),%esi
  116180:	89 16                	mov    %edx,(%esi)
}
  116182:	5e                   	pop    %esi
  116183:	5d                   	pop    %ebp
  116184:	c3                   	ret    
  116185:	66 90                	xchg   %ax,%ax
  116187:	66 90                	xchg   %ax,%ax
  116189:	66 90                	xchg   %ax,%ax
  11618b:	66 90                	xchg   %ax,%ax
  11618d:	66 90                	xchg   %ax,%ax
  11618f:	90                   	nop

00116190 <lv_img_decoder_built_in_info>:
 * @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol
 * @param header store the image data here
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
  116190:	55                   	push   %ebp
  116191:	89 e5                	mov    %esp,%ebp
  116193:	56                   	push   %esi
  116194:	83 ec 20             	sub    $0x20,%esp
  116197:	8b 45 10             	mov    0x10(%ebp),%eax
  11619a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11619d:	8b 55 08             	mov    0x8(%ebp),%edx
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
  1161a0:	8b 75 0c             	mov    0xc(%ebp),%esi
  1161a3:	89 34 24             	mov    %esi,(%esp)
  1161a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1161a9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1161ac:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1161af:	e8 6c fd ff ff       	call   115f20 <lv_img_src_get_type>
  1161b4:	88 45 fa             	mov    %al,-0x6(%ebp)
    if(src_type == LV_IMG_SRC_VARIABLE) {
  1161b7:	0f b6 4d fa          	movzbl -0x6(%ebp),%ecx
  1161bb:	83 f9 00             	cmp    $0x0,%ecx
  1161be:	0f 85 8d 00 00 00    	jne    116251 <lv_img_decoder_built_in_info+0xc1>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
  1161c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1161c7:	8b 00                	mov    (%eax),%eax
  1161c9:	83 e0 1f             	and    $0x1f,%eax
  1161cc:	88 45 f9             	mov    %al,-0x7(%ebp)
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
  1161cf:	0f b6 4d f9          	movzbl -0x7(%ebp),%ecx
  1161d3:	83 f9 04             	cmp    $0x4,%ecx
  1161d6:	0f 8c 0d 00 00 00    	jl     1161e9 <lv_img_decoder_built_in_info+0x59>
  1161dc:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  1161e0:	83 f8 0e             	cmp    $0xe,%eax
  1161e3:	0f 8e 09 00 00 00    	jle    1161f2 <lv_img_decoder_built_in_info+0x62>
  1161e9:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
  1161ed:	e9 de 00 00 00       	jmp    1162d0 <lv_img_decoder_built_in_info+0x140>

        header->w  = ((lv_img_dsc_t *)src)->header.w;
  1161f2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1161f5:	8b 00                	mov    (%eax),%eax
  1161f7:	c1 e8 0a             	shr    $0xa,%eax
  1161fa:	25 ff 07 00 00       	and    $0x7ff,%eax
  1161ff:	8b 4d 10             	mov    0x10(%ebp),%ecx
  116202:	8b 11                	mov    (%ecx),%edx
  116204:	25 ff 07 00 00       	and    $0x7ff,%eax
  116209:	c1 e0 0a             	shl    $0xa,%eax
  11620c:	81 e2 ff 03 e0 ff    	and    $0xffe003ff,%edx
  116212:	09 c2                	or     %eax,%edx
  116214:	89 11                	mov    %edx,(%ecx)
        header->h  = ((lv_img_dsc_t *)src)->header.h;
  116216:	8b 45 0c             	mov    0xc(%ebp),%eax
  116219:	8b 00                	mov    (%eax),%eax
  11621b:	c1 e8 15             	shr    $0x15,%eax
  11621e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  116221:	8b 11                	mov    (%ecx),%edx
  116223:	25 ff 07 00 00       	and    $0x7ff,%eax
  116228:	c1 e0 15             	shl    $0x15,%eax
  11622b:	81 e2 ff ff 1f 00    	and    $0x1fffff,%edx
  116231:	09 c2                	or     %eax,%edx
  116233:	89 11                	mov    %edx,(%ecx)
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
  116235:	8b 45 0c             	mov    0xc(%ebp),%eax
  116238:	8b 00                	mov    (%eax),%eax
  11623a:	83 e0 1f             	and    $0x1f,%eax
  11623d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  116240:	8b 11                	mov    (%ecx),%edx
  116242:	83 e0 1f             	and    $0x1f,%eax
  116245:	83 e2 e0             	and    $0xffffffe0,%edx
  116248:	09 c2                	or     %eax,%edx
  11624a:	89 11                	mov    %edx,(%ecx)
    }
  11624c:	e9 7b 00 00 00       	jmp    1162cc <lv_img_decoder_built_in_info+0x13c>

        if(header->cf < CF_BUILT_IN_FIRST || header->cf > CF_BUILT_IN_LAST) return LV_RES_INV;

    }
#endif
    else if(src_type == LV_IMG_SRC_SYMBOL) {
  116251:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
  116255:	83 f8 02             	cmp    $0x2,%eax
  116258:	0f 85 38 00 00 00    	jne    116296 <lv_img_decoder_built_in_info+0x106>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         * function*/
        header->w = 1;
  11625e:	8b 45 10             	mov    0x10(%ebp),%eax
  116261:	8b 08                	mov    (%eax),%ecx
  116263:	81 e1 ff 03 e0 ff    	and    $0xffe003ff,%ecx
  116269:	81 c9 00 04 00 00    	or     $0x400,%ecx
  11626f:	89 08                	mov    %ecx,(%eax)
        header->h = 1;
  116271:	8b 45 10             	mov    0x10(%ebp),%eax
  116274:	8b 08                	mov    (%eax),%ecx
  116276:	81 e1 ff ff 1f 00    	and    $0x1fffff,%ecx
  11627c:	81 c9 00 00 20 00    	or     $0x200000,%ecx
  116282:	89 08                	mov    %ecx,(%eax)
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
  116284:	8b 45 10             	mov    0x10(%ebp),%eax
  116287:	8b 08                	mov    (%eax),%ecx
  116289:	83 e1 e0             	and    $0xffffffe0,%ecx
  11628c:	83 c9 0b             	or     $0xb,%ecx
  11628f:	89 08                	mov    %ecx,(%eax)
    } else {
  116291:	e9 31 00 00 00       	jmp    1162c7 <lv_img_decoder_built_in_info+0x137>
        LV_LOG_WARN("Image get info found unknown src type");
  116296:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  11629d:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  1162a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1162a7:	c7 44 24 08 23 01 00 	movl   $0x123,0x8(%esp)
  1162ae:	00 
  1162af:	8d 05 30 42 12 00    	lea    0x124230,%eax
  1162b5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1162b9:	e8 82 37 00 00       	call   119a40 <lv_log_add>
        return LV_RES_INV;
  1162be:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
  1162c2:	e9 09 00 00 00       	jmp    1162d0 <lv_img_decoder_built_in_info+0x140>
  1162c7:	e9 00 00 00 00       	jmp    1162cc <lv_img_decoder_built_in_info+0x13c>
    }
    return LV_RES_OK;
  1162cc:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
}
  1162d0:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  1162d4:	83 c4 20             	add    $0x20,%esp
  1162d7:	5e                   	pop    %esi
  1162d8:	5d                   	pop    %ebp
  1162d9:	c3                   	ret    
  1162da:	66 90                	xchg   %ax,%ax
  1162dc:	66 90                	xchg   %ax,%ax
  1162de:	66 90                	xchg   %ax,%ax

001162e0 <lv_img_decoder_set_open_cb>:
{
  1162e0:	55                   	push   %ebp
  1162e1:	89 e5                	mov    %esp,%ebp
  1162e3:	56                   	push   %esi
  1162e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1162e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    decoder->open_cb = open_cb;
  1162ea:	8b 55 0c             	mov    0xc(%ebp),%edx
  1162ed:	8b 75 08             	mov    0x8(%ebp),%esi
  1162f0:	89 56 04             	mov    %edx,0x4(%esi)
}
  1162f3:	5e                   	pop    %esi
  1162f4:	5d                   	pop    %ebp
  1162f5:	c3                   	ret    
  1162f6:	66 90                	xchg   %ax,%ax
  1162f8:	66 90                	xchg   %ax,%ax
  1162fa:	66 90                	xchg   %ax,%ax
  1162fc:	66 90                	xchg   %ax,%ax
  1162fe:	66 90                	xchg   %ax,%ax

00116300 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
  116300:	55                   	push   %ebp
  116301:	89 e5                	mov    %esp,%ebp
  116303:	53                   	push   %ebx
  116304:	57                   	push   %edi
  116305:	56                   	push   %esi
  116306:	83 e4 f8             	and    $0xfffffff8,%esp
  116309:	83 ec 40             	sub    $0x40,%esp
  11630c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11630f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
  116312:	8b 55 0c             	mov    0xc(%ebp),%edx
  116315:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  116319:	83 fa 01             	cmp    $0x1,%edx
  11631c:	0f 85 32 00 00 00    	jne    116354 <lv_img_decoder_built_in_open+0x54>
        }

        memcpy(user_data->f, &f, sizeof(f));

#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
  116322:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116329:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11632f:	89 44 24 04          	mov    %eax,0x4(%esp)
  116333:	c7 44 24 08 53 01 00 	movl   $0x153,0x8(%esp)
  11633a:	00 
  11633b:	8d 05 56 42 12 00    	lea    0x124256,%eax
  116341:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116345:	e8 f6 36 00 00       	call   119a40 <lv_log_add>
        return LV_RES_INV;
  11634a:	c6 44 24 3b 00       	movb   $0x0,0x3b(%esp)
  11634f:	e9 57 03 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
#endif
    }

    lv_img_cf_t cf = dsc->header.cf;
  116354:	8b 45 0c             	mov    0xc(%ebp),%eax
  116357:	8b 40 10             	mov    0x10(%eax),%eax
  11635a:	83 e0 1f             	and    $0x1f,%eax
  11635d:	88 44 24 3a          	mov    %al,0x3a(%esp)
    /*Process true color formats*/
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
  116361:	0f b6 4c 24 3a       	movzbl 0x3a(%esp),%ecx
  116366:	83 f9 04             	cmp    $0x4,%ecx
  116369:	0f 84 1c 00 00 00    	je     11638b <lv_img_decoder_built_in_open+0x8b>
  11636f:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116374:	83 f8 05             	cmp    $0x5,%eax
  116377:	0f 84 0e 00 00 00    	je     11638b <lv_img_decoder_built_in_open+0x8b>
  11637d:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116382:	83 f8 06             	cmp    $0x6,%eax
  116385:	0f 85 3d 00 00 00    	jne    1163c8 <lv_img_decoder_built_in_open+0xc8>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
  11638b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11638e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116392:	83 f8 00             	cmp    $0x0,%eax
  116395:	0f 85 19 00 00 00    	jne    1163b4 <lv_img_decoder_built_in_open+0xb4>
            /* In case of uncompressed formats the image stored in the ROM/RAM.
             * So simply give its pointer*/
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
  11639b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11639e:	8b 40 04             	mov    0x4(%eax),%eax
  1163a1:	8b 40 08             	mov    0x8(%eax),%eax
  1163a4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1163a7:	89 41 14             	mov    %eax,0x14(%ecx)
            return LV_RES_OK;
  1163aa:	c6 44 24 3b 01       	movb   $0x1,0x3b(%esp)
  1163af:	e9 f7 02 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
        } else {
            /*If it's a file it need to be read line by line later*/
            dsc->img_data = NULL;
  1163b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1163b7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
            return LV_RES_OK;
  1163be:	c6 44 24 3b 01       	movb   $0x1,0x3b(%esp)
  1163c3:	e9 e3 02 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
        }
    }
    /*Process indexed images. Build a palette*/
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
  1163c8:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  1163cd:	83 f8 07             	cmp    $0x7,%eax
  1163d0:	0f 84 2a 00 00 00    	je     116400 <lv_img_decoder_built_in_open+0x100>
  1163d6:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  1163db:	83 f8 08             	cmp    $0x8,%eax
  1163de:	0f 84 1c 00 00 00    	je     116400 <lv_img_decoder_built_in_open+0x100>
  1163e4:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  1163e9:	83 f8 09             	cmp    $0x9,%eax
  1163ec:	0f 84 0e 00 00 00    	je     116400 <lv_img_decoder_built_in_open+0x100>
            cf == LV_IMG_CF_INDEXED_8BIT) {
  1163f2:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  1163f7:	83 f8 0a             	cmp    $0xa,%eax
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
  1163fa:	0f 85 20 02 00 00    	jne    116620 <lv_img_decoder_built_in_open+0x320>

#if LV_IMG_CF_INDEXED
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
  116400:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116405:	89 04 24             	mov    %eax,(%esp)
  116408:	e8 93 fa ff ff       	call   115ea0 <lv_img_color_format_get_px_size>
  11640d:	88 44 24 39          	mov    %al,0x39(%esp)
        uint32_t palette_size = 1 << px_size;
  116411:	0f b6 4c 24 39       	movzbl 0x39(%esp),%ecx
  116416:	ba 01 00 00 00       	mov    $0x1,%edx
  11641b:	d3 e2                	shl    %cl,%edx
  11641d:	89 54 24 34          	mov    %edx,0x34(%esp)

        /*Allocate the palette*/
        if(dsc->user_data == NULL) {
  116421:	8b 55 0c             	mov    0xc(%ebp),%edx
  116424:	83 7a 20 00          	cmpl   $0x0,0x20(%edx)
  116428:	0f 85 aa 00 00 00    	jne    1164d8 <lv_img_decoder_built_in_open+0x1d8>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
  11642e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  116435:	e8 26 23 00 00       	call   118760 <lv_mem_alloc>
  11643a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11643d:	89 41 20             	mov    %eax,0x20(%ecx)
            if(dsc->user_data == NULL) {
  116440:	8b 45 0c             	mov    0xc(%ebp),%eax
  116443:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
  116447:	0f 85 67 00 00 00    	jne    1164b4 <lv_img_decoder_built_in_open+0x1b4>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
  11644d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  116454:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11645a:	89 44 24 04          	mov    %eax,0x4(%esp)
  11645e:	c7 44 24 08 72 01 00 	movl   $0x172,0x8(%esp)
  116465:	00 
  116466:	8d 05 9c 42 12 00    	lea    0x12429c,%eax
  11646c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116470:	e8 cb 35 00 00       	call   119a40 <lv_log_add>
                lv_mem_assert(dsc->user_data);
  116475:	8b 45 0c             	mov    0xc(%ebp),%eax
  116478:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
  11647c:	0f 85 2d 00 00 00    	jne    1164af <lv_img_decoder_built_in_open+0x1af>
  116482:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  116489:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11648f:	89 44 24 04          	mov    %eax,0x4(%esp)
  116493:	c7 44 24 08 73 01 00 	movl   $0x173,0x8(%esp)
  11649a:	00 
  11649b:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  1164a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1164a5:	e8 96 35 00 00       	call   119a40 <lv_log_add>
  1164aa:	e9 fb ff ff ff       	jmp    1164aa <lv_img_decoder_built_in_open+0x1aa>
            }
  1164af:	e9 00 00 00 00       	jmp    1164b4 <lv_img_decoder_built_in_open+0x1b4>
  1164b4:	31 c0                	xor    %eax,%eax
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
  1164b6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1164b9:	8b 49 20             	mov    0x20(%ecx),%ecx
  1164bc:	89 0c 24             	mov    %ecx,(%esp)
  1164bf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1164c6:	00 
  1164c7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1164ce:	00 
  1164cf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1164d3:	e8 98 3f ff ff       	call   10a470 <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
  1164d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1164db:	8b 40 20             	mov    0x20(%eax),%eax
  1164de:	89 44 24 30          	mov    %eax,0x30(%esp)
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
  1164e2:	8b 44 24 34          	mov    0x34(%esp),%eax
  1164e6:	c1 e0 02             	shl    $0x2,%eax
  1164e9:	89 04 24             	mov    %eax,(%esp)
  1164ec:	e8 6f 22 00 00       	call   118760 <lv_mem_alloc>
  1164f1:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  1164f5:	89 01                	mov    %eax,(%ecx)
        if(user_data->palette == NULL) {
  1164f7:	8b 44 24 30          	mov    0x30(%esp),%eax
  1164fb:	83 38 00             	cmpl   $0x0,(%eax)
  1164fe:	0f 85 28 00 00 00    	jne    11652c <lv_img_decoder_built_in_open+0x22c>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
  116504:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11650b:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  116511:	89 44 24 04          	mov    %eax,0x4(%esp)
  116515:	c7 44 24 08 7b 01 00 	movl   $0x17b,0x8(%esp)
  11651c:	00 
  11651d:	8d 05 9c 42 12 00    	lea    0x12429c,%eax
  116523:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116527:	e8 14 35 00 00       	call   119a40 <lv_log_add>
#if LV_USE_FILESYSTEM
            lv_mem_assert(user_data->f);
#endif
        }

        if(dsc->src_type == LV_IMG_SRC_FILE) {
  11652c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11652f:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116533:	83 f8 01             	cmp    $0x1,%eax
  116536:	0f 85 32 00 00 00    	jne    11656e <lv_img_decoder_built_in_open+0x26e>
            /*Read the palette from file*/
#if LV_USE_FILESYSTEM
            lv_fs_seek(user_data->f, 4); /*Skip the header*/
            lv_fs_read(user_data->f, user_data->palette, palette_size * sizeof(lv_color_t), NULL);
#else
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
  11653c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116543:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  116549:	89 44 24 04          	mov    %eax,0x4(%esp)
  11654d:	c7 44 24 08 87 01 00 	movl   $0x187,0x8(%esp)
  116554:	00 
  116555:	8d 05 c5 42 12 00    	lea    0x1242c5,%eax
  11655b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11655f:	e8 dc 34 00 00       	call   119a40 <lv_log_add>
            return LV_RES_INV;
  116564:	c6 44 24 3b 00       	movb   $0x0,0x3b(%esp)
  116569:	e9 3d 01 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
#endif
        } else {
            /*The palette begins in the beginning of the image data. Just point to it.*/
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
  11656e:	8b 45 0c             	mov    0xc(%ebp),%eax
  116571:	8b 40 04             	mov    0x4(%eax),%eax
  116574:	8b 40 08             	mov    0x8(%eax),%eax
  116577:	89 44 24 2c          	mov    %eax,0x2c(%esp)

            uint32_t i;
            for(i = 0; i < palette_size; i++) {
  11657b:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  116582:	00 
  116583:	8b 44 24 28          	mov    0x28(%esp),%eax
  116587:	3b 44 24 34          	cmp    0x34(%esp),%eax
  11658b:	0f 83 76 00 00 00    	jae    116607 <lv_img_decoder_built_in_open+0x307>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
  116591:	8b 44 24 30          	mov    0x30(%esp),%eax
  116595:	8b 00                	mov    (%eax),%eax
  116597:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  11659b:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  11659f:	8b 74 24 28          	mov    0x28(%esp),%esi
  1165a3:	8a 5c b2 02          	mov    0x2(%edx,%esi,4),%bl
  1165a7:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  1165ab:	8b 74 24 28          	mov    0x28(%esp),%esi
  1165af:	8a 7c b2 01          	mov    0x1(%edx,%esi,4),%bh
  1165b3:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  1165b7:	8b 74 24 28          	mov    0x28(%esp),%esi
  1165bb:	8d 7c 24 20          	lea    0x20(%esp),%edi
  1165bf:	89 3c 24             	mov    %edi,(%esp)
  1165c2:	0f b6 fb             	movzbl %bl,%edi
  1165c5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1165c9:	0f b6 ff             	movzbl %bh,%edi
  1165cc:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1165d0:	0f b6 14 b2          	movzbl (%edx,%esi,4),%edx
  1165d4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1165d8:	89 44 24 18          	mov    %eax,0x18(%esp)
  1165dc:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  1165e0:	e8 cb 03 00 00       	call   1169b0 <lv_color_make>
  1165e5:	83 ec 04             	sub    $0x4,%esp
  1165e8:	8b 44 24 20          	mov    0x20(%esp),%eax
  1165ec:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  1165f0:	8b 54 24 14          	mov    0x14(%esp),%edx
  1165f4:	89 04 91             	mov    %eax,(%ecx,%edx,4)
            for(i = 0; i < palette_size; i++) {
  1165f7:	8b 44 24 28          	mov    0x28(%esp),%eax
  1165fb:	83 c0 01             	add    $0x1,%eax
  1165fe:	89 44 24 28          	mov    %eax,0x28(%esp)
  116602:	e9 7c ff ff ff       	jmp    116583 <lv_img_decoder_built_in_open+0x283>
  116607:	e9 00 00 00 00       	jmp    11660c <lv_img_decoder_built_in_open+0x30c>
            }
        }

        dsc->img_data = NULL;
  11660c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11660f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        return LV_RES_OK;
  116616:	c6 44 24 3b 01       	movb   $0x1,0x3b(%esp)
  11661b:	e9 8b 00 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
        LV_LOG_WARN("Indexed (palette) images are not enabled in lv_conf.h. See LV_IMG_CF_INDEXED");
        return LV_RES_INV;
#endif
    }
    /*Alpha indexed images. */
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
  116620:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116625:	83 f8 0b             	cmp    $0xb,%eax
  116628:	0f 84 2a 00 00 00    	je     116658 <lv_img_decoder_built_in_open+0x358>
  11662e:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116633:	83 f8 0c             	cmp    $0xc,%eax
  116636:	0f 84 1c 00 00 00    	je     116658 <lv_img_decoder_built_in_open+0x358>
  11663c:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  116641:	83 f8 0d             	cmp    $0xd,%eax
  116644:	0f 84 0e 00 00 00    	je     116658 <lv_img_decoder_built_in_open+0x358>
            cf == LV_IMG_CF_ALPHA_8BIT) {
  11664a:	0f b6 44 24 3a       	movzbl 0x3a(%esp),%eax
  11664f:	83 f8 0e             	cmp    $0xe,%eax
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
  116652:	0f 85 14 00 00 00    	jne    11666c <lv_img_decoder_built_in_open+0x36c>
#if LV_IMG_CF_ALPHA
        dsc->img_data = NULL;
  116658:	8b 45 0c             	mov    0xc(%ebp),%eax
  11665b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        return LV_RES_OK; /*Nothing to process*/
  116662:	c6 44 24 3b 01       	movb   $0x1,0x3b(%esp)
  116667:	e9 3f 00 00 00       	jmp    1166ab <lv_img_decoder_built_in_open+0x3ab>
#endif
    }
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);
  11666c:	8b 45 08             	mov    0x8(%ebp),%eax
  11666f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  116672:	89 04 24             	mov    %eax,(%esp)
  116675:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  116679:	e8 82 02 00 00       	call   116900 <lv_img_decoder_built_in_close>

        LV_LOG_WARN("Image decoder open: unknown color format")
  11667e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116685:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  11668b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11668f:	c7 44 24 08 ab 01 00 	movl   $0x1ab,0x8(%esp)
  116696:	00 
  116697:	8d 05 0f 43 12 00    	lea    0x12430f,%eax
  11669d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1166a1:	e8 9a 33 00 00       	call   119a40 <lv_log_add>
        return LV_RES_INV;
  1166a6:	c6 44 24 3b 00       	movb   $0x0,0x3b(%esp)
    }
}
  1166ab:	0f b6 44 24 3b       	movzbl 0x3b(%esp),%eax
  1166b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1166b3:	5e                   	pop    %esi
  1166b4:	5f                   	pop    %edi
  1166b5:	5b                   	pop    %ebx
  1166b6:	5d                   	pop    %ebp
  1166b7:	c3                   	ret    
  1166b8:	66 90                	xchg   %ax,%ax
  1166ba:	66 90                	xchg   %ax,%ax
  1166bc:	66 90                	xchg   %ax,%ax
  1166be:	66 90                	xchg   %ax,%ax

001166c0 <lv_img_decoder_set_read_line_cb>:
{
  1166c0:	55                   	push   %ebp
  1166c1:	89 e5                	mov    %esp,%ebp
  1166c3:	56                   	push   %esi
  1166c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1166c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    decoder->read_line_cb = read_line_cb;
  1166ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  1166cd:	8b 75 08             	mov    0x8(%ebp),%esi
  1166d0:	89 56 08             	mov    %edx,0x8(%esi)
}
  1166d3:	5e                   	pop    %esi
  1166d4:	5d                   	pop    %ebp
  1166d5:	c3                   	ret    
  1166d6:	66 90                	xchg   %ax,%ax
  1166d8:	66 90                	xchg   %ax,%ax
  1166da:	66 90                	xchg   %ax,%ax
  1166dc:	66 90                	xchg   %ax,%ax
  1166de:	66 90                	xchg   %ax,%ax

001166e0 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
  1166e0:	55                   	push   %ebp
  1166e1:	89 e5                	mov    %esp,%ebp
  1166e3:	53                   	push   %ebx
  1166e4:	57                   	push   %edi
  1166e5:	56                   	push   %esi
  1166e6:	83 ec 1c             	sub    $0x1c,%esp
  1166e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
  1166ec:	66 8b 4d 18          	mov    0x18(%ebp),%cx
  1166f0:	66 8b 55 14          	mov    0x14(%ebp),%dx
  1166f4:	66 8b 75 10          	mov    0x10(%ebp),%si
  1166f8:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1166fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;
  1166fe:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  116702:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
  116705:	8b 45 0c             	mov    0xc(%ebp),%eax
  116708:	8b 40 10             	mov    0x10(%eax),%eax
  11670b:	83 e0 1f             	and    $0x1f,%eax
  11670e:	83 f8 04             	cmp    $0x4,%eax
  116711:	0f 84 24 00 00 00    	je     11673b <lv_img_decoder_built_in_read_line+0x5b>
  116717:	8b 45 0c             	mov    0xc(%ebp),%eax
  11671a:	8b 40 10             	mov    0x10(%eax),%eax
  11671d:	83 e0 1f             	and    $0x1f,%eax
  116720:	83 f8 05             	cmp    $0x5,%eax
  116723:	0f 84 12 00 00 00    	je     11673b <lv_img_decoder_built_in_read_line+0x5b>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
  116729:	8b 45 0c             	mov    0xc(%ebp),%eax
  11672c:	8b 40 10             	mov    0x10(%eax),%eax
  11672f:	83 e0 1f             	and    $0x1f,%eax
  116732:	83 f8 06             	cmp    $0x6,%eax
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
  116735:	0f 85 4b 00 00 00    	jne    116786 <lv_img_decoder_built_in_read_line+0xa6>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
  11673b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11673e:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116742:	83 f8 01             	cmp    $0x1,%eax
  116745:	0f 85 36 00 00 00    	jne    116781 <lv_img_decoder_built_in_read_line+0xa1>
            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);
  11674b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11674e:	66 8b 4d 10          	mov    0x10(%ebp),%cx
  116752:	66 8b 55 14          	mov    0x14(%ebp),%dx
  116756:	66 8b 75 18          	mov    0x18(%ebp),%si
  11675a:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  11675d:	89 04 24             	mov    %eax,(%esp)
  116760:	0f bf c1             	movswl %cx,%eax
  116763:	89 44 24 04          	mov    %eax,0x4(%esp)
  116767:	0f bf c2             	movswl %dx,%eax
  11676a:	89 44 24 08          	mov    %eax,0x8(%esp)
  11676e:	0f bf c6             	movswl %si,%eax
  116771:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116775:	89 7c 24 10          	mov    %edi,0x10(%esp)
  116779:	e8 62 02 00 00       	call   1169e0 <lv_img_decoder_built_in_line_true_color>
  11677e:	88 45 f2             	mov    %al,-0xe(%ebp)
        }
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
  116781:	e9 41 01 00 00       	jmp    1168c7 <lv_img_decoder_built_in_read_line+0x1e7>
  116786:	8b 45 0c             	mov    0xc(%ebp),%eax
  116789:	8b 40 10             	mov    0x10(%eax),%eax
  11678c:	83 e0 1f             	and    $0x1f,%eax
  11678f:	83 f8 0b             	cmp    $0xb,%eax
  116792:	0f 84 36 00 00 00    	je     1167ce <lv_img_decoder_built_in_read_line+0xee>
  116798:	8b 45 0c             	mov    0xc(%ebp),%eax
  11679b:	8b 40 10             	mov    0x10(%eax),%eax
  11679e:	83 e0 1f             	and    $0x1f,%eax
  1167a1:	83 f8 0c             	cmp    $0xc,%eax
  1167a4:	0f 84 24 00 00 00    	je     1167ce <lv_img_decoder_built_in_read_line+0xee>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
  1167aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1167ad:	8b 40 10             	mov    0x10(%eax),%eax
  1167b0:	83 e0 1f             	and    $0x1f,%eax
  1167b3:	83 f8 0d             	cmp    $0xd,%eax
  1167b6:	0f 84 12 00 00 00    	je     1167ce <lv_img_decoder_built_in_read_line+0xee>
  1167bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1167bf:	8b 40 10             	mov    0x10(%eax),%eax
  1167c2:	83 e0 1f             	and    $0x1f,%eax
  1167c5:	83 f8 0e             	cmp    $0xe,%eax
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
  1167c8:	0f 85 3b 00 00 00    	jne    116809 <lv_img_decoder_built_in_read_line+0x129>

        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
  1167ce:	8b 45 0c             	mov    0xc(%ebp),%eax
  1167d1:	66 8b 4d 10          	mov    0x10(%ebp),%cx
  1167d5:	66 8b 55 14          	mov    0x14(%ebp),%dx
  1167d9:	66 8b 75 18          	mov    0x18(%ebp),%si
  1167dd:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  1167e0:	89 04 24             	mov    %eax,(%esp)
  1167e3:	0f bf c1             	movswl %cx,%eax
  1167e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1167ea:	0f bf c2             	movswl %dx,%eax
  1167ed:	89 44 24 08          	mov    %eax,0x8(%esp)
  1167f1:	0f bf c6             	movswl %si,%eax
  1167f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1167f8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  1167fc:	e8 4f 02 00 00       	call   116a50 <lv_img_decoder_built_in_line_alpha>
  116801:	88 45 f2             	mov    %al,-0xe(%ebp)
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
  116804:	e9 b9 00 00 00       	jmp    1168c2 <lv_img_decoder_built_in_read_line+0x1e2>
  116809:	8b 45 0c             	mov    0xc(%ebp),%eax
  11680c:	8b 40 10             	mov    0x10(%eax),%eax
  11680f:	83 e0 1f             	and    $0x1f,%eax
  116812:	83 f8 07             	cmp    $0x7,%eax
  116815:	0f 84 36 00 00 00    	je     116851 <lv_img_decoder_built_in_read_line+0x171>
  11681b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11681e:	8b 40 10             	mov    0x10(%eax),%eax
  116821:	83 e0 1f             	and    $0x1f,%eax
  116824:	83 f8 08             	cmp    $0x8,%eax
  116827:	0f 84 24 00 00 00    	je     116851 <lv_img_decoder_built_in_read_line+0x171>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
  11682d:	8b 45 0c             	mov    0xc(%ebp),%eax
  116830:	8b 40 10             	mov    0x10(%eax),%eax
  116833:	83 e0 1f             	and    $0x1f,%eax
  116836:	83 f8 09             	cmp    $0x9,%eax
  116839:	0f 84 12 00 00 00    	je     116851 <lv_img_decoder_built_in_read_line+0x171>
  11683f:	8b 45 0c             	mov    0xc(%ebp),%eax
  116842:	8b 40 10             	mov    0x10(%eax),%eax
  116845:	83 e0 1f             	and    $0x1f,%eax
  116848:	83 f8 0a             	cmp    $0xa,%eax
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
  11684b:	0f 85 3b 00 00 00    	jne    11688c <lv_img_decoder_built_in_read_line+0x1ac>
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
  116851:	8b 45 0c             	mov    0xc(%ebp),%eax
  116854:	66 8b 4d 10          	mov    0x10(%ebp),%cx
  116858:	66 8b 55 14          	mov    0x14(%ebp),%dx
  11685c:	66 8b 75 18          	mov    0x18(%ebp),%si
  116860:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  116863:	89 04 24             	mov    %eax,(%esp)
  116866:	0f bf c1             	movswl %cx,%eax
  116869:	89 44 24 04          	mov    %eax,0x4(%esp)
  11686d:	0f bf c2             	movswl %dx,%eax
  116870:	89 44 24 08          	mov    %eax,0x8(%esp)
  116874:	0f bf c6             	movswl %si,%eax
  116877:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11687b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  11687f:	e8 fc 05 00 00       	call   116e80 <lv_img_decoder_built_in_line_indexed>
  116884:	88 45 f2             	mov    %al,-0xe(%ebp)
    } else {
  116887:	e9 31 00 00 00       	jmp    1168bd <lv_img_decoder_built_in_read_line+0x1dd>
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
  11688c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116893:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  116899:	89 44 24 04          	mov    %eax,0x4(%esp)
  11689d:	c7 44 24 08 d1 01 00 	movl   $0x1d1,0x8(%esp)
  1168a4:	00 
  1168a5:	8d 05 38 43 12 00    	lea    0x124338,%eax
  1168ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1168af:	e8 8c 31 00 00       	call   119a40 <lv_log_add>
        return LV_RES_INV;
  1168b4:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  1168b8:	e9 10 00 00 00       	jmp    1168cd <lv_img_decoder_built_in_read_line+0x1ed>
  1168bd:	e9 00 00 00 00       	jmp    1168c2 <lv_img_decoder_built_in_read_line+0x1e2>
  1168c2:	e9 00 00 00 00       	jmp    1168c7 <lv_img_decoder_built_in_read_line+0x1e7>
    }

    return res;
  1168c7:	8a 45 f2             	mov    -0xe(%ebp),%al
  1168ca:	88 45 f3             	mov    %al,-0xd(%ebp)
}
  1168cd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  1168d1:	83 c4 1c             	add    $0x1c,%esp
  1168d4:	5e                   	pop    %esi
  1168d5:	5f                   	pop    %edi
  1168d6:	5b                   	pop    %ebx
  1168d7:	5d                   	pop    %ebp
  1168d8:	c3                   	ret    
  1168d9:	66 90                	xchg   %ax,%ax
  1168db:	66 90                	xchg   %ax,%ax
  1168dd:	66 90                	xchg   %ax,%ax
  1168df:	90                   	nop

001168e0 <lv_img_decoder_set_close_cb>:
{
  1168e0:	55                   	push   %ebp
  1168e1:	89 e5                	mov    %esp,%ebp
  1168e3:	56                   	push   %esi
  1168e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1168e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    decoder->close_cb = close_cb;
  1168ea:	8b 55 0c             	mov    0xc(%ebp),%edx
  1168ed:	8b 75 08             	mov    0x8(%ebp),%esi
  1168f0:	89 56 0c             	mov    %edx,0xc(%esi)
}
  1168f3:	5e                   	pop    %esi
  1168f4:	5d                   	pop    %ebp
  1168f5:	c3                   	ret    
  1168f6:	66 90                	xchg   %ax,%ax
  1168f8:	66 90                	xchg   %ax,%ax
  1168fa:	66 90                	xchg   %ax,%ax
  1168fc:	66 90                	xchg   %ax,%ax
  1168fe:	66 90                	xchg   %ax,%ax

00116900 <lv_img_decoder_built_in_close>:
 * Close the pending decoding. Free resources etc.
 * @param decoder pointer to the decoder the function associated with
 * @param dsc pointer to decoder descriptor
 */
void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
  116900:	55                   	push   %ebp
  116901:	89 e5                	mov    %esp,%ebp
  116903:	83 ec 08             	sub    $0x8,%esp
  116906:	8b 45 0c             	mov    0xc(%ebp),%eax
  116909:	8b 4d 08             	mov    0x8(%ebp),%ecx
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
  11690c:	8b 55 0c             	mov    0xc(%ebp),%edx
  11690f:	8b 52 20             	mov    0x20(%edx),%edx
  116912:	89 55 fc             	mov    %edx,-0x4(%ebp)
    if(user_data) {
  116915:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  116919:	0f 84 2e 00 00 00    	je     11694d <lv_img_decoder_built_in_close+0x4d>
        if(user_data->f) {
            lv_fs_close(user_data->f);
            lv_mem_free(user_data->f);
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
  11691f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  116922:	83 38 00             	cmpl   $0x0,(%eax)
  116925:	0f 84 0d 00 00 00    	je     116938 <lv_img_decoder_built_in_close+0x38>
  11692b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11692e:	8b 00                	mov    (%eax),%eax
  116930:	89 04 24             	mov    %eax,(%esp)
  116933:	e8 28 1f 00 00       	call   118860 <lv_mem_free>

        lv_mem_free(user_data);
  116938:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11693b:	89 04 24             	mov    %eax,(%esp)
  11693e:	e8 1d 1f 00 00       	call   118860 <lv_mem_free>

        dsc->user_data = NULL;
  116943:	8b 45 0c             	mov    0xc(%ebp),%eax
  116946:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
    }
}
  11694d:	83 c4 08             	add    $0x8,%esp
  116950:	5d                   	pop    %ebp
  116951:	c3                   	ret    
  116952:	66 90                	xchg   %ax,%ax
  116954:	66 90                	xchg   %ax,%ax
  116956:	66 90                	xchg   %ax,%ax
  116958:	66 90                	xchg   %ax,%ax
  11695a:	66 90                	xchg   %ax,%ax
  11695c:	66 90                	xchg   %ax,%ax
  11695e:	66 90                	xchg   %ax,%ax

00116960 <lv_img_decoder_close>:
{
  116960:	55                   	push   %ebp
  116961:	89 e5                	mov    %esp,%ebp
  116963:	83 ec 08             	sub    $0x8,%esp
  116966:	8b 45 08             	mov    0x8(%ebp),%eax
    if(dsc->decoder) {
  116969:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11696c:	83 39 00             	cmpl   $0x0,(%ecx)
  11696f:	0f 84 2d 00 00 00    	je     1169a2 <lv_img_decoder_close+0x42>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
  116975:	8b 45 08             	mov    0x8(%ebp),%eax
  116978:	8b 00                	mov    (%eax),%eax
  11697a:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  11697e:	0f 84 19 00 00 00    	je     11699d <lv_img_decoder_close+0x3d>
  116984:	8b 45 08             	mov    0x8(%ebp),%eax
  116987:	8b 00                	mov    (%eax),%eax
  116989:	8b 40 0c             	mov    0xc(%eax),%eax
  11698c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11698f:	8b 09                	mov    (%ecx),%ecx
  116991:	8b 55 08             	mov    0x8(%ebp),%edx
  116994:	89 0c 24             	mov    %ecx,(%esp)
  116997:	89 54 24 04          	mov    %edx,0x4(%esp)
  11699b:	ff d0                	call   *%eax
    }
  11699d:	e9 00 00 00 00       	jmp    1169a2 <lv_img_decoder_close+0x42>
}
  1169a2:	83 c4 08             	add    $0x8,%esp
  1169a5:	5d                   	pop    %ebp
  1169a6:	c3                   	ret    
  1169a7:	66 90                	xchg   %ax,%ax
  1169a9:	66 90                	xchg   %ax,%ax
  1169ab:	66 90                	xchg   %ax,%ax
  1169ad:	66 90                	xchg   %ax,%ax
  1169af:	90                   	nop

001169b0 <lv_color_make>:
{
  1169b0:	55                   	push   %ebp
  1169b1:	89 e5                	mov    %esp,%ebp
  1169b3:	53                   	push   %ebx
  1169b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1169b7:	89 c1                	mov    %eax,%ecx
  1169b9:	8a 55 14             	mov    0x14(%ebp),%dl
  1169bc:	8a 75 10             	mov    0x10(%ebp),%dh
  1169bf:	8a 5d 0c             	mov    0xc(%ebp),%bl
    color.ch.blue  = b8;
  1169c2:	8a 7d 14             	mov    0x14(%ebp),%bh
  1169c5:	88 38                	mov    %bh,(%eax)
    color.ch.green = g8;
  1169c7:	8a 7d 10             	mov    0x10(%ebp),%bh
  1169ca:	88 78 01             	mov    %bh,0x1(%eax)
    color.ch.red   = r8;
  1169cd:	8a 7d 0c             	mov    0xc(%ebp),%bh
  1169d0:	88 78 02             	mov    %bh,0x2(%eax)
    color.ch.alpha = 0xff;
  1169d3:	c6 40 03 ff          	movb   $0xff,0x3(%eax)
    return color;
  1169d7:	89 c8                	mov    %ecx,%eax
  1169d9:	5b                   	pop    %ebx
  1169da:	5d                   	pop    %ebp
  1169db:	c2 04 00             	ret    $0x4
  1169de:	66 90                	xchg   %ax,%ax

001169e0 <lv_img_decoder_built_in_line_true_color>:
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                        lv_coord_t len, uint8_t * buf)
{
  1169e0:	55                   	push   %ebp
  1169e1:	89 e5                	mov    %esp,%ebp
  1169e3:	53                   	push   %ebx
  1169e4:	57                   	push   %edi
  1169e5:	56                   	push   %esi
  1169e6:	83 ec 20             	sub    $0x20,%esp
  1169e9:	8b 45 18             	mov    0x18(%ebp),%eax
  1169ec:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  1169f0:	66 8b 55 10          	mov    0x10(%ebp),%dx
  1169f4:	66 8b 75 0c          	mov    0xc(%ebp),%si
  1169f8:	8b 7d 08             	mov    0x8(%ebp),%edi
        return LV_RES_INV;
    }

    return LV_RES_OK;
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
  1169fb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116a02:	8d 1d c1 41 12 00    	lea    0x1241c1,%ebx
  116a08:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  116a0c:	c7 44 24 08 0f 02 00 	movl   $0x20f,0x8(%esp)
  116a13:	00 
  116a14:	8d 1d 56 42 12 00    	lea    0x124256,%ebx
  116a1a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  116a1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  116a21:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  116a25:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
  116a29:	66 89 75 ea          	mov    %si,-0x16(%ebp)
  116a2d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  116a30:	e8 0b 30 00 00       	call   119a40 <lv_log_add>
  116a35:	31 c0                	xor    %eax,%eax
    return LV_RES_INV;
  116a37:	0f b6 c0             	movzbl %al,%eax
  116a3a:	83 c4 20             	add    $0x20,%esp
  116a3d:	5e                   	pop    %esi
  116a3e:	5f                   	pop    %edi
  116a3f:	5b                   	pop    %ebx
  116a40:	5d                   	pop    %ebp
  116a41:	c3                   	ret    
  116a42:	66 90                	xchg   %ax,%ax
  116a44:	66 90                	xchg   %ax,%ax
  116a46:	66 90                	xchg   %ax,%ax
  116a48:	66 90                	xchg   %ax,%ax
  116a4a:	66 90                	xchg   %ax,%ax
  116a4c:	66 90                	xchg   %ax,%ax
  116a4e:	66 90                	xchg   %ax,%ax

00116a50 <lv_img_decoder_built_in_line_alpha>:
#endif
}

static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{
  116a50:	55                   	push   %ebp
  116a51:	89 e5                	mov    %esp,%ebp
  116a53:	53                   	push   %ebx
  116a54:	57                   	push   %edi
  116a55:	56                   	push   %esi
  116a56:	83 e4 f8             	and    $0xfffffff8,%esp
  116a59:	83 ec 60             	sub    $0x60,%esp
  116a5c:	8b 45 18             	mov    0x18(%ebp),%eax
  116a5f:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  116a63:	66 8b 55 10          	mov    0x10(%ebp),%dx
  116a67:	66 8b 75 0c          	mov    0xc(%ebp),%si
  116a6b:	8b 7d 08             	mov    0x8(%ebp),%edi

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
  116a6e:	66 8b 1d 12 44 12 00 	mov    0x124412,%bx
  116a75:	66 89 5c 24 59       	mov    %bx,0x59(%esp)
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
  116a7a:	8b 1d 14 44 12 00    	mov    0x124414,%ebx
  116a80:	89 5c 24 55          	mov    %ebx,0x55(%esp)
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
  116a84:	8b 1d a2 3f 12 00    	mov    0x123fa2,%ebx
  116a8a:	89 5c 24 45          	mov    %ebx,0x45(%esp)
  116a8e:	8b 1d a6 3f 12 00    	mov    0x123fa6,%ebx
  116a94:	89 5c 24 49          	mov    %ebx,0x49(%esp)
  116a98:	8b 1d aa 3f 12 00    	mov    0x123faa,%ebx
  116a9e:	89 5c 24 4d          	mov    %ebx,0x4d(%esp)
  116aa2:	8b 1d ae 3f 12 00    	mov    0x123fae,%ebx
  116aa8:	89 5c 24 51          	mov    %ebx,0x51(%esp)
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
  116aac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  116aaf:	8b 5b 08             	mov    0x8(%ebx),%ebx
  116ab2:	8b 5b 40             	mov    0x40(%ebx),%ebx
  116ab5:	89 5c 24 40          	mov    %ebx,0x40(%esp)
    lv_coord_t i;
    for(i = 0; i < len; i++) {
  116ab9:	66 c7 44 24 3e 00 00 	movw   $0x0,0x3e(%esp)
  116ac0:	0f bf 44 24 3e       	movswl 0x3e(%esp),%eax
  116ac5:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx
  116ac9:	39 c8                	cmp    %ecx,%eax
  116acb:	0f 8d 25 00 00 00    	jge    116af6 <lv_img_decoder_built_in_line_alpha+0xa6>
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
#elif LV_COLOR_DEPTH == 32
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
  116ad1:	8b 44 24 40          	mov    0x40(%esp),%eax
  116ad5:	8b 4d 18             	mov    0x18(%ebp),%ecx
  116ad8:	0f bf 54 24 3e       	movswl 0x3e(%esp),%edx
  116add:	c1 e2 02             	shl    $0x2,%edx
  116ae0:	89 04 11             	mov    %eax,(%ecx,%edx,1)
    for(i = 0; i < len; i++) {
  116ae3:	66 8b 44 24 3e       	mov    0x3e(%esp),%ax
  116ae8:	66 83 c0 01          	add    $0x1,%ax
  116aec:	66 89 44 24 3e       	mov    %ax,0x3e(%esp)
  116af1:	e9 ca ff ff ff       	jmp    116ac0 <lv_img_decoder_built_in_line_alpha+0x70>
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
  116af6:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
  116afd:	00 
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
  116afe:	8b 45 08             	mov    0x8(%ebp),%eax
  116b01:	8b 40 10             	mov    0x10(%eax),%eax
  116b04:	83 e0 1f             	and    $0x1f,%eax
  116b07:	89 e1                	mov    %esp,%ecx
  116b09:	89 01                	mov    %eax,(%ecx)
  116b0b:	e8 90 f3 ff ff       	call   115ea0 <lv_img_color_format_get_px_size>
  116b10:	88 44 24 37          	mov    %al,0x37(%esp)
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
  116b14:	8a 4c 24 37          	mov    0x37(%esp),%cl
  116b18:	ba 01 00 00 00       	mov    $0x1,%edx
  116b1d:	d3 e2                	shl    %cl,%edx
  116b1f:	4a                   	dec    %edx
  116b20:	66 89 54 24 34       	mov    %dx,0x34(%esp)

    lv_coord_t w = 0;
  116b25:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%esp)
    uint32_t ofs = 0;
  116b2c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  116b33:	00 
    int8_t pos   = 0;
  116b34:	c6 44 24 2b 00       	movb   $0x0,0x2b(%esp)
    switch(dsc->header.cf) {
  116b39:	8b 75 08             	mov    0x8(%ebp),%esi
  116b3c:	8b 76 10             	mov    0x10(%esi),%esi
  116b3f:	83 e6 1f             	and    $0x1f,%esi
  116b42:	83 c6 f5             	add    $0xfffffff5,%esi
  116b45:	89 f7                	mov    %esi,%edi
  116b47:	83 ef 03             	sub    $0x3,%edi
  116b4a:	89 74 24 18          	mov    %esi,0x18(%esp)
  116b4e:	0f 87 b6 01 00 00    	ja     116d0a <lv_img_decoder_built_in_line_alpha+0x2ba>
  116b54:	8b 44 24 18          	mov    0x18(%esp),%eax
  116b58:	8b 0c 85 70 36 12 00 	mov    0x123670(,%eax,4),%ecx
  116b5f:	ff e1                	jmp    *%ecx
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
  116b61:	8b 45 08             	mov    0x8(%ebp),%eax
  116b64:	8b 40 10             	mov    0x10(%eax),%eax
  116b67:	c1 e8 0a             	shr    $0xa,%eax
  116b6a:	25 ff 07 00 00       	and    $0x7ff,%eax
  116b6f:	c1 f8 03             	sar    $0x3,%eax
  116b72:	66 89 44 24 32       	mov    %ax,0x32(%esp)
            if(dsc->header.w & 0x7) w++;
  116b77:	8b 4d 08             	mov    0x8(%ebp),%ecx
  116b7a:	8b 49 10             	mov    0x10(%ecx),%ecx
  116b7d:	c1 e9 0a             	shr    $0xa,%ecx
  116b80:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  116b86:	83 e1 07             	and    $0x7,%ecx
  116b89:	83 f9 00             	cmp    $0x0,%ecx
  116b8c:	0f 84 0e 00 00 00    	je     116ba0 <lv_img_decoder_built_in_line_alpha+0x150>
  116b92:	66 8b 44 24 32       	mov    0x32(%esp),%ax
  116b97:	66 83 c0 01          	add    $0x1,%ax
  116b9b:	66 89 44 24 32       	mov    %ax,0x32(%esp)
  116ba0:	8d 44 24 59          	lea    0x59(%esp),%eax
            ofs += w * y + (x >> 3); /*First pixel*/
  116ba4:	0f bf 4c 24 32       	movswl 0x32(%esp),%ecx
  116ba9:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  116bad:	0f af ca             	imul   %edx,%ecx
  116bb0:	0f bf 55 0c          	movswl 0xc(%ebp),%edx
  116bb4:	c1 fa 03             	sar    $0x3,%edx
  116bb7:	01 d1                	add    %edx,%ecx
  116bb9:	03 4c 24 2c          	add    0x2c(%esp),%ecx
  116bbd:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
            pos       = 7 - (x & 0x7);
  116bc1:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  116bc5:	83 e1 07             	and    $0x7,%ecx
  116bc8:	ba 07 00 00 00       	mov    $0x7,%edx
  116bcd:	29 ca                	sub    %ecx,%edx
  116bcf:	88 54 24 2b          	mov    %dl,0x2b(%esp)
            opa_table = alpha1_opa_table;
  116bd3:	89 44 24 38          	mov    %eax,0x38(%esp)
            break;
  116bd7:	e9 2e 01 00 00       	jmp    116d0a <lv_img_decoder_built_in_line_alpha+0x2ba>
        case LV_IMG_CF_ALPHA_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
  116bdc:	8b 45 08             	mov    0x8(%ebp),%eax
  116bdf:	8b 40 10             	mov    0x10(%eax),%eax
  116be2:	c1 e8 0a             	shr    $0xa,%eax
  116be5:	25 ff 07 00 00       	and    $0x7ff,%eax
  116bea:	c1 f8 02             	sar    $0x2,%eax
  116bed:	66 89 44 24 32       	mov    %ax,0x32(%esp)
            if(dsc->header.w & 0x3) w++;
  116bf2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  116bf5:	8b 49 10             	mov    0x10(%ecx),%ecx
  116bf8:	c1 e9 0a             	shr    $0xa,%ecx
  116bfb:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  116c01:	83 e1 03             	and    $0x3,%ecx
  116c04:	83 f9 00             	cmp    $0x0,%ecx
  116c07:	0f 84 0e 00 00 00    	je     116c1b <lv_img_decoder_built_in_line_alpha+0x1cb>
  116c0d:	66 8b 44 24 32       	mov    0x32(%esp),%ax
  116c12:	66 83 c0 01          	add    $0x1,%ax
  116c16:	66 89 44 24 32       	mov    %ax,0x32(%esp)
  116c1b:	8d 44 24 55          	lea    0x55(%esp),%eax
            ofs += w * y + (x >> 2); /*First pixel*/
  116c1f:	0f bf 4c 24 32       	movswl 0x32(%esp),%ecx
  116c24:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  116c28:	0f af ca             	imul   %edx,%ecx
  116c2b:	0f bf 55 0c          	movswl 0xc(%ebp),%edx
  116c2f:	c1 fa 02             	sar    $0x2,%edx
  116c32:	01 d1                	add    %edx,%ecx
  116c34:	03 4c 24 2c          	add    0x2c(%esp),%ecx
  116c38:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
            pos       = 6 - ((x & 0x3) * 2);
  116c3c:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  116c40:	83 e1 03             	and    $0x3,%ecx
  116c43:	c1 e1 01             	shl    $0x1,%ecx
  116c46:	ba 06 00 00 00       	mov    $0x6,%edx
  116c4b:	29 ca                	sub    %ecx,%edx
  116c4d:	88 54 24 2b          	mov    %dl,0x2b(%esp)
            opa_table = alpha2_opa_table;
  116c51:	89 44 24 38          	mov    %eax,0x38(%esp)
            break;
  116c55:	e9 b0 00 00 00       	jmp    116d0a <lv_img_decoder_built_in_line_alpha+0x2ba>
        case LV_IMG_CF_ALPHA_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
  116c5a:	8b 45 08             	mov    0x8(%ebp),%eax
  116c5d:	8b 40 10             	mov    0x10(%eax),%eax
  116c60:	c1 e8 0a             	shr    $0xa,%eax
  116c63:	25 ff 07 00 00       	and    $0x7ff,%eax
  116c68:	c1 f8 01             	sar    $0x1,%eax
  116c6b:	66 89 44 24 32       	mov    %ax,0x32(%esp)
            if(dsc->header.w & 0x1) w++;
  116c70:	8b 4d 08             	mov    0x8(%ebp),%ecx
  116c73:	8b 49 10             	mov    0x10(%ecx),%ecx
  116c76:	c1 e9 0a             	shr    $0xa,%ecx
  116c79:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  116c7f:	83 e1 01             	and    $0x1,%ecx
  116c82:	83 f9 00             	cmp    $0x0,%ecx
  116c85:	0f 84 0e 00 00 00    	je     116c99 <lv_img_decoder_built_in_line_alpha+0x249>
  116c8b:	66 8b 44 24 32       	mov    0x32(%esp),%ax
  116c90:	66 83 c0 01          	add    $0x1,%ax
  116c94:	66 89 44 24 32       	mov    %ax,0x32(%esp)
  116c99:	8d 44 24 45          	lea    0x45(%esp),%eax
            ofs += w * y + (x >> 1); /*First pixel*/
  116c9d:	0f bf 4c 24 32       	movswl 0x32(%esp),%ecx
  116ca2:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  116ca6:	0f af ca             	imul   %edx,%ecx
  116ca9:	0f bf 55 0c          	movswl 0xc(%ebp),%edx
  116cad:	c1 fa 01             	sar    $0x1,%edx
  116cb0:	01 d1                	add    %edx,%ecx
  116cb2:	03 4c 24 2c          	add    0x2c(%esp),%ecx
  116cb6:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
            pos       = 4 - ((x & 0x1) * 4);
  116cba:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  116cbe:	83 e1 01             	and    $0x1,%ecx
  116cc1:	c1 e1 02             	shl    $0x2,%ecx
  116cc4:	ba 04 00 00 00       	mov    $0x4,%edx
  116cc9:	29 ca                	sub    %ecx,%edx
  116ccb:	88 54 24 2b          	mov    %dl,0x2b(%esp)
            opa_table = alpha4_opa_table;
  116ccf:	89 44 24 38          	mov    %eax,0x38(%esp)
            break;
  116cd3:	e9 32 00 00 00       	jmp    116d0a <lv_img_decoder_built_in_line_alpha+0x2ba>
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
  116cd8:	8b 45 08             	mov    0x8(%ebp),%eax
  116cdb:	8b 40 10             	mov    0x10(%eax),%eax
  116cde:	c1 e8 0a             	shr    $0xa,%eax
  116ce1:	25 ff 07 00 00       	and    $0x7ff,%eax
  116ce6:	66 89 44 24 32       	mov    %ax,0x32(%esp)
            ofs += w * y + x;  /*First pixel*/
  116ceb:	0f bf 4c 24 32       	movswl 0x32(%esp),%ecx
  116cf0:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  116cf4:	0f af ca             	imul   %edx,%ecx
  116cf7:	0f bf 55 0c          	movswl 0xc(%ebp),%edx
  116cfb:	01 d1                	add    %edx,%ecx
  116cfd:	03 4c 24 2c          	add    0x2c(%esp),%ecx
  116d01:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
            pos = 0;
  116d05:	c6 44 24 2b 00       	movb   $0x0,0x2b(%esp)
#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
  116d0a:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  116d11:	00 
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
  116d12:	8b 45 08             	mov    0x8(%ebp),%eax
  116d15:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  116d19:	83 f8 00             	cmp    $0x0,%eax
  116d1c:	0f 85 1e 00 00 00    	jne    116d40 <lv_img_decoder_built_in_line_alpha+0x2f0>
        const lv_img_dsc_t * img_dsc = dsc->src;
  116d22:	8b 45 08             	mov    0x8(%ebp),%eax
  116d25:	8b 40 04             	mov    0x4(%eax),%eax
  116d28:	89 44 24 20          	mov    %eax,0x20(%esp)

        data_tmp = img_dsc->data + ofs;
  116d2c:	8b 44 24 20          	mov    0x20(%esp),%eax
  116d30:	8b 40 08             	mov    0x8(%eax),%eax
  116d33:	03 44 24 2c          	add    0x2c(%esp),%eax
  116d37:	89 44 24 24          	mov    %eax,0x24(%esp)
    } else {
  116d3b:	e9 3a 00 00 00       	jmp    116d7a <lv_img_decoder_built_in_line_alpha+0x32a>
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
        lv_fs_read(user_data->f, fs_buf, w, NULL);
        data_tmp = fs_buf;
#else
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
  116d40:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  116d47:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  116d4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  116d51:	c7 44 24 08 63 02 00 	movl   $0x263,0x8(%esp)
  116d58:	00 
  116d59:	8d 05 72 43 12 00    	lea    0x124372,%eax
  116d5f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  116d63:	e8 d8 2c 00 00       	call   119a40 <lv_log_add>
        data_tmp = NULL; /*To avoid warnings*/
  116d68:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  116d6f:	00 
        return LV_RES_INV;
  116d70:	c6 44 24 5b 00       	movb   $0x0,0x5b(%esp)
  116d75:	e9 ec 00 00 00       	jmp    116e66 <lv_img_decoder_built_in_line_alpha+0x416>
#endif
    }

    uint8_t byte_act = 0;
  116d7a:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
    uint8_t val_act;
    for(i = 0; i < len; i++) {
  116d7f:	66 c7 44 24 3e 00 00 	movw   $0x0,0x3e(%esp)
  116d86:	0f bf 44 24 3e       	movswl 0x3e(%esp),%eax
  116d8b:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx
  116d8f:	39 c8                	cmp    %ecx,%eax
  116d91:	0f 8d ca 00 00 00    	jge    116e61 <lv_img_decoder_built_in_line_alpha+0x411>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
  116d97:	8b 44 24 24          	mov    0x24(%esp),%eax
  116d9b:	0f b6 4c 24 1f       	movzbl 0x1f(%esp),%ecx
  116da0:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  116da4:	0f b7 4c 24 34       	movzwl 0x34(%esp),%ecx
  116da9:	0f be 54 24 2b       	movsbl 0x2b(%esp),%edx
  116dae:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  116db2:	89 d1                	mov    %edx,%ecx
  116db4:	8b 54 24 14          	mov    0x14(%esp),%edx
  116db8:	d3 e2                	shl    %cl,%edx
  116dba:	21 d0                	and    %edx,%eax
  116dbc:	0f be 4c 24 2b       	movsbl 0x2b(%esp),%ecx
  116dc1:	d3 f8                	sar    %cl,%eax
  116dc3:	88 44 24 1e          	mov    %al,0x1e(%esp)

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
  116dc7:	8b 55 08             	mov    0x8(%ebp),%edx
  116dca:	8b 52 10             	mov    0x10(%edx),%edx
  116dcd:	83 e2 1f             	and    $0x1f,%edx
  116dd0:	83 fa 0e             	cmp    $0xe,%edx
  116dd3:	0f 85 0e 00 00 00    	jne    116de7 <lv_img_decoder_built_in_line_alpha+0x397>
  116dd9:	0f b6 44 24 1e       	movzbl 0x1e(%esp),%eax
  116dde:	89 44 24 10          	mov    %eax,0x10(%esp)
  116de2:	e9 11 00 00 00       	jmp    116df8 <lv_img_decoder_built_in_line_alpha+0x3a8>
  116de7:	8b 44 24 38          	mov    0x38(%esp),%eax
  116deb:	0f b6 4c 24 1e       	movzbl 0x1e(%esp),%ecx
  116df0:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  116df4:	89 44 24 10          	mov    %eax,0x10(%esp)
  116df8:	8b 44 24 10          	mov    0x10(%esp),%eax
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
  116dfc:	8b 4d 18             	mov    0x18(%ebp),%ecx
  116dff:	0f bf 54 24 3e       	movswl 0x3e(%esp),%edx
  116e04:	c1 e2 02             	shl    $0x2,%edx
  116e07:	83 c2 04             	add    $0x4,%edx
  116e0a:	83 ea 01             	sub    $0x1,%edx
  116e0d:	88 04 11             	mov    %al,(%ecx,%edx,1)

        pos -= px_size;
  116e10:	0f b6 4c 24 37       	movzbl 0x37(%esp),%ecx
  116e15:	0f be 54 24 2b       	movsbl 0x2b(%esp),%edx
  116e1a:	29 ca                	sub    %ecx,%edx
  116e1c:	88 54 24 2b          	mov    %dl,0x2b(%esp)
        if(pos < 0) {
  116e20:	0f be 4c 24 2b       	movsbl 0x2b(%esp),%ecx
  116e25:	83 f9 00             	cmp    $0x0,%ecx
  116e28:	0f 8d 1b 00 00 00    	jge    116e49 <lv_img_decoder_built_in_line_alpha+0x3f9>
            pos = 8 - px_size;
  116e2e:	0f b6 44 24 37       	movzbl 0x37(%esp),%eax
  116e33:	b9 08 00 00 00       	mov    $0x8,%ecx
  116e38:	29 c1                	sub    %eax,%ecx
  116e3a:	88 4c 24 2b          	mov    %cl,0x2b(%esp)
            data_tmp++;
  116e3e:	8b 44 24 24          	mov    0x24(%esp),%eax
  116e42:	83 c0 01             	add    $0x1,%eax
  116e45:	89 44 24 24          	mov    %eax,0x24(%esp)
        }
    }
  116e49:	e9 00 00 00 00       	jmp    116e4e <lv_img_decoder_built_in_line_alpha+0x3fe>
    for(i = 0; i < len; i++) {
  116e4e:	66 8b 44 24 3e       	mov    0x3e(%esp),%ax
  116e53:	66 83 c0 01          	add    $0x1,%ax
  116e57:	66 89 44 24 3e       	mov    %ax,0x3e(%esp)
  116e5c:	e9 25 ff ff ff       	jmp    116d86 <lv_img_decoder_built_in_line_alpha+0x336>

    return LV_RES_OK;
  116e61:	c6 44 24 5b 01       	movb   $0x1,0x5b(%esp)

#else
    LV_LOG_WARN("Image built-in alpha line reader failed because LV_IMG_CF_ALPHA is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
  116e66:	0f b6 44 24 5b       	movzbl 0x5b(%esp),%eax
  116e6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  116e6e:	5e                   	pop    %esi
  116e6f:	5f                   	pop    %edi
  116e70:	5b                   	pop    %ebx
  116e71:	5d                   	pop    %ebp
  116e72:	c3                   	ret    
  116e73:	66 90                	xchg   %ax,%ax
  116e75:	66 90                	xchg   %ax,%ax
  116e77:	66 90                	xchg   %ax,%ax
  116e79:	66 90                	xchg   %ax,%ax
  116e7b:	66 90                	xchg   %ax,%ax
  116e7d:	66 90                	xchg   %ax,%ax
  116e7f:	90                   	nop

00116e80 <lv_img_decoder_built_in_line_indexed>:

static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{
  116e80:	55                   	push   %ebp
  116e81:	89 e5                	mov    %esp,%ebp
  116e83:	53                   	push   %ebx
  116e84:	57                   	push   %edi
  116e85:	56                   	push   %esi
  116e86:	83 ec 48             	sub    $0x48,%esp
  116e89:	8b 45 18             	mov    0x18(%ebp),%eax
  116e8c:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  116e90:	66 8b 55 10          	mov    0x10(%ebp),%dx
  116e94:	66 8b 75 0c          	mov    0xc(%ebp),%si
  116e98:	8b 7d 08             	mov    0x8(%ebp),%edi

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
  116e9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  116e9e:	8b 5b 10             	mov    0x10(%ebx),%ebx
  116ea1:	83 e3 1f             	and    $0x1f,%ebx
  116ea4:	89 45 d0             	mov    %eax,-0x30(%ebp)
  116ea7:	89 e0                	mov    %esp,%eax
  116ea9:	89 18                	mov    %ebx,(%eax)
  116eab:	66 89 4d ce          	mov    %cx,-0x32(%ebp)
  116eaf:	66 89 55 cc          	mov    %dx,-0x34(%ebp)
  116eb3:	66 89 75 ca          	mov    %si,-0x36(%ebp)
  116eb7:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  116eba:	e8 e1 ef ff ff       	call   115ea0 <lv_img_color_format_get_px_size>
  116ebf:	88 45 f2             	mov    %al,-0xe(%ebp)
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
  116ec2:	8a 4d f2             	mov    -0xe(%ebp),%cl
  116ec5:	bf 01 00 00 00       	mov    $0x1,%edi
  116eca:	d3 e7                	shl    %cl,%edi
  116ecc:	4f                   	dec    %edi
  116ecd:	66 89 7d f0          	mov    %di,-0x10(%ebp)

    lv_coord_t w = 0;
  116ed1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    int8_t pos   = 0;
  116ed7:	c6 45 ed 00          	movb   $0x0,-0x13(%ebp)
    uint32_t ofs = 0;
  116edb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    switch(dsc->header.cf) {
  116ee2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  116ee5:	8b 5b 10             	mov    0x10(%ebx),%ebx
  116ee8:	83 e3 1f             	and    $0x1f,%ebx
  116eeb:	83 c3 f9             	add    $0xfffffff9,%ebx
  116eee:	89 d8                	mov    %ebx,%eax
  116ef0:	83 e8 03             	sub    $0x3,%eax
  116ef3:	89 5d c0             	mov    %ebx,-0x40(%ebp)
  116ef6:	0f 87 aa 01 00 00    	ja     1170a6 <lv_img_decoder_built_in_line_indexed+0x226>
  116efc:	8b 45 c0             	mov    -0x40(%ebp),%eax
  116eff:	8b 0c 85 80 36 12 00 	mov    0x123680(,%eax,4),%ecx
  116f06:	ff e1                	jmp    *%ecx
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
  116f08:	8b 45 08             	mov    0x8(%ebp),%eax
  116f0b:	8b 40 10             	mov    0x10(%eax),%eax
  116f0e:	c1 e8 0a             	shr    $0xa,%eax
  116f11:	25 ff 07 00 00       	and    $0x7ff,%eax
  116f16:	c1 f8 03             	sar    $0x3,%eax
  116f19:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            if(dsc->header.w & 0x7) w++;
  116f1d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  116f20:	8b 49 10             	mov    0x10(%ecx),%ecx
  116f23:	c1 e9 0a             	shr    $0xa,%ecx
  116f26:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  116f2c:	83 e1 07             	and    $0x7,%ecx
  116f2f:	83 f9 00             	cmp    $0x0,%ecx
  116f32:	0f 84 0c 00 00 00    	je     116f44 <lv_img_decoder_built_in_line_indexed+0xc4>
  116f38:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  116f3c:	66 83 c0 01          	add    $0x1,%ax
  116f40:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            ofs += w * y + (x >> 3); /*First pixel*/
  116f44:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
  116f48:	0f bf 4d 10          	movswl 0x10(%ebp),%ecx
  116f4c:	0f af c1             	imul   %ecx,%eax
  116f4f:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  116f53:	c1 f9 03             	sar    $0x3,%ecx
  116f56:	01 c8                	add    %ecx,%eax
  116f58:	03 45 e8             	add    -0x18(%ebp),%eax
  116f5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
            ofs += 8;                /*Skip the palette*/
  116f5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  116f61:	83 c0 08             	add    $0x8,%eax
  116f64:	89 45 e8             	mov    %eax,-0x18(%ebp)
            pos = 7 - (x & 0x7);
  116f67:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  116f6b:	83 e0 07             	and    $0x7,%eax
  116f6e:	b9 07 00 00 00       	mov    $0x7,%ecx
  116f73:	29 c1                	sub    %eax,%ecx
  116f75:	88 4d ed             	mov    %cl,-0x13(%ebp)
            break;
  116f78:	e9 29 01 00 00       	jmp    1170a6 <lv_img_decoder_built_in_line_indexed+0x226>
        case LV_IMG_CF_INDEXED_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
  116f7d:	8b 45 08             	mov    0x8(%ebp),%eax
  116f80:	8b 40 10             	mov    0x10(%eax),%eax
  116f83:	c1 e8 0a             	shr    $0xa,%eax
  116f86:	25 ff 07 00 00       	and    $0x7ff,%eax
  116f8b:	c1 f8 02             	sar    $0x2,%eax
  116f8e:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            if(dsc->header.w & 0x3) w++;
  116f92:	8b 4d 08             	mov    0x8(%ebp),%ecx
  116f95:	8b 49 10             	mov    0x10(%ecx),%ecx
  116f98:	c1 e9 0a             	shr    $0xa,%ecx
  116f9b:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  116fa1:	83 e1 03             	and    $0x3,%ecx
  116fa4:	83 f9 00             	cmp    $0x0,%ecx
  116fa7:	0f 84 0c 00 00 00    	je     116fb9 <lv_img_decoder_built_in_line_indexed+0x139>
  116fad:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  116fb1:	66 83 c0 01          	add    $0x1,%ax
  116fb5:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            ofs += w * y + (x >> 2); /*First pixel*/
  116fb9:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
  116fbd:	0f bf 4d 10          	movswl 0x10(%ebp),%ecx
  116fc1:	0f af c1             	imul   %ecx,%eax
  116fc4:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  116fc8:	c1 f9 02             	sar    $0x2,%ecx
  116fcb:	01 c8                	add    %ecx,%eax
  116fcd:	03 45 e8             	add    -0x18(%ebp),%eax
  116fd0:	89 45 e8             	mov    %eax,-0x18(%ebp)
            ofs += 16;               /*Skip the palette*/
  116fd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  116fd6:	83 c0 10             	add    $0x10,%eax
  116fd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
            pos = 6 - ((x & 0x3) * 2);
  116fdc:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  116fe0:	83 e0 03             	and    $0x3,%eax
  116fe3:	c1 e0 01             	shl    $0x1,%eax
  116fe6:	b9 06 00 00 00       	mov    $0x6,%ecx
  116feb:	29 c1                	sub    %eax,%ecx
  116fed:	88 4d ed             	mov    %cl,-0x13(%ebp)
            break;
  116ff0:	e9 b1 00 00 00       	jmp    1170a6 <lv_img_decoder_built_in_line_indexed+0x226>
        case LV_IMG_CF_INDEXED_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
  116ff5:	8b 45 08             	mov    0x8(%ebp),%eax
  116ff8:	8b 40 10             	mov    0x10(%eax),%eax
  116ffb:	c1 e8 0a             	shr    $0xa,%eax
  116ffe:	25 ff 07 00 00       	and    $0x7ff,%eax
  117003:	c1 f8 01             	sar    $0x1,%eax
  117006:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            if(dsc->header.w & 0x1) w++;
  11700a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11700d:	8b 49 10             	mov    0x10(%ecx),%ecx
  117010:	c1 e9 0a             	shr    $0xa,%ecx
  117013:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  117019:	83 e1 01             	and    $0x1,%ecx
  11701c:	83 f9 00             	cmp    $0x0,%ecx
  11701f:	0f 84 0c 00 00 00    	je     117031 <lv_img_decoder_built_in_line_indexed+0x1b1>
  117025:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  117029:	66 83 c0 01          	add    $0x1,%ax
  11702d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            ofs += w * y + (x >> 1); /*First pixel*/
  117031:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
  117035:	0f bf 4d 10          	movswl 0x10(%ebp),%ecx
  117039:	0f af c1             	imul   %ecx,%eax
  11703c:	0f bf 4d 0c          	movswl 0xc(%ebp),%ecx
  117040:	c1 f9 01             	sar    $0x1,%ecx
  117043:	01 c8                	add    %ecx,%eax
  117045:	03 45 e8             	add    -0x18(%ebp),%eax
  117048:	89 45 e8             	mov    %eax,-0x18(%ebp)
            ofs += 64;               /*Skip the palette*/
  11704b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11704e:	83 c0 40             	add    $0x40,%eax
  117051:	89 45 e8             	mov    %eax,-0x18(%ebp)
            pos = 4 - ((x & 0x1) * 4);
  117054:	0f bf 45 0c          	movswl 0xc(%ebp),%eax
  117058:	83 e0 01             	and    $0x1,%eax
  11705b:	c1 e0 02             	shl    $0x2,%eax
  11705e:	b9 04 00 00 00       	mov    $0x4,%ecx
  117063:	29 c1                	sub    %eax,%ecx
  117065:	88 4d ed             	mov    %cl,-0x13(%ebp)
            break;
  117068:	e9 39 00 00 00       	jmp    1170a6 <lv_img_decoder_built_in_line_indexed+0x226>
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
  11706d:	8b 45 08             	mov    0x8(%ebp),%eax
  117070:	8b 40 10             	mov    0x10(%eax),%eax
  117073:	c1 e8 0a             	shr    $0xa,%eax
  117076:	25 ff 07 00 00       	and    $0x7ff,%eax
  11707b:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
            ofs += w * y + x;  /*First pixel*/
  11707f:	0f bf 4d ee          	movswl -0x12(%ebp),%ecx
  117083:	0f bf 55 10          	movswl 0x10(%ebp),%edx
  117087:	0f af ca             	imul   %edx,%ecx
  11708a:	0f bf 55 0c          	movswl 0xc(%ebp),%edx
  11708e:	01 d1                	add    %edx,%ecx
  117090:	03 4d e8             	add    -0x18(%ebp),%ecx
  117093:	89 4d e8             	mov    %ecx,-0x18(%ebp)
            ofs += 1024;       /*Skip the palette*/
  117096:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  117099:	81 c1 00 04 00 00    	add    $0x400,%ecx
  11709f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
            pos = 0;
  1170a2:	c6 45 ed 00          	movb   $0x0,-0x13(%ebp)
            break;
    }

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
  1170a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1170a9:	8b 40 20             	mov    0x20(%eax),%eax
  1170ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)

#if LV_USE_FILESYSTEM
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif
    const uint8_t * data_tmp = NULL;
  1170af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
  1170b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1170b9:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1170bd:	83 f8 00             	cmp    $0x0,%eax
  1170c0:	0f 85 1a 00 00 00    	jne    1170e0 <lv_img_decoder_built_in_line_indexed+0x260>
        const lv_img_dsc_t * img_dsc = dsc->src;
  1170c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1170c9:	8b 40 04             	mov    0x4(%eax),%eax
  1170cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
        data_tmp                     = img_dsc->data + ofs;
  1170cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1170d2:	8b 40 08             	mov    0x8(%eax),%eax
  1170d5:	03 45 e8             	add    -0x18(%ebp),%eax
  1170d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    } else {
  1170db:	e9 38 00 00 00       	jmp    117118 <lv_img_decoder_built_in_line_indexed+0x298>
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
        lv_fs_read(user_data->f, fs_buf, w, NULL);
        data_tmp = fs_buf;
#else
        LV_LOG_WARN("Image built-in indexed line reader can't read file because LV_USE_FILESYSTEM = 0");
  1170e0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1170e7:	8d 05 c1 41 12 00    	lea    0x1241c1,%eax
  1170ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  1170f1:	c7 44 24 08 b8 02 00 	movl   $0x2b8,0x8(%esp)
  1170f8:	00 
  1170f9:	8d 05 c1 43 12 00    	lea    0x1243c1,%eax
  1170ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
  117103:	e8 38 29 00 00       	call   119a40 <lv_log_add>
        data_tmp = NULL; /*To avoid warnings*/
  117108:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        return LV_RES_INV;
  11710f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  117113:	e9 ab 00 00 00       	jmp    1171c3 <lv_img_decoder_built_in_line_indexed+0x343>
#endif
    }

    uint8_t byte_act = 0;
  117118:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
    uint8_t val_act;
    lv_coord_t i;
    lv_color_t * cbuf = (lv_color_t *)buf;
  11711c:	8b 45 18             	mov    0x18(%ebp),%eax
  11711f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    for(i = 0; i < len; i++) {
  117122:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%ebp)
  117128:	0f bf 45 d8          	movswl -0x28(%ebp),%eax
  11712c:	0f bf 4d 14          	movswl 0x14(%ebp),%ecx
  117130:	39 c8                	cmp    %ecx,%eax
  117132:	0f 8d 87 00 00 00    	jge    1171bf <lv_img_decoder_built_in_line_indexed+0x33f>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
  117138:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11713b:	0f b6 4d db          	movzbl -0x25(%ebp),%ecx
  11713f:	0f b6 04 08          	movzbl (%eax,%ecx,1),%eax
  117143:	0f b7 4d f0          	movzwl -0x10(%ebp),%ecx
  117147:	0f be 55 ed          	movsbl -0x13(%ebp),%edx
  11714b:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  11714e:	89 d1                	mov    %edx,%ecx
  117150:	8b 55 bc             	mov    -0x44(%ebp),%edx
  117153:	d3 e2                	shl    %cl,%edx
  117155:	21 d0                	and    %edx,%eax
  117157:	0f be 4d ed          	movsbl -0x13(%ebp),%ecx
  11715b:	d3 f8                	sar    %cl,%eax
  11715d:	88 45 da             	mov    %al,-0x26(%ebp)
        cbuf[i] = user_data->palette[val_act];
  117160:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  117163:	0f bf 75 d8          	movswl -0x28(%ebp),%esi
  117167:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  11716a:	8b 3f                	mov    (%edi),%edi
  11716c:	0f b6 5d da          	movzbl -0x26(%ebp),%ebx
  117170:	8b 3c 9f             	mov    (%edi,%ebx,4),%edi
  117173:	89 3c b2             	mov    %edi,(%edx,%esi,4)

        pos -= px_size;
  117176:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
  11717a:	0f be 75 ed          	movsbl -0x13(%ebp),%esi
  11717e:	89 f3                	mov    %esi,%ebx
  117180:	29 d3                	sub    %edx,%ebx
  117182:	88 5d ed             	mov    %bl,-0x13(%ebp)
        if(pos < 0) {
  117185:	0f be 55 ed          	movsbl -0x13(%ebp),%edx
  117189:	83 fa 00             	cmp    $0x0,%edx
  11718c:	0f 8d 17 00 00 00    	jge    1171a9 <lv_img_decoder_built_in_line_indexed+0x329>
            pos = 8 - px_size;
  117192:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
  117196:	b9 08 00 00 00       	mov    $0x8,%ecx
  11719b:	29 c1                	sub    %eax,%ecx
  11719d:	88 4d ed             	mov    %cl,-0x13(%ebp)
            data_tmp++;
  1171a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1171a3:	83 c0 01             	add    $0x1,%eax
  1171a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
        }
    }
  1171a9:	e9 00 00 00 00       	jmp    1171ae <lv_img_decoder_built_in_line_indexed+0x32e>
    for(i = 0; i < len; i++) {
  1171ae:	66 8b 45 d8          	mov    -0x28(%ebp),%ax
  1171b2:	66 83 c0 01          	add    $0x1,%ax
  1171b6:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  1171ba:	e9 69 ff ff ff       	jmp    117128 <lv_img_decoder_built_in_line_indexed+0x2a8>

    return LV_RES_OK;
  1171bf:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
#else
    LV_LOG_WARN("Image built-in indexed line reader failed because LV_IMG_CF_INDEXED is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
  1171c3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  1171c7:	83 c4 48             	add    $0x48,%esp
  1171ca:	5e                   	pop    %esi
  1171cb:	5f                   	pop    %edi
  1171cc:	5b                   	pop    %ebx
  1171cd:	5d                   	pop    %ebp
  1171ce:	c3                   	ret    
  1171cf:	90                   	nop

001171d0 <lv_img_cache_set_size>:
 * More cached images mean more opened image at same time which might mean more memory usage.
 * E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache.
 * @param new_entry_cnt number of image to cache
 */
void lv_img_cache_set_size(uint16_t new_entry_cnt)
{
  1171d0:	55                   	push   %ebp
  1171d1:	89 e5                	mov    %esp,%ebp
  1171d3:	56                   	push   %esi
  1171d4:	83 ec 24             	sub    $0x24,%esp
  1171d7:	66 8b 45 08          	mov    0x8(%ebp),%ax
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
  1171db:	83 3d ac 55 13 00 00 	cmpl   $0x0,0x1355ac
  1171e2:	0f 84 1e 00 00 00    	je     117206 <lv_img_cache_set_size+0x36>
  1171e8:	31 c0                	xor    %eax,%eax
        /*Clean the cache before free it*/
        lv_img_cache_invalidate_src(NULL);
  1171ea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1171f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1171f4:	e8 17 01 00 00       	call   117310 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
  1171f9:	a1 ac 55 13 00       	mov    0x1355ac,%eax
  1171fe:	89 04 24             	mov    %eax,(%esp)
  117201:	e8 5a 16 00 00       	call   118860 <lv_mem_free>
    }

    /*Reallocate the cache*/
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
  117206:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  11720a:	6b c0 28             	imul   $0x28,%eax,%eax
  11720d:	89 04 24             	mov    %eax,(%esp)
  117210:	e8 4b 15 00 00       	call   118760 <lv_mem_alloc>
  117215:	a3 ac 55 13 00       	mov    %eax,0x1355ac
    lv_mem_assert(LV_GC_ROOT(_lv_img_cache_array));
  11721a:	83 3d ac 55 13 00 00 	cmpl   $0x0,0x1355ac
  117221:	0f 85 2d 00 00 00    	jne    117254 <lv_img_cache_set_size+0x84>
  117227:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11722e:	8d 05 18 44 12 00    	lea    0x124418,%eax
  117234:	89 44 24 04          	mov    %eax,0x4(%esp)
  117238:	c7 44 24 08 9b 00 00 	movl   $0x9b,0x8(%esp)
  11723f:	00 
  117240:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  117246:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11724a:	e8 f1 27 00 00       	call   119a40 <lv_log_add>
  11724f:	e9 fb ff ff ff       	jmp    11724f <lv_img_cache_set_size+0x7f>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
  117254:	83 3d ac 55 13 00 00 	cmpl   $0x0,0x1355ac
  11725b:	0f 85 0e 00 00 00    	jne    11726f <lv_img_cache_set_size+0x9f>
        entry_cnt = 0;
  117261:	66 c7 05 e4 96 13 00 	movw   $0x0,0x1396e4
  117268:	00 00 
        return;
  11726a:	e9 8f 00 00 00       	jmp    1172fe <lv_img_cache_set_size+0x12e>
    }
    entry_cnt = new_entry_cnt;
  11726f:	66 8b 45 08          	mov    0x8(%ebp),%ax
  117273:	66 a3 e4 96 13 00    	mov    %ax,0x1396e4

    /*Clean the cache*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
  117279:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%ebp)
  11727f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  117283:	0f b7 0d e4 96 13 00 	movzwl 0x1396e4,%ecx
  11728a:	39 c8                	cmp    %ecx,%eax
  11728c:	0f 8d 6c 00 00 00    	jge    1172fe <lv_img_cache_set_size+0x12e>
  117292:	31 c0                	xor    %eax,%eax
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
  117294:	8b 0d ac 55 13 00    	mov    0x1355ac,%ecx
  11729a:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
  11729e:	6b d2 28             	imul   $0x28,%edx,%edx
  1172a1:	01 d1                	add    %edx,%ecx
  1172a3:	89 0c 24             	mov    %ecx,(%esp)
  1172a6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1172ad:	00 
  1172ae:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  1172b5:	00 
  1172b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1172b9:	e8 b2 31 ff ff       	call   10a470 <memset>
  1172be:	31 c9                	xor    %ecx,%ecx
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
  1172c0:	8b 15 ac 55 13 00    	mov    0x1355ac,%edx
  1172c6:	0f b7 75 fa          	movzwl -0x6(%ebp),%esi
  1172ca:	6b f6 28             	imul   $0x28,%esi,%esi
  1172cd:	01 f2                	add    %esi,%edx
  1172cf:	89 14 24             	mov    %edx,(%esp)
  1172d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1172d9:	00 
  1172da:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
  1172e1:	00 
  1172e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1172e5:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1172e8:	e8 83 31 ff ff       	call   10a470 <memset>
    for(i = 0; i < entry_cnt; i++) {
  1172ed:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
  1172f1:	66 83 c0 01          	add    $0x1,%ax
  1172f5:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  1172f9:	e9 81 ff ff ff       	jmp    11727f <lv_img_cache_set_size+0xaf>
    }
}
  1172fe:	83 c4 24             	add    $0x24,%esp
  117301:	5e                   	pop    %esi
  117302:	5d                   	pop    %ebp
  117303:	c3                   	ret    
  117304:	66 90                	xchg   %ax,%ax
  117306:	66 90                	xchg   %ax,%ax
  117308:	66 90                	xchg   %ax,%ax
  11730a:	66 90                	xchg   %ax,%ax
  11730c:	66 90                	xchg   %ax,%ax
  11730e:	66 90                	xchg   %ax,%ax

00117310 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
  117310:	55                   	push   %ebp
  117311:	89 e5                	mov    %esp,%ebp
  117313:	56                   	push   %esi
  117314:	83 ec 20             	sub    $0x20,%esp
  117317:	8b 45 08             	mov    0x8(%ebp),%eax

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
  11731a:	8b 0d ac 55 13 00    	mov    0x1355ac,%ecx
  117320:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
  117323:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
  117329:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  11732d:	0f b7 0d e4 96 13 00 	movzwl 0x1396e4,%ecx
  117334:	39 c8                	cmp    %ecx,%eax
  117336:	0f 8d b7 00 00 00    	jge    1173f3 <lv_img_cache_invalidate_src+0xe3>
        if(cache[i].dec_dsc.src == src || src == NULL) {
  11733c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11733f:	0f b7 4d f6          	movzwl -0xa(%ebp),%ecx
  117343:	6b c9 28             	imul   $0x28,%ecx,%ecx
  117346:	01 c8                	add    %ecx,%eax
  117348:	8b 40 04             	mov    0x4(%eax),%eax
  11734b:	3b 45 08             	cmp    0x8(%ebp),%eax
  11734e:	0f 84 0a 00 00 00    	je     11735e <lv_img_cache_invalidate_src+0x4e>
  117354:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  117358:	0f 85 7f 00 00 00    	jne    1173dd <lv_img_cache_invalidate_src+0xcd>
            if(cache[i].dec_dsc.src != NULL) {
  11735e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  117361:	0f b7 4d f6          	movzwl -0xa(%ebp),%ecx
  117365:	6b c9 28             	imul   $0x28,%ecx,%ecx
  117368:	01 c8                	add    %ecx,%eax
  11736a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11736e:	0f 84 14 00 00 00    	je     117388 <lv_img_cache_invalidate_src+0x78>
                lv_img_decoder_close(&cache[i].dec_dsc);
  117374:	8b 45 f8             	mov    -0x8(%ebp),%eax
  117377:	0f b7 4d f6          	movzwl -0xa(%ebp),%ecx
  11737b:	6b c9 28             	imul   $0x28,%ecx,%ecx
  11737e:	01 c8                	add    %ecx,%eax
  117380:	89 04 24             	mov    %eax,(%esp)
  117383:	e8 d8 f5 ff ff       	call   116960 <lv_img_decoder_close>
  117388:	31 c0                	xor    %eax,%eax
            }

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
  11738a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11738d:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
  117391:	6b d2 28             	imul   $0x28,%edx,%edx
  117394:	01 d1                	add    %edx,%ecx
  117396:	89 0c 24             	mov    %ecx,(%esp)
  117399:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173a0:	00 
  1173a1:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  1173a8:	00 
  1173a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1173ac:	e8 bf 30 ff ff       	call   10a470 <memset>
  1173b1:	31 c9                	xor    %ecx,%ecx
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
  1173b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1173b6:	0f b7 75 f6          	movzwl -0xa(%ebp),%esi
  1173ba:	6b f6 28             	imul   $0x28,%esi,%esi
  1173bd:	01 f2                	add    %esi,%edx
  1173bf:	89 14 24             	mov    %edx,(%esp)
  1173c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1173c9:	00 
  1173ca:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
  1173d1:	00 
  1173d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1173d5:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1173d8:	e8 93 30 ff ff       	call   10a470 <memset>
        }
    }
  1173dd:	e9 00 00 00 00       	jmp    1173e2 <lv_img_cache_invalidate_src+0xd2>
    for(i = 0; i < entry_cnt; i++) {
  1173e2:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
  1173e6:	66 83 c0 01          	add    $0x1,%ax
  1173ea:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  1173ee:	e9 36 ff ff ff       	jmp    117329 <lv_img_cache_invalidate_src+0x19>
}
  1173f3:	83 c4 20             	add    $0x20,%esp
  1173f6:	5e                   	pop    %esi
  1173f7:	5d                   	pop    %ebp
  1173f8:	c3                   	ret    
  1173f9:	66 90                	xchg   %ax,%ax
  1173fb:	66 90                	xchg   %ax,%ax
  1173fd:	66 90                	xchg   %ax,%ax
  1173ff:	90                   	nop

00117400 <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
  117400:	55                   	push   %ebp
  117401:	89 e5                	mov    %esp,%ebp
  117403:	53                   	push   %ebx
  117404:	83 e4 f8             	and    $0xfffffff8,%esp
  117407:	83 ec 20             	sub    $0x20,%esp
  11740a:	8b 45 08             	mov    0x8(%ebp),%eax
  11740d:	31 c9                	xor    %ecx,%ecx
    memset(driver, 0, sizeof(lv_disp_drv_t));
  11740f:	8b 55 08             	mov    0x8(%ebp),%edx
  117412:	89 14 24             	mov    %edx,(%esp)
  117415:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11741c:	00 
  11741d:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  117424:	00 
  117425:	89 44 24 14          	mov    %eax,0x14(%esp)
  117429:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11742d:	e8 3e 30 ff ff       	call   10a470 <memset>

    driver->flush_cb         = NULL;
  117432:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117435:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
    driver->hor_res          = LV_HOR_RES_MAX;
  11743c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11743f:	66 c7 01 40 01       	movw   $0x140,(%ecx)
    driver->ver_res          = LV_VER_RES_MAX;
  117444:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117447:	66 c7 41 02 f0 00    	movw   $0xf0,0x2(%ecx)
    driver->buffer           = NULL;
  11744d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117450:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
    driver->rotated          = 0;
  117457:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11745a:	8a 59 08             	mov    0x8(%ecx),%bl
  11745d:	80 e3 fe             	and    $0xfe,%bl
  117460:	88 59 08             	mov    %bl,0x8(%ecx)
    driver->color_chroma_key = LV_COLOR_TRANSP;
  117463:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117466:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
  11746b:	c6 44 24 19 ff       	movb   $0xff,0x19(%esp)
  117470:	c6 44 24 1a 00       	movb   $0x0,0x1a(%esp)
  117475:	c6 44 24 1b ff       	movb   $0xff,0x1b(%esp)
  11747a:	8b 54 24 18          	mov    0x18(%esp),%edx
  11747e:	89 51 1c             	mov    %edx,0x1c(%ecx)
    driver->gpu_blend_cb = NULL;
    driver->gpu_fill_cb  = NULL;
#endif

#if LV_USE_USER_DATA
    driver->user_data = NULL;
  117481:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117484:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
#endif

    driver->set_px_cb = NULL;
  11748b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11748e:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
}
  117495:	8d 65 fc             	lea    -0x4(%ebp),%esp
  117498:	5b                   	pop    %ebx
  117499:	5d                   	pop    %ebp
  11749a:	c3                   	ret    
  11749b:	66 90                	xchg   %ax,%ax
  11749d:	66 90                	xchg   %ax,%ax
  11749f:	90                   	nop

001174a0 <lv_disp_buf_init>:
 *             It lets LittlevGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
  1174a0:	55                   	push   %ebp
  1174a1:	89 e5                	mov    %esp,%ebp
  1174a3:	53                   	push   %ebx
  1174a4:	57                   	push   %edi
  1174a5:	56                   	push   %esi
  1174a6:	83 ec 20             	sub    $0x20,%esp
  1174a9:	8b 45 14             	mov    0x14(%ebp),%eax
  1174ac:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1174af:	8b 55 0c             	mov    0xc(%ebp),%edx
  1174b2:	8b 75 08             	mov    0x8(%ebp),%esi
  1174b5:	31 ff                	xor    %edi,%edi
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
  1174b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1174ba:	89 1c 24             	mov    %ebx,(%esp)
  1174bd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1174c4:	00 
  1174c5:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  1174cc:	00 
  1174cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1174d0:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1174d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1174d6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  1174d9:	89 7d e0             	mov    %edi,-0x20(%ebp)
  1174dc:	e8 8f 2f ff ff       	call   10a470 <memset>

    disp_buf->buf1    = buf1;
  1174e1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1174e4:	8b 55 08             	mov    0x8(%ebp),%edx
  1174e7:	89 0a                	mov    %ecx,(%edx)
    disp_buf->buf2    = buf2;
  1174e9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1174ec:	8b 55 08             	mov    0x8(%ebp),%edx
  1174ef:	89 4a 04             	mov    %ecx,0x4(%edx)
    disp_buf->buf_act = disp_buf->buf1;
  1174f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1174f5:	8b 09                	mov    (%ecx),%ecx
  1174f7:	8b 55 08             	mov    0x8(%ebp),%edx
  1174fa:	89 4a 08             	mov    %ecx,0x8(%edx)
    disp_buf->size    = size_in_px_cnt;
  1174fd:	8b 4d 14             	mov    0x14(%ebp),%ecx
  117500:	8b 55 08             	mov    0x8(%ebp),%edx
  117503:	89 4a 0c             	mov    %ecx,0xc(%edx)
}
  117506:	83 c4 20             	add    $0x20,%esp
  117509:	5e                   	pop    %esi
  11750a:	5f                   	pop    %edi
  11750b:	5b                   	pop    %ebx
  11750c:	5d                   	pop    %ebp
  11750d:	c3                   	ret    
  11750e:	66 90                	xchg   %ax,%ax

00117510 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
  117510:	55                   	push   %ebp
  117511:	89 e5                	mov    %esp,%ebp
  117513:	56                   	push   %esi
  117514:	83 ec 40             	sub    $0x40,%esp
  117517:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
  11751a:	8d 0d 88 55 13 00    	lea    0x135588,%ecx
  117520:	89 0c 24             	mov    %ecx,(%esp)
  117523:	89 45 ec             	mov    %eax,-0x14(%ebp)
  117526:	e8 95 15 00 00       	call   118ac0 <lv_ll_ins_head>
  11752b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!disp) {
  11752e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  117532:	0f 85 43 00 00 00    	jne    11757b <lv_disp_drv_register+0x6b>
        lv_mem_assert(disp);
  117538:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  11753c:	0f 85 2d 00 00 00    	jne    11756f <lv_disp_drv_register+0x5f>
  117542:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  117549:	8d 05 15 45 12 00    	lea    0x124515,%eax
  11754f:	89 44 24 04          	mov    %eax,0x4(%esp)
  117553:	c7 44 24 08 79 00 00 	movl   $0x79,0x8(%esp)
  11755a:	00 
  11755b:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  117561:	89 44 24 0c          	mov    %eax,0xc(%esp)
  117565:	e8 d6 24 00 00       	call   119a40 <lv_log_add>
  11756a:	e9 fb ff ff ff       	jmp    11756a <lv_disp_drv_register+0x5a>
        return NULL;
  11756f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  117576:	e9 f4 01 00 00       	jmp    11776f <lv_disp_drv_register+0x25f>
    }

    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
  11757b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11757e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117581:	89 04 24             	mov    %eax,(%esp)
  117584:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  117588:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
  11758f:	00 
  117590:	e8 bb 2d ff ff       	call   10a350 <memcpy>
  117595:	31 c9                	xor    %ecx,%ecx
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
  117597:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11759a:	81 c2 40 01 00 00    	add    $0x140,%edx
  1175a0:	89 14 24             	mov    %edx,(%esp)
  1175a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1175aa:	00 
  1175ab:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  1175b2:	00 
  1175b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1175b6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1175b9:	e8 b2 2e ff ff       	call   10a470 <memset>
  1175be:	31 c9                	xor    %ecx,%ecx
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
  1175c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1175c3:	83 c2 40             	add    $0x40,%edx
  1175c6:	89 14 24             	mov    %edx,(%esp)
  1175c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1175d0:	00 
  1175d1:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  1175d8:	00 
  1175d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1175dc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1175df:	e8 8c 2e ff ff       	call   10a470 <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
  1175e4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1175e7:	83 c1 28             	add    $0x28,%ecx
  1175ea:	89 0c 24             	mov    %ecx,(%esp)
  1175ed:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  1175f4:	00 
  1175f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1175f8:	e8 73 14 00 00       	call   118a70 <lv_ll_init>

    if(disp_def == NULL) disp_def = disp;
  1175fd:	83 3d 64 55 13 00 00 	cmpl   $0x0,0x135564
  117604:	0f 85 08 00 00 00    	jne    117612 <lv_disp_drv_register+0x102>
  11760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11760d:	a3 64 55 13 00       	mov    %eax,0x135564
  117612:	31 c0                	xor    %eax,%eax

    lv_disp_t * disp_def_tmp = disp_def;
  117614:	8b 0d 64 55 13 00    	mov    0x135564,%ecx
  11761a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
  11761d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  117620:	89 0d 64 55 13 00    	mov    %ecx,0x135564
                                        new display*/

    disp->inv_p = 0;
  117626:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  117629:	66 8b 91 60 01 00 00 	mov    0x160(%ecx),%dx
  117630:	66 81 e2 00 fc       	and    $0xfc00,%dx
  117635:	66 89 91 60 01 00 00 	mov    %dx,0x160(%ecx)

    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
  11763c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  117643:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11764a:	00 
  11764b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  11764e:	e8 2d 68 ff ff       	call   10de80 <lv_obj_create>
  117653:	31 c9                	xor    %ecx,%ecx
  117655:	8b 75 f4             	mov    -0xc(%ebp),%esi
  117658:	89 46 34             	mov    %eax,0x34(%esi)
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
  11765b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  117662:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117669:	00 
  11766a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  11766d:	e8 0e 68 ff ff       	call   10de80 <lv_obj_create>
  117672:	31 c9                	xor    %ecx,%ecx
  117674:	8b 75 f4             	mov    -0xc(%ebp),%esi
  117677:	89 46 38             	mov    %eax,0x38(%esi)
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
  11767a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  117681:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  117688:	00 
  117689:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  11768c:	e8 ef 67 ff ff       	call   10de80 <lv_obj_create>
  117691:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  117694:	89 41 3c             	mov    %eax,0x3c(%ecx)
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
  117697:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11769a:	8b 40 38             	mov    0x38(%eax),%eax
  11769d:	89 04 24             	mov    %eax,(%esp)
  1176a0:	8d 05 e0 52 13 00    	lea    0x1352e0,%eax
  1176a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1176aa:	e8 e1 81 ff ff       	call   10f890 <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
  1176af:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1176b2:	8b 40 3c             	mov    0x3c(%eax),%eax
  1176b5:	89 04 24             	mov    %eax,(%esp)
  1176b8:	8d 05 e0 52 13 00    	lea    0x1352e0,%eax
  1176be:	89 44 24 04          	mov    %eax,0x4(%esp)
  1176c2:	e8 c9 81 ff ff       	call   10f890 <lv_obj_set_style>

    lv_obj_invalidate(disp->act_scr);
  1176c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1176ca:	8b 40 34             	mov    0x34(%eax),%eax
  1176cd:	89 04 24             	mov    %eax,(%esp)
  1176d0:	e8 9b 74 ff ff       	call   10eb70 <lv_obj_invalidate>

    disp_def = disp_def_tmp; /*Revert the default display*/
  1176d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1176d8:	a3 64 55 13 00       	mov    %eax,0x135564

    /*Create a refresh task*/
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
  1176dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1176e0:	8d 0d b0 fc 10 00    	lea    0x10fcb0,%ecx
  1176e6:	89 0c 24             	mov    %ecx,(%esp)
  1176e9:	c7 44 24 04 32 00 00 	movl   $0x32,0x4(%esp)
  1176f0:	00 
  1176f1:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  1176f8:	00 
  1176f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1176fd:	e8 be 0d 00 00       	call   1184c0 <lv_task_create>
  117702:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  117705:	89 41 24             	mov    %eax,0x24(%ecx)
    lv_mem_assert(disp->refr_task);
  117708:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11770b:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
  11770f:	0f 85 2d 00 00 00    	jne    117742 <lv_disp_drv_register+0x232>
  117715:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11771c:	8d 05 15 45 12 00    	lea    0x124515,%eax
  117722:	89 44 24 04          	mov    %eax,0x4(%esp)
  117726:	c7 44 24 08 96 00 00 	movl   $0x96,0x8(%esp)
  11772d:	00 
  11772e:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  117734:	89 44 24 0c          	mov    %eax,0xc(%esp)
  117738:	e8 03 23 00 00       	call   119a40 <lv_log_add>
  11773d:	e9 fb ff ff ff       	jmp    11773d <lv_disp_drv_register+0x22d>
    if(disp->refr_task == NULL) return NULL;
  117742:	8b 45 f4             	mov    -0xc(%ebp),%eax
  117745:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
  117749:	0f 85 0c 00 00 00    	jne    11775b <lv_disp_drv_register+0x24b>
  11774f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  117756:	e9 14 00 00 00       	jmp    11776f <lv_disp_drv_register+0x25f>

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
  11775b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11775e:	8b 40 24             	mov    0x24(%eax),%eax
  117761:	89 04 24             	mov    %eax,(%esp)
  117764:	e8 b7 0f 00 00       	call   118720 <lv_task_ready>

    return disp;
  117769:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11776c:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  11776f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  117772:	83 c4 40             	add    $0x40,%esp
  117775:	5e                   	pop    %esi
  117776:	5d                   	pop    %ebp
  117777:	c3                   	ret    
  117778:	66 90                	xchg   %ax,%ax
  11777a:	66 90                	xchg   %ax,%ax
  11777c:	66 90                	xchg   %ax,%ax
  11777e:	66 90                	xchg   %ax,%ax

00117780 <lv_disp_get_hor_res>:
 * Get the horizontal resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
  117780:	55                   	push   %ebp
  117781:	89 e5                	mov    %esp,%ebp
  117783:	83 ec 08             	sub    $0x8,%esp
  117786:	8b 45 08             	mov    0x8(%ebp),%eax
    if(disp == NULL) disp = lv_disp_get_default();
  117789:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11778d:	0f 85 08 00 00 00    	jne    11779b <lv_disp_get_hor_res+0x1b>
  117793:	e8 c8 00 00 00       	call   117860 <lv_disp_get_default>
  117798:	89 45 08             	mov    %eax,0x8(%ebp)

    if(disp == NULL)
  11779b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11779f:	0f 85 0b 00 00 00    	jne    1177b0 <lv_disp_get_hor_res+0x30>
        return LV_HOR_RES_MAX;
  1177a5:	66 c7 45 fe 40 01    	movw   $0x140,-0x2(%ebp)
  1177ab:	e9 34 00 00 00       	jmp    1177e4 <lv_disp_get_hor_res+0x64>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
  1177b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1177b3:	8a 48 08             	mov    0x8(%eax),%cl
  1177b6:	80 e1 01             	and    $0x1,%cl
  1177b9:	0f b6 c1             	movzbl %cl,%eax
  1177bc:	83 f8 00             	cmp    $0x0,%eax
  1177bf:	0f 85 0e 00 00 00    	jne    1177d3 <lv_disp_get_hor_res+0x53>
  1177c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1177c8:	0f bf 00             	movswl (%eax),%eax
  1177cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1177ce:	e9 0a 00 00 00       	jmp    1177dd <lv_disp_get_hor_res+0x5d>
  1177d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1177d6:	0f bf 40 02          	movswl 0x2(%eax),%eax
  1177da:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1177dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1177e0:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
}
  1177e4:	0f bf 45 fe          	movswl -0x2(%ebp),%eax
  1177e8:	83 c4 08             	add    $0x8,%esp
  1177eb:	5d                   	pop    %ebp
  1177ec:	c3                   	ret    
  1177ed:	66 90                	xchg   %ax,%ax
  1177ef:	90                   	nop

001177f0 <lv_disp_get_ver_res>:
 * Get the vertical resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
  1177f0:	55                   	push   %ebp
  1177f1:	89 e5                	mov    %esp,%ebp
  1177f3:	83 ec 08             	sub    $0x8,%esp
  1177f6:	8b 45 08             	mov    0x8(%ebp),%eax
    if(disp == NULL) disp = lv_disp_get_default();
  1177f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1177fd:	0f 85 08 00 00 00    	jne    11780b <lv_disp_get_ver_res+0x1b>
  117803:	e8 58 00 00 00       	call   117860 <lv_disp_get_default>
  117808:	89 45 08             	mov    %eax,0x8(%ebp)

    if(disp == NULL)
  11780b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11780f:	0f 85 0b 00 00 00    	jne    117820 <lv_disp_get_ver_res+0x30>
        return LV_VER_RES_MAX;
  117815:	66 c7 45 fe f0 00    	movw   $0xf0,-0x2(%ebp)
  11781b:	e9 34 00 00 00       	jmp    117854 <lv_disp_get_ver_res+0x64>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
  117820:	8b 45 08             	mov    0x8(%ebp),%eax
  117823:	8a 48 08             	mov    0x8(%eax),%cl
  117826:	80 e1 01             	and    $0x1,%cl
  117829:	0f b6 c1             	movzbl %cl,%eax
  11782c:	83 f8 00             	cmp    $0x0,%eax
  11782f:	0f 85 0f 00 00 00    	jne    117844 <lv_disp_get_ver_res+0x54>
  117835:	8b 45 08             	mov    0x8(%ebp),%eax
  117838:	0f bf 40 02          	movswl 0x2(%eax),%eax
  11783c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11783f:	e9 09 00 00 00       	jmp    11784d <lv_disp_get_ver_res+0x5d>
  117844:	8b 45 08             	mov    0x8(%ebp),%eax
  117847:	0f bf 00             	movswl (%eax),%eax
  11784a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11784d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  117850:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
}
  117854:	0f bf 45 fe          	movswl -0x2(%ebp),%eax
  117858:	83 c4 08             	add    $0x8,%esp
  11785b:	5d                   	pop    %ebp
  11785c:	c3                   	ret    
  11785d:	66 90                	xchg   %ax,%ax
  11785f:	90                   	nop

00117860 <lv_disp_get_default>:
{
  117860:	55                   	push   %ebp
  117861:	89 e5                	mov    %esp,%ebp
    return disp_def;
  117863:	a1 64 55 13 00       	mov    0x135564,%eax
  117868:	5d                   	pop    %ebp
  117869:	c3                   	ret    
  11786a:	66 90                	xchg   %ax,%ax
  11786c:	66 90                	xchg   %ax,%ax
  11786e:	66 90                	xchg   %ax,%ax

00117870 <lv_disp_get_antialiasing>:
 * Get if anti-aliasing is enabled for a display or not
 * @param disp pointer to a display (NULL to use the default display)
 * @return true: anti-aliasing is enabled; false: disabled
 */
bool lv_disp_get_antialiasing(lv_disp_t * disp)
{
  117870:	55                   	push   %ebp
  117871:	89 e5                	mov    %esp,%ebp
  117873:	50                   	push   %eax
  117874:	8b 45 08             	mov    0x8(%ebp),%eax
  117877:	31 c9                	xor    %ecx,%ecx
#if LV_ANTIALIAS == 0
    return false;
  117879:	80 e1 01             	and    $0x1,%cl
  11787c:	0f b6 d1             	movzbl %cl,%edx
  11787f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  117882:	89 d0                	mov    %edx,%eax
  117884:	83 c4 04             	add    $0x4,%esp
  117887:	5d                   	pop    %ebp
  117888:	c3                   	ret    
  117889:	66 90                	xchg   %ax,%ax
  11788b:	66 90                	xchg   %ax,%ax
  11788d:	66 90                	xchg   %ax,%ax
  11788f:	90                   	nop

00117890 <lv_disp_flush_ready>:
/**
 * Call in the display driver's `flush_cb` function when the flushing is finished
 * @param disp_drv pointer to display driver in `flush_cb` where this function is called
 */
LV_ATTRIBUTE_FLUSH_READY void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)
{
  117890:	55                   	push   %ebp
  117891:	89 e5                	mov    %esp,%ebp
  117893:	8b 45 08             	mov    0x8(%ebp),%eax
    disp_drv->buffer->flushing = 0;
  117896:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117899:	8b 49 04             	mov    0x4(%ecx),%ecx
  11789c:	8a 51 18             	mov    0x18(%ecx),%dl
  11789f:	80 e2 fe             	and    $0xfe,%dl
  1178a2:	88 51 18             	mov    %dl,0x18(%ecx)
#if LV_COLOR_SCREEN_TRANSP
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif
}
  1178a5:	5d                   	pop    %ebp
  1178a6:	c3                   	ret    
  1178a7:	66 90                	xchg   %ax,%ax
  1178a9:	66 90                	xchg   %ax,%ax
  1178ab:	66 90                	xchg   %ax,%ax
  1178ad:	66 90                	xchg   %ax,%ax
  1178af:	90                   	nop

001178b0 <lv_disp_get_buf>:
 * Get the internal buffer of a display
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
  1178b0:	55                   	push   %ebp
  1178b1:	89 e5                	mov    %esp,%ebp
  1178b3:	50                   	push   %eax
  1178b4:	8b 45 08             	mov    0x8(%ebp),%eax
    return disp->driver.buffer;
  1178b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1178ba:	8b 49 04             	mov    0x4(%ecx),%ecx
  1178bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1178c0:	89 c8                	mov    %ecx,%eax
  1178c2:	83 c4 04             	add    $0x4,%esp
  1178c5:	5d                   	pop    %ebp
  1178c6:	c3                   	ret    
  1178c7:	66 90                	xchg   %ax,%ax
  1178c9:	66 90                	xchg   %ax,%ax
  1178cb:	66 90                	xchg   %ax,%ax
  1178cd:	66 90                	xchg   %ax,%ax
  1178cf:	90                   	nop

001178d0 <lv_disp_is_double_buf>:
 * Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
  1178d0:	55                   	push   %ebp
  1178d1:	89 e5                	mov    %esp,%ebp
  1178d3:	50                   	push   %eax
  1178d4:	8b 45 08             	mov    0x8(%ebp),%eax
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
  1178d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1178da:	8b 49 04             	mov    0x4(%ecx),%ecx
  1178dd:	83 39 00             	cmpl   $0x0,(%ecx)
  1178e0:	0f 84 19 00 00 00    	je     1178ff <lv_disp_is_double_buf+0x2f>
  1178e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1178e9:	8b 40 04             	mov    0x4(%eax),%eax
  1178ec:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  1178f0:	0f 84 09 00 00 00    	je     1178ff <lv_disp_is_double_buf+0x2f>
        return true;
  1178f6:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  1178fa:	e9 04 00 00 00       	jmp    117903 <lv_disp_is_double_buf+0x33>
    else
        return false;
  1178ff:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
}
  117903:	8a 45 ff             	mov    -0x1(%ebp),%al
  117906:	24 01                	and    $0x1,%al
  117908:	0f b6 c0             	movzbl %al,%eax
  11790b:	83 c4 04             	add    $0x4,%esp
  11790e:	5d                   	pop    %ebp
  11790f:	c3                   	ret    

00117910 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
  117910:	55                   	push   %ebp
  117911:	89 e5                	mov    %esp,%ebp
  117913:	83 ec 10             	sub    $0x10,%esp
  117916:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
  117919:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11791c:	0f bf 09             	movswl (%ecx),%ecx
  11791f:	8b 55 08             	mov    0x8(%ebp),%edx
  117922:	0f bf 52 02          	movswl 0x2(%edx),%edx
  117926:	0f af ca             	imul   %edx,%ecx
  117929:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
  11792c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11792f:	89 0c 24             	mov    %ecx,(%esp)
  117932:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117935:	e8 96 ff ff ff       	call   1178d0 <lv_disp_is_double_buf>
  11793a:	a8 01                	test   $0x1,%al
  11793c:	0f 85 05 00 00 00    	jne    117947 <lv_disp_is_true_double_buf+0x37>
  117942:	e9 1b 00 00 00       	jmp    117962 <lv_disp_is_true_double_buf+0x52>
  117947:	8b 45 08             	mov    0x8(%ebp),%eax
  11794a:	8b 40 04             	mov    0x4(%eax),%eax
  11794d:	8b 40 0c             	mov    0xc(%eax),%eax
  117950:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  117953:	0f 85 09 00 00 00    	jne    117962 <lv_disp_is_true_double_buf+0x52>
        return true;
  117959:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  11795d:	e9 04 00 00 00       	jmp    117966 <lv_disp_is_true_double_buf+0x56>
    } else {
        return false;
  117962:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
    }
}
  117966:	8a 45 ff             	mov    -0x1(%ebp),%al
  117969:	24 01                	and    $0x1,%al
  11796b:	0f b6 c0             	movzbl %al,%eax
  11796e:	83 c4 10             	add    $0x10,%esp
  117971:	5d                   	pop    %ebp
  117972:	c3                   	ret    
  117973:	66 90                	xchg   %ax,%ax
  117975:	66 90                	xchg   %ax,%ax
  117977:	66 90                	xchg   %ax,%ax
  117979:	66 90                	xchg   %ax,%ax
  11797b:	66 90                	xchg   %ax,%ax
  11797d:	66 90                	xchg   %ax,%ax
  11797f:	90                   	nop

00117980 <lv_indev_get_next>:
 * @param indev pointer to the current input device. NULL to initialize.
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
  117980:	55                   	push   %ebp
  117981:	89 e5                	mov    %esp,%ebp
  117983:	83 ec 0c             	sub    $0xc,%esp
  117986:	8b 45 08             	mov    0x8(%ebp),%eax
    if(indev == NULL)
  117989:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11798d:	0f 85 16 00 00 00    	jne    1179a9 <lv_indev_get_next+0x29>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
  117993:	8d 05 94 55 13 00    	lea    0x135594,%eax
  117999:	89 04 24             	mov    %eax,(%esp)
  11799c:	e8 0f 14 00 00       	call   118db0 <lv_ll_get_head>
  1179a1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1179a4:	e9 18 00 00 00       	jmp    1179c1 <lv_indev_get_next+0x41>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
  1179a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1179ac:	8d 0d 94 55 13 00    	lea    0x135594,%ecx
  1179b2:	89 0c 24             	mov    %ecx,(%esp)
  1179b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1179b9:	e8 b2 16 00 00       	call   119070 <lv_ll_get_next>
  1179be:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1179c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1179c4:	83 c4 0c             	add    $0xc,%esp
  1179c7:	5d                   	pop    %ebp
  1179c8:	c3                   	ret    
  1179c9:	66 90                	xchg   %ax,%ax
  1179cb:	66 90                	xchg   %ax,%ax
  1179cd:	66 90                	xchg   %ax,%ax
  1179cf:	90                   	nop

001179d0 <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
  1179d0:	55                   	push   %ebp
  1179d1:	89 e5                	mov    %esp,%ebp
    } while(!tick_irq_flag); /*'lv_tick_inc()' clears this flag which can be in an interrupt.
                                Continue until make a non interrupted cycle */

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
  1179d3:	e8 08 00 00 00       	call   1179e0 <k_uptime_get_32>
  1179d8:	5d                   	pop    %ebp
  1179d9:	c3                   	ret    
  1179da:	66 90                	xchg   %ax,%ax
  1179dc:	66 90                	xchg   %ax,%ax
  1179de:	66 90                	xchg   %ax,%ax

001179e0 <k_uptime_get_32>:
{
  1179e0:	55                   	push   %ebp
  1179e1:	89 e5                	mov    %esp,%ebp
	return (u32_t)k_uptime_get();
  1179e3:	e8 58 00 00 00       	call   117a40 <k_uptime_get>
  1179e8:	5d                   	pop    %ebp
  1179e9:	c3                   	ret    
  1179ea:	66 90                	xchg   %ax,%ax
  1179ec:	66 90                	xchg   %ax,%ax
  1179ee:	66 90                	xchg   %ax,%ax

001179f0 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
  1179f0:	55                   	push   %ebp
  1179f1:	89 e5                	mov    %esp,%ebp
  1179f3:	83 ec 08             	sub    $0x8,%esp
  1179f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1179f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t act_time = lv_tick_get();
  1179fc:	e8 cf ff ff ff       	call   1179d0 <lv_tick_get>
  117a01:	89 45 fc             	mov    %eax,-0x4(%ebp)

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
  117a04:	8b 45 fc             	mov    -0x4(%ebp),%eax
  117a07:	3b 45 08             	cmp    0x8(%ebp),%eax
  117a0a:	0f 82 0e 00 00 00    	jb     117a1e <lv_tick_elaps+0x2e>
        prev_tick = act_time - prev_tick;
  117a10:	8b 45 fc             	mov    -0x4(%ebp),%eax
  117a13:	2b 45 08             	sub    0x8(%ebp),%eax
  117a16:	89 45 08             	mov    %eax,0x8(%ebp)
    } else {
  117a19:	e9 17 00 00 00       	jmp    117a35 <lv_tick_elaps+0x45>
        prev_tick = UINT32_MAX - prev_tick + 1;
  117a1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  117a23:	2b 45 08             	sub    0x8(%ebp),%eax
  117a26:	83 c0 01             	add    $0x1,%eax
  117a29:	89 45 08             	mov    %eax,0x8(%ebp)
        prev_tick += act_time;
  117a2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  117a2f:	03 45 08             	add    0x8(%ebp),%eax
  117a32:	89 45 08             	mov    %eax,0x8(%ebp)
    }

    return prev_tick;
  117a35:	8b 45 08             	mov    0x8(%ebp),%eax
  117a38:	83 c4 08             	add    $0x8,%esp
  117a3b:	5d                   	pop    %ebp
  117a3c:	c3                   	ret    
  117a3d:	66 90                	xchg   %ax,%ax
  117a3f:	90                   	nop

00117a40 <k_uptime_get>:
{
  117a40:	55                   	push   %ebp
  117a41:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  117a43:	e9 00 00 00 00       	jmp    117a48 <k_uptime_get+0x8>
	return z_impl_k_uptime_get();
  117a48:	e8 03 a0 00 00       	call   121a50 <z_impl_k_uptime_get>
  117a4d:	5d                   	pop    %ebp
  117a4e:	c3                   	ret    
  117a4f:	90                   	nop

00117a50 <lv_circ_init>:
 * @param c pointer to a point. The coordinates will be calculated here
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
  117a50:	55                   	push   %ebp
  117a51:	89 e5                	mov    %esp,%ebp
  117a53:	53                   	push   %ebx
  117a54:	57                   	push   %edi
  117a55:	56                   	push   %esi
  117a56:	66 8b 45 10          	mov    0x10(%ebp),%ax
  117a5a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117a5d:	8b 55 08             	mov    0x8(%ebp),%edx
    c->x = radius;
  117a60:	66 8b 75 10          	mov    0x10(%ebp),%si
  117a64:	8b 7d 08             	mov    0x8(%ebp),%edi
  117a67:	66 89 37             	mov    %si,(%edi)
    c->y = 0;
  117a6a:	8b 7d 08             	mov    0x8(%ebp),%edi
  117a6d:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
    *tmp = 1 - radius;
  117a73:	0f bf 7d 10          	movswl 0x10(%ebp),%edi
  117a77:	bb 01 00 00 00       	mov    $0x1,%ebx
  117a7c:	29 fb                	sub    %edi,%ebx
  117a7e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  117a81:	66 89 1f             	mov    %bx,(%edi)
}
  117a84:	5e                   	pop    %esi
  117a85:	5f                   	pop    %edi
  117a86:	5b                   	pop    %ebx
  117a87:	5d                   	pop    %ebp
  117a88:	c3                   	ret    
  117a89:	66 90                	xchg   %ax,%ax
  117a8b:	66 90                	xchg   %ax,%ax
  117a8d:	66 90                	xchg   %ax,%ax
  117a8f:	90                   	nop

00117a90 <lv_circ_cont>:
 * Test the circle drawing is ready or not
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
  117a90:	55                   	push   %ebp
  117a91:	89 e5                	mov    %esp,%ebp
  117a93:	56                   	push   %esi
  117a94:	83 ec 08             	sub    $0x8,%esp
  117a97:	8b 45 08             	mov    0x8(%ebp),%eax
  117a9a:	31 c9                	xor    %ecx,%ecx
    return c->y <= c->x ? true : false;
  117a9c:	8b 55 08             	mov    0x8(%ebp),%edx
  117a9f:	0f bf 52 02          	movswl 0x2(%edx),%edx
  117aa3:	8b 75 08             	mov    0x8(%ebp),%esi
  117aa6:	0f bf 36             	movswl (%esi),%esi
  117aa9:	39 f2                	cmp    %esi,%edx
  117aab:	ba 01 00 00 00       	mov    $0x1,%edx
  117ab0:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  117ab3:	89 55 f4             	mov    %edx,-0xc(%ebp)
  117ab6:	0f 8e 06 00 00 00    	jle    117ac2 <lv_circ_cont+0x32>
  117abc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  117abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  117ac5:	83 f8 00             	cmp    $0x0,%eax
  117ac8:	0f 95 c1             	setne  %cl
  117acb:	80 e1 01             	and    $0x1,%cl
  117ace:	0f b6 c1             	movzbl %cl,%eax
  117ad1:	83 c4 08             	add    $0x8,%esp
  117ad4:	5e                   	pop    %esi
  117ad5:	5d                   	pop    %ebp
  117ad6:	c3                   	ret    
  117ad7:	66 90                	xchg   %ax,%ax
  117ad9:	66 90                	xchg   %ax,%ax
  117adb:	66 90                	xchg   %ax,%ax
  117add:	66 90                	xchg   %ax,%ax
  117adf:	90                   	nop

00117ae0 <lv_circ_next>:
 * Get the next point from the circle
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
  117ae0:	55                   	push   %ebp
  117ae1:	89 e5                	mov    %esp,%ebp
  117ae3:	56                   	push   %esi
  117ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
  117ae7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c->y++;
  117aea:	8b 55 08             	mov    0x8(%ebp),%edx
  117aed:	66 8b 72 02          	mov    0x2(%edx),%si
  117af1:	66 83 c6 01          	add    $0x1,%si
  117af5:	66 89 72 02          	mov    %si,0x2(%edx)

    if(*tmp <= 0) {
  117af9:	8b 55 0c             	mov    0xc(%ebp),%edx
  117afc:	0f bf 12             	movswl (%edx),%edx
  117aff:	83 fa 00             	cmp    $0x0,%edx
  117b02:	0f 8f 1d 00 00 00    	jg     117b25 <lv_circ_next+0x45>
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
  117b08:	8b 45 08             	mov    0x8(%ebp),%eax
  117b0b:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117b0f:	c1 e0 01             	shl    $0x1,%eax
  117b12:	83 c0 01             	add    $0x1,%eax
  117b15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117b18:	0f bf 11             	movswl (%ecx),%edx
  117b1b:	01 c2                	add    %eax,%edx
  117b1d:	66 89 11             	mov    %dx,(%ecx)
    } else {
  117b20:	e9 2d 00 00 00       	jmp    117b52 <lv_circ_next+0x72>
        c->x--;
  117b25:	8b 45 08             	mov    0x8(%ebp),%eax
  117b28:	66 8b 08             	mov    (%eax),%cx
  117b2b:	66 83 c1 ff          	add    $0xffff,%cx
  117b2f:	66 89 08             	mov    %cx,(%eax)
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
  117b32:	8b 45 08             	mov    0x8(%ebp),%eax
  117b35:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117b39:	8b 55 08             	mov    0x8(%ebp),%edx
  117b3c:	0f bf 12             	movswl (%edx),%edx
  117b3f:	29 d0                	sub    %edx,%eax
  117b41:	c1 e0 01             	shl    $0x1,%eax
  117b44:	83 c0 01             	add    $0x1,%eax
  117b47:	8b 55 0c             	mov    0xc(%ebp),%edx
  117b4a:	0f bf 32             	movswl (%edx),%esi
  117b4d:	01 c6                	add    %eax,%esi
  117b4f:	66 89 32             	mov    %si,(%edx)
    }
}
  117b52:	5e                   	pop    %esi
  117b53:	5d                   	pop    %ebp
  117b54:	c3                   	ret    
  117b55:	66 90                	xchg   %ax,%ax
  117b57:	66 90                	xchg   %ax,%ax
  117b59:	66 90                	xchg   %ax,%ax
  117b5b:	66 90                	xchg   %ax,%ax
  117b5d:	66 90                	xchg   %ax,%ax
  117b5f:	90                   	nop

00117b60 <lv_area_set>:
 * @param y1 top coordinate of the area
 * @param x2 right coordinate of the area
 * @param y2 bottom coordinate of the area
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
  117b60:	55                   	push   %ebp
  117b61:	89 e5                	mov    %esp,%ebp
  117b63:	53                   	push   %ebx
  117b64:	57                   	push   %edi
  117b65:	56                   	push   %esi
  117b66:	50                   	push   %eax
  117b67:	66 8b 45 18          	mov    0x18(%ebp),%ax
  117b6b:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  117b6f:	66 8b 55 10          	mov    0x10(%ebp),%dx
  117b73:	66 8b 75 0c          	mov    0xc(%ebp),%si
  117b77:	8b 7d 08             	mov    0x8(%ebp),%edi
    area_p->x1 = x1;
  117b7a:	66 8b 5d 0c          	mov    0xc(%ebp),%bx
  117b7e:	89 7d f0             	mov    %edi,-0x10(%ebp)
  117b81:	8b 7d 08             	mov    0x8(%ebp),%edi
  117b84:	66 89 1f             	mov    %bx,(%edi)
    area_p->y1 = y1;
  117b87:	66 8b 5d 10          	mov    0x10(%ebp),%bx
  117b8b:	8b 7d 08             	mov    0x8(%ebp),%edi
  117b8e:	66 89 5f 02          	mov    %bx,0x2(%edi)
    area_p->x2 = x2;
  117b92:	66 8b 5d 14          	mov    0x14(%ebp),%bx
  117b96:	8b 7d 08             	mov    0x8(%ebp),%edi
  117b99:	66 89 5f 04          	mov    %bx,0x4(%edi)
    area_p->y2 = y2;
  117b9d:	66 8b 5d 18          	mov    0x18(%ebp),%bx
  117ba1:	8b 7d 08             	mov    0x8(%ebp),%edi
  117ba4:	66 89 5f 06          	mov    %bx,0x6(%edi)
}
  117ba8:	83 c4 04             	add    $0x4,%esp
  117bab:	5e                   	pop    %esi
  117bac:	5f                   	pop    %edi
  117bad:	5b                   	pop    %ebx
  117bae:	5d                   	pop    %ebp
  117baf:	c3                   	ret    

00117bb0 <lv_area_get_size>:
 * Return with area of an area (x * y)
 * @param area_p pointer to an area
 * @return size of area
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
  117bb0:	55                   	push   %ebp
  117bb1:	89 e5                	mov    %esp,%ebp
  117bb3:	56                   	push   %esi
  117bb4:	83 ec 08             	sub    $0x8,%esp
  117bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
  117bba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117bbd:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  117bc1:	8b 55 08             	mov    0x8(%ebp),%edx
  117bc4:	0f bf 12             	movswl (%edx),%edx
  117bc7:	29 d1                	sub    %edx,%ecx
  117bc9:	83 c1 01             	add    $0x1,%ecx
  117bcc:	8b 55 08             	mov    0x8(%ebp),%edx
  117bcf:	0f bf 52 06          	movswl 0x6(%edx),%edx
  117bd3:	8b 75 08             	mov    0x8(%ebp),%esi
  117bd6:	0f bf 76 02          	movswl 0x2(%esi),%esi
  117bda:	29 f2                	sub    %esi,%edx
  117bdc:	83 c2 01             	add    $0x1,%edx
  117bdf:	0f af ca             	imul   %edx,%ecx
  117be2:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    return size;
  117be5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  117be8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117beb:	89 c8                	mov    %ecx,%eax
  117bed:	83 c4 08             	add    $0x8,%esp
  117bf0:	5e                   	pop    %esi
  117bf1:	5d                   	pop    %ebp
  117bf2:	c3                   	ret    
  117bf3:	66 90                	xchg   %ax,%ax
  117bf5:	66 90                	xchg   %ax,%ax
  117bf7:	66 90                	xchg   %ax,%ax
  117bf9:	66 90                	xchg   %ax,%ax
  117bfb:	66 90                	xchg   %ax,%ax
  117bfd:	66 90                	xchg   %ax,%ax
  117bff:	90                   	nop

00117c00 <lv_area_intersect>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
  117c00:	55                   	push   %ebp
  117c01:	89 e5                	mov    %esp,%ebp
  117c03:	57                   	push   %edi
  117c04:	56                   	push   %esi
  117c05:	83 ec 14             	sub    $0x14,%esp
  117c08:	8b 45 10             	mov    0x10(%ebp),%eax
  117c0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117c0e:	8b 55 08             	mov    0x8(%ebp),%edx
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
  117c11:	8b 75 0c             	mov    0xc(%ebp),%esi
  117c14:	0f bf 36             	movswl (%esi),%esi
  117c17:	8b 7d 10             	mov    0x10(%ebp),%edi
  117c1a:	0f bf 3f             	movswl (%edi),%edi
  117c1d:	39 fe                	cmp    %edi,%esi
  117c1f:	0f 8e 0e 00 00 00    	jle    117c33 <lv_area_intersect+0x33>
  117c25:	8b 45 0c             	mov    0xc(%ebp),%eax
  117c28:	0f bf 00             	movswl (%eax),%eax
  117c2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  117c2e:	e9 09 00 00 00       	jmp    117c3c <lv_area_intersect+0x3c>
  117c33:	8b 45 10             	mov    0x10(%ebp),%eax
  117c36:	0f bf 00             	movswl (%eax),%eax
  117c39:	89 45 f0             	mov    %eax,-0x10(%ebp)
  117c3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  117c3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117c42:	66 89 01             	mov    %ax,(%ecx)
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
  117c45:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117c48:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  117c4c:	8b 55 10             	mov    0x10(%ebp),%edx
  117c4f:	0f bf 52 02          	movswl 0x2(%edx),%edx
  117c53:	39 d1                	cmp    %edx,%ecx
  117c55:	0f 8e 0f 00 00 00    	jle    117c6a <lv_area_intersect+0x6a>
  117c5b:	8b 45 0c             	mov    0xc(%ebp),%eax
  117c5e:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117c62:	89 45 ec             	mov    %eax,-0x14(%ebp)
  117c65:	e9 0a 00 00 00       	jmp    117c74 <lv_area_intersect+0x74>
  117c6a:	8b 45 10             	mov    0x10(%ebp),%eax
  117c6d:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117c71:	89 45 ec             	mov    %eax,-0x14(%ebp)
  117c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
  117c77:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117c7a:	66 89 41 02          	mov    %ax,0x2(%ecx)
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
  117c7e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117c81:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  117c85:	8b 55 10             	mov    0x10(%ebp),%edx
  117c88:	0f bf 52 04          	movswl 0x4(%edx),%edx
  117c8c:	39 d1                	cmp    %edx,%ecx
  117c8e:	0f 8d 0f 00 00 00    	jge    117ca3 <lv_area_intersect+0xa3>
  117c94:	8b 45 0c             	mov    0xc(%ebp),%eax
  117c97:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117c9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  117c9e:	e9 0a 00 00 00       	jmp    117cad <lv_area_intersect+0xad>
  117ca3:	8b 45 10             	mov    0x10(%ebp),%eax
  117ca6:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117caa:	89 45 e8             	mov    %eax,-0x18(%ebp)
  117cad:	8b 45 e8             	mov    -0x18(%ebp),%eax
  117cb0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117cb3:	66 89 41 04          	mov    %ax,0x4(%ecx)
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
  117cb7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117cba:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  117cbe:	8b 55 10             	mov    0x10(%ebp),%edx
  117cc1:	0f bf 52 06          	movswl 0x6(%edx),%edx
  117cc5:	39 d1                	cmp    %edx,%ecx
  117cc7:	0f 8d 0f 00 00 00    	jge    117cdc <lv_area_intersect+0xdc>
  117ccd:	8b 45 0c             	mov    0xc(%ebp),%eax
  117cd0:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117cd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  117cd7:	e9 0a 00 00 00       	jmp    117ce6 <lv_area_intersect+0xe6>
  117cdc:	8b 45 10             	mov    0x10(%ebp),%eax
  117cdf:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117ce3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  117ce6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  117ce9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117cec:	66 89 41 06          	mov    %ax,0x6(%ecx)

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
  117cf0:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
  117cf4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117cf7:	0f bf 09             	movswl (%ecx),%ecx
  117cfa:	8b 55 08             	mov    0x8(%ebp),%edx
  117cfd:	0f bf 52 04          	movswl 0x4(%edx),%edx
  117d01:	39 d1                	cmp    %edx,%ecx
  117d03:	0f 8f 16 00 00 00    	jg     117d1f <lv_area_intersect+0x11f>
  117d09:	8b 45 08             	mov    0x8(%ebp),%eax
  117d0c:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117d10:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117d13:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  117d17:	39 c8                	cmp    %ecx,%eax
  117d19:	0f 8e 04 00 00 00    	jle    117d23 <lv_area_intersect+0x123>
        union_ok = false;
  117d1f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    }

    return union_ok;
  117d23:	8a 45 f7             	mov    -0x9(%ebp),%al
  117d26:	24 01                	and    $0x1,%al
  117d28:	0f b6 c0             	movzbl %al,%eax
  117d2b:	83 c4 14             	add    $0x14,%esp
  117d2e:	5e                   	pop    %esi
  117d2f:	5f                   	pop    %edi
  117d30:	5d                   	pop    %ebp
  117d31:	c3                   	ret    
  117d32:	66 90                	xchg   %ax,%ax
  117d34:	66 90                	xchg   %ax,%ax
  117d36:	66 90                	xchg   %ax,%ax
  117d38:	66 90                	xchg   %ax,%ax
  117d3a:	66 90                	xchg   %ax,%ax
  117d3c:	66 90                	xchg   %ax,%ax
  117d3e:	66 90                	xchg   %ax,%ax

00117d40 <lv_area_join>:
 * @param res_p pointer to an area, the result will be stored here
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
  117d40:	55                   	push   %ebp
  117d41:	89 e5                	mov    %esp,%ebp
  117d43:	57                   	push   %edi
  117d44:	56                   	push   %esi
  117d45:	83 ec 10             	sub    $0x10,%esp
  117d48:	8b 45 10             	mov    0x10(%ebp),%eax
  117d4b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117d4e:	8b 55 08             	mov    0x8(%ebp),%edx
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
  117d51:	8b 75 0c             	mov    0xc(%ebp),%esi
  117d54:	0f bf 36             	movswl (%esi),%esi
  117d57:	8b 7d 10             	mov    0x10(%ebp),%edi
  117d5a:	0f bf 3f             	movswl (%edi),%edi
  117d5d:	39 fe                	cmp    %edi,%esi
  117d5f:	0f 8d 0e 00 00 00    	jge    117d73 <lv_area_join+0x33>
  117d65:	8b 45 0c             	mov    0xc(%ebp),%eax
  117d68:	0f bf 00             	movswl (%eax),%eax
  117d6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117d6e:	e9 09 00 00 00       	jmp    117d7c <lv_area_join+0x3c>
  117d73:	8b 45 10             	mov    0x10(%ebp),%eax
  117d76:	0f bf 00             	movswl (%eax),%eax
  117d79:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117d7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  117d7f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117d82:	66 89 01             	mov    %ax,(%ecx)
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
  117d85:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117d88:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  117d8c:	8b 55 10             	mov    0x10(%ebp),%edx
  117d8f:	0f bf 52 02          	movswl 0x2(%edx),%edx
  117d93:	39 d1                	cmp    %edx,%ecx
  117d95:	0f 8d 0f 00 00 00    	jge    117daa <lv_area_join+0x6a>
  117d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  117d9e:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  117da5:	e9 0a 00 00 00       	jmp    117db4 <lv_area_join+0x74>
  117daa:	8b 45 10             	mov    0x10(%ebp),%eax
  117dad:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117db1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  117db4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  117db7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117dba:	66 89 41 02          	mov    %ax,0x2(%ecx)
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
  117dbe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117dc1:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  117dc5:	8b 55 10             	mov    0x10(%ebp),%edx
  117dc8:	0f bf 52 04          	movswl 0x4(%edx),%edx
  117dcc:	39 d1                	cmp    %edx,%ecx
  117dce:	0f 8e 0f 00 00 00    	jle    117de3 <lv_area_join+0xa3>
  117dd4:	8b 45 0c             	mov    0xc(%ebp),%eax
  117dd7:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117ddb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  117dde:	e9 0a 00 00 00       	jmp    117ded <lv_area_join+0xad>
  117de3:	8b 45 10             	mov    0x10(%ebp),%eax
  117de6:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117dea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  117ded:	8b 45 ec             	mov    -0x14(%ebp),%eax
  117df0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117df3:	66 89 41 04          	mov    %ax,0x4(%ecx)
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
  117df7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117dfa:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  117dfe:	8b 55 10             	mov    0x10(%ebp),%edx
  117e01:	0f bf 52 06          	movswl 0x6(%edx),%edx
  117e05:	39 d1                	cmp    %edx,%ecx
  117e07:	0f 8e 0f 00 00 00    	jle    117e1c <lv_area_join+0xdc>
  117e0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  117e10:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117e14:	89 45 e8             	mov    %eax,-0x18(%ebp)
  117e17:	e9 0a 00 00 00       	jmp    117e26 <lv_area_join+0xe6>
  117e1c:	8b 45 10             	mov    0x10(%ebp),%eax
  117e1f:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117e23:	89 45 e8             	mov    %eax,-0x18(%ebp)
  117e26:	8b 45 e8             	mov    -0x18(%ebp),%eax
  117e29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  117e2c:	66 89 41 06          	mov    %ax,0x6(%ecx)
}
  117e30:	83 c4 10             	add    $0x10,%esp
  117e33:	5e                   	pop    %esi
  117e34:	5f                   	pop    %edi
  117e35:	5d                   	pop    %ebp
  117e36:	c3                   	ret    
  117e37:	66 90                	xchg   %ax,%ax
  117e39:	66 90                	xchg   %ax,%ax
  117e3b:	66 90                	xchg   %ax,%ax
  117e3d:	66 90                	xchg   %ax,%ax
  117e3f:	90                   	nop

00117e40 <lv_area_is_on>:
 * @param a1_p pointer to an area.
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
  117e40:	55                   	push   %ebp
  117e41:	89 e5                	mov    %esp,%ebp
  117e43:	56                   	push   %esi
  117e44:	50                   	push   %eax
  117e45:	8b 45 0c             	mov    0xc(%ebp),%eax
  117e48:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
  117e4b:	8b 55 08             	mov    0x8(%ebp),%edx
  117e4e:	0f bf 12             	movswl (%edx),%edx
  117e51:	8b 75 0c             	mov    0xc(%ebp),%esi
  117e54:	0f bf 76 04          	movswl 0x4(%esi),%esi
  117e58:	39 f2                	cmp    %esi,%edx
  117e5a:	0f 8f 4a 00 00 00    	jg     117eaa <lv_area_is_on+0x6a>
  117e60:	8b 45 08             	mov    0x8(%ebp),%eax
  117e63:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117e67:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117e6a:	0f bf 09             	movswl (%ecx),%ecx
  117e6d:	39 c8                	cmp    %ecx,%eax
  117e6f:	0f 8c 35 00 00 00    	jl     117eaa <lv_area_is_on+0x6a>
  117e75:	8b 45 08             	mov    0x8(%ebp),%eax
  117e78:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117e7c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117e7f:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  117e83:	39 c8                	cmp    %ecx,%eax
  117e85:	0f 8f 1f 00 00 00    	jg     117eaa <lv_area_is_on+0x6a>
  117e8b:	8b 45 08             	mov    0x8(%ebp),%eax
  117e8e:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117e92:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117e95:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  117e99:	39 c8                	cmp    %ecx,%eax
  117e9b:	0f 8c 09 00 00 00    	jl     117eaa <lv_area_is_on+0x6a>
        return true;
  117ea1:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
  117ea5:	e9 04 00 00 00       	jmp    117eae <lv_area_is_on+0x6e>
    } else {
        return false;
  117eaa:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
    }
}
  117eae:	8a 45 fb             	mov    -0x5(%ebp),%al
  117eb1:	24 01                	and    $0x1,%al
  117eb3:	0f b6 c0             	movzbl %al,%eax
  117eb6:	83 c4 04             	add    $0x4,%esp
  117eb9:	5e                   	pop    %esi
  117eba:	5d                   	pop    %ebp
  117ebb:	c3                   	ret    
  117ebc:	66 90                	xchg   %ax,%ax
  117ebe:	66 90                	xchg   %ax,%ax

00117ec0 <lv_area_is_in>:
 * @param ain_p pointer to an area which could be in 'aholder_p'
 * @param aholder pointer to an area which could involve 'ain_p'
 * @return
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
  117ec0:	55                   	push   %ebp
  117ec1:	89 e5                	mov    %esp,%ebp
  117ec3:	56                   	push   %esi
  117ec4:	50                   	push   %eax
  117ec5:	8b 45 0c             	mov    0xc(%ebp),%eax
  117ec8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bool is_in = false;
  117ecb:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
  117ecf:	8b 55 08             	mov    0x8(%ebp),%edx
  117ed2:	0f bf 12             	movswl (%edx),%edx
  117ed5:	8b 75 0c             	mov    0xc(%ebp),%esi
  117ed8:	0f bf 36             	movswl (%esi),%esi
  117edb:	39 f2                	cmp    %esi,%edx
  117edd:	0f 8c 46 00 00 00    	jl     117f29 <lv_area_is_in+0x69>
  117ee3:	8b 45 08             	mov    0x8(%ebp),%eax
  117ee6:	0f bf 40 02          	movswl 0x2(%eax),%eax
  117eea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117eed:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  117ef1:	39 c8                	cmp    %ecx,%eax
  117ef3:	0f 8c 30 00 00 00    	jl     117f29 <lv_area_is_in+0x69>
  117ef9:	8b 45 08             	mov    0x8(%ebp),%eax
  117efc:	0f bf 40 04          	movswl 0x4(%eax),%eax
  117f00:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117f03:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  117f07:	39 c8                	cmp    %ecx,%eax
  117f09:	0f 8f 1a 00 00 00    	jg     117f29 <lv_area_is_in+0x69>
       ain_p->y2 <= aholder_p->y2) {
  117f0f:	8b 45 08             	mov    0x8(%ebp),%eax
  117f12:	0f bf 40 06          	movswl 0x6(%eax),%eax
  117f16:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  117f19:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  117f1d:	39 c8                	cmp    %ecx,%eax
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
  117f1f:	0f 8f 04 00 00 00    	jg     117f29 <lv_area_is_in+0x69>
        is_in = true;
  117f25:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
    }

    return is_in;
  117f29:	8a 45 fb             	mov    -0x5(%ebp),%al
  117f2c:	24 01                	and    $0x1,%al
  117f2e:	0f b6 c0             	movzbl %al,%eax
  117f31:	83 c4 04             	add    $0x4,%esp
  117f34:	5e                   	pop    %esi
  117f35:	5d                   	pop    %ebp
  117f36:	c3                   	ret    
  117f37:	66 90                	xchg   %ax,%ax
  117f39:	66 90                	xchg   %ax,%ax
  117f3b:	66 90                	xchg   %ax,%ax
  117f3d:	66 90                	xchg   %ax,%ax
  117f3f:	90                   	nop

00117f40 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
  117f40:	55                   	push   %ebp
  117f41:	89 e5                	mov    %esp,%ebp
  117f43:	83 ec 08             	sub    $0x8,%esp
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
  117f46:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  117f4c:	89 04 24             	mov    %eax,(%esp)
  117f4f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  117f56:	00 
  117f57:	e8 14 0b 00 00       	call   118a70 <lv_ll_init>

    /*Initially enable the lv_task handling*/
    lv_task_enable(true);
  117f5c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  117f63:	e8 08 00 00 00       	call   117f70 <lv_task_enable>
}
  117f68:	83 c4 08             	add    $0x8,%esp
  117f6b:	5d                   	pop    %ebp
  117f6c:	c3                   	ret    
  117f6d:	66 90                	xchg   %ax,%ax
  117f6f:	90                   	nop

00117f70 <lv_task_enable>:
/**
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
  117f70:	55                   	push   %ebp
  117f71:	89 e5                	mov    %esp,%ebp
  117f73:	50                   	push   %eax
  117f74:	8a 45 08             	mov    0x8(%ebp),%al
  117f77:	24 01                	and    $0x1,%al
  117f79:	88 45 ff             	mov    %al,-0x1(%ebp)
    lv_task_run = en;
  117f7c:	8a 45 ff             	mov    -0x1(%ebp),%al
  117f7f:	24 01                	and    $0x1,%al
  117f81:	a2 eb 0e 14 00       	mov    %al,0x140eeb
}
  117f86:	83 c4 04             	add    $0x4,%esp
  117f89:	5d                   	pop    %ebp
  117f8a:	c3                   	ret    
  117f8b:	66 90                	xchg   %ax,%ax
  117f8d:	66 90                	xchg   %ax,%ax
  117f8f:	90                   	nop

00117f90 <lv_task_handler>:
{
  117f90:	55                   	push   %ebp
  117f91:	89 e5                	mov    %esp,%ebp
  117f93:	83 ec 1c             	sub    $0x1c,%esp
    if(task_handler_mutex) return;
  117f96:	f6 05 ea 0e 14 00 01 	testb  $0x1,0x140eea
  117f9d:	0f 84 05 00 00 00    	je     117fa8 <lv_task_handler+0x18>
  117fa3:	e9 5d 02 00 00       	jmp    118205 <lv_task_handler+0x275>
    task_handler_mutex = true;
  117fa8:	c6 05 ea 0e 14 00 01 	movb   $0x1,0x140eea
    if(lv_task_run == false) {
  117faf:	a0 eb 0e 14 00       	mov    0x140eeb,%al
  117fb4:	24 01                	and    $0x1,%al
  117fb6:	0f b6 c8             	movzbl %al,%ecx
  117fb9:	83 f9 00             	cmp    $0x0,%ecx
  117fbc:	0f 85 0c 00 00 00    	jne    117fce <lv_task_handler+0x3e>
        task_handler_mutex = false; /*Release mutex*/
  117fc2:	c6 05 ea 0e 14 00 00 	movb   $0x0,0x140eea
        return;
  117fc9:	e9 37 02 00 00       	jmp    118205 <lv_task_handler+0x275>
    handler_start = lv_tick_get();
  117fce:	e8 fd f9 ff ff       	call   1179d0 <lv_tick_get>
  117fd3:	a3 6c 55 13 00       	mov    %eax,0x13556c
    lv_task_t * task_interrupter = NULL;
  117fd8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        end_flag                 = true;
  117fdf:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        task_deleted             = false;
  117fe3:	c6 05 ec 0e 14 00 00 	movb   $0x0,0x140eec
        task_created             = false;
  117fea:	c6 05 ed 0e 14 00 00 	movb   $0x0,0x140eed
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
  117ff1:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  117ff7:	89 04 24             	mov    %eax,(%esp)
  117ffa:	e8 b1 0d 00 00       	call   118db0 <lv_ll_get_head>
  117fff:	a3 b0 55 13 00       	mov    %eax,0x1355b0
        while(LV_GC_ROOT(_lv_task_act)) {
  118004:	83 3d b0 55 13 00 00 	cmpl   $0x0,0x1355b0
  11800b:	0f 84 4a 01 00 00    	je     11815b <lv_task_handler+0x1cb>
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
  118011:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118016:	8d 0d 7c 55 13 00    	lea    0x13557c,%ecx
  11801c:	89 0c 24             	mov    %ecx,(%esp)
  11801f:	89 44 24 04          	mov    %eax,0x4(%esp)
  118023:	e8 48 10 00 00       	call   119070 <lv_ll_get_next>
  118028:	89 45 f8             	mov    %eax,-0x8(%ebp)
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
  11802b:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118030:	8a 50 10             	mov    0x10(%eax),%dl
  118033:	80 e2 07             	and    $0x7,%dl
  118036:	0f b6 c2             	movzbl %dl,%eax
  118039:	83 f8 00             	cmp    $0x0,%eax
  11803c:	0f 85 05 00 00 00    	jne    118047 <lv_task_handler+0xb7>
                break;
  118042:	e9 14 01 00 00       	jmp    11815b <lv_task_handler+0x1cb>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
  118047:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  11804c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11804f:	39 c8                	cmp    %ecx,%eax
  118051:	0f 85 14 00 00 00    	jne    11806b <lv_task_handler+0xdb>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
  118057:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                LV_GC_ROOT(_lv_task_act) = next;
  11805e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118061:	a3 b0 55 13 00       	mov    %eax,0x1355b0
                continue; /*Load the next task*/
  118066:	e9 99 ff ff ff       	jmp    118004 <lv_task_handler+0x74>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
  11806b:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118070:	8a 48 10             	mov    0x10(%eax),%cl
  118073:	80 e1 07             	and    $0x7,%cl
  118076:	0f b6 c1             	movzbl %cl,%eax
  118079:	83 f8 05             	cmp    $0x5,%eax
  11807c:	0f 85 12 00 00 00    	jne    118094 <lv_task_handler+0x104>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
  118082:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118087:	89 04 24             	mov    %eax,(%esp)
  11808a:	e8 81 01 00 00       	call   118210 <lv_task_exec>
            }
  11808f:	e9 96 00 00 00       	jmp    11812a <lv_task_handler+0x19a>
            else if(task_interrupter) {
  118094:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  118098:	0f 84 57 00 00 00    	je     1180f5 <lv_task_handler+0x165>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
  11809e:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  1180a3:	8a 48 10             	mov    0x10(%eax),%cl
  1180a6:	80 e1 07             	and    $0x7,%cl
  1180a9:	0f b6 c1             	movzbl %cl,%eax
  1180ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1180af:	8a 4a 10             	mov    0x10(%edx),%cl
  1180b2:	80 e1 07             	and    $0x7,%cl
  1180b5:	0f b6 d1             	movzbl %cl,%edx
  1180b8:	39 d0                	cmp    %edx,%eax
  1180ba:	0f 8e 30 00 00 00    	jle    1180f0 <lv_task_handler+0x160>
                    if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
  1180c0:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  1180c5:	89 04 24             	mov    %eax,(%esp)
  1180c8:	e8 43 01 00 00       	call   118210 <lv_task_exec>
  1180cd:	a8 01                	test   $0x1,%al
  1180cf:	0f 85 05 00 00 00    	jne    1180da <lv_task_handler+0x14a>
  1180d5:	e9 11 00 00 00       	jmp    1180eb <lv_task_handler+0x15b>
                            LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
  1180da:	a1 b0 55 13 00       	mov    0x1355b0,%eax
                        task_interrupter =
  1180df:	89 45 fc             	mov    %eax,-0x4(%ebp)
                        end_flag = false;
  1180e2:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
                        break;
  1180e6:	e9 70 00 00 00       	jmp    11815b <lv_task_handler+0x1cb>
                }
  1180eb:	e9 00 00 00 00       	jmp    1180f0 <lv_task_handler+0x160>
            }
  1180f0:	e9 30 00 00 00       	jmp    118125 <lv_task_handler+0x195>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
  1180f5:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  1180fa:	89 04 24             	mov    %eax,(%esp)
  1180fd:	e8 0e 01 00 00       	call   118210 <lv_task_exec>
  118102:	a8 01                	test   $0x1,%al
  118104:	0f 85 05 00 00 00    	jne    11810f <lv_task_handler+0x17f>
  11810a:	e9 11 00 00 00       	jmp    118120 <lv_task_handler+0x190>
                    task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
  11810f:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118114:	89 45 fc             	mov    %eax,-0x4(%ebp)
                    end_flag         = false;
  118117:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
                    break;
  11811b:	e9 3b 00 00 00       	jmp    11815b <lv_task_handler+0x1cb>
  118120:	e9 00 00 00 00       	jmp    118125 <lv_task_handler+0x195>
  118125:	e9 00 00 00 00       	jmp    11812a <lv_task_handler+0x19a>
            if(task_deleted) break; /*If a task was deleted then this or the next item might be corrupted*/
  11812a:	f6 05 ec 0e 14 00 01 	testb  $0x1,0x140eec
  118131:	0f 84 05 00 00 00    	je     11813c <lv_task_handler+0x1ac>
  118137:	e9 1f 00 00 00       	jmp    11815b <lv_task_handler+0x1cb>
            if(task_created) break; /*If a task was created then this or the next item might be corrupted*/
  11813c:	f6 05 ed 0e 14 00 01 	testb  $0x1,0x140eed
  118143:	0f 84 05 00 00 00    	je     11814e <lv_task_handler+0x1be>
  118149:	e9 0d 00 00 00       	jmp    11815b <lv_task_handler+0x1cb>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
  11814e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118151:	a3 b0 55 13 00       	mov    %eax,0x1355b0
        while(LV_GC_ROOT(_lv_task_act)) {
  118156:	e9 a9 fe ff ff       	jmp    118004 <lv_task_handler+0x74>
    } while(!end_flag);
  11815b:	e9 00 00 00 00       	jmp    118160 <lv_task_handler+0x1d0>
  118160:	8a 45 f7             	mov    -0x9(%ebp),%al
  118163:	34 ff                	xor    $0xff,%al
  118165:	a8 01                	test   $0x1,%al
  118167:	0f 85 72 fe ff ff    	jne    117fdf <lv_task_handler+0x4f>
    busy_time += lv_tick_elaps(handler_start);
  11816d:	a1 6c 55 13 00       	mov    0x13556c,%eax
  118172:	89 04 24             	mov    %eax,(%esp)
  118175:	e8 76 f8 ff ff       	call   1179f0 <lv_tick_elaps>
  11817a:	03 05 70 55 13 00    	add    0x135570,%eax
  118180:	a3 70 55 13 00       	mov    %eax,0x135570
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
  118185:	a1 68 55 13 00       	mov    0x135568,%eax
  11818a:	89 04 24             	mov    %eax,(%esp)
  11818d:	e8 5e f8 ff ff       	call   1179f0 <lv_tick_elaps>
  118192:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
  118195:	81 7d f0 f4 01 00 00 	cmpl   $0x1f4,-0x10(%ebp)
  11819c:	0f 82 5c 00 00 00    	jb     1181fe <lv_task_handler+0x26e>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
  1181a2:	6b 05 70 55 13 00 64 	imul   $0x64,0x135570,%eax
  1181a9:	31 d2                	xor    %edx,%edx
  1181ab:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  1181b0:	f7 f1                	div    %ecx
  1181b2:	a2 ee 0e 14 00       	mov    %al,0x140eee
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
  1181b7:	0f b6 0d ee 0e 14 00 	movzbl 0x140eee,%ecx
  1181be:	83 f9 64             	cmp    $0x64,%ecx
  1181c1:	0f 8e 0a 00 00 00    	jle    1181d1 <lv_task_handler+0x241>
  1181c7:	31 c0                	xor    %eax,%eax
  1181c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1181cc:	e9 11 00 00 00       	jmp    1181e2 <lv_task_handler+0x252>
  1181d1:	0f b6 05 ee 0e 14 00 	movzbl 0x140eee,%eax
  1181d8:	b9 64 00 00 00       	mov    $0x64,%ecx
  1181dd:	29 c1                	sub    %eax,%ecx
  1181df:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1181e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1181e5:	a2 ee 0e 14 00       	mov    %al,0x140eee
        busy_time         = 0;
  1181ea:	c7 05 70 55 13 00 00 	movl   $0x0,0x135570
  1181f1:	00 00 00 
        idle_period_start = lv_tick_get();
  1181f4:	e8 d7 f7 ff ff       	call   1179d0 <lv_tick_get>
  1181f9:	a3 68 55 13 00       	mov    %eax,0x135568
    task_handler_mutex = false; /*Release the mutex*/
  1181fe:	c6 05 ea 0e 14 00 00 	movb   $0x0,0x140eea
}
  118205:	83 c4 1c             	add    $0x1c,%esp
  118208:	5d                   	pop    %ebp
  118209:	c3                   	ret    
  11820a:	66 90                	xchg   %ax,%ax
  11820c:	66 90                	xchg   %ax,%ax
  11820e:	66 90                	xchg   %ax,%ax

00118210 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
  118210:	55                   	push   %ebp
  118211:	89 e5                	mov    %esp,%ebp
  118213:	83 ec 10             	sub    $0x10,%esp
  118216:	8b 45 08             	mov    0x8(%ebp),%eax
    bool exec = false;
  118219:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
  11821d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118220:	8b 49 04             	mov    0x4(%ecx),%ecx
  118223:	89 0c 24             	mov    %ecx,(%esp)
  118226:	89 45 f4             	mov    %eax,-0xc(%ebp)
  118229:	e8 c2 f7 ff ff       	call   1179f0 <lv_tick_elaps>
  11822e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(elp >= task->period) {
  118231:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118234:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118237:	3b 01                	cmp    (%ecx),%eax
  118239:	0f 82 73 00 00 00    	jb     1182b2 <lv_task_exec+0xa2>
        task->last_run = lv_tick_get();
  11823f:	e8 8c f7 ff ff       	call   1179d0 <lv_tick_get>
  118244:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118247:	89 41 04             	mov    %eax,0x4(%ecx)
        task_deleted   = false;
  11824a:	c6 05 ec 0e 14 00 00 	movb   $0x0,0x140eec
        task_created   = false;
  118251:	c6 05 ed 0e 14 00 00 	movb   $0x0,0x140eed
        if(task->task_cb) task->task_cb(task);
  118258:	8b 45 08             	mov    0x8(%ebp),%eax
  11825b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  11825f:	0f 84 0e 00 00 00    	je     118273 <lv_task_exec+0x63>
  118265:	8b 45 08             	mov    0x8(%ebp),%eax
  118268:	8b 40 08             	mov    0x8(%eax),%eax
  11826b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11826e:	89 0c 24             	mov    %ecx,(%esp)
  118271:	ff d0                	call   *%eax

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
  118273:	a0 ec 0e 14 00       	mov    0x140eec,%al
  118278:	24 01                	and    $0x1,%al
  11827a:	0f b6 c8             	movzbl %al,%ecx
  11827d:	83 f9 00             	cmp    $0x0,%ecx
  118280:	0f 85 28 00 00 00    	jne    1182ae <lv_task_exec+0x9e>
            if(task->once != 0) {
  118286:	8b 45 08             	mov    0x8(%ebp),%eax
  118289:	8a 48 10             	mov    0x10(%eax),%cl
  11828c:	c0 e9 03             	shr    $0x3,%cl
  11828f:	80 e1 01             	and    $0x1,%cl
  118292:	0f b6 c1             	movzbl %cl,%eax
  118295:	83 f8 00             	cmp    $0x0,%eax
  118298:	0f 84 0b 00 00 00    	je     1182a9 <lv_task_exec+0x99>
                lv_task_del(task);
  11829e:	8b 45 08             	mov    0x8(%ebp),%eax
  1182a1:	89 04 24             	mov    %eax,(%esp)
  1182a4:	e8 27 04 00 00       	call   1186d0 <lv_task_del>
            }
        }
  1182a9:	e9 00 00 00 00       	jmp    1182ae <lv_task_exec+0x9e>
        exec = true;
  1182ae:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
    }

    return exec;
  1182b2:	8a 45 ff             	mov    -0x1(%ebp),%al
  1182b5:	24 01                	and    $0x1,%al
  1182b7:	0f b6 c0             	movzbl %al,%eax
  1182ba:	83 c4 10             	add    $0x10,%esp
  1182bd:	5d                   	pop    %ebp
  1182be:	c3                   	ret    
  1182bf:	90                   	nop

001182c0 <lv_task_create_basic>:
{
  1182c0:	55                   	push   %ebp
  1182c1:	89 e5                	mov    %esp,%ebp
  1182c3:	83 ec 1c             	sub    $0x1c,%esp
    lv_task_t * new_task = NULL;
  1182c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
  1182cd:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  1182d3:	89 04 24             	mov    %eax,(%esp)
  1182d6:	e8 d5 0a 00 00       	call   118db0 <lv_ll_get_head>
  1182db:	31 c9                	xor    %ecx,%ecx
  1182dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(NULL == tmp) {
  1182e0:	3b 4d f4             	cmp    -0xc(%ebp),%ecx
  1182e3:	0f 85 63 00 00 00    	jne    11834c <lv_task_create_basic+0x8c>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
  1182e9:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  1182ef:	89 04 24             	mov    %eax,(%esp)
  1182f2:	e8 c9 07 00 00       	call   118ac0 <lv_ll_ins_head>
  1182f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        lv_mem_assert(new_task);
  1182fa:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1182fe:	0f 85 2d 00 00 00    	jne    118331 <lv_task_create_basic+0x71>
  118304:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11830b:	8d 05 5d 45 12 00    	lea    0x12455d,%eax
  118311:	89 44 24 04          	mov    %eax,0x4(%esp)
  118315:	c7 44 24 08 b0 00 00 	movl   $0xb0,0x8(%esp)
  11831c:	00 
  11831d:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  118323:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118327:	e8 14 17 00 00       	call   119a40 <lv_log_add>
  11832c:	e9 fb ff ff ff       	jmp    11832c <lv_task_create_basic+0x6c>
        if(new_task == NULL) return NULL;
  118331:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118335:	0f 85 0c 00 00 00    	jne    118347 <lv_task_create_basic+0x87>
  11833b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118342:	e9 6d 01 00 00       	jmp    1184b4 <lv_task_create_basic+0x1f4>
    }
  118347:	e9 18 01 00 00       	jmp    118464 <lv_task_create_basic+0x1a4>
        do {
  11834c:	e9 00 00 00 00       	jmp    118351 <lv_task_create_basic+0x91>
            if(tmp->prio <= DEF_PRIO) {
  118351:	8b 45 f4             	mov    -0xc(%ebp),%eax
  118354:	8a 48 10             	mov    0x10(%eax),%cl
  118357:	80 e1 07             	and    $0x7,%cl
  11835a:	0f b6 c1             	movzbl %cl,%eax
  11835d:	83 f8 03             	cmp    $0x3,%eax
  118360:	0f 8f 6a 00 00 00    	jg     1183d0 <lv_task_create_basic+0x110>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
  118366:	8b 45 f4             	mov    -0xc(%ebp),%eax
  118369:	8d 0d 7c 55 13 00    	lea    0x13557c,%ecx
  11836f:	89 0c 24             	mov    %ecx,(%esp)
  118372:	89 44 24 04          	mov    %eax,0x4(%esp)
  118376:	e8 15 09 00 00       	call   118c90 <lv_ll_ins_prev>
  11837b:	89 45 f8             	mov    %eax,-0x8(%ebp)
                lv_mem_assert(new_task);
  11837e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118382:	0f 85 2d 00 00 00    	jne    1183b5 <lv_task_create_basic+0xf5>
  118388:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11838f:	8d 05 5d 45 12 00    	lea    0x12455d,%eax
  118395:	89 44 24 04          	mov    %eax,0x4(%esp)
  118399:	c7 44 24 08 b8 00 00 	movl   $0xb8,0x8(%esp)
  1183a0:	00 
  1183a1:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  1183a7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1183ab:	e8 90 16 00 00       	call   119a40 <lv_log_add>
  1183b0:	e9 fb ff ff ff       	jmp    1183b0 <lv_task_create_basic+0xf0>
                if(new_task == NULL) return NULL;
  1183b5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1183b9:	0f 85 0c 00 00 00    	jne    1183cb <lv_task_create_basic+0x10b>
  1183bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1183c6:	e9 e9 00 00 00       	jmp    1184b4 <lv_task_create_basic+0x1f4>
                break;
  1183cb:	e9 22 00 00 00       	jmp    1183f2 <lv_task_create_basic+0x132>
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
  1183d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1183d3:	8d 0d 7c 55 13 00    	lea    0x13557c,%ecx
  1183d9:	89 0c 24             	mov    %ecx,(%esp)
  1183dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1183e0:	e8 8b 0c 00 00       	call   119070 <lv_ll_get_next>
  1183e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        } while(tmp != NULL);
  1183e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1183ec:	0f 85 5f ff ff ff    	jne    118351 <lv_task_create_basic+0x91>
        if(tmp == NULL) {
  1183f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1183f6:	0f 85 63 00 00 00    	jne    11845f <lv_task_create_basic+0x19f>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
  1183fc:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  118402:	89 04 24             	mov    %eax,(%esp)
  118405:	e8 26 0a 00 00       	call   118e30 <lv_ll_ins_tail>
  11840a:	89 45 f8             	mov    %eax,-0x8(%ebp)
            lv_mem_assert(new_task);
  11840d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118411:	0f 85 2d 00 00 00    	jne    118444 <lv_task_create_basic+0x184>
  118417:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11841e:	8d 05 5d 45 12 00    	lea    0x12455d,%eax
  118424:	89 44 24 04          	mov    %eax,0x4(%esp)
  118428:	c7 44 24 08 c2 00 00 	movl   $0xc2,0x8(%esp)
  11842f:	00 
  118430:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  118436:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11843a:	e8 01 16 00 00       	call   119a40 <lv_log_add>
  11843f:	e9 fb ff ff ff       	jmp    11843f <lv_task_create_basic+0x17f>
            if(new_task == NULL) return NULL;
  118444:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118448:	0f 85 0c 00 00 00    	jne    11845a <lv_task_create_basic+0x19a>
  11844e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118455:	e9 5a 00 00 00       	jmp    1184b4 <lv_task_create_basic+0x1f4>
        }
  11845a:	e9 00 00 00 00       	jmp    11845f <lv_task_create_basic+0x19f>
  11845f:	e9 00 00 00 00       	jmp    118464 <lv_task_create_basic+0x1a4>
    new_task->period  = DEF_PERIOD;
  118464:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118467:	c7 00 f4 01 00 00    	movl   $0x1f4,(%eax)
    new_task->task_cb = NULL;
  11846d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118470:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    new_task->prio    = DEF_PRIO;
  118477:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11847a:	8a 48 10             	mov    0x10(%eax),%cl
  11847d:	80 e1 f8             	and    $0xf8,%cl
  118480:	80 c9 03             	or     $0x3,%cl
  118483:	88 48 10             	mov    %cl,0x10(%eax)
    new_task->once     = 0;
  118486:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118489:	8a 48 10             	mov    0x10(%eax),%cl
  11848c:	80 e1 f7             	and    $0xf7,%cl
  11848f:	88 48 10             	mov    %cl,0x10(%eax)
    new_task->last_run = lv_tick_get();
  118492:	e8 39 f5 ff ff       	call   1179d0 <lv_tick_get>
  118497:	8b 55 f8             	mov    -0x8(%ebp),%edx
  11849a:	89 42 04             	mov    %eax,0x4(%edx)
    new_task->user_data = NULL;
  11849d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1184a0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task_created = true;
  1184a7:	c6 05 ed 0e 14 00 01 	movb   $0x1,0x140eed
    return new_task;
  1184ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1184b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1184b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1184b7:	83 c4 1c             	add    $0x1c,%esp
  1184ba:	5d                   	pop    %ebp
  1184bb:	c3                   	ret    
  1184bc:	66 90                	xchg   %ax,%ax
  1184be:	66 90                	xchg   %ax,%ax

001184c0 <lv_task_create>:
{
  1184c0:	55                   	push   %ebp
  1184c1:	89 e5                	mov    %esp,%ebp
  1184c3:	56                   	push   %esi
  1184c4:	83 ec 28             	sub    $0x28,%esp
  1184c7:	8b 45 14             	mov    0x14(%ebp),%eax
  1184ca:	8a 4d 10             	mov    0x10(%ebp),%cl
  1184cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1184d0:	8b 75 08             	mov    0x8(%ebp),%esi
  1184d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1184d6:	88 4d ef             	mov    %cl,-0x11(%ebp)
  1184d9:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1184dc:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    lv_task_t * new_task = lv_task_create_basic();
  1184df:	e8 dc fd ff ff       	call   1182c0 <lv_task_create_basic>
  1184e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lv_mem_assert(new_task);
  1184e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1184eb:	0f 85 2d 00 00 00    	jne    11851e <lv_task_create+0x5e>
  1184f1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1184f8:	8d 05 5d 45 12 00    	lea    0x12455d,%eax
  1184fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  118502:	c7 44 24 08 e2 00 00 	movl   $0xe2,0x8(%esp)
  118509:	00 
  11850a:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  118510:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118514:	e8 27 15 00 00       	call   119a40 <lv_log_add>
  118519:	e9 fb ff ff ff       	jmp    118519 <lv_task_create+0x59>
    if(new_task == NULL) return NULL;
  11851e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  118522:	0f 85 0c 00 00 00    	jne    118534 <lv_task_create+0x74>
  118528:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11852f:	e9 46 00 00 00       	jmp    11857a <lv_task_create+0xba>
    lv_task_set_cb(new_task, task_cb);
  118534:	8b 45 f4             	mov    -0xc(%ebp),%eax
  118537:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11853a:	89 04 24             	mov    %eax,(%esp)
  11853d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118541:	e8 4a 00 00 00       	call   118590 <lv_task_set_cb>
    lv_task_set_period(new_task, period);
  118546:	8b 45 f4             	mov    -0xc(%ebp),%eax
  118549:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11854c:	89 04 24             	mov    %eax,(%esp)
  11854f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118553:	e8 58 00 00 00       	call   1185b0 <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
  118558:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11855b:	89 04 24             	mov    %eax,(%esp)
  11855e:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  118562:	89 44 24 04          	mov    %eax,0x4(%esp)
  118566:	e8 65 00 00 00       	call   1185d0 <lv_task_set_prio>
    new_task->user_data = user_data;
  11856b:	8b 45 14             	mov    0x14(%ebp),%eax
  11856e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  118571:	89 41 0c             	mov    %eax,0xc(%ecx)
    return new_task;
  118574:	8b 45 f4             	mov    -0xc(%ebp),%eax
  118577:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  11857a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11857d:	83 c4 28             	add    $0x28,%esp
  118580:	5e                   	pop    %esi
  118581:	5d                   	pop    %ebp
  118582:	c3                   	ret    
  118583:	66 90                	xchg   %ax,%ax
  118585:	66 90                	xchg   %ax,%ax
  118587:	66 90                	xchg   %ax,%ax
  118589:	66 90                	xchg   %ax,%ax
  11858b:	66 90                	xchg   %ax,%ax
  11858d:	66 90                	xchg   %ax,%ax
  11858f:	90                   	nop

00118590 <lv_task_set_cb>:
{
  118590:	55                   	push   %ebp
  118591:	89 e5                	mov    %esp,%ebp
  118593:	56                   	push   %esi
  118594:	8b 45 0c             	mov    0xc(%ebp),%eax
  118597:	8b 4d 08             	mov    0x8(%ebp),%ecx
    task->task_cb = task_cb;
  11859a:	8b 55 0c             	mov    0xc(%ebp),%edx
  11859d:	8b 75 08             	mov    0x8(%ebp),%esi
  1185a0:	89 56 08             	mov    %edx,0x8(%esi)
}
  1185a3:	5e                   	pop    %esi
  1185a4:	5d                   	pop    %ebp
  1185a5:	c3                   	ret    
  1185a6:	66 90                	xchg   %ax,%ax
  1185a8:	66 90                	xchg   %ax,%ax
  1185aa:	66 90                	xchg   %ax,%ax
  1185ac:	66 90                	xchg   %ax,%ax
  1185ae:	66 90                	xchg   %ax,%ax

001185b0 <lv_task_set_period>:
{
  1185b0:	55                   	push   %ebp
  1185b1:	89 e5                	mov    %esp,%ebp
  1185b3:	56                   	push   %esi
  1185b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1185b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    task->period = period;
  1185ba:	8b 55 0c             	mov    0xc(%ebp),%edx
  1185bd:	8b 75 08             	mov    0x8(%ebp),%esi
  1185c0:	89 16                	mov    %edx,(%esi)
}
  1185c2:	5e                   	pop    %esi
  1185c3:	5d                   	pop    %ebp
  1185c4:	c3                   	ret    
  1185c5:	66 90                	xchg   %ax,%ax
  1185c7:	66 90                	xchg   %ax,%ax
  1185c9:	66 90                	xchg   %ax,%ax
  1185cb:	66 90                	xchg   %ax,%ax
  1185cd:	66 90                	xchg   %ax,%ax
  1185cf:	90                   	nop

001185d0 <lv_task_set_prio>:
{
  1185d0:	55                   	push   %ebp
  1185d1:	89 e5                	mov    %esp,%ebp
  1185d3:	56                   	push   %esi
  1185d4:	83 ec 14             	sub    $0x14,%esp
  1185d7:	8a 45 0c             	mov    0xc(%ebp),%al
  1185da:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(task->prio == prio) return;
  1185dd:	8b 55 08             	mov    0x8(%ebp),%edx
  1185e0:	8a 62 10             	mov    0x10(%edx),%ah
  1185e3:	80 e4 07             	and    $0x7,%ah
  1185e6:	0f b6 d4             	movzbl %ah,%edx
  1185e9:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  1185ed:	39 f2                	cmp    %esi,%edx
  1185ef:	0f 85 05 00 00 00    	jne    1185fa <lv_task_set_prio+0x2a>
  1185f5:	e9 c1 00 00 00       	jmp    1186bb <lv_task_set_prio+0xeb>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
  1185fa:	8d 05 7c 55 13 00    	lea    0x13557c,%eax
  118600:	89 04 24             	mov    %eax,(%esp)
  118603:	e8 a8 07 00 00       	call   118db0 <lv_ll_get_head>
  118608:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11860b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  11860f:	0f 84 67 00 00 00    	je     11867c <lv_task_set_prio+0xac>
        if(i->prio <= prio) {
  118615:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118618:	8a 48 10             	mov    0x10(%eax),%cl
  11861b:	80 e1 07             	and    $0x7,%cl
  11861e:	0f b6 c1             	movzbl %cl,%eax
  118621:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
  118625:	39 d0                	cmp    %edx,%eax
  118627:	0f 8f 2d 00 00 00    	jg     11865a <lv_task_set_prio+0x8a>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
  11862d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118630:	3b 45 08             	cmp    0x8(%ebp),%eax
  118633:	0f 84 1c 00 00 00    	je     118655 <lv_task_set_prio+0x85>
  118639:	8b 45 08             	mov    0x8(%ebp),%eax
  11863c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11863f:	8d 15 7c 55 13 00    	lea    0x13557c,%edx
  118645:	89 14 24             	mov    %edx,(%esp)
  118648:	89 44 24 04          	mov    %eax,0x4(%esp)
  11864c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  118650:	e8 9b 0a 00 00       	call   1190f0 <lv_ll_move_before>
            break;
  118655:	e9 22 00 00 00       	jmp    11867c <lv_task_set_prio+0xac>
    }
  11865a:	e9 00 00 00 00       	jmp    11865f <lv_task_set_prio+0x8f>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
  11865f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118662:	8d 0d 7c 55 13 00    	lea    0x13557c,%ecx
  118668:	89 0c 24             	mov    %ecx,(%esp)
  11866b:	89 44 24 04          	mov    %eax,0x4(%esp)
  11866f:	e8 fc 09 00 00       	call   119070 <lv_ll_get_next>
  118674:	89 45 f8             	mov    %eax,-0x8(%ebp)
  118677:	e9 8f ff ff ff       	jmp    11860b <lv_task_set_prio+0x3b>
    if(i == NULL) {
  11867c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118680:	0f 85 22 00 00 00    	jne    1186a8 <lv_task_set_prio+0xd8>
  118686:	31 c0                	xor    %eax,%eax
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
  118688:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11868b:	8d 15 7c 55 13 00    	lea    0x13557c,%edx
  118691:	89 14 24             	mov    %edx,(%esp)
  118694:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118698:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11869f:	00 
  1186a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1186a3:	e8 48 0a 00 00       	call   1190f0 <lv_ll_move_before>
    task->prio = prio;
  1186a8:	8a 45 0c             	mov    0xc(%ebp),%al
  1186ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1186ae:	8a 51 10             	mov    0x10(%ecx),%dl
  1186b1:	24 07                	and    $0x7,%al
  1186b3:	80 e2 f8             	and    $0xf8,%dl
  1186b6:	08 c2                	or     %al,%dl
  1186b8:	88 51 10             	mov    %dl,0x10(%ecx)
}
  1186bb:	83 c4 14             	add    $0x14,%esp
  1186be:	5e                   	pop    %esi
  1186bf:	5d                   	pop    %ebp
  1186c0:	c3                   	ret    
  1186c1:	66 90                	xchg   %ax,%ax
  1186c3:	66 90                	xchg   %ax,%ax
  1186c5:	66 90                	xchg   %ax,%ax
  1186c7:	66 90                	xchg   %ax,%ax
  1186c9:	66 90                	xchg   %ax,%ax
  1186cb:	66 90                	xchg   %ax,%ax
  1186cd:	66 90                	xchg   %ax,%ax
  1186cf:	90                   	nop

001186d0 <lv_task_del>:
{
  1186d0:	55                   	push   %ebp
  1186d1:	89 e5                	mov    %esp,%ebp
  1186d3:	83 ec 0c             	sub    $0xc,%esp
  1186d6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
  1186d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1186dc:	8d 15 7c 55 13 00    	lea    0x13557c,%edx
  1186e2:	89 14 24             	mov    %edx,(%esp)
  1186e5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1186e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1186ec:	e8 1f 08 00 00       	call   118f10 <lv_ll_rem>
    lv_mem_free(task);
  1186f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1186f4:	89 04 24             	mov    %eax,(%esp)
  1186f7:	e8 64 01 00 00       	call   118860 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
  1186fc:	a1 b0 55 13 00       	mov    0x1355b0,%eax
  118701:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118704:	39 c8                	cmp    %ecx,%eax
  118706:	0f 85 07 00 00 00    	jne    118713 <lv_task_del+0x43>
  11870c:	c6 05 ec 0e 14 00 01 	movb   $0x1,0x140eec
}
  118713:	83 c4 0c             	add    $0xc,%esp
  118716:	5d                   	pop    %ebp
  118717:	c3                   	ret    
  118718:	66 90                	xchg   %ax,%ax
  11871a:	66 90                	xchg   %ax,%ax
  11871c:	66 90                	xchg   %ax,%ax
  11871e:	66 90                	xchg   %ax,%ax

00118720 <lv_task_ready>:
{
  118720:	55                   	push   %ebp
  118721:	89 e5                	mov    %esp,%ebp
  118723:	50                   	push   %eax
  118724:	8b 45 08             	mov    0x8(%ebp),%eax
  118727:	89 45 fc             	mov    %eax,-0x4(%ebp)
    task->last_run = lv_tick_get() - task->period - 1;
  11872a:	e8 a1 f2 ff ff       	call   1179d0 <lv_tick_get>
  11872f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118732:	2b 01                	sub    (%ecx),%eax
  118734:	83 e8 01             	sub    $0x1,%eax
  118737:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11873a:	89 41 04             	mov    %eax,0x4(%ecx)
}
  11873d:	83 c4 04             	add    $0x4,%esp
  118740:	5d                   	pop    %ebp
  118741:	c3                   	ret    
  118742:	66 90                	xchg   %ax,%ax
  118744:	66 90                	xchg   %ax,%ax
  118746:	66 90                	xchg   %ax,%ax
  118748:	66 90                	xchg   %ax,%ax
  11874a:	66 90                	xchg   %ax,%ax
  11874c:	66 90                	xchg   %ax,%ax
  11874e:	66 90                	xchg   %ax,%ax

00118750 <lv_mem_init>:

/**
 * Initiaiize the dyn_mem module (work memory and other variables)
 */
void lv_mem_init(void)
{
  118750:	55                   	push   %ebp
  118751:	89 e5                	mov    %esp,%ebp
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
  118753:	5d                   	pop    %ebp
  118754:	c3                   	ret    
  118755:	66 90                	xchg   %ax,%ax
  118757:	66 90                	xchg   %ax,%ax
  118759:	66 90                	xchg   %ax,%ax
  11875b:	66 90                	xchg   %ax,%ax
  11875d:	66 90                	xchg   %ax,%ax
  11875f:	90                   	nop

00118760 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(uint32_t size)
{
  118760:	55                   	push   %ebp
  118761:	89 e5                	mov    %esp,%ebp
  118763:	83 ec 18             	sub    $0x18,%esp
  118766:	8b 45 08             	mov    0x8(%ebp),%eax
    if(size == 0) {
  118769:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11876d:	0f 85 0e 00 00 00    	jne    118781 <lv_mem_alloc+0x21>
  118773:	8d 05 74 55 13 00    	lea    0x135574,%eax
        return &zero_mem;
  118779:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11877c:	e9 cc 00 00 00       	jmp    11884d <lv_mem_alloc+0xed>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
  118781:	8b 45 08             	mov    0x8(%ebp),%eax
  118784:	83 e0 03             	and    $0x3,%eax
  118787:	83 f8 00             	cmp    $0x0,%eax
  11878a:	0f 84 12 00 00 00    	je     1187a2 <lv_mem_alloc+0x42>
        size = size & (~0x3);
  118790:	8b 45 08             	mov    0x8(%ebp),%eax
  118793:	83 e0 fc             	and    $0xfffffffc,%eax
  118796:	89 45 08             	mov    %eax,0x8(%ebp)
        size += 4;
  118799:	8b 45 08             	mov    0x8(%ebp),%eax
  11879c:	83 c0 04             	add    $0x4,%eax
  11879f:	89 45 08             	mov    %eax,0x8(%ebp)
    }
#endif
    void * alloc = NULL;
  1187a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
  1187a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1187ac:	83 c0 04             	add    $0x4,%eax
  1187af:	89 04 24             	mov    %eax,(%esp)
  1187b2:	e8 69 53 00 00       	call   11db20 <k_malloc>
  1187b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(alloc != NULL) {
  1187ba:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1187be:	0f 84 2d 00 00 00    	je     1187f1 <lv_mem_alloc+0x91>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
  1187c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1187c7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1187ca:	8b 11                	mov    (%ecx),%edx
  1187cc:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
  1187d1:	c1 e0 01             	shl    $0x1,%eax
  1187d4:	83 e2 01             	and    $0x1,%edx
  1187d7:	09 c2                	or     %eax,%edx
  1187d9:	89 11                	mov    %edx,(%ecx)
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
  1187db:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1187de:	8b 08                	mov    (%eax),%ecx
  1187e0:	83 e1 fe             	and    $0xfffffffe,%ecx
  1187e3:	83 c9 01             	or     $0x1,%ecx
  1187e6:	89 08                	mov    %ecx,(%eax)

        alloc = &((lv_mem_ent_t *)alloc)->first_data;
  1187e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1187eb:	83 c0 04             	add    $0x4,%eax
  1187ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
#endif                /* LV_ENABLE_GC */
#endif                /* LV_MEM_CUSTOM */

#if LV_MEM_ADD_JUNK
    if(alloc != NULL) memset(alloc, 0xaa, size);
  1187f1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1187f5:	0f 84 1a 00 00 00    	je     118815 <lv_mem_alloc+0xb5>
  1187fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1187fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118801:	89 04 24             	mov    %eax,(%esp)
  118804:	c7 44 24 04 aa 00 00 	movl   $0xaa,0x4(%esp)
  11880b:	00 
  11880c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  118810:	e8 5b 1c ff ff       	call   10a470 <memset>
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");
  118815:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118819:	0f 85 28 00 00 00    	jne    118847 <lv_mem_alloc+0xe7>
  11881f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  118826:	8d 05 a2 45 12 00    	lea    0x1245a2,%eax
  11882c:	89 44 24 04          	mov    %eax,0x4(%esp)
  118830:	c7 44 24 08 a5 00 00 	movl   $0xa5,0x8(%esp)
  118837:	00 
  118838:	8d 05 e6 45 12 00    	lea    0x1245e6,%eax
  11883e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118842:	e8 f9 11 00 00       	call   119a40 <lv_log_add>

    return alloc;
  118847:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11884a:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  11884d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118850:	83 c4 18             	add    $0x18,%esp
  118853:	5d                   	pop    %ebp
  118854:	c3                   	ret    
  118855:	66 90                	xchg   %ax,%ax
  118857:	66 90                	xchg   %ax,%ax
  118859:	66 90                	xchg   %ax,%ax
  11885b:	66 90                	xchg   %ax,%ax
  11885d:	66 90                	xchg   %ax,%ax
  11885f:	90                   	nop

00118860 <lv_mem_free>:
/**
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
  118860:	55                   	push   %ebp
  118861:	89 e5                	mov    %esp,%ebp
  118863:	83 ec 18             	sub    $0x18,%esp
  118866:	8b 45 08             	mov    0x8(%ebp),%eax
  118869:	8d 0d 74 55 13 00    	lea    0x135574,%ecx
    if(data == &zero_mem) return;
  11886f:	39 4d 08             	cmp    %ecx,0x8(%ebp)
  118872:	0f 85 05 00 00 00    	jne    11887d <lv_mem_free+0x1d>
  118878:	e9 58 00 00 00       	jmp    1188d5 <lv_mem_free+0x75>
    if(data == NULL) return;
  11887d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  118881:	0f 85 05 00 00 00    	jne    11888c <lv_mem_free+0x2c>
  118887:	e9 49 00 00 00       	jmp    1188d5 <lv_mem_free+0x75>

#if LV_MEM_ADD_JUNK
    memset((void *)data, 0xbb, lv_mem_get_size(data));
  11888c:	8b 45 08             	mov    0x8(%ebp),%eax
  11888f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118892:	89 0c 24             	mov    %ecx,(%esp)
  118895:	89 45 f8             	mov    %eax,-0x8(%ebp)
  118898:	e8 43 00 00 00       	call   1188e0 <lv_mem_get_size>
  11889d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1188a0:	89 0c 24             	mov    %ecx,(%esp)
  1188a3:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  1188aa:	00 
  1188ab:	89 44 24 08          	mov    %eax,0x8(%esp)
  1188af:	e8 bc 1b ff ff       	call   10a470 <memset>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
  1188b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1188b7:	83 c1 fc             	add    $0xfffffffc,%ecx
  1188ba:	89 4d fc             	mov    %ecx,-0x4(%ebp)
    e->header.s.used = 0;
  1188bd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1188c0:	8b 11                	mov    (%ecx),%edx
  1188c2:	83 e2 fe             	and    $0xfffffffe,%edx
  1188c5:	89 11                	mov    %edx,(%ecx)
        e_next = ent_get_next(e_next);
    }
#endif
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
  1188c7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1188ca:	89 0c 24             	mov    %ecx,(%esp)
  1188cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1188d0:	e8 1b 52 00 00       	call   11daf0 <k_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
  1188d5:	83 c4 18             	add    $0x18,%esp
  1188d8:	5d                   	pop    %ebp
  1188d9:	c3                   	ret    
  1188da:	66 90                	xchg   %ax,%ax
  1188dc:	66 90                	xchg   %ax,%ax
  1188de:	66 90                	xchg   %ax,%ax

001188e0 <lv_mem_get_size>:
 */

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
  1188e0:	55                   	push   %ebp
  1188e1:	89 e5                	mov    %esp,%ebp
  1188e3:	83 ec 08             	sub    $0x8,%esp
  1188e6:	8b 45 08             	mov    0x8(%ebp),%eax
    if(data == NULL) return 0;
  1188e9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1188ed:	0f 85 0c 00 00 00    	jne    1188ff <lv_mem_get_size+0x1f>
  1188f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1188fa:	e9 2f 00 00 00       	jmp    11892e <lv_mem_get_size+0x4e>
  1188ff:	8d 05 74 55 13 00    	lea    0x135574,%eax
    if(data == &zero_mem) return 0;
  118905:	39 45 08             	cmp    %eax,0x8(%ebp)
  118908:	0f 85 0c 00 00 00    	jne    11891a <lv_mem_get_size+0x3a>
  11890e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118915:	e9 14 00 00 00       	jmp    11892e <lv_mem_get_size+0x4e>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
  11891a:	8b 45 08             	mov    0x8(%ebp),%eax
  11891d:	83 c0 fc             	add    $0xfffffffc,%eax
  118920:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return e->header.s.d_size;
  118923:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118926:	8b 00                	mov    (%eax),%eax
  118928:	c1 e8 01             	shr    $0x1,%eax
  11892b:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  11892e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118931:	83 c4 08             	add    $0x8,%esp
  118934:	5d                   	pop    %ebp
  118935:	c3                   	ret    
  118936:	66 90                	xchg   %ax,%ax
  118938:	66 90                	xchg   %ax,%ax
  11893a:	66 90                	xchg   %ax,%ax
  11893c:	66 90                	xchg   %ax,%ax
  11893e:	66 90                	xchg   %ax,%ax

00118940 <lv_mem_realloc>:
{
  118940:	55                   	push   %ebp
  118941:	89 e5                	mov    %esp,%ebp
  118943:	83 ec 30             	sub    $0x30,%esp
  118946:	8b 45 0c             	mov    0xc(%ebp),%eax
  118949:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(data_p != NULL) {
  11894c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  118950:	0f 84 26 00 00 00    	je     11897c <lv_mem_realloc+0x3c>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
  118956:	8b 45 08             	mov    0x8(%ebp),%eax
  118959:	83 c0 fc             	add    $0xfffffffc,%eax
  11895c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(e->header.s.used == 0) {
  11895f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118962:	8b 00                	mov    (%eax),%eax
  118964:	83 e0 01             	and    $0x1,%eax
  118967:	83 f8 00             	cmp    $0x0,%eax
  11896a:	0f 85 07 00 00 00    	jne    118977 <lv_mem_realloc+0x37>
            data_p = NULL;
  118970:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
    }
  118977:	e9 00 00 00 00       	jmp    11897c <lv_mem_realloc+0x3c>
    uint32_t old_size = lv_mem_get_size(data_p);
  11897c:	8b 45 08             	mov    0x8(%ebp),%eax
  11897f:	89 04 24             	mov    %eax,(%esp)
  118982:	e8 59 ff ff ff       	call   1188e0 <lv_mem_get_size>
  118987:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
  11898a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11898d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  118990:	0f 85 0b 00 00 00    	jne    1189a1 <lv_mem_realloc+0x61>
  118996:	8b 45 08             	mov    0x8(%ebp),%eax
  118999:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11899c:	e9 b9 00 00 00       	jmp    118a5a <lv_mem_realloc+0x11a>
    new_p = lv_mem_alloc(new_size);
  1189a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1189a4:	89 04 24             	mov    %eax,(%esp)
  1189a7:	e8 b4 fd ff ff       	call   118760 <lv_mem_alloc>
  1189ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(new_p != NULL && data_p != NULL) {
  1189af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1189b3:	0f 84 69 00 00 00    	je     118a22 <lv_mem_realloc+0xe2>
  1189b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1189bd:	0f 84 5f 00 00 00    	je     118a22 <lv_mem_realloc+0xe2>
        if(old_size != 0) {
  1189c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1189c7:	0f 84 50 00 00 00    	je     118a1d <lv_mem_realloc+0xdd>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
  1189cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1189d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1189d3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1189d6:	3b 55 f4             	cmp    -0xc(%ebp),%edx
  1189d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1189dc:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1189df:	0f 83 0b 00 00 00    	jae    1189f0 <lv_mem_realloc+0xb0>
  1189e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1189e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1189eb:	e9 06 00 00 00       	jmp    1189f6 <lv_mem_realloc+0xb6>
  1189f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1189f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1189f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1189f9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1189fc:	89 0c 24             	mov    %ecx,(%esp)
  1189ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
  118a02:	89 54 24 04          	mov    %edx,0x4(%esp)
  118a06:	89 44 24 08          	mov    %eax,0x8(%esp)
  118a0a:	e8 41 19 ff ff       	call   10a350 <memcpy>
            lv_mem_free(data_p);
  118a0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118a12:	89 0c 24             	mov    %ecx,(%esp)
  118a15:	89 45 e0             	mov    %eax,-0x20(%ebp)
  118a18:	e8 43 fe ff ff       	call   118860 <lv_mem_free>
    }
  118a1d:	e9 00 00 00 00       	jmp    118a22 <lv_mem_realloc+0xe2>
    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");
  118a22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  118a26:	0f 85 28 00 00 00    	jne    118a54 <lv_mem_realloc+0x114>
  118a2c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  118a33:	8d 05 a2 45 12 00    	lea    0x1245a2,%eax
  118a39:	89 44 24 04          	mov    %eax,0x4(%esp)
  118a3d:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  118a44:	00 
  118a45:	8d 05 e6 45 12 00    	lea    0x1245e6,%eax
  118a4b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  118a4f:	e8 ec 0f 00 00       	call   119a40 <lv_log_add>
    return new_p;
  118a54:	8b 45 f0             	mov    -0x10(%ebp),%eax
  118a57:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  118a5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118a5d:	83 c4 30             	add    $0x30,%esp
  118a60:	5d                   	pop    %ebp
  118a61:	c3                   	ret    
  118a62:	66 90                	xchg   %ax,%ax
  118a64:	66 90                	xchg   %ax,%ax
  118a66:	66 90                	xchg   %ax,%ax
  118a68:	66 90                	xchg   %ax,%ax
  118a6a:	66 90                	xchg   %ax,%ax
  118a6c:	66 90                	xchg   %ax,%ax
  118a6e:	66 90                	xchg   %ax,%ax

00118a70 <lv_ll_init>:
 * Initialize linked list
 * @param ll_dsc pointer to ll_dsc variable
 * @param node_size the size of 1 node in bytes
 */
void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
  118a70:	55                   	push   %ebp
  118a71:	89 e5                	mov    %esp,%ebp
  118a73:	8b 45 0c             	mov    0xc(%ebp),%eax
  118a76:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ll_p->head = NULL;
  118a79:	8b 55 08             	mov    0x8(%ebp),%edx
  118a7c:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    ll_p->tail = NULL;
  118a83:	8b 55 08             	mov    0x8(%ebp),%edx
  118a86:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
        node_size = node_size & (~0x7);
        node_size += 8;
    }
#else
    /*Round the size up to 4*/
    if(node_size & 0x3) {
  118a8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  118a90:	83 e2 03             	and    $0x3,%edx
  118a93:	83 fa 00             	cmp    $0x0,%edx
  118a96:	0f 84 12 00 00 00    	je     118aae <lv_ll_init+0x3e>
        node_size = node_size & (~0x3);
  118a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
  118a9f:	83 e0 fc             	and    $0xfffffffc,%eax
  118aa2:	89 45 0c             	mov    %eax,0xc(%ebp)
        node_size += 4;
  118aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
  118aa8:	83 c0 04             	add    $0x4,%eax
  118aab:	89 45 0c             	mov    %eax,0xc(%ebp)
    }
#endif

    ll_p->n_size = node_size;
  118aae:	8b 45 0c             	mov    0xc(%ebp),%eax
  118ab1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118ab4:	89 01                	mov    %eax,(%ecx)
}
  118ab6:	5d                   	pop    %ebp
  118ab7:	c3                   	ret    
  118ab8:	66 90                	xchg   %ax,%ax
  118aba:	66 90                	xchg   %ax,%ax
  118abc:	66 90                	xchg   %ax,%ax
  118abe:	66 90                	xchg   %ax,%ax

00118ac0 <lv_ll_ins_head>:
 * Add a new head to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new head
 */
void * lv_ll_ins_head(lv_ll_t * ll_p)
{
  118ac0:	55                   	push   %ebp
  118ac1:	89 e5                	mov    %esp,%ebp
  118ac3:	83 ec 18             	sub    $0x18,%esp
  118ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
  118ac9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118acc:	8b 09                	mov    (%ecx),%ecx
  118ace:	83 c1 08             	add    $0x8,%ecx
  118ad1:	89 0c 24             	mov    %ecx,(%esp)
  118ad4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  118ad7:	e8 84 fc ff ff       	call   118760 <lv_mem_alloc>
  118adc:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(n_new != NULL) {
  118adf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  118ae3:	0f 84 88 00 00 00    	je     118b71 <lv_ll_ins_head+0xb1>
  118ae9:	31 c0                	xor    %eax,%eax
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
  118aeb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118aee:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118af1:	89 0c 24             	mov    %ecx,(%esp)
  118af4:	89 54 24 04          	mov    %edx,0x4(%esp)
  118af8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  118aff:	00 
  118b00:	89 45 f4             	mov    %eax,-0xc(%ebp)
  118b03:	e8 78 00 00 00       	call   118b80 <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
  118b08:	8b 45 08             	mov    0x8(%ebp),%eax
  118b0b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  118b0e:	8b 55 08             	mov    0x8(%ebp),%edx
  118b11:	8b 52 04             	mov    0x4(%edx),%edx
  118b14:	89 04 24             	mov    %eax,(%esp)
  118b17:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118b1b:	89 54 24 08          	mov    %edx,0x8(%esp)
  118b1f:	e8 dc 00 00 00       	call   118c00 <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
  118b24:	8b 45 08             	mov    0x8(%ebp),%eax
  118b27:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  118b2b:	0f 84 1c 00 00 00    	je     118b4d <lv_ll_ins_head+0x8d>
            node_set_prev(ll_p, ll_p->head, n_new);
  118b31:	8b 45 08             	mov    0x8(%ebp),%eax
  118b34:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118b37:	8b 49 04             	mov    0x4(%ecx),%ecx
  118b3a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118b3d:	89 04 24             	mov    %eax,(%esp)
  118b40:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118b44:	89 54 24 08          	mov    %edx,0x8(%esp)
  118b48:	e8 33 00 00 00       	call   118b80 <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
  118b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118b50:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118b53:	89 41 04             	mov    %eax,0x4(%ecx)
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
  118b56:	8b 45 08             	mov    0x8(%ebp),%eax
  118b59:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  118b5d:	0f 85 09 00 00 00    	jne    118b6c <lv_ll_ins_head+0xac>
            ll_p->tail = n_new;
  118b63:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118b66:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118b69:	89 41 08             	mov    %eax,0x8(%ecx)
        }
    }
  118b6c:	e9 00 00 00 00       	jmp    118b71 <lv_ll_ins_head+0xb1>

    return n_new;
  118b71:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118b74:	83 c4 18             	add    $0x18,%esp
  118b77:	5d                   	pop    %ebp
  118b78:	c3                   	ret    
  118b79:	66 90                	xchg   %ax,%ax
  118b7b:	66 90                	xchg   %ax,%ax
  118b7d:	66 90                	xchg   %ax,%ax
  118b7f:	90                   	nop

00118b80 <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
  118b80:	55                   	push   %ebp
  118b81:	89 e5                	mov    %esp,%ebp
  118b83:	83 ec 14             	sub    $0x14,%esp
  118b86:	8b 45 10             	mov    0x10(%ebp),%eax
  118b89:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118b8c:	8b 55 08             	mov    0x8(%ebp),%edx
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
  118b8f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118b93:	0f 85 05 00 00 00    	jne    118b9e <node_set_prev+0x1e>
  118b99:	e9 58 00 00 00       	jmp    118bf6 <node_set_prev+0x76>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
  118b9e:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
    if(prev)
  118ba5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118ba9:	0f 84 23 00 00 00    	je     118bd2 <node_set_prev+0x52>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
  118baf:	8b 45 0c             	mov    0xc(%ebp),%eax
  118bb2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118bb5:	03 01                	add    (%ecx),%eax
  118bb7:	8d 4d 10             	lea    0x10(%ebp),%ecx
  118bba:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118bbd:	89 04 24             	mov    %eax,(%esp)
  118bc0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118bc4:	89 54 24 08          	mov    %edx,0x8(%esp)
  118bc8:	e8 83 17 ff ff       	call   10a350 <memcpy>
  118bcd:	e9 24 00 00 00       	jmp    118bf6 <node_set_prev+0x76>
  118bd2:	31 c0                	xor    %eax,%eax
    else
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
  118bd4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118bd7:	8b 55 08             	mov    0x8(%ebp),%edx
  118bda:	03 0a                	add    (%edx),%ecx
  118bdc:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118bdf:	89 0c 24             	mov    %ecx,(%esp)
  118be2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118be9:	00 
  118bea:	89 54 24 08          	mov    %edx,0x8(%esp)
  118bee:	89 45 f8             	mov    %eax,-0x8(%ebp)
  118bf1:	e8 7a 18 ff ff       	call   10a470 <memset>
}
  118bf6:	83 c4 14             	add    $0x14,%esp
  118bf9:	5d                   	pop    %ebp
  118bfa:	c3                   	ret    
  118bfb:	66 90                	xchg   %ax,%ax
  118bfd:	66 90                	xchg   %ax,%ax
  118bff:	90                   	nop

00118c00 <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
  118c00:	55                   	push   %ebp
  118c01:	89 e5                	mov    %esp,%ebp
  118c03:	83 ec 14             	sub    $0x14,%esp
  118c06:	8b 45 10             	mov    0x10(%ebp),%eax
  118c09:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118c0c:	8b 55 08             	mov    0x8(%ebp),%edx
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
  118c0f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118c13:	0f 85 05 00 00 00    	jne    118c1e <node_set_next+0x1e>
  118c19:	e9 62 00 00 00       	jmp    118c80 <node_set_next+0x80>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
  118c1e:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
    if(next)
  118c25:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  118c29:	0f 84 28 00 00 00    	je     118c57 <node_set_next+0x57>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
  118c2f:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c32:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118c35:	8b 09                	mov    (%ecx),%ecx
  118c37:	83 c1 04             	add    $0x4,%ecx
  118c3a:	01 c8                	add    %ecx,%eax
  118c3c:	8d 4d 10             	lea    0x10(%ebp),%ecx
  118c3f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118c42:	89 04 24             	mov    %eax,(%esp)
  118c45:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118c49:	89 54 24 08          	mov    %edx,0x8(%esp)
  118c4d:	e8 fe 16 ff ff       	call   10a350 <memcpy>
  118c52:	e9 29 00 00 00       	jmp    118c80 <node_set_next+0x80>
  118c57:	31 c0                	xor    %eax,%eax
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
  118c59:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118c5c:	8b 55 08             	mov    0x8(%ebp),%edx
  118c5f:	8b 12                	mov    (%edx),%edx
  118c61:	83 c2 04             	add    $0x4,%edx
  118c64:	01 d1                	add    %edx,%ecx
  118c66:	8b 55 fc             	mov    -0x4(%ebp),%edx
  118c69:	89 0c 24             	mov    %ecx,(%esp)
  118c6c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  118c73:	00 
  118c74:	89 54 24 08          	mov    %edx,0x8(%esp)
  118c78:	89 45 f8             	mov    %eax,-0x8(%ebp)
  118c7b:	e8 f0 17 ff ff       	call   10a470 <memset>
}
  118c80:	83 c4 14             	add    $0x14,%esp
  118c83:	5d                   	pop    %ebp
  118c84:	c3                   	ret    
  118c85:	66 90                	xchg   %ax,%ax
  118c87:	66 90                	xchg   %ax,%ax
  118c89:	66 90                	xchg   %ax,%ax
  118c8b:	66 90                	xchg   %ax,%ax
  118c8d:	66 90                	xchg   %ax,%ax
  118c8f:	90                   	nop

00118c90 <lv_ll_ins_prev>:
{
  118c90:	55                   	push   %ebp
  118c91:	89 e5                	mov    %esp,%ebp
  118c93:	83 ec 18             	sub    $0x18,%esp
  118c96:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118c9c:	31 d2                	xor    %edx,%edx
    if(NULL == ll_p || NULL == n_act) return NULL;
  118c9e:	3b 55 08             	cmp    0x8(%ebp),%edx
  118ca1:	0f 84 0b 00 00 00    	je     118cb2 <lv_ll_ins_prev+0x22>
  118ca7:	31 c0                	xor    %eax,%eax
  118ca9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  118cac:	0f 85 0c 00 00 00    	jne    118cbe <lv_ll_ins_prev+0x2e>
  118cb2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118cb9:	e9 e5 00 00 00       	jmp    118da3 <lv_ll_ins_prev+0x113>
    if(lv_ll_get_head(ll_p) == n_act) {
  118cbe:	8b 45 08             	mov    0x8(%ebp),%eax
  118cc1:	89 04 24             	mov    %eax,(%esp)
  118cc4:	e8 e7 00 00 00       	call   118db0 <lv_ll_get_head>
  118cc9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  118ccc:	0f 85 29 00 00 00    	jne    118cfb <lv_ll_ins_prev+0x6b>
        n_new = lv_ll_ins_head(ll_p);
  118cd2:	8b 45 08             	mov    0x8(%ebp),%eax
  118cd5:	89 04 24             	mov    %eax,(%esp)
  118cd8:	e8 e3 fd ff ff       	call   118ac0 <lv_ll_ins_head>
  118cdd:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(n_new == NULL) return NULL;
  118ce0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118ce4:	0f 85 0c 00 00 00    	jne    118cf6 <lv_ll_ins_prev+0x66>
  118cea:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118cf1:	e9 ad 00 00 00       	jmp    118da3 <lv_ll_ins_prev+0x113>
    } else {
  118cf6:	e9 a2 00 00 00       	jmp    118d9d <lv_ll_ins_prev+0x10d>
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
  118cfb:	8b 45 08             	mov    0x8(%ebp),%eax
  118cfe:	8b 00                	mov    (%eax),%eax
  118d00:	83 c0 08             	add    $0x8,%eax
  118d03:	89 04 24             	mov    %eax,(%esp)
  118d06:	e8 55 fa ff ff       	call   118760 <lv_mem_alloc>
  118d0b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(n_new == NULL) return NULL;
  118d0e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118d12:	0f 85 0c 00 00 00    	jne    118d24 <lv_ll_ins_prev+0x94>
  118d18:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118d1f:	e9 7f 00 00 00       	jmp    118da3 <lv_ll_ins_prev+0x113>
        n_prev = lv_ll_get_prev(ll_p, n_act);
  118d24:	8b 45 08             	mov    0x8(%ebp),%eax
  118d27:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118d2a:	89 04 24             	mov    %eax,(%esp)
  118d2d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118d31:	e8 aa 00 00 00       	call   118de0 <lv_ll_get_prev>
  118d36:	89 45 f4             	mov    %eax,-0xc(%ebp)
        node_set_next(ll_p, n_prev, n_new);
  118d39:	8b 45 08             	mov    0x8(%ebp),%eax
  118d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  118d3f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  118d42:	89 04 24             	mov    %eax,(%esp)
  118d45:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118d49:	89 54 24 08          	mov    %edx,0x8(%esp)
  118d4d:	e8 ae fe ff ff       	call   118c00 <node_set_next>
        node_set_prev(ll_p, n_new, n_prev);
  118d52:	8b 45 08             	mov    0x8(%ebp),%eax
  118d55:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  118d58:	8b 55 f4             	mov    -0xc(%ebp),%edx
  118d5b:	89 04 24             	mov    %eax,(%esp)
  118d5e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118d62:	89 54 24 08          	mov    %edx,0x8(%esp)
  118d66:	e8 15 fe ff ff       	call   118b80 <node_set_prev>
        node_set_prev(ll_p, n_act, n_new);
  118d6b:	8b 45 08             	mov    0x8(%ebp),%eax
  118d6e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118d71:	8b 55 f8             	mov    -0x8(%ebp),%edx
  118d74:	89 04 24             	mov    %eax,(%esp)
  118d77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118d7b:	89 54 24 08          	mov    %edx,0x8(%esp)
  118d7f:	e8 fc fd ff ff       	call   118b80 <node_set_prev>
        node_set_next(ll_p, n_new, n_act);
  118d84:	8b 45 08             	mov    0x8(%ebp),%eax
  118d87:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  118d8a:	8b 55 0c             	mov    0xc(%ebp),%edx
  118d8d:	89 04 24             	mov    %eax,(%esp)
  118d90:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118d94:	89 54 24 08          	mov    %edx,0x8(%esp)
  118d98:	e8 63 fe ff ff       	call   118c00 <node_set_next>
    return n_new;
  118d9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118da0:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  118da3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118da6:	83 c4 18             	add    $0x18,%esp
  118da9:	5d                   	pop    %ebp
  118daa:	c3                   	ret    
  118dab:	66 90                	xchg   %ax,%ax
  118dad:	66 90                	xchg   %ax,%ax
  118daf:	90                   	nop

00118db0 <lv_ll_get_head>:
{
  118db0:	55                   	push   %ebp
  118db1:	89 e5                	mov    %esp,%ebp
  118db3:	50                   	push   %eax
  118db4:	8b 45 08             	mov    0x8(%ebp),%eax
    void * head = NULL;
  118db7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(ll_p != NULL) {
  118dbe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  118dc2:	0f 84 09 00 00 00    	je     118dd1 <lv_ll_get_head+0x21>
        head = ll_p->head;
  118dc8:	8b 45 08             	mov    0x8(%ebp),%eax
  118dcb:	8b 40 04             	mov    0x4(%eax),%eax
  118dce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return head;
  118dd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118dd4:	83 c4 04             	add    $0x4,%esp
  118dd7:	5d                   	pop    %ebp
  118dd8:	c3                   	ret    
  118dd9:	66 90                	xchg   %ax,%ax
  118ddb:	66 90                	xchg   %ax,%ax
  118ddd:	66 90                	xchg   %ax,%ax
  118ddf:	90                   	nop

00118de0 <lv_ll_get_prev>:
{
  118de0:	55                   	push   %ebp
  118de1:	89 e5                	mov    %esp,%ebp
  118de3:	83 ec 14             	sub    $0x14,%esp
  118de6:	8b 45 0c             	mov    0xc(%ebp),%eax
  118de9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    void * prev = NULL;
  118dec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(ll_p != NULL) {
  118df3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  118df7:	0f 84 25 00 00 00    	je     118e22 <lv_ll_get_prev+0x42>
        const lv_ll_node_t * n_act_d = n_act;
  118dfd:	8b 45 0c             	mov    0xc(%ebp),%eax
  118e00:	89 45 f8             	mov    %eax,-0x8(%ebp)
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
  118e03:	8d 45 fc             	lea    -0x4(%ebp),%eax
  118e06:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  118e09:	8b 55 08             	mov    0x8(%ebp),%edx
  118e0c:	03 0a                	add    (%edx),%ecx
  118e0e:	89 04 24             	mov    %eax,(%esp)
  118e11:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118e15:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  118e1c:	00 
  118e1d:	e8 2e 15 ff ff       	call   10a350 <memcpy>
    return prev;
  118e22:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118e25:	83 c4 14             	add    $0x14,%esp
  118e28:	5d                   	pop    %ebp
  118e29:	c3                   	ret    
  118e2a:	66 90                	xchg   %ax,%ax
  118e2c:	66 90                	xchg   %ax,%ax
  118e2e:	66 90                	xchg   %ax,%ax

00118e30 <lv_ll_ins_tail>:
{
  118e30:	55                   	push   %ebp
  118e31:	89 e5                	mov    %esp,%ebp
  118e33:	83 ec 1c             	sub    $0x1c,%esp
  118e36:	8b 45 08             	mov    0x8(%ebp),%eax
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
  118e39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118e3c:	8b 09                	mov    (%ecx),%ecx
  118e3e:	83 c1 08             	add    $0x8,%ecx
  118e41:	89 0c 24             	mov    %ecx,(%esp)
  118e44:	89 45 f4             	mov    %eax,-0xc(%ebp)
  118e47:	e8 14 f9 ff ff       	call   118760 <lv_mem_alloc>
  118e4c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(n_new == NULL) return NULL;
  118e4f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118e53:	0f 85 0c 00 00 00    	jne    118e65 <lv_ll_ins_tail+0x35>
  118e59:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  118e60:	e9 98 00 00 00       	jmp    118efd <lv_ll_ins_tail+0xcd>
    if(n_new != NULL) {
  118e65:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  118e69:	0f 84 88 00 00 00    	je     118ef7 <lv_ll_ins_tail+0xc7>
  118e6f:	31 c0                	xor    %eax,%eax
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
  118e71:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118e74:	8b 55 f8             	mov    -0x8(%ebp),%edx
  118e77:	89 0c 24             	mov    %ecx,(%esp)
  118e7a:	89 54 24 04          	mov    %edx,0x4(%esp)
  118e7e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  118e85:	00 
  118e86:	89 45 f0             	mov    %eax,-0x10(%ebp)
  118e89:	e8 72 fd ff ff       	call   118c00 <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
  118e8e:	8b 45 08             	mov    0x8(%ebp),%eax
  118e91:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  118e94:	8b 55 08             	mov    0x8(%ebp),%edx
  118e97:	8b 52 08             	mov    0x8(%edx),%edx
  118e9a:	89 04 24             	mov    %eax,(%esp)
  118e9d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118ea1:	89 54 24 08          	mov    %edx,0x8(%esp)
  118ea5:	e8 d6 fc ff ff       	call   118b80 <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
  118eaa:	8b 45 08             	mov    0x8(%ebp),%eax
  118ead:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  118eb1:	0f 84 1c 00 00 00    	je     118ed3 <lv_ll_ins_tail+0xa3>
            node_set_next(ll_p, ll_p->tail, n_new);
  118eb7:	8b 45 08             	mov    0x8(%ebp),%eax
  118eba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118ebd:	8b 49 08             	mov    0x8(%ecx),%ecx
  118ec0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  118ec3:	89 04 24             	mov    %eax,(%esp)
  118ec6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118eca:	89 54 24 08          	mov    %edx,0x8(%esp)
  118ece:	e8 2d fd ff ff       	call   118c00 <node_set_next>
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
  118ed3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118ed6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118ed9:	89 41 08             	mov    %eax,0x8(%ecx)
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
  118edc:	8b 45 08             	mov    0x8(%ebp),%eax
  118edf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  118ee3:	0f 85 09 00 00 00    	jne    118ef2 <lv_ll_ins_tail+0xc2>
            ll_p->head = n_new;
  118ee9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118eec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118eef:	89 41 04             	mov    %eax,0x4(%ecx)
    }
  118ef2:	e9 00 00 00 00       	jmp    118ef7 <lv_ll_ins_tail+0xc7>
    return n_new;
  118ef7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  118efa:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  118efd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118f00:	83 c4 1c             	add    $0x1c,%esp
  118f03:	5d                   	pop    %ebp
  118f04:	c3                   	ret    
  118f05:	66 90                	xchg   %ax,%ax
  118f07:	66 90                	xchg   %ax,%ax
  118f09:	66 90                	xchg   %ax,%ax
  118f0b:	66 90                	xchg   %ax,%ax
  118f0d:	66 90                	xchg   %ax,%ax
  118f0f:	90                   	nop

00118f10 <lv_ll_rem>:
{
  118f10:	55                   	push   %ebp
  118f11:	89 e5                	mov    %esp,%ebp
  118f13:	83 ec 24             	sub    $0x24,%esp
  118f16:	8b 45 0c             	mov    0xc(%ebp),%eax
  118f19:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(lv_ll_get_head(ll_p) == node_p) {
  118f1c:	8b 55 08             	mov    0x8(%ebp),%edx
  118f1f:	89 14 24             	mov    %edx,(%esp)
  118f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  118f25:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  118f28:	e8 83 fe ff ff       	call   118db0 <lv_ll_get_head>
  118f2d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  118f30:	0f 85 5b 00 00 00    	jne    118f91 <lv_ll_rem+0x81>
        ll_p->head = lv_ll_get_next(ll_p, node_p);
  118f36:	8b 45 08             	mov    0x8(%ebp),%eax
  118f39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118f3c:	89 04 24             	mov    %eax,(%esp)
  118f3f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118f43:	e8 28 01 00 00       	call   119070 <lv_ll_get_next>
  118f48:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118f4b:	89 41 04             	mov    %eax,0x4(%ecx)
        if(ll_p->head == NULL) {
  118f4e:	8b 45 08             	mov    0x8(%ebp),%eax
  118f51:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  118f55:	0f 85 0f 00 00 00    	jne    118f6a <lv_ll_rem+0x5a>
            ll_p->tail = NULL;
  118f5b:	8b 45 08             	mov    0x8(%ebp),%eax
  118f5e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        } else {
  118f65:	e9 22 00 00 00       	jmp    118f8c <lv_ll_rem+0x7c>
  118f6a:	31 c0                	xor    %eax,%eax
            node_set_prev(ll_p, ll_p->head, NULL);
  118f6c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118f6f:	8b 55 08             	mov    0x8(%ebp),%edx
  118f72:	8b 52 04             	mov    0x4(%edx),%edx
  118f75:	89 0c 24             	mov    %ecx,(%esp)
  118f78:	89 54 24 04          	mov    %edx,0x4(%esp)
  118f7c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  118f83:	00 
  118f84:	89 45 ec             	mov    %eax,-0x14(%ebp)
  118f87:	e8 f4 fb ff ff       	call   118b80 <node_set_prev>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
  118f8c:	e9 d0 00 00 00       	jmp    119061 <lv_ll_rem+0x151>
  118f91:	8b 45 08             	mov    0x8(%ebp),%eax
  118f94:	89 04 24             	mov    %eax,(%esp)
  118f97:	e8 24 01 00 00       	call   1190c0 <lv_ll_get_tail>
  118f9c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  118f9f:	0f 85 5b 00 00 00    	jne    119000 <lv_ll_rem+0xf0>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
  118fa5:	8b 45 08             	mov    0x8(%ebp),%eax
  118fa8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  118fab:	89 04 24             	mov    %eax,(%esp)
  118fae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  118fb2:	e8 29 fe ff ff       	call   118de0 <lv_ll_get_prev>
  118fb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118fba:	89 41 08             	mov    %eax,0x8(%ecx)
        if(ll_p->tail == NULL) {
  118fbd:	8b 45 08             	mov    0x8(%ebp),%eax
  118fc0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  118fc4:	0f 85 0f 00 00 00    	jne    118fd9 <lv_ll_rem+0xc9>
            ll_p->head = NULL;
  118fca:	8b 45 08             	mov    0x8(%ebp),%eax
  118fcd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        } else {
  118fd4:	e9 22 00 00 00       	jmp    118ffb <lv_ll_rem+0xeb>
  118fd9:	31 c0                	xor    %eax,%eax
            node_set_next(ll_p, ll_p->tail, NULL);
  118fdb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  118fde:	8b 55 08             	mov    0x8(%ebp),%edx
  118fe1:	8b 52 08             	mov    0x8(%edx),%edx
  118fe4:	89 0c 24             	mov    %ecx,(%esp)
  118fe7:	89 54 24 04          	mov    %edx,0x4(%esp)
  118feb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  118ff2:	00 
  118ff3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  118ff6:	e8 05 fc ff ff       	call   118c00 <node_set_next>
    } else {
  118ffb:	e9 5c 00 00 00       	jmp    11905c <lv_ll_rem+0x14c>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
  119000:	8b 45 08             	mov    0x8(%ebp),%eax
  119003:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  119006:	89 04 24             	mov    %eax,(%esp)
  119009:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11900d:	e8 ce fd ff ff       	call   118de0 <lv_ll_get_prev>
  119012:	89 45 fc             	mov    %eax,-0x4(%ebp)
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
  119015:	8b 45 08             	mov    0x8(%ebp),%eax
  119018:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11901b:	89 04 24             	mov    %eax,(%esp)
  11901e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119022:	e8 49 00 00 00       	call   119070 <lv_ll_get_next>
  119027:	89 45 f8             	mov    %eax,-0x8(%ebp)
        node_set_next(ll_p, n_prev, n_next);
  11902a:	8b 45 08             	mov    0x8(%ebp),%eax
  11902d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  119030:	8b 55 f8             	mov    -0x8(%ebp),%edx
  119033:	89 04 24             	mov    %eax,(%esp)
  119036:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11903a:	89 54 24 08          	mov    %edx,0x8(%esp)
  11903e:	e8 bd fb ff ff       	call   118c00 <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
  119043:	8b 45 08             	mov    0x8(%ebp),%eax
  119046:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  119049:	8b 55 fc             	mov    -0x4(%ebp),%edx
  11904c:	89 04 24             	mov    %eax,(%esp)
  11904f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119053:	89 54 24 08          	mov    %edx,0x8(%esp)
  119057:	e8 24 fb ff ff       	call   118b80 <node_set_prev>
  11905c:	e9 00 00 00 00       	jmp    119061 <lv_ll_rem+0x151>
}
  119061:	83 c4 24             	add    $0x24,%esp
  119064:	5d                   	pop    %ebp
  119065:	c3                   	ret    
  119066:	66 90                	xchg   %ax,%ax
  119068:	66 90                	xchg   %ax,%ax
  11906a:	66 90                	xchg   %ax,%ax
  11906c:	66 90                	xchg   %ax,%ax
  11906e:	66 90                	xchg   %ax,%ax

00119070 <lv_ll_get_next>:
{
  119070:	55                   	push   %ebp
  119071:	89 e5                	mov    %esp,%ebp
  119073:	83 ec 14             	sub    $0x14,%esp
  119076:	8b 45 0c             	mov    0xc(%ebp),%eax
  119079:	8b 4d 08             	mov    0x8(%ebp),%ecx
    void * next = NULL;
  11907c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(ll_p != NULL) {
  119083:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  119087:	0f 84 2a 00 00 00    	je     1190b7 <lv_ll_get_next+0x47>
        const lv_ll_node_t * n_act_d = n_act;
  11908d:	8b 45 0c             	mov    0xc(%ebp),%eax
  119090:	89 45 f8             	mov    %eax,-0x8(%ebp)
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
  119093:	8d 45 fc             	lea    -0x4(%ebp),%eax
  119096:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  119099:	8b 55 08             	mov    0x8(%ebp),%edx
  11909c:	8b 12                	mov    (%edx),%edx
  11909e:	83 c2 04             	add    $0x4,%edx
  1190a1:	01 d1                	add    %edx,%ecx
  1190a3:	89 04 24             	mov    %eax,(%esp)
  1190a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1190aa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1190b1:	00 
  1190b2:	e8 99 12 ff ff       	call   10a350 <memcpy>
    return next;
  1190b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1190ba:	83 c4 14             	add    $0x14,%esp
  1190bd:	5d                   	pop    %ebp
  1190be:	c3                   	ret    
  1190bf:	90                   	nop

001190c0 <lv_ll_get_tail>:
{
  1190c0:	55                   	push   %ebp
  1190c1:	89 e5                	mov    %esp,%ebp
  1190c3:	50                   	push   %eax
  1190c4:	8b 45 08             	mov    0x8(%ebp),%eax
    void * tail = NULL;
  1190c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(ll_p != NULL) {
  1190ce:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1190d2:	0f 84 09 00 00 00    	je     1190e1 <lv_ll_get_tail+0x21>
        tail = ll_p->tail;
  1190d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1190db:	8b 40 08             	mov    0x8(%eax),%eax
  1190de:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return tail;
  1190e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1190e4:	83 c4 04             	add    $0x4,%esp
  1190e7:	5d                   	pop    %ebp
  1190e8:	c3                   	ret    
  1190e9:	66 90                	xchg   %ax,%ax
  1190eb:	66 90                	xchg   %ax,%ax
  1190ed:	66 90                	xchg   %ax,%ax
  1190ef:	90                   	nop

001190f0 <lv_ll_move_before>:
{
  1190f0:	55                   	push   %ebp
  1190f1:	89 e5                	mov    %esp,%ebp
  1190f3:	56                   	push   %esi
  1190f4:	83 ec 10             	sub    $0x10,%esp
  1190f7:	8b 45 10             	mov    0x10(%ebp),%eax
  1190fa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1190fd:	8b 55 08             	mov    0x8(%ebp),%edx
    if(n_act == n_after) return; /*Can't move before itself*/
  119100:	8b 75 0c             	mov    0xc(%ebp),%esi
  119103:	3b 75 10             	cmp    0x10(%ebp),%esi
  119106:	0f 85 05 00 00 00    	jne    119111 <lv_ll_move_before+0x21>
  11910c:	e9 df 00 00 00       	jmp    1191f0 <lv_ll_move_before+0x100>
    if(n_after != NULL)
  119111:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  119115:	0f 84 1a 00 00 00    	je     119135 <lv_ll_move_before+0x45>
        n_before = lv_ll_get_prev(ll_p, n_after);
  11911b:	8b 45 08             	mov    0x8(%ebp),%eax
  11911e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  119121:	89 04 24             	mov    %eax,(%esp)
  119124:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119128:	e8 b3 fc ff ff       	call   118de0 <lv_ll_get_prev>
  11912d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  119130:	e9 0e 00 00 00       	jmp    119143 <lv_ll_move_before+0x53>
        n_before = lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
  119135:	8b 45 08             	mov    0x8(%ebp),%eax
  119138:	89 04 24             	mov    %eax,(%esp)
  11913b:	e8 80 ff ff ff       	call   1190c0 <lv_ll_get_tail>
  119140:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(n_act == n_before) return; /*Already before `n_after`*/
  119143:	8b 45 0c             	mov    0xc(%ebp),%eax
  119146:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  119149:	0f 85 05 00 00 00    	jne    119154 <lv_ll_move_before+0x64>
  11914f:	e9 9c 00 00 00       	jmp    1191f0 <lv_ll_move_before+0x100>
    lv_ll_rem(ll_p, n_act);
  119154:	8b 45 08             	mov    0x8(%ebp),%eax
  119157:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11915a:	89 04 24             	mov    %eax,(%esp)
  11915d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119161:	e8 aa fd ff ff       	call   118f10 <lv_ll_rem>
    node_set_next(ll_p, n_before, n_act);
  119166:	8b 45 08             	mov    0x8(%ebp),%eax
  119169:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11916c:	8b 55 0c             	mov    0xc(%ebp),%edx
  11916f:	89 04 24             	mov    %eax,(%esp)
  119172:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119176:	89 54 24 08          	mov    %edx,0x8(%esp)
  11917a:	e8 81 fa ff ff       	call   118c00 <node_set_next>
    node_set_prev(ll_p, n_act, n_before);
  11917f:	8b 45 08             	mov    0x8(%ebp),%eax
  119182:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  119185:	8b 55 f8             	mov    -0x8(%ebp),%edx
  119188:	89 04 24             	mov    %eax,(%esp)
  11918b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11918f:	89 54 24 08          	mov    %edx,0x8(%esp)
  119193:	e8 e8 f9 ff ff       	call   118b80 <node_set_prev>
    node_set_prev(ll_p, n_after, n_act);
  119198:	8b 45 08             	mov    0x8(%ebp),%eax
  11919b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11919e:	8b 55 0c             	mov    0xc(%ebp),%edx
  1191a1:	89 04 24             	mov    %eax,(%esp)
  1191a4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1191a8:	89 54 24 08          	mov    %edx,0x8(%esp)
  1191ac:	e8 cf f9 ff ff       	call   118b80 <node_set_prev>
    node_set_next(ll_p, n_act, n_after);
  1191b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1191b4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1191b7:	8b 55 10             	mov    0x10(%ebp),%edx
  1191ba:	89 04 24             	mov    %eax,(%esp)
  1191bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1191c1:	89 54 24 08          	mov    %edx,0x8(%esp)
  1191c5:	e8 36 fa ff ff       	call   118c00 <node_set_next>
    if(n_after == NULL) ll_p->tail = n_act;
  1191ca:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1191ce:	0f 85 09 00 00 00    	jne    1191dd <lv_ll_move_before+0xed>
  1191d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1191d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1191da:	89 41 08             	mov    %eax,0x8(%ecx)
    if(n_before == NULL) ll_p->head = n_act;
  1191dd:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1191e1:	0f 85 09 00 00 00    	jne    1191f0 <lv_ll_move_before+0x100>
  1191e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1191ea:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1191ed:	89 41 04             	mov    %eax,0x4(%ecx)
}
  1191f0:	83 c4 10             	add    $0x10,%esp
  1191f3:	5e                   	pop    %esi
  1191f4:	5d                   	pop    %ebp
  1191f5:	c3                   	ret    
  1191f6:	66 90                	xchg   %ax,%ax
  1191f8:	66 90                	xchg   %ax,%ax
  1191fa:	66 90                	xchg   %ax,%ax
  1191fc:	66 90                	xchg   %ax,%ax
  1191fe:	66 90                	xchg   %ax,%ax

00119200 <lv_txt_iso8859_1_size>:
 * Give the size of an ISO8859-1 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_iso8859_1_size(const char * str)
{
  119200:	55                   	push   %ebp
  119201:	89 e5                	mov    %esp,%ebp
  119203:	50                   	push   %eax
  119204:	8b 45 08             	mov    0x8(%ebp),%eax
    (void)str; /*Unused*/
    return 1;
  119207:	b1 01                	mov    $0x1,%cl
  119209:	0f b6 d1             	movzbl %cl,%edx
  11920c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11920f:	89 d0                	mov    %edx,%eax
  119211:	83 c4 04             	add    $0x4,%esp
  119214:	5d                   	pop    %ebp
  119215:	c3                   	ret    
  119216:	66 90                	xchg   %ax,%ax
  119218:	66 90                	xchg   %ax,%ax
  11921a:	66 90                	xchg   %ax,%ax
  11921c:	66 90                	xchg   %ax,%ax
  11921e:	66 90                	xchg   %ax,%ax

00119220 <lv_txt_iso8859_1_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_iso8859_1_next(const char * txt, uint32_t * i)
{
  119220:	55                   	push   %ebp
  119221:	89 e5                	mov    %esp,%ebp
  119223:	83 ec 08             	sub    $0x8,%esp
  119226:	8b 45 0c             	mov    0xc(%ebp),%eax
  119229:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(i == NULL) return txt[1]; /*Get the next char */
  11922c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119230:	0f 85 0f 00 00 00    	jne    119245 <lv_txt_iso8859_1_next+0x25>
  119236:	8b 45 08             	mov    0x8(%ebp),%eax
  119239:	0f be 40 01          	movsbl 0x1(%eax),%eax
  11923d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  119240:	e9 1f 00 00 00       	jmp    119264 <lv_txt_iso8859_1_next+0x44>

    uint8_t letter = txt[*i];
  119245:	8b 45 08             	mov    0x8(%ebp),%eax
  119248:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11924b:	8b 09                	mov    (%ecx),%ecx
  11924d:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  119250:	88 55 fb             	mov    %dl,-0x5(%ebp)
    (*i)++;
  119253:	8b 45 0c             	mov    0xc(%ebp),%eax
  119256:	8b 08                	mov    (%eax),%ecx
  119258:	83 c1 01             	add    $0x1,%ecx
  11925b:	89 08                	mov    %ecx,(%eax)
    return letter;
  11925d:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  119261:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  119264:	8b 45 fc             	mov    -0x4(%ebp),%eax
  119267:	83 c4 08             	add    $0x8,%esp
  11926a:	5d                   	pop    %ebp
  11926b:	c3                   	ret    
  11926c:	66 90                	xchg   %ax,%ax
  11926e:	66 90                	xchg   %ax,%ax

00119270 <lv_txt_iso8859_1_prev>:
 * @param txt pointer to '\0' terminated string
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_iso8859_1_prev(const char * txt, uint32_t * i)
{
  119270:	55                   	push   %ebp
  119271:	89 e5                	mov    %esp,%ebp
  119273:	83 ec 08             	sub    $0x8,%esp
  119276:	8b 45 0c             	mov    0xc(%ebp),%eax
  119279:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(i == NULL) return *(txt - 1); /*Get the prev. char */
  11927c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119280:	0f 85 0f 00 00 00    	jne    119295 <lv_txt_iso8859_1_prev+0x25>
  119286:	8b 45 08             	mov    0x8(%ebp),%eax
  119289:	0f be 40 ff          	movsbl -0x1(%eax),%eax
  11928d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  119290:	e9 1f 00 00 00       	jmp    1192b4 <lv_txt_iso8859_1_prev+0x44>

    (*i)--;
  119295:	8b 45 0c             	mov    0xc(%ebp),%eax
  119298:	8b 08                	mov    (%eax),%ecx
  11929a:	83 c1 ff             	add    $0xffffffff,%ecx
  11929d:	89 08                	mov    %ecx,(%eax)
    uint8_t letter = txt[*i];
  11929f:	8b 45 08             	mov    0x8(%ebp),%eax
  1192a2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1192a5:	8b 09                	mov    (%ecx),%ecx
  1192a7:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  1192aa:	88 55 fb             	mov    %dl,-0x5(%ebp)

    return letter;
  1192ad:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
  1192b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1192b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1192b7:	83 c4 08             	add    $0x8,%esp
  1192ba:	5d                   	pop    %ebp
  1192bb:	c3                   	ret    
  1192bc:	66 90                	xchg   %ax,%ax
  1192be:	66 90                	xchg   %ax,%ax

001192c0 <lv_txt_iso8859_1_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_iso8859_1_get_byte_id(const char * txt, uint32_t utf8_id)
{
  1192c0:	55                   	push   %ebp
  1192c1:	89 e5                	mov    %esp,%ebp
  1192c3:	50                   	push   %eax
  1192c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1192c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    (void)txt;      /*Unused*/
    return utf8_id; /*In Non encoded no difference*/
  1192ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  1192cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1192d0:	89 d0                	mov    %edx,%eax
  1192d2:	83 c4 04             	add    $0x4,%esp
  1192d5:	5d                   	pop    %ebp
  1192d6:	c3                   	ret    
  1192d7:	66 90                	xchg   %ax,%ax
  1192d9:	66 90                	xchg   %ax,%ax
  1192db:	66 90                	xchg   %ax,%ax
  1192dd:	66 90                	xchg   %ax,%ax
  1192df:	90                   	nop

001192e0 <lv_txt_iso8859_1_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_iso8859_1_get_char_id(const char * txt, uint32_t byte_id)
{
  1192e0:	55                   	push   %ebp
  1192e1:	89 e5                	mov    %esp,%ebp
  1192e3:	50                   	push   %eax
  1192e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1192e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    (void)txt;      /*Unused*/
    return byte_id; /*In Non encoded no difference*/
  1192ea:	8b 55 0c             	mov    0xc(%ebp),%edx
  1192ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1192f0:	89 d0                	mov    %edx,%eax
  1192f2:	83 c4 04             	add    $0x4,%esp
  1192f5:	5d                   	pop    %ebp
  1192f6:	c3                   	ret    
  1192f7:	66 90                	xchg   %ax,%ax
  1192f9:	66 90                	xchg   %ax,%ax
  1192fb:	66 90                	xchg   %ax,%ax
  1192fd:	66 90                	xchg   %ax,%ax
  1192ff:	90                   	nop

00119300 <lv_txt_iso8859_1_get_length>:
 * E.g.: "BC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_iso8859_1_get_length(const char * txt)
{
  119300:	55                   	push   %ebp
  119301:	89 e5                	mov    %esp,%ebp
  119303:	83 ec 08             	sub    $0x8,%esp
  119306:	8b 45 08             	mov    0x8(%ebp),%eax
    return strlen(txt);
  119309:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11930c:	89 0c 24             	mov    %ecx,(%esp)
  11930f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  119312:	e8 89 0f ff ff       	call   10a2a0 <strlen>
  119317:	83 c4 08             	add    $0x8,%esp
  11931a:	5d                   	pop    %ebp
  11931b:	c3                   	ret    
  11931c:	66 90                	xchg   %ax,%ax
  11931e:	66 90                	xchg   %ax,%ax

00119320 <lv_txt_get_size>:
{
  119320:	55                   	push   %ebp
  119321:	89 e5                	mov    %esp,%ebp
  119323:	53                   	push   %ebx
  119324:	57                   	push   %edi
  119325:	56                   	push   %esi
  119326:	83 ec 28             	sub    $0x28,%esp
  119329:	8a 45 20             	mov    0x20(%ebp),%al
  11932c:	66 8b 4d 1c          	mov    0x1c(%ebp),%cx
  119330:	66 8b 55 18          	mov    0x18(%ebp),%dx
  119334:	66 8b 75 14          	mov    0x14(%ebp),%si
  119338:	8b 7d 10             	mov    0x10(%ebp),%edi
  11933b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  11933e:	88 45 e8             	mov    %al,-0x18(%ebp)
  119341:	8b 45 08             	mov    0x8(%ebp),%eax
  119344:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    size_res->x = 0;
  119347:	8b 45 08             	mov    0x8(%ebp),%eax
  11934a:	66 c7 00 00 00       	movw   $0x0,(%eax)
    size_res->y = 0;
  11934f:	8b 45 08             	mov    0x8(%ebp),%eax
  119352:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
    if(text == NULL) return;
  119358:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11935c:	0f 85 05 00 00 00    	jne    119367 <lv_txt_get_size+0x47>
  119362:	e9 a4 01 00 00       	jmp    11950b <lv_txt_get_size+0x1eb>
    if(font == NULL) return;
  119367:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  11936b:	0f 85 05 00 00 00    	jne    119376 <lv_txt_get_size+0x56>
  119371:	e9 95 01 00 00       	jmp    11950b <lv_txt_get_size+0x1eb>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
  119376:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  11937a:	83 e0 02             	and    $0x2,%eax
  11937d:	83 f8 00             	cmp    $0x0,%eax
  119380:	0f 84 06 00 00 00    	je     11938c <lv_txt_get_size+0x6c>
  119386:	66 c7 45 1c 18 7c    	movw   $0x7c18,0x1c(%ebp)
    uint32_t line_start     = 0;
  11938c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    uint32_t new_line_start = 0;
  119393:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    uint8_t letter_height = lv_font_get_line_height(font);
  11939a:	8b 45 10             	mov    0x10(%ebp),%eax
  11939d:	89 04 24             	mov    %eax,(%esp)
  1193a0:	e8 7b 01 00 00       	call   119520 <lv_font_get_line_height>
  1193a5:	88 45 e9             	mov    %al,-0x17(%ebp)
    while(text[line_start] != '\0') {
  1193a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1193ab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1193ae:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1193b2:	83 f8 00             	cmp    $0x0,%eax
  1193b5:	0f 84 d2 00 00 00    	je     11948d <lv_txt_get_size+0x16d>
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
  1193bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1193be:	03 45 f0             	add    -0x10(%ebp),%eax
  1193c1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1193c4:	66 8b 55 14          	mov    0x14(%ebp),%dx
  1193c8:	66 8b 75 1c          	mov    0x1c(%ebp),%si
  1193cc:	89 04 24             	mov    %eax,(%esp)
  1193cf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1193d3:	0f bf c2             	movswl %dx,%eax
  1193d6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1193da:	0f bf c6             	movswl %si,%eax
  1193dd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1193e1:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  1193e5:	89 44 24 10          	mov    %eax,0x10(%esp)
  1193e9:	e8 52 01 00 00       	call   119540 <lv_txt_get_next_line>
  1193ee:	0f b7 c8             	movzwl %ax,%ecx
  1193f1:	03 4d ec             	add    -0x14(%ebp),%ecx
  1193f4:	89 4d ec             	mov    %ecx,-0x14(%ebp)
        size_res->y += letter_height;
  1193f7:	0f b6 4d e9          	movzbl -0x17(%ebp),%ecx
  1193fb:	8b 7d 08             	mov    0x8(%ebp),%edi
  1193fe:	0f bf 5f 02          	movswl 0x2(%edi),%ebx
  119402:	01 cb                	add    %ecx,%ebx
  119404:	66 89 5f 02          	mov    %bx,0x2(%edi)
        size_res->y += line_space;
  119408:	0f bf 4d 18          	movswl 0x18(%ebp),%ecx
  11940c:	8b 7d 08             	mov    0x8(%ebp),%edi
  11940f:	0f bf 47 02          	movswl 0x2(%edi),%eax
  119413:	01 c8                	add    %ecx,%eax
  119415:	66 89 47 02          	mov    %ax,0x2(%edi)
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
  119419:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11941c:	03 4d f0             	add    -0x10(%ebp),%ecx
  11941f:	8b 7d ec             	mov    -0x14(%ebp),%edi
  119422:	2b 7d f0             	sub    -0x10(%ebp),%edi
  119425:	8b 45 10             	mov    0x10(%ebp),%eax
  119428:	66 8b 55 14          	mov    0x14(%ebp),%dx
  11942c:	89 0c 24             	mov    %ecx,(%esp)
  11942f:	0f b7 cf             	movzwl %di,%ecx
  119432:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119436:	89 44 24 08          	mov    %eax,0x8(%esp)
  11943a:	0f bf c2             	movswl %dx,%eax
  11943d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  119441:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  119445:	89 44 24 10          	mov    %eax,0x10(%esp)
  119449:	e8 32 03 00 00       	call   119780 <lv_txt_get_width>
  11944e:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
  119452:	0f bf 4d ea          	movswl -0x16(%ebp),%ecx
  119456:	8b 45 08             	mov    0x8(%ebp),%eax
  119459:	0f bf 00             	movswl (%eax),%eax
  11945c:	39 c1                	cmp    %eax,%ecx
  11945e:	0f 8e 0c 00 00 00    	jle    119470 <lv_txt_get_size+0x150>
  119464:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  119468:	89 45 e0             	mov    %eax,-0x20(%ebp)
  11946b:	e9 09 00 00 00       	jmp    119479 <lv_txt_get_size+0x159>
  119470:	8b 45 08             	mov    0x8(%ebp),%eax
  119473:	0f bf 00             	movswl (%eax),%eax
  119476:	89 45 e0             	mov    %eax,-0x20(%ebp)
  119479:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11947c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11947f:	66 89 01             	mov    %ax,(%ecx)
        line_start  = new_line_start;
  119482:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119485:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    while(text[line_start] != '\0') {
  119488:	e9 1b ff ff ff       	jmp    1193a8 <lv_txt_get_size+0x88>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
  11948d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  119491:	0f 84 43 00 00 00    	je     1194da <lv_txt_get_size+0x1ba>
  119497:	8b 45 0c             	mov    0xc(%ebp),%eax
  11949a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11949d:	83 e9 01             	sub    $0x1,%ecx
  1194a0:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1194a4:	83 f8 0a             	cmp    $0xa,%eax
  1194a7:	0f 84 16 00 00 00    	je     1194c3 <lv_txt_get_size+0x1a3>
  1194ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  1194b0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1194b3:	83 e9 01             	sub    $0x1,%ecx
  1194b6:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1194ba:	83 f8 0d             	cmp    $0xd,%eax
  1194bd:	0f 85 17 00 00 00    	jne    1194da <lv_txt_get_size+0x1ba>
        size_res->y += letter_height + line_space;
  1194c3:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  1194c7:	0f bf 4d 18          	movswl 0x18(%ebp),%ecx
  1194cb:	01 c8                	add    %ecx,%eax
  1194cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1194d0:	0f bf 51 02          	movswl 0x2(%ecx),%edx
  1194d4:	01 c2                	add    %eax,%edx
  1194d6:	66 89 51 02          	mov    %dx,0x2(%ecx)
    if(size_res->y == 0)
  1194da:	8b 45 08             	mov    0x8(%ebp),%eax
  1194dd:	0f bf 40 02          	movswl 0x2(%eax),%eax
  1194e1:	83 f8 00             	cmp    $0x0,%eax
  1194e4:	0f 85 10 00 00 00    	jne    1194fa <lv_txt_get_size+0x1da>
        size_res->y = letter_height;
  1194ea:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  1194ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1194f1:	66 89 41 02          	mov    %ax,0x2(%ecx)
  1194f5:	e9 11 00 00 00       	jmp    11950b <lv_txt_get_size+0x1eb>
        size_res->y -= line_space;
  1194fa:	0f bf 45 18          	movswl 0x18(%ebp),%eax
  1194fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  119501:	0f bf 51 02          	movswl 0x2(%ecx),%edx
  119505:	29 c2                	sub    %eax,%edx
  119507:	66 89 51 02          	mov    %dx,0x2(%ecx)
}
  11950b:	83 c4 28             	add    $0x28,%esp
  11950e:	5e                   	pop    %esi
  11950f:	5f                   	pop    %edi
  119510:	5b                   	pop    %ebx
  119511:	5d                   	pop    %ebp
  119512:	c3                   	ret    
  119513:	66 90                	xchg   %ax,%ax
  119515:	66 90                	xchg   %ax,%ax
  119517:	66 90                	xchg   %ax,%ax
  119519:	66 90                	xchg   %ax,%ax
  11951b:	66 90                	xchg   %ax,%ax
  11951d:	66 90                	xchg   %ax,%ax
  11951f:	90                   	nop

00119520 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
  119520:	55                   	push   %ebp
  119521:	89 e5                	mov    %esp,%ebp
  119523:	50                   	push   %eax
  119524:	8b 45 08             	mov    0x8(%ebp),%eax
    return font_p->line_height;
  119527:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11952a:	0f b6 49 08          	movzbl 0x8(%ecx),%ecx
  11952e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  119531:	89 c8                	mov    %ecx,%eax
  119533:	83 c4 04             	add    $0x4,%esp
  119536:	5d                   	pop    %ebp
  119537:	c3                   	ret    
  119538:	66 90                	xchg   %ax,%ax
  11953a:	66 90                	xchg   %ax,%ax
  11953c:	66 90                	xchg   %ax,%ax
  11953e:	66 90                	xchg   %ax,%ax

00119540 <lv_txt_get_next_line>:
{
  119540:	55                   	push   %ebp
  119541:	89 e5                	mov    %esp,%ebp
  119543:	57                   	push   %edi
  119544:	56                   	push   %esi
  119545:	83 ec 30             	sub    $0x30,%esp
  119548:	8a 45 18             	mov    0x18(%ebp),%al
  11954b:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  11954f:	66 8b 55 10          	mov    0x10(%ebp),%dx
  119553:	8b 75 0c             	mov    0xc(%ebp),%esi
  119556:	8b 7d 08             	mov    0x8(%ebp),%edi
    if(txt == NULL) return 0;
  119559:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11955d:	0f 85 0b 00 00 00    	jne    11956e <lv_txt_get_next_line+0x2e>
  119563:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
  119569:	e9 fa 01 00 00       	jmp    119768 <lv_txt_get_next_line+0x228>
    if(font == NULL) return 0;
  11956e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119572:	0f 85 0b 00 00 00    	jne    119583 <lv_txt_get_next_line+0x43>
  119578:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
  11957e:	e9 e5 01 00 00       	jmp    119768 <lv_txt_get_next_line+0x228>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
  119583:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  119587:	83 e0 02             	and    $0x2,%eax
  11958a:	83 f8 00             	cmp    $0x0,%eax
  11958d:	0f 84 06 00 00 00    	je     119599 <lv_txt_get_next_line+0x59>
  119593:	66 c7 45 14 18 7c    	movw   $0x7c18,0x14(%ebp)
    uint32_t i                   = 0;
  119599:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    uint32_t i_next              = 0;
  1195a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    lv_coord_t cur_w             = 0;
  1195a7:	66 c7 45 ea 00 00    	movw   $0x0,-0x16(%ebp)
    uint32_t last_break          = NO_BREAK_FOUND;
  1195ad:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
  1195b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    uint32_t letter      = 0;
  1195b8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    uint32_t letter_next = 0;
  1195bf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    letter_next = lv_txt_encoded_next(txt, &i_next);
  1195c6:	a1 44 30 14 00       	mov    0x143044,%eax
  1195cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1195ce:	89 0c 24             	mov    %ecx,(%esp)
  1195d1:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  1195d4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1195d8:	ff d0                	call   *%eax
  1195da:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    while(txt[i] != '\0') {
  1195dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1195e0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1195e3:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1195e7:	83 f8 00             	cmp    $0x0,%eax
  1195ea:	0f 84 71 01 00 00    	je     119761 <lv_txt_get_next_line+0x221>
        letter      = letter_next;
  1195f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1195f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
        i           = i_next;
  1195f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1195f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        letter_next = lv_txt_encoded_next(txt, &i_next);
  1195fc:	a1 44 30 14 00       	mov    0x143044,%eax
  119601:	8b 4d 08             	mov    0x8(%ebp),%ecx
  119604:	89 0c 24             	mov    %ecx,(%esp)
  119607:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  11960a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11960e:	ff d0                	call   *%eax
  119610:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
  119613:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  119617:	83 e0 01             	and    $0x1,%eax
  11961a:	83 f8 00             	cmp    $0x0,%eax
  11961d:	0f 84 2a 00 00 00    	je     11964d <lv_txt_get_next_line+0x10d>
            if(lv_txt_is_cmd(&cmd_state, letter) != false) {
  119623:	8b 45 d8             	mov    -0x28(%ebp),%eax
  119626:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
  119629:	89 0c 24             	mov    %ecx,(%esp)
  11962c:	89 44 24 04          	mov    %eax,0x4(%esp)
  119630:	e8 bb 02 00 00       	call   1198f0 <lv_txt_is_cmd>
  119635:	24 01                	and    $0x1,%al
  119637:	0f b6 c8             	movzbl %al,%ecx
  11963a:	83 f9 00             	cmp    $0x0,%ecx
  11963d:	0f 84 05 00 00 00    	je     119648 <lv_txt_get_next_line+0x108>
                continue; /*Skip the letter is it is part of a command*/
  119643:	e9 95 ff ff ff       	jmp    1195dd <lv_txt_get_next_line+0x9d>
        }
  119648:	e9 00 00 00 00       	jmp    11964d <lv_txt_get_next_line+0x10d>
        if(letter == '\n' || letter == '\r') {
  11964d:	83 7d d8 0a          	cmpl   $0xa,-0x28(%ebp)
  119651:	0f 84 0a 00 00 00    	je     119661 <lv_txt_get_next_line+0x121>
  119657:	83 7d d8 0d          	cmpl   $0xd,-0x28(%ebp)
  11965b:	0f 85 2c 00 00 00    	jne    11968d <lv_txt_get_next_line+0x14d>
            if(letter == '\r' && letter_next == '\n')
  119661:	83 7d d8 0d          	cmpl   $0xd,-0x28(%ebp)
  119665:	0f 85 16 00 00 00    	jne    119681 <lv_txt_get_next_line+0x141>
  11966b:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
  11966f:	0f 85 0c 00 00 00    	jne    119681 <lv_txt_get_next_line+0x141>
                return i_next;
  119675:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119678:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  11967c:	e9 e7 00 00 00       	jmp    119768 <lv_txt_get_next_line+0x228>
                return i;
  119681:	8b 45 f0             	mov    -0x10(%ebp),%eax
  119684:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  119688:	e9 db 00 00 00       	jmp    119768 <lv_txt_get_next_line+0x228>
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
  11968d:	8b 45 0c             	mov    0xc(%ebp),%eax
  119690:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  119693:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  119696:	89 04 24             	mov    %eax,(%esp)
  119699:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11969d:	89 54 24 08          	mov    %edx,0x8(%esp)
  1196a1:	e8 6a 27 00 00       	call   11be10 <lv_font_get_glyph_width>
  1196a6:	0f b7 c8             	movzwl %ax,%ecx
  1196a9:	89 4d dc             	mov    %ecx,-0x24(%ebp)
            cur_w += letter_w;
  1196ac:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1196af:	0f bf 55 ea          	movswl -0x16(%ebp),%edx
  1196b3:	01 ca                	add    %ecx,%edx
  1196b5:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
            if(cur_w > max_width) {
  1196b9:	0f bf 4d ea          	movswl -0x16(%ebp),%ecx
  1196bd:	0f bf 75 14          	movswl 0x14(%ebp),%esi
  1196c1:	39 f1                	cmp    %esi,%ecx
  1196c3:	0f 8e 53 00 00 00    	jle    11971c <lv_txt_get_next_line+0x1dc>
                if(last_break != NO_BREAK_FOUND) {
  1196c9:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  1196cd:	0f 84 0b 00 00 00    	je     1196de <lv_txt_get_next_line+0x19e>
                    i = last_break;
  1196d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1196d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
                } else {
  1196d9:	e9 14 00 00 00       	jmp    1196f2 <lv_txt_get_next_line+0x1b2>
                    lv_txt_encoded_prev(txt, &i);
  1196de:	a1 48 30 14 00       	mov    0x143048,%eax
  1196e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1196e6:	89 0c 24             	mov    %ecx,(%esp)
  1196e9:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  1196ec:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1196f0:	ff d0                	call   *%eax
                if(i == 0) lv_txt_encoded_next(txt, &i);
  1196f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1196f6:	0f 85 14 00 00 00    	jne    119710 <lv_txt_get_next_line+0x1d0>
  1196fc:	a1 44 30 14 00       	mov    0x143044,%eax
  119701:	8b 4d 08             	mov    0x8(%ebp),%ecx
  119704:	89 0c 24             	mov    %ecx,(%esp)
  119707:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  11970a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11970e:	ff d0                	call   *%eax
                return i;
  119710:	8b 45 f0             	mov    -0x10(%ebp),%eax
  119713:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  119717:	e9 4c 00 00 00       	jmp    119768 <lv_txt_get_next_line+0x228>
            else if(is_break_char(letter)) {
  11971c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11971f:	89 04 24             	mov    %eax,(%esp)
  119722:	e8 89 02 00 00       	call   1199b0 <is_break_char>
  119727:	a8 01                	test   $0x1,%al
  119729:	0f 85 05 00 00 00    	jne    119734 <lv_txt_get_next_line+0x1f4>
  11972f:	e9 06 00 00 00       	jmp    11973a <lv_txt_get_next_line+0x1fa>
                last_break = i; /*Save the first char index after break*/
  119734:	8b 45 f0             	mov    -0x10(%ebp),%eax
  119737:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11973a:	e9 00 00 00 00       	jmp    11973f <lv_txt_get_next_line+0x1ff>
  11973f:	e9 00 00 00 00       	jmp    119744 <lv_txt_get_next_line+0x204>
        if(letter_w > 0) {
  119744:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  119748:	0f 86 0e 00 00 00    	jbe    11975c <lv_txt_get_next_line+0x21c>
            cur_w += letter_space;
  11974e:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  119752:	0f bf 4d ea          	movswl -0x16(%ebp),%ecx
  119756:	01 c1                	add    %eax,%ecx
  119758:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
    while(txt[i] != '\0') {
  11975c:	e9 7c fe ff ff       	jmp    1195dd <lv_txt_get_next_line+0x9d>
    return i;
  119761:	8b 45 f0             	mov    -0x10(%ebp),%eax
  119764:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
}
  119768:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  11976c:	83 c4 30             	add    $0x30,%esp
  11976f:	5e                   	pop    %esi
  119770:	5f                   	pop    %edi
  119771:	5d                   	pop    %ebp
  119772:	c3                   	ret    
  119773:	66 90                	xchg   %ax,%ax
  119775:	66 90                	xchg   %ax,%ax
  119777:	66 90                	xchg   %ax,%ax
  119779:	66 90                	xchg   %ax,%ax
  11977b:	66 90                	xchg   %ax,%ax
  11977d:	66 90                	xchg   %ax,%ax
  11977f:	90                   	nop

00119780 <lv_txt_get_width>:
{
  119780:	55                   	push   %ebp
  119781:	89 e5                	mov    %esp,%ebp
  119783:	57                   	push   %edi
  119784:	56                   	push   %esi
  119785:	83 ec 28             	sub    $0x28,%esp
  119788:	8a 45 18             	mov    0x18(%ebp),%al
  11978b:	66 8b 4d 14          	mov    0x14(%ebp),%cx
  11978f:	8b 55 10             	mov    0x10(%ebp),%edx
  119792:	66 8b 75 0c          	mov    0xc(%ebp),%si
  119796:	8b 7d 08             	mov    0x8(%ebp),%edi
    if(txt == NULL) return 0;
  119799:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11979d:	0f 85 0b 00 00 00    	jne    1197ae <lv_txt_get_width+0x2e>
  1197a3:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
  1197a9:	e9 2b 01 00 00       	jmp    1198d9 <lv_txt_get_width+0x159>
    if(font == NULL) return 0;
  1197ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1197b2:	0f 85 0b 00 00 00    	jne    1197c3 <lv_txt_get_width+0x43>
  1197b8:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
  1197be:	e9 16 01 00 00       	jmp    1198d9 <lv_txt_get_width+0x159>
    uint32_t i                   = 0;
  1197c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    lv_coord_t width             = 0;
  1197ca:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
  1197d0:	c6 45 ed 00          	movb   $0x0,-0x13(%ebp)
    if(length != 0) {
  1197d4:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1197d8:	83 f8 00             	cmp    $0x0,%eax
  1197db:	0f 84 f0 00 00 00    	je     1198d1 <lv_txt_get_width+0x151>
        while(i < length) {
  1197e1:	e9 00 00 00 00       	jmp    1197e6 <lv_txt_get_width+0x66>
  1197e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1197e9:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  1197ed:	39 c8                	cmp    %ecx,%eax
  1197ef:	0f 83 bc 00 00 00    	jae    1198b1 <lv_txt_get_width+0x131>
            letter      = lv_txt_encoded_next(txt, &i);
  1197f5:	a1 44 30 14 00       	mov    0x143044,%eax
  1197fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1197fd:	89 0c 24             	mov    %ecx,(%esp)
  119800:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  119803:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119807:	ff d0                	call   *%eax
  119809:	31 c9                	xor    %ecx,%ecx
  11980b:	89 45 e8             	mov    %eax,-0x18(%ebp)
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
  11980e:	a1 44 30 14 00       	mov    0x143044,%eax
  119813:	8b 55 08             	mov    0x8(%ebp),%edx
  119816:	03 55 f0             	add    -0x10(%ebp),%edx
  119819:	89 14 24             	mov    %edx,(%esp)
  11981c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119823:	00 
  119824:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  119827:	ff d0                	call   *%eax
  119829:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
  11982c:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  119830:	83 e0 01             	and    $0x1,%eax
  119833:	83 f8 00             	cmp    $0x0,%eax
  119836:	0f 84 2a 00 00 00    	je     119866 <lv_txt_get_width+0xe6>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
  11983c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11983f:	8d 4d ed             	lea    -0x13(%ebp),%ecx
  119842:	89 0c 24             	mov    %ecx,(%esp)
  119845:	89 44 24 04          	mov    %eax,0x4(%esp)
  119849:	e8 a2 00 00 00       	call   1198f0 <lv_txt_is_cmd>
  11984e:	24 01                	and    $0x1,%al
  119850:	0f b6 c8             	movzbl %al,%ecx
  119853:	83 f9 00             	cmp    $0x0,%ecx
  119856:	0f 84 05 00 00 00    	je     119861 <lv_txt_get_width+0xe1>
                    continue;
  11985c:	e9 85 ff ff ff       	jmp    1197e6 <lv_txt_get_width+0x66>
            }
  119861:	e9 00 00 00 00       	jmp    119866 <lv_txt_get_width+0xe6>
            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
  119866:	8b 45 10             	mov    0x10(%ebp),%eax
  119869:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11986c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  11986f:	89 04 24             	mov    %eax,(%esp)
  119872:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119876:	89 54 24 08          	mov    %edx,0x8(%esp)
  11987a:	e8 91 25 00 00       	call   11be10 <lv_font_get_glyph_width>
  11987f:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
            if(char_width > 0) {
  119883:	0f bf 4d e2          	movswl -0x1e(%ebp),%ecx
  119887:	83 f9 00             	cmp    $0x0,%ecx
  11988a:	0f 8e 1c 00 00 00    	jle    1198ac <lv_txt_get_width+0x12c>
                width += char_width;
  119890:	0f bf 45 e2          	movswl -0x1e(%ebp),%eax
  119894:	0f bf 4d ee          	movswl -0x12(%ebp),%ecx
  119898:	01 c1                	add    %eax,%ecx
  11989a:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
                width += letter_space;
  11989e:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  1198a2:	0f bf 55 ee          	movswl -0x12(%ebp),%edx
  1198a6:	01 c2                	add    %eax,%edx
  1198a8:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
        while(i < length) {
  1198ac:	e9 35 ff ff ff       	jmp    1197e6 <lv_txt_get_width+0x66>
        if(width > 0) {
  1198b1:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
  1198b5:	83 f8 00             	cmp    $0x0,%eax
  1198b8:	0f 8e 0e 00 00 00    	jle    1198cc <lv_txt_get_width+0x14c>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
  1198be:	0f bf 45 14          	movswl 0x14(%ebp),%eax
  1198c2:	0f bf 4d ee          	movswl -0x12(%ebp),%ecx
  1198c6:	29 c1                	sub    %eax,%ecx
  1198c8:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
    }
  1198cc:	e9 00 00 00 00       	jmp    1198d1 <lv_txt_get_width+0x151>
    return width;
  1198d1:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  1198d5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
}
  1198d9:	0f bf 45 f6          	movswl -0xa(%ebp),%eax
  1198dd:	83 c4 28             	add    $0x28,%esp
  1198e0:	5e                   	pop    %esi
  1198e1:	5f                   	pop    %edi
  1198e2:	5d                   	pop    %ebp
  1198e3:	c3                   	ret    
  1198e4:	66 90                	xchg   %ax,%ax
  1198e6:	66 90                	xchg   %ax,%ax
  1198e8:	66 90                	xchg   %ax,%ax
  1198ea:	66 90                	xchg   %ax,%ax
  1198ec:	66 90                	xchg   %ax,%ax
  1198ee:	66 90                	xchg   %ax,%ax

001198f0 <lv_txt_is_cmd>:
{
  1198f0:	55                   	push   %ebp
  1198f1:	89 e5                	mov    %esp,%ebp
  1198f3:	56                   	push   %esi
  1198f4:	50                   	push   %eax
  1198f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1198f8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    bool ret = false;
  1198fb:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
  1198ff:	8b 55 0c             	mov    0xc(%ebp),%edx
  119902:	0f be 35 20 40 12 00 	movsbl 0x124020,%esi
  119909:	39 f2                	cmp    %esi,%edx
  11990b:	0f 85 60 00 00 00    	jne    119971 <lv_txt_is_cmd+0x81>
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
  119911:	8b 45 08             	mov    0x8(%ebp),%eax
  119914:	0f b6 00             	movzbl (%eax),%eax
  119917:	83 f8 00             	cmp    $0x0,%eax
  11991a:	0f 85 0f 00 00 00    	jne    11992f <lv_txt_is_cmd+0x3f>
            *state = LV_TXT_CMD_STATE_PAR;
  119920:	8b 45 08             	mov    0x8(%ebp),%eax
  119923:	c6 00 01             	movb   $0x1,(%eax)
            ret    = true;
  119926:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
        }
  11992a:	e9 3d 00 00 00       	jmp    11996c <lv_txt_is_cmd+0x7c>
        else if(*state == LV_TXT_CMD_STATE_PAR) {
  11992f:	8b 45 08             	mov    0x8(%ebp),%eax
  119932:	0f b6 00             	movzbl (%eax),%eax
  119935:	83 f8 01             	cmp    $0x1,%eax
  119938:	0f 85 0b 00 00 00    	jne    119949 <lv_txt_is_cmd+0x59>
            *state = LV_TXT_CMD_STATE_WAIT;
  11993e:	8b 45 08             	mov    0x8(%ebp),%eax
  119941:	c6 00 00             	movb   $0x0,(%eax)
        }
  119944:	e9 1e 00 00 00       	jmp    119967 <lv_txt_is_cmd+0x77>
        else if(*state == LV_TXT_CMD_STATE_IN) {
  119949:	8b 45 08             	mov    0x8(%ebp),%eax
  11994c:	0f b6 00             	movzbl (%eax),%eax
  11994f:	83 f8 02             	cmp    $0x2,%eax
  119952:	0f 85 0a 00 00 00    	jne    119962 <lv_txt_is_cmd+0x72>
            *state = LV_TXT_CMD_STATE_WAIT;
  119958:	8b 45 08             	mov    0x8(%ebp),%eax
  11995b:	c6 00 00             	movb   $0x0,(%eax)
            ret    = true;
  11995e:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
  119962:	e9 00 00 00 00       	jmp    119967 <lv_txt_is_cmd+0x77>
  119967:	e9 00 00 00 00       	jmp    11996c <lv_txt_is_cmd+0x7c>
    }
  11996c:	e9 00 00 00 00       	jmp    119971 <lv_txt_is_cmd+0x81>
    if(*state == LV_TXT_CMD_STATE_PAR) {
  119971:	8b 45 08             	mov    0x8(%ebp),%eax
  119974:	0f b6 00             	movzbl (%eax),%eax
  119977:	83 f8 01             	cmp    $0x1,%eax
  11997a:	0f 85 14 00 00 00    	jne    119994 <lv_txt_is_cmd+0xa4>
        if(c == ' ') {
  119980:	83 7d 0c 20          	cmpl   $0x20,0xc(%ebp)
  119984:	0f 85 06 00 00 00    	jne    119990 <lv_txt_is_cmd+0xa0>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
  11998a:	8b 45 08             	mov    0x8(%ebp),%eax
  11998d:	c6 00 02             	movb   $0x2,(%eax)
        ret = true;
  119990:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
    return ret;
  119994:	8a 45 fb             	mov    -0x5(%ebp),%al
  119997:	24 01                	and    $0x1,%al
  119999:	0f b6 c0             	movzbl %al,%eax
  11999c:	83 c4 04             	add    $0x4,%esp
  11999f:	5e                   	pop    %esi
  1199a0:	5d                   	pop    %ebp
  1199a1:	c3                   	ret    
  1199a2:	66 90                	xchg   %ax,%ax
  1199a4:	66 90                	xchg   %ax,%ax
  1199a6:	66 90                	xchg   %ax,%ax
  1199a8:	66 90                	xchg   %ax,%ax
  1199aa:	66 90                	xchg   %ax,%ax
  1199ac:	66 90                	xchg   %ax,%ax
  1199ae:	66 90                	xchg   %ax,%ax

001199b0 <is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool is_break_char(uint32_t letter)
{
  1199b0:	55                   	push   %ebp
  1199b1:	89 e5                	mov    %esp,%ebp
  1199b3:	50                   	push   %eax
  1199b4:	8b 45 08             	mov    0x8(%ebp),%eax
    uint8_t i;
    bool ret = false;
  1199b7:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
  1199bb:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
  1199bf:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  1199c3:	0f be 04 05 ff 45 12 	movsbl 0x1245ff(,%eax,1),%eax
  1199ca:	00 
  1199cb:	83 f8 00             	cmp    $0x0,%eax
  1199ce:	0f 84 32 00 00 00    	je     119a06 <is_break_char+0x56>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
  1199d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1199d7:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  1199db:	0f be 0c 0d ff 45 12 	movsbl 0x1245ff(,%ecx,1),%ecx
  1199e2:	00 
  1199e3:	39 c8                	cmp    %ecx,%eax
  1199e5:	0f 85 09 00 00 00    	jne    1199f4 <is_break_char+0x44>
            ret = true; /*If match then it is break char*/
  1199eb:	c6 45 fe 01          	movb   $0x1,-0x2(%ebp)
            break;
  1199ef:	e9 12 00 00 00       	jmp    119a06 <is_break_char+0x56>
        }
    }
  1199f4:	e9 00 00 00 00       	jmp    1199f9 <is_break_char+0x49>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
  1199f9:	8a 45 ff             	mov    -0x1(%ebp),%al
  1199fc:	04 01                	add    $0x1,%al
  1199fe:	88 45 ff             	mov    %al,-0x1(%ebp)
  119a01:	e9 b9 ff ff ff       	jmp    1199bf <is_break_char+0xf>

    return ret;
  119a06:	8a 45 fe             	mov    -0x2(%ebp),%al
  119a09:	24 01                	and    $0x1,%al
  119a0b:	0f b6 c0             	movzbl %al,%eax
  119a0e:	83 c4 04             	add    $0x4,%esp
  119a11:	5d                   	pop    %ebp
  119a12:	c3                   	ret    
  119a13:	66 90                	xchg   %ax,%ax
  119a15:	66 90                	xchg   %ax,%ax
  119a17:	66 90                	xchg   %ax,%ax
  119a19:	66 90                	xchg   %ax,%ax
  119a1b:	66 90                	xchg   %ax,%ax
  119a1d:	66 90                	xchg   %ax,%ax
  119a1f:	90                   	nop

00119a20 <lv_log_register_print_cb>:
 * It can format its "File path", "Line number" and "Description" as required
 * and send the formatted log message to a consol or serial port.
 * @param print_cb a function pointer to print a log
 */
void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
{
  119a20:	55                   	push   %ebp
  119a21:	89 e5                	mov    %esp,%ebp
  119a23:	8b 45 08             	mov    0x8(%ebp),%eax
    custom_print_cb = print_cb;
  119a26:	8b 4d 08             	mov    0x8(%ebp),%ecx
  119a29:	89 0d 78 55 13 00    	mov    %ecx,0x135578
}
  119a2f:	5d                   	pop    %ebp
  119a30:	c3                   	ret    
  119a31:	66 90                	xchg   %ax,%ax
  119a33:	66 90                	xchg   %ax,%ax
  119a35:	66 90                	xchg   %ax,%ax
  119a37:	66 90                	xchg   %ax,%ax
  119a39:	66 90                	xchg   %ax,%ax
  119a3b:	66 90                	xchg   %ax,%ax
  119a3d:	66 90                	xchg   %ax,%ax
  119a3f:	90                   	nop

00119a40 <lv_log_add>:
 * @param file name of the file when the log added
 * @param line line number in the source code where the log added
 * @param dsc description of the log
 */
void lv_log_add(lv_log_level_t level, const char * file, int line, const char * dsc)
{
  119a40:	55                   	push   %ebp
  119a41:	89 e5                	mov    %esp,%ebp
  119a43:	53                   	push   %ebx
  119a44:	57                   	push   %edi
  119a45:	56                   	push   %esi
  119a46:	83 ec 10             	sub    $0x10,%esp
  119a49:	8b 45 14             	mov    0x14(%ebp),%eax
  119a4c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  119a4f:	8b 55 0c             	mov    0xc(%ebp),%edx
  119a52:	8a 5d 08             	mov    0x8(%ebp),%bl
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/
  119a55:	0f be 75 08          	movsbl 0x8(%ebp),%esi
  119a59:	83 fe 05             	cmp    $0x5,%esi
  119a5c:	0f 8c 05 00 00 00    	jl     119a67 <lv_log_add+0x27>
  119a62:	e9 44 00 00 00       	jmp    119aab <lv_log_add+0x6b>

    if(level >= LV_LOG_LEVEL) {
  119a67:	0f be 45 08          	movsbl 0x8(%ebp),%eax
  119a6b:	83 f8 01             	cmp    $0x1,%eax
  119a6e:	0f 8c 37 00 00 00    	jl     119aab <lv_log_add+0x6b>

#if LV_LOG_PRINTF
        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error"};
        printf("%s: %s \t(%s #%d)\n", lvl_prefix[level], dsc, file, line);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
  119a74:	83 3d 78 55 13 00 00 	cmpl   $0x0,0x135578
  119a7b:	0f 84 25 00 00 00    	je     119aa6 <lv_log_add+0x66>
  119a81:	a1 78 55 13 00       	mov    0x135578,%eax
  119a86:	8a 4d 08             	mov    0x8(%ebp),%cl
  119a89:	8b 55 0c             	mov    0xc(%ebp),%edx
  119a8c:	8b 75 10             	mov    0x10(%ebp),%esi
  119a8f:	8b 7d 14             	mov    0x14(%ebp),%edi
  119a92:	0f be d9             	movsbl %cl,%ebx
  119a95:	89 1c 24             	mov    %ebx,(%esp)
  119a98:	89 54 24 04          	mov    %edx,0x4(%esp)
  119a9c:	89 74 24 08          	mov    %esi,0x8(%esp)
  119aa0:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  119aa4:	ff d0                	call   *%eax
#endif
    }
  119aa6:	e9 00 00 00 00       	jmp    119aab <lv_log_add+0x6b>
}
  119aab:	83 c4 10             	add    $0x10,%esp
  119aae:	5e                   	pop    %esi
  119aaf:	5f                   	pop    %edi
  119ab0:	5b                   	pop    %ebx
  119ab1:	5d                   	pop    %ebp
  119ab2:	c3                   	ret    
  119ab3:	66 90                	xchg   %ax,%ax
  119ab5:	66 90                	xchg   %ax,%ax
  119ab7:	66 90                	xchg   %ax,%ax
  119ab9:	66 90                	xchg   %ax,%ax
  119abb:	66 90                	xchg   %ax,%ax
  119abd:	66 90                	xchg   %ax,%ax
  119abf:	90                   	nop

00119ac0 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
  119ac0:	55                   	push   %ebp
  119ac1:	89 e5                	mov    %esp,%ebp
  119ac3:	53                   	push   %ebx
  119ac4:	57                   	push   %edi
  119ac5:	56                   	push   %esi
  119ac6:	83 ec 14             	sub    $0x14,%esp
  119ac9:	8b 45 18             	mov    0x18(%ebp),%eax
  119acc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  119acf:	8b 55 10             	mov    0x10(%ebp),%edx
  119ad2:	8b 75 0c             	mov    0xc(%ebp),%esi
  119ad5:	8b 7d 08             	mov    0x8(%ebp),%edi
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
  119ad8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  119adb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  119ade:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  119ae2:	0f 84 8f 00 00 00    	je     119b77 <lv_utils_bsearch+0xb7>
        middle += (n / 2) * size;
  119ae8:	8b 45 10             	mov    0x10(%ebp),%eax
  119aeb:	c1 e8 01             	shr    $0x1,%eax
  119aee:	0f af 45 14          	imul   0x14(%ebp),%eax
  119af2:	03 45 ec             	add    -0x14(%ebp),%eax
  119af5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if((c = (*cmp)(key, middle)) > 0) {
  119af8:	8b 45 18             	mov    0x18(%ebp),%eax
  119afb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  119afe:	8b 55 ec             	mov    -0x14(%ebp),%edx
  119b01:	89 0c 24             	mov    %ecx,(%esp)
  119b04:	89 54 24 04          	mov    %edx,0x4(%esp)
  119b08:	ff d0                	call   *%eax
  119b0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  119b0d:	83 f8 00             	cmp    $0x0,%eax
  119b10:	0f 8e 2e 00 00 00    	jle    119b44 <lv_utils_bsearch+0x84>
            n    = (n / 2) - ((n & 1) == 0);
  119b16:	8b 45 10             	mov    0x10(%ebp),%eax
  119b19:	c1 e8 01             	shr    $0x1,%eax
  119b1c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  119b1f:	83 e1 01             	and    $0x1,%ecx
  119b22:	83 f9 00             	cmp    $0x0,%ecx
  119b25:	0f 94 c2             	sete   %dl
  119b28:	80 e2 01             	and    $0x1,%dl
  119b2b:	0f b6 ca             	movzbl %dl,%ecx
  119b2e:	29 c8                	sub    %ecx,%eax
  119b30:	89 45 10             	mov    %eax,0x10(%ebp)
            base = (middle += size);
  119b33:	8b 45 14             	mov    0x14(%ebp),%eax
  119b36:	03 45 ec             	add    -0x14(%ebp),%eax
  119b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
  119b3c:	89 45 0c             	mov    %eax,0xc(%ebp)
        } else if(c < 0) {
  119b3f:	e9 2e 00 00 00       	jmp    119b72 <lv_utils_bsearch+0xb2>
  119b44:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  119b48:	0f 8d 14 00 00 00    	jge    119b62 <lv_utils_bsearch+0xa2>
            n /= 2;
  119b4e:	8b 45 10             	mov    0x10(%ebp),%eax
  119b51:	c1 e8 01             	shr    $0x1,%eax
  119b54:	89 45 10             	mov    %eax,0x10(%ebp)
            middle = base;
  119b57:	8b 45 0c             	mov    0xc(%ebp),%eax
  119b5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        } else {
  119b5d:	e9 0b 00 00 00       	jmp    119b6d <lv_utils_bsearch+0xad>
            return (char *)middle;
  119b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119b65:	89 45 f0             	mov    %eax,-0x10(%ebp)
  119b68:	e9 11 00 00 00       	jmp    119b7e <lv_utils_bsearch+0xbe>
  119b6d:	e9 00 00 00 00       	jmp    119b72 <lv_utils_bsearch+0xb2>
    for(middle = base; n != 0;) {
  119b72:	e9 67 ff ff ff       	jmp    119ade <lv_utils_bsearch+0x1e>
        }
    }
    return NULL;
  119b77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
}
  119b7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  119b81:	83 c4 14             	add    $0x14,%esp
  119b84:	5e                   	pop    %esi
  119b85:	5f                   	pop    %edi
  119b86:	5b                   	pop    %ebx
  119b87:	5d                   	pop    %ebp
  119b88:	c3                   	ret    
  119b89:	66 90                	xchg   %ax,%ax
  119b8b:	66 90                	xchg   %ax,%ax
  119b8d:	66 90                	xchg   %ax,%ax
  119b8f:	90                   	nop

00119b90 <lv_label_create>:
 * @param par pointer to an object, it will be the parent of the new label
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_label_create(lv_obj_t * par, const lv_obj_t * copy)
{
  119b90:	55                   	push   %ebp
  119b91:	89 e5                	mov    %esp,%ebp
  119b93:	53                   	push   %ebx
  119b94:	57                   	push   %edi
  119b95:	56                   	push   %esi
  119b96:	83 ec 60             	sub    $0x60,%esp
  119b99:	8b 45 0c             	mov    0xc(%ebp),%eax
  119b9c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    LV_LOG_TRACE("label create started");

    /*Create a basic object*/
    lv_obj_t * new_label = lv_obj_create(par, copy);
  119b9f:	8b 55 08             	mov    0x8(%ebp),%edx
  119ba2:	8b 75 0c             	mov    0xc(%ebp),%esi
  119ba5:	89 14 24             	mov    %edx,(%esp)
  119ba8:	89 74 24 04          	mov    %esi,0x4(%esp)
  119bac:	89 45 dc             	mov    %eax,-0x24(%ebp)
  119baf:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  119bb2:	e8 c9 42 ff ff       	call   10de80 <lv_obj_create>
  119bb7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    lv_mem_assert(new_label);
  119bba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  119bbe:	0f 85 2d 00 00 00    	jne    119bf1 <lv_label_create+0x61>
  119bc4:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  119bcb:	8d 05 07 46 12 00    	lea    0x124607,%eax
  119bd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  119bd5:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
  119bdc:	00 
  119bdd:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  119be3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  119be7:	e8 54 fe ff ff       	call   119a40 <lv_log_add>
  119bec:	e9 fb ff ff ff       	jmp    119bec <lv_label_create+0x5c>
    if(new_label == NULL) return NULL;
  119bf1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  119bf5:	0f 85 0c 00 00 00    	jne    119c07 <lv_label_create+0x77>
  119bfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  119c02:	e9 6e 04 00 00       	jmp    11a075 <lv_label_create+0x4e5>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
  119c07:	83 3d b8 55 13 00 00 	cmpl   $0x0,0x1355b8
  119c0e:	0f 85 10 00 00 00    	jne    119c24 <lv_label_create+0x94>
  119c14:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119c17:	89 04 24             	mov    %eax,(%esp)
  119c1a:	e8 41 60 ff ff       	call   10fc60 <lv_obj_get_signal_cb>
  119c1f:	a3 b8 55 13 00       	mov    %eax,0x1355b8

    /*Extend the basic object to a label object*/
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
  119c24:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119c27:	89 04 24             	mov    %eax,(%esp)
  119c2a:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  119c31:	00 
  119c32:	e8 e9 5d ff ff       	call   10fa20 <lv_obj_allocate_ext_attr>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
  119c37:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119c3a:	89 0c 24             	mov    %ecx,(%esp)
  119c3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  119c40:	e8 3b 60 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  119c45:	89 45 e8             	mov    %eax,-0x18(%ebp)
    lv_mem_assert(ext);
  119c48:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  119c4c:	0f 85 2d 00 00 00    	jne    119c7f <lv_label_create+0xef>
  119c52:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  119c59:	8d 05 07 46 12 00    	lea    0x124607,%eax
  119c5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  119c63:	c7 44 24 08 54 00 00 	movl   $0x54,0x8(%esp)
  119c6a:	00 
  119c6b:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  119c71:	89 44 24 0c          	mov    %eax,0xc(%esp)
  119c75:	e8 c6 fd ff ff       	call   119a40 <lv_log_add>
  119c7a:	e9 fb ff ff ff       	jmp    119c7a <lv_label_create+0xea>
    if(ext == NULL) return NULL;
  119c7f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  119c83:	0f 85 0c 00 00 00    	jne    119c95 <lv_label_create+0x105>
  119c89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  119c90:	e9 e0 03 00 00       	jmp    11a075 <lv_label_create+0x4e5>

    ext->text       = NULL;
  119c95:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119c98:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    ext->static_txt = 0;
  119c9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119ca1:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119ca5:	66 83 e1 f7          	and    $0xfff7,%cx
  119ca9:	66 89 48 0e          	mov    %cx,0xe(%eax)
    ext->recolor    = 0;
  119cad:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119cb0:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119cb4:	66 83 e1 bf          	and    $0xffbf,%cx
  119cb8:	66 89 48 0e          	mov    %cx,0xe(%eax)
    ext->body_draw  = 0;
  119cbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119cbf:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119cc3:	66 81 e1 ff fe       	and    $0xfeff,%cx
  119cc8:	66 89 48 0e          	mov    %cx,0xe(%eax)
    ext->align      = LV_LABEL_ALIGN_LEFT;
  119ccc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119ccf:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119cd3:	66 83 e1 cf          	and    $0xffcf,%cx
  119cd7:	66 89 48 0e          	mov    %cx,0xe(%eax)
    ext->dot_end    = LV_LABEL_DOT_END_INV;
  119cdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119cde:	66 c7 40 08 ff ff    	movw   $0xffff,0x8(%eax)
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
  119ce4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119ce7:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119ceb:	66 83 e1 f8          	and    $0xfff8,%cx
  119cef:	66 89 48 0e          	mov    %cx,0xe(%eax)
#if LV_USE_ANIMATION
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
#endif
    ext->offset.x = 0;
  119cf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119cf6:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    ext->offset.y = 0;
  119cfc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119cff:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)

#if LV_LABEL_TEXT_SEL
    ext->txt_sel_start = LV_LABEL_TEXT_SEL_OFF;
    ext->txt_sel_end   = LV_LABEL_TEXT_SEL_OFF;
#endif
    ext->dot.tmp_ptr   = NULL;
  119d05:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119d08:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    ext->dot_tmp_alloc = 0;
  119d0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119d12:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119d16:	66 81 e1 ff fd       	and    $0xfdff,%cx
  119d1b:	66 89 48 0e          	mov    %cx,0xe(%eax)

    lv_obj_set_design_cb(new_label, lv_label_design);
  119d1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119d22:	89 04 24             	mov    %eax,(%esp)
  119d25:	8d 05 80 a0 11 00    	lea    0x11a080,%eax
  119d2b:	89 44 24 04          	mov    %eax,0x4(%esp)
  119d2f:	e8 dc 49 ff ff       	call   10e710 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
  119d34:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119d37:	89 04 24             	mov    %eax,(%esp)
  119d3a:	8d 05 e0 a7 11 00    	lea    0x11a7e0,%eax
  119d40:	89 44 24 04          	mov    %eax,0x4(%esp)
  119d44:	e8 b7 48 ff ff       	call   10e600 <lv_obj_set_signal_cb>

    /*Init the new label*/
    if(copy == NULL) {
  119d49:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  119d4d:	0f 85 6a 00 00 00    	jne    119dbd <lv_label_create+0x22d>
  119d53:	31 c0                	xor    %eax,%eax
        lv_obj_set_click(new_label, false);
  119d55:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119d58:	89 0c 24             	mov    %ecx,(%esp)
  119d5b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119d62:	00 
  119d63:	89 45 d0             	mov    %eax,-0x30(%ebp)
  119d66:	e8 55 5c ff ff       	call   10f9c0 <lv_obj_set_click>
  119d6b:	31 c0                	xor    %eax,%eax
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
  119d6d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119d70:	89 0c 24             	mov    %ecx,(%esp)
  119d73:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119d7a:	00 
  119d7b:	89 45 cc             	mov    %eax,-0x34(%ebp)
  119d7e:	e8 6d 0d 00 00       	call   11aaf0 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
  119d83:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119d86:	89 04 24             	mov    %eax,(%esp)
  119d89:	8d 05 4d 46 12 00    	lea    0x12464d,%eax
  119d8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  119d93:	e8 48 0e 00 00       	call   11abe0 <lv_label_set_text>
  119d98:	31 c0                	xor    %eax,%eax
        lv_label_set_style(new_label, LV_LABEL_STYLE_MAIN, NULL); /*Inherit parent's style*/
  119d9a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119d9d:	89 0c 24             	mov    %ecx,(%esp)
  119da0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  119da7:	00 
  119da8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  119daf:	00 
  119db0:	89 45 c8             	mov    %eax,-0x38(%ebp)
  119db3:	e8 d8 0f 00 00       	call   11ad90 <lv_label_set_style>
    }
  119db8:	e9 8a 02 00 00       	jmp    11a047 <lv_label_create+0x4b7>
    /*Copy 'copy' if not NULL*/
    else {
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
  119dbd:	8b 45 0c             	mov    0xc(%ebp),%eax
  119dc0:	89 04 24             	mov    %eax,(%esp)
  119dc3:	e8 b8 5e ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  119dc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
  119dcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119dce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  119dd1:	89 0c 24             	mov    %ecx,(%esp)
  119dd4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  119dd7:	e8 f4 0f 00 00       	call   11add0 <lv_label_get_long_mode>
  119ddc:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  119ddf:	89 0c 24             	mov    %ecx,(%esp)
  119de2:	0f b6 c8             	movzbl %al,%ecx
  119de5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119de9:	e8 02 0d 00 00       	call   11aaf0 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
  119dee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119df1:	8b 55 0c             	mov    0xc(%ebp),%edx
  119df4:	89 14 24             	mov    %edx,(%esp)
  119df7:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  119dfa:	e8 b1 10 00 00       	call   11aeb0 <lv_label_get_recolor>
  119dff:	89 e1                	mov    %esp,%ecx
  119e01:	8b 55 c0             	mov    -0x40(%ebp),%edx
  119e04:	89 11                	mov    %edx,(%ecx)
  119e06:	0f b6 f0             	movzbl %al,%esi
  119e09:	83 e6 01             	and    $0x1,%esi
  119e0c:	89 71 04             	mov    %esi,0x4(%ecx)
  119e0f:	e8 ec 0f 00 00       	call   11ae00 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
  119e14:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119e17:	8b 55 0c             	mov    0xc(%ebp),%edx
  119e1a:	89 14 24             	mov    %edx,(%esp)
  119e1d:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  119e20:	e8 ab 11 00 00       	call   11afd0 <lv_label_get_body_draw>
  119e25:	89 e1                	mov    %esp,%ecx
  119e27:	8b 55 bc             	mov    -0x44(%ebp),%edx
  119e2a:	89 11                	mov    %edx,(%ecx)
  119e2c:	0f b6 f0             	movzbl %al,%esi
  119e2f:	83 e6 01             	and    $0x1,%esi
  119e32:	89 71 04             	mov    %esi,0x4(%ecx)
  119e35:	e8 d6 10 00 00       	call   11af10 <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
  119e3a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  119e3d:	8b 55 0c             	mov    0xc(%ebp),%edx
  119e40:	89 14 24             	mov    %edx,(%esp)
  119e43:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  119e46:	e8 65 12 00 00       	call   11b0b0 <lv_label_get_align>
  119e4b:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  119e4e:	89 0c 24             	mov    %ecx,(%esp)
  119e51:	0f b6 c8             	movzbl %al,%ecx
  119e54:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119e58:	e8 d3 11 00 00       	call   11b030 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
  119e5d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  119e60:	66 8b 79 0e          	mov    0xe(%ecx),%di
  119e64:	66 c1 ef 03          	shr    $0x3,%di
  119e68:	66 89 fb             	mov    %di,%bx
  119e6b:	66 83 e3 01          	and    $0x1,%bx
  119e6f:	0f b6 cb             	movzbl %bl,%ecx
  119e72:	83 f9 00             	cmp    $0x0,%ecx
  119e75:	0f 85 25 00 00 00    	jne    119ea0 <lv_label_create+0x310>
            lv_label_set_text(new_label, lv_label_get_text(copy));
  119e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119e7e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  119e81:	89 0c 24             	mov    %ecx,(%esp)
  119e84:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  119e87:	e8 64 12 00 00       	call   11b0f0 <lv_label_get_text>
  119e8c:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  119e8f:	89 0c 24             	mov    %ecx,(%esp)
  119e92:	89 44 24 04          	mov    %eax,0x4(%esp)
  119e96:	e8 45 0d 00 00       	call   11abe0 <lv_label_set_text>
  119e9b:	e9 20 00 00 00       	jmp    119ec0 <lv_label_create+0x330>
        else
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
  119ea0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119ea3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  119ea6:	89 0c 24             	mov    %ecx,(%esp)
  119ea9:	89 45 b0             	mov    %eax,-0x50(%ebp)
  119eac:	e8 3f 12 00 00       	call   11b0f0 <lv_label_get_text>
  119eb1:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  119eb4:	89 0c 24             	mov    %ecx,(%esp)
  119eb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  119ebb:	e8 60 12 00 00       	call   11b120 <lv_label_set_static_text>

        /*In DOT mode save the text byte-to-byte because a '\0' can be in the middle*/
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
  119ec0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  119ec3:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119ec7:	66 83 e1 07          	and    $0x7,%cx
  119ecb:	0f b6 c1             	movzbl %cl,%eax
  119ece:	83 f8 02             	cmp    $0x2,%eax
  119ed1:	0f 85 ad 00 00 00    	jne    119f84 <lv_label_create+0x3f4>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
  119ed7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119eda:	8b 00                	mov    (%eax),%eax
  119edc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  119edf:	8b 09                	mov    (%ecx),%ecx
  119ee1:	89 0c 24             	mov    %ecx,(%esp)
  119ee4:	89 45 ac             	mov    %eax,-0x54(%ebp)
  119ee7:	e8 f4 e9 ff ff       	call   1188e0 <lv_mem_get_size>
  119eec:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  119eef:	89 0c 24             	mov    %ecx,(%esp)
  119ef2:	89 44 24 04          	mov    %eax,0x4(%esp)
  119ef6:	e8 45 ea ff ff       	call   118940 <lv_mem_realloc>
  119efb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  119efe:	89 01                	mov    %eax,(%ecx)
            lv_mem_assert(ext->text);
  119f00:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119f03:	83 38 00             	cmpl   $0x0,(%eax)
  119f06:	0f 85 2d 00 00 00    	jne    119f39 <lv_label_create+0x3a9>
  119f0c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  119f13:	8d 05 07 46 12 00    	lea    0x124607,%eax
  119f19:	89 44 24 04          	mov    %eax,0x4(%esp)
  119f1d:	c7 44 24 08 8a 00 00 	movl   $0x8a,0x8(%esp)
  119f24:	00 
  119f25:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  119f2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  119f2f:	e8 0c fb ff ff       	call   119a40 <lv_log_add>
  119f34:	e9 fb ff ff ff       	jmp    119f34 <lv_label_create+0x3a4>
            if(ext->text == NULL) return NULL;
  119f39:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119f3c:	83 38 00             	cmpl   $0x0,(%eax)
  119f3f:	0f 85 0c 00 00 00    	jne    119f51 <lv_label_create+0x3c1>
  119f45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  119f4c:	e9 24 01 00 00       	jmp    11a075 <lv_label_create+0x4e5>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
  119f51:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119f54:	8b 00                	mov    (%eax),%eax
  119f56:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  119f59:	8b 09                	mov    (%ecx),%ecx
  119f5b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  119f5e:	8b 12                	mov    (%edx),%edx
  119f60:	89 14 24             	mov    %edx,(%esp)
  119f63:	89 45 a8             	mov    %eax,-0x58(%ebp)
  119f66:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  119f69:	e8 72 e9 ff ff       	call   1188e0 <lv_mem_get_size>
  119f6e:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  119f71:	89 0c 24             	mov    %ecx,(%esp)
  119f74:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
  119f77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119f7b:	89 44 24 08          	mov    %eax,0x8(%esp)
  119f7f:	e8 cc 03 ff ff       	call   10a350 <memcpy>
        }

        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
  119f84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  119f87:	66 8b 48 0e          	mov    0xe(%eax),%cx
  119f8b:	66 c1 e9 09          	shr    $0x9,%cx
  119f8f:	66 83 e1 01          	and    $0x1,%cx
  119f93:	0f b6 c1             	movzbl %cl,%eax
  119f96:	83 f8 00             	cmp    $0x0,%eax
  119f99:	0f 84 42 00 00 00    	je     119fe1 <lv_label_create+0x451>
  119f9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  119fa2:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  119fa6:	0f 84 35 00 00 00    	je     119fe1 <lv_label_create+0x451>
            int len = strlen(copy_ext->dot.tmp_ptr);
  119fac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  119faf:	8b 40 04             	mov    0x4(%eax),%eax
  119fb2:	89 04 24             	mov    %eax,(%esp)
  119fb5:	e8 e6 02 ff ff       	call   10a2a0 <strlen>
  119fba:	89 45 e0             	mov    %eax,-0x20(%ebp)
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
  119fbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  119fc0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  119fc3:	8b 49 04             	mov    0x4(%ecx),%ecx
  119fc6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  119fc9:	89 04 24             	mov    %eax,(%esp)
  119fcc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119fd0:	0f b7 c2             	movzwl %dx,%eax
  119fd3:	89 44 24 08          	mov    %eax,0x8(%esp)
  119fd7:	e8 e4 11 00 00       	call   11b1c0 <lv_label_set_dot_tmp>
        } else {
  119fdc:	e9 20 00 00 00       	jmp    11a001 <lv_label_create+0x471>
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
  119fe1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  119fe4:	83 c0 04             	add    $0x4,%eax
  119fe7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  119fea:	83 c1 04             	add    $0x4,%ecx
  119fed:	89 04 24             	mov    %eax,(%esp)
  119ff0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  119ff4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  119ffb:	00 
  119ffc:	e8 4f 03 ff ff       	call   10a350 <memcpy>
        }
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
  11a001:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11a004:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a008:	66 c1 e9 09          	shr    $0x9,%cx
  11a00c:	66 83 e1 01          	and    $0x1,%cx
  11a010:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11a013:	0f b6 d1             	movzbl %cl,%edx
  11a016:	66 8b 70 0e          	mov    0xe(%eax),%si
  11a01a:	66 83 e2 01          	and    $0x1,%dx
  11a01e:	66 c1 e2 09          	shl    $0x9,%dx
  11a022:	66 81 e6 ff fd       	and    $0xfdff,%si
  11a027:	66 09 d6             	or     %dx,%si
  11a02a:	66 89 70 0e          	mov    %si,0xe(%eax)
        ext->dot_end       = copy_ext->dot_end;
  11a02e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11a031:	66 8b 50 08          	mov    0x8(%eax),%dx
  11a035:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11a038:	66 89 50 08          	mov    %dx,0x8(%eax)

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_label);
  11a03c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a03f:	89 04 24             	mov    %eax,(%esp)
  11a042:	e8 29 59 ff ff       	call   10f970 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("label created");
  11a047:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11a04e:	8d 05 07 46 12 00    	lea    0x124607,%eax
  11a054:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a058:	c7 44 24 08 9c 00 00 	movl   $0x9c,0x8(%esp)
  11a05f:	00 
  11a060:	8d 05 52 46 12 00    	lea    0x124652,%eax
  11a066:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11a06a:	e8 d1 f9 ff ff       	call   119a40 <lv_log_add>

    return new_label;
  11a06f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a072:	89 45 f0             	mov    %eax,-0x10(%ebp)
}
  11a075:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11a078:	83 c4 60             	add    $0x60,%esp
  11a07b:	5e                   	pop    %esi
  11a07c:	5f                   	pop    %edi
  11a07d:	5b                   	pop    %ebx
  11a07e:	5d                   	pop    %ebp
  11a07f:	c3                   	ret    

0011a080 <lv_label_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_label_design(lv_obj_t * label, const lv_area_t * mask, lv_design_mode_t mode)
{
  11a080:	55                   	push   %ebp
  11a081:	89 e5                	mov    %esp,%ebp
  11a083:	53                   	push   %ebx
  11a084:	57                   	push   %edi
  11a085:	56                   	push   %esi
  11a086:	83 e4 f8             	and    $0xfffffff8,%esp
  11a089:	81 ec d0 00 00 00    	sub    $0xd0,%esp
  11a08f:	8a 45 10             	mov    0x10(%ebp),%al
  11a092:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11a095:	8b 55 08             	mov    0x8(%ebp),%edx
    /* A label never covers an area */
    if(mode == LV_DESIGN_COVER_CHK)
  11a098:	0f b6 75 10          	movzbl 0x10(%ebp),%esi
  11a09c:	83 fe 02             	cmp    $0x2,%esi
  11a09f:	0f 85 0d 00 00 00    	jne    11a0b2 <lv_label_design+0x32>
        return false;
  11a0a5:	c6 84 24 cb 00 00 00 	movb   $0x0,0xcb(%esp)
  11a0ac:	00 
  11a0ad:	e9 1a 07 00 00       	jmp    11a7cc <lv_label_design+0x74c>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
  11a0b2:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  11a0b6:	83 f8 00             	cmp    $0x0,%eax
  11a0b9:	0f 85 00 07 00 00    	jne    11a7bf <lv_label_design+0x73f>
        lv_area_t coords;
        const lv_style_t * style = lv_obj_get_style(label);
  11a0bf:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0c2:	89 04 24             	mov    %eax,(%esp)
  11a0c5:	e8 e6 59 ff ff       	call   10fab0 <lv_obj_get_style>
  11a0ca:	89 84 24 bc 00 00 00 	mov    %eax,0xbc(%esp)
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
  11a0d1:	8b 45 08             	mov    0x8(%ebp),%eax
  11a0d4:	89 04 24             	mov    %eax,(%esp)
  11a0d7:	e8 d4 5a ff ff       	call   10fbb0 <lv_obj_get_opa_scale>
  11a0dc:	88 84 24 bb 00 00 00 	mov    %al,0xbb(%esp)
        lv_obj_get_coords(label, &coords);
  11a0e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a0e6:	89 0c 24             	mov    %ecx,(%esp)
  11a0e9:	8d 8c 24 c0 00 00 00 	lea    0xc0(%esp),%ecx
  11a0f0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11a0f4:	e8 47 4e ff ff       	call   10ef40 <lv_obj_get_coords>
        if(lv_group_get_focused(g) == label) {
            lv_draw_rect(&coords, mask, style, opa_scale);
        }
#endif

        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11a0f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a0fc:	89 0c 24             	mov    %ecx,(%esp)
  11a0ff:	e8 7c 5b ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11a104:	89 84 24 b4 00 00 00 	mov    %eax,0xb4(%esp)

        if(ext->body_draw) {
  11a10b:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a112:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11a116:	66 c1 ea 08          	shr    $0x8,%dx
  11a11a:	66 83 e2 01          	and    $0x1,%dx
  11a11e:	80 fa 00             	cmp    $0x0,%dl
  11a121:	0f 84 d9 00 00 00    	je     11a200 <lv_label_design+0x180>
            lv_area_t bg;
            lv_obj_get_coords(label, &bg);
  11a127:	8b 45 08             	mov    0x8(%ebp),%eax
  11a12a:	89 04 24             	mov    %eax,(%esp)
  11a12d:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
  11a134:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a138:	e8 03 4e ff ff       	call   10ef40 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
  11a13d:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
  11a144:	0f bf 40 24          	movswl 0x24(%eax),%eax
  11a148:	0f bf 8c 24 a8 00 00 	movswl 0xa8(%esp),%ecx
  11a14f:	00 
  11a150:	29 c1                	sub    %eax,%ecx
  11a152:	66 89 8c 24 a8 00 00 	mov    %cx,0xa8(%esp)
  11a159:	00 
            bg.x2 += style->body.padding.right;
  11a15a:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
  11a161:	0f bf 40 26          	movswl 0x26(%eax),%eax
  11a165:	0f bf 94 24 ac 00 00 	movswl 0xac(%esp),%edx
  11a16c:	00 
  11a16d:	01 c2                	add    %eax,%edx
  11a16f:	66 89 94 24 ac 00 00 	mov    %dx,0xac(%esp)
  11a176:	00 
            bg.y1 -= style->body.padding.top;
  11a177:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
  11a17e:	0f bf 40 20          	movswl 0x20(%eax),%eax
  11a182:	0f bf b4 24 aa 00 00 	movswl 0xaa(%esp),%esi
  11a189:	00 
  11a18a:	29 c6                	sub    %eax,%esi
  11a18c:	66 89 b4 24 aa 00 00 	mov    %si,0xaa(%esp)
  11a193:	00 
            bg.y2 += style->body.padding.bottom;
  11a194:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
  11a19b:	0f bf 40 22          	movswl 0x22(%eax),%eax
  11a19f:	0f bf bc 24 ae 00 00 	movswl 0xae(%esp),%edi
  11a1a6:	00 
  11a1a7:	01 c7                	add    %eax,%edi
  11a1a9:	66 89 bc 24 ae 00 00 	mov    %di,0xae(%esp)
  11a1b0:	00 

            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
  11a1b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a1b4:	8b 9c 24 bc 00 00 00 	mov    0xbc(%esp),%ebx
  11a1bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a1be:	89 0c 24             	mov    %ecx,(%esp)
  11a1c1:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
  11a1c8:	89 9c 24 88 00 00 00 	mov    %ebx,0x88(%esp)
  11a1cf:	e8 dc 59 ff ff       	call   10fbb0 <lv_obj_get_opa_scale>
  11a1d4:	8d 8c 24 a8 00 00 00 	lea    0xa8(%esp),%ecx
  11a1db:	89 0c 24             	mov    %ecx,(%esp)
  11a1de:	8b 8c 24 8c 00 00 00 	mov    0x8c(%esp),%ecx
  11a1e5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11a1e9:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
  11a1f0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11a1f4:	0f b6 c8             	movzbl %al,%ecx
  11a1f7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11a1fb:	e8 30 89 ff ff       	call   112b30 <lv_draw_rect>
        }

        /*TEST: draw a background for the label*/
        // lv_draw_rect(&label->coords, mask, &lv_style_plain_color, LV_OPA_COVER);

        lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
  11a200:	c6 84 24 a7 00 00 00 	movb   $0x0,0xa7(%esp)
  11a207:	00 
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
  11a208:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a20f:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a213:	66 c1 e9 06          	shr    $0x6,%cx
  11a217:	66 83 e1 01          	and    $0x1,%cx
  11a21b:	0f b6 c1             	movzbl %cl,%eax
  11a21e:	83 f8 00             	cmp    $0x0,%eax
  11a221:	0f 84 12 00 00 00    	je     11a239 <lv_label_design+0x1b9>
  11a227:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a22e:	00 
  11a22f:	83 c8 01             	or     $0x1,%eax
  11a232:	88 84 24 a7 00 00 00 	mov    %al,0xa7(%esp)
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
  11a239:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a240:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a244:	66 c1 e9 07          	shr    $0x7,%cx
  11a248:	66 83 e1 01          	and    $0x1,%cx
  11a24c:	0f b6 c1             	movzbl %cl,%eax
  11a24f:	83 f8 00             	cmp    $0x0,%eax
  11a252:	0f 84 12 00 00 00    	je     11a26a <lv_label_design+0x1ea>
  11a258:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a25f:	00 
  11a260:	83 c8 02             	or     $0x2,%eax
  11a263:	88 84 24 a7 00 00 00 	mov    %al,0xa7(%esp)
        if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
  11a26a:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a271:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a275:	66 c1 e9 04          	shr    $0x4,%cx
  11a279:	66 83 e1 03          	and    $0x3,%cx
  11a27d:	0f b6 c1             	movzbl %cl,%eax
  11a280:	83 f8 01             	cmp    $0x1,%eax
  11a283:	0f 85 12 00 00 00    	jne    11a29b <lv_label_design+0x21b>
  11a289:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a290:	00 
  11a291:	83 c8 04             	or     $0x4,%eax
  11a294:	88 84 24 a7 00 00 00 	mov    %al,0xa7(%esp)
        if(ext->align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
  11a29b:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a2a2:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a2a6:	66 c1 e9 04          	shr    $0x4,%cx
  11a2aa:	66 83 e1 03          	and    $0x3,%cx
  11a2ae:	0f b6 c1             	movzbl %cl,%eax
  11a2b1:	83 f8 02             	cmp    $0x2,%eax
  11a2b4:	0f 85 12 00 00 00    	jne    11a2cc <lv_label_design+0x24c>
  11a2ba:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a2c1:	00 
  11a2c2:	83 c8 08             	or     $0x8,%eax
  11a2c5:	88 84 24 a7 00 00 00 	mov    %al,0xa7(%esp)

        /* In ROLL mode the CENTER and RIGHT are pointless so remove them.
         * (In addition they will result mis-alignment is this case)*/
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
  11a2cc:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a2d3:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a2d7:	66 83 e1 07          	and    $0x7,%cx
  11a2db:	0f b6 c1             	movzbl %cl,%eax
  11a2de:	83 f8 03             	cmp    $0x3,%eax
  11a2e1:	0f 84 1b 00 00 00    	je     11a302 <lv_label_design+0x282>
  11a2e7:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a2ee:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a2f2:	66 83 e1 07          	and    $0x7,%cx
  11a2f6:	0f b6 c1             	movzbl %cl,%eax
  11a2f9:	83 f8 04             	cmp    $0x4,%eax
  11a2fc:	0f 85 f5 00 00 00    	jne    11a3f7 <lv_label_design+0x377>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
  11a302:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a309:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a30d:	66 c1 e9 04          	shr    $0x4,%cx
  11a311:	66 83 e1 03          	and    $0x3,%cx
  11a315:	0f b6 c1             	movzbl %cl,%eax
  11a318:	83 f8 01             	cmp    $0x1,%eax
  11a31b:	0f 84 1f 00 00 00    	je     11a340 <lv_label_design+0x2c0>
  11a321:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a328:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a32c:	66 c1 e9 04          	shr    $0x4,%cx
  11a330:	66 83 e1 03          	and    $0x3,%cx
  11a334:	0f b6 c1             	movzbl %cl,%eax
  11a337:	83 f8 02             	cmp    $0x2,%eax
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
  11a33a:	0f 85 b7 00 00 00    	jne    11a3f7 <lv_label_design+0x377>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
  11a340:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a347:	8b 00                	mov    (%eax),%eax
  11a349:	8b 8c 24 bc 00 00 00 	mov    0xbc(%esp),%ecx
  11a350:	8b 49 34             	mov    0x34(%ecx),%ecx
  11a353:	8b 94 24 bc 00 00 00 	mov    0xbc(%esp),%edx
  11a35a:	66 8b 72 38          	mov    0x38(%edx),%si
  11a35e:	8b 94 24 bc 00 00 00 	mov    0xbc(%esp),%edx
  11a365:	66 8b 7a 3a          	mov    0x3a(%edx),%di
  11a369:	8d 94 24 a0 00 00 00 	lea    0xa0(%esp),%edx
  11a370:	89 14 24             	mov    %edx,(%esp)
  11a373:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a377:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11a37b:	0f bf c6             	movswl %si,%eax
  11a37e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11a382:	0f bf c7             	movswl %di,%eax
  11a385:	89 44 24 10          	mov    %eax,0x10(%esp)
  11a389:	c7 44 24 14 18 7c 00 	movl   $0x7c18,0x14(%esp)
  11a390:	00 
  11a391:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a398:	00 
  11a399:	89 44 24 18          	mov    %eax,0x18(%esp)
  11a39d:	e8 7e ef ff ff       	call   119320 <lv_txt_get_size>
                            LV_COORD_MAX, flag);
            if(size.x > lv_obj_get_width(label)) {
  11a3a2:	0f bf 84 24 a0 00 00 	movswl 0xa0(%esp),%eax
  11a3a9:	00 
  11a3aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a3ad:	89 0c 24             	mov    %ecx,(%esp)
  11a3b0:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
  11a3b7:	e8 04 4e ff ff       	call   10f1c0 <lv_obj_get_width>
  11a3bc:	0f bf c8             	movswl %ax,%ecx
  11a3bf:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
  11a3c6:	39 ca                	cmp    %ecx,%edx
  11a3c8:	0f 8e 24 00 00 00    	jle    11a3f2 <lv_label_design+0x372>
                flag &= ~LV_TXT_FLAG_RIGHT;
  11a3ce:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a3d5:	00 
  11a3d6:	83 e0 f7             	and    $0xfffffff7,%eax
  11a3d9:	88 84 24 a7 00 00 00 	mov    %al,0xa7(%esp)
                flag &= ~LV_TXT_FLAG_CENTER;
  11a3e0:	0f b6 8c 24 a7 00 00 	movzbl 0xa7(%esp),%ecx
  11a3e7:	00 
  11a3e8:	83 e1 fb             	and    $0xfffffffb,%ecx
  11a3eb:	88 8c 24 a7 00 00 00 	mov    %cl,0xa7(%esp)
            }
        }
  11a3f2:	e9 00 00 00 00       	jmp    11a3f7 <lv_label_design+0x377>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC || lv_obj_get_height(label) < LV_LABEL_HINT_HEIGHT_LIMIT)
            hint = NULL;

#else
        /*Just for compatibility*/
        lv_draw_label_hint_t * hint = NULL;
  11a3f7:	c7 84 24 9c 00 00 00 	movl   $0x0,0x9c(%esp)
  11a3fe:	00 00 00 00 
#endif
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset,
  11a402:	8b 45 0c             	mov    0xc(%ebp),%eax
  11a405:	8b 8c 24 bc 00 00 00 	mov    0xbc(%esp),%ecx
  11a40c:	8a 94 24 bb 00 00 00 	mov    0xbb(%esp),%dl
  11a413:	8b b4 24 b4 00 00 00 	mov    0xb4(%esp),%esi
  11a41a:	8b 36                	mov    (%esi),%esi
  11a41c:	8a b4 24 a7 00 00 00 	mov    0xa7(%esp),%dh
  11a423:	8b bc 24 b4 00 00 00 	mov    0xb4(%esp),%edi
  11a42a:	83 c7 0a             	add    $0xa,%edi
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), hint);
  11a42d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11a430:	89 1c 24             	mov    %ebx,(%esp)
  11a433:	89 84 24 80 00 00 00 	mov    %eax,0x80(%esp)
  11a43a:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
  11a43e:	88 54 24 7b          	mov    %dl,0x7b(%esp)
  11a442:	89 74 24 74          	mov    %esi,0x74(%esp)
  11a446:	88 74 24 73          	mov    %dh,0x73(%esp)
  11a44a:	89 7c 24 6c          	mov    %edi,0x6c(%esp)
  11a44e:	e8 7d 17 00 00       	call   11bbd0 <lv_label_get_text_sel_start>
  11a453:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a456:	89 0c 24             	mov    %ecx,(%esp)
  11a459:	66 89 44 24 6a       	mov    %ax,0x6a(%esp)
  11a45e:	e8 8d 17 00 00       	call   11bbf0 <lv_label_get_text_sel_end>
  11a463:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset,
  11a46a:	8d b4 24 c0 00 00 00 	lea    0xc0(%esp),%esi
  11a471:	89 34 24             	mov    %esi,(%esp)
  11a474:	8b b4 24 80 00 00 00 	mov    0x80(%esp),%esi
  11a47b:	89 74 24 04          	mov    %esi,0x4(%esp)
  11a47f:	8b 74 24 7c          	mov    0x7c(%esp),%esi
  11a483:	89 74 24 08          	mov    %esi,0x8(%esp)
  11a487:	8a 54 24 7b          	mov    0x7b(%esp),%dl
  11a48b:	0f b6 f2             	movzbl %dl,%esi
  11a48e:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11a492:	8b 74 24 74          	mov    0x74(%esp),%esi
  11a496:	89 74 24 10          	mov    %esi,0x10(%esp)
  11a49a:	8a 74 24 73          	mov    0x73(%esp),%dh
  11a49e:	0f b6 f6             	movzbl %dh,%esi
  11a4a1:	89 74 24 14          	mov    %esi,0x14(%esp)
  11a4a5:	8b 74 24 6c          	mov    0x6c(%esp),%esi
  11a4a9:	89 74 24 18          	mov    %esi,0x18(%esp)
  11a4ad:	66 8b 74 24 6a       	mov    0x6a(%esp),%si
  11a4b2:	0f b7 fe             	movzwl %si,%edi
  11a4b5:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
  11a4b9:	0f b7 f8             	movzwl %ax,%edi
  11a4bc:	89 7c 24 20          	mov    %edi,0x20(%esp)
  11a4c0:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  11a4c4:	e8 d7 ac ff ff       	call   1151a0 <lv_draw_label>


        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
  11a4c9:	8b 8c 24 b4 00 00 00 	mov    0xb4(%esp),%ecx
  11a4d0:	66 8b 41 0e          	mov    0xe(%ecx),%ax
  11a4d4:	66 83 e0 07          	and    $0x7,%ax
  11a4d8:	0f b6 c8             	movzbl %al,%ecx
  11a4db:	83 f9 04             	cmp    $0x4,%ecx
  11a4de:	0f 85 d6 02 00 00    	jne    11a7ba <lv_label_design+0x73a>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
  11a4e4:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a4eb:	8b 00                	mov    (%eax),%eax
  11a4ed:	8b 8c 24 bc 00 00 00 	mov    0xbc(%esp),%ecx
  11a4f4:	8b 49 34             	mov    0x34(%ecx),%ecx
  11a4f7:	8b 94 24 bc 00 00 00 	mov    0xbc(%esp),%edx
  11a4fe:	66 8b 72 38          	mov    0x38(%edx),%si
  11a502:	8b 94 24 bc 00 00 00 	mov    0xbc(%esp),%edx
  11a509:	66 8b 7a 3a          	mov    0x3a(%edx),%di
  11a50d:	8d 94 24 98 00 00 00 	lea    0x98(%esp),%edx
  11a514:	89 14 24             	mov    %edx,(%esp)
  11a517:	89 44 24 04          	mov    %eax,0x4(%esp)
  11a51b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11a51f:	0f bf c6             	movswl %si,%eax
  11a522:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11a526:	0f bf c7             	movswl %di,%eax
  11a529:	89 44 24 10          	mov    %eax,0x10(%esp)
  11a52d:	c7 44 24 14 18 7c 00 	movl   $0x7c18,0x14(%esp)
  11a534:	00 
  11a535:	0f b6 84 24 a7 00 00 	movzbl 0xa7(%esp),%eax
  11a53c:	00 
  11a53d:	89 44 24 18          	mov    %eax,0x18(%esp)
  11a541:	e8 da ed ff ff       	call   119320 <lv_txt_get_size>
                            LV_COORD_MAX, flag);

            lv_point_t ofs;

            /*Draw the text again next to the original to make an circular effect */
            if(size.x > lv_obj_get_width(label)) {
  11a546:	0f bf 84 24 98 00 00 	movswl 0x98(%esp),%eax
  11a54d:	00 
  11a54e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a551:	89 0c 24             	mov    %ecx,(%esp)
  11a554:	89 44 24 64          	mov    %eax,0x64(%esp)
  11a558:	e8 63 4c ff ff       	call   10f1c0 <lv_obj_get_width>
  11a55d:	0f bf c8             	movswl %ax,%ecx
  11a560:	8b 54 24 64          	mov    0x64(%esp),%edx
  11a564:	39 ca                	cmp    %ecx,%edx
  11a566:	0f 8e 1b 01 00 00    	jle    11a687 <lv_label_design+0x607>
                ofs.x = ext->offset.x + size.x +
  11a56c:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a573:	0f bf 40 0a          	movswl 0xa(%eax),%eax
  11a577:	0f bf 8c 24 98 00 00 	movswl 0x98(%esp),%ecx
  11a57e:	00 
  11a57f:	01 c8                	add    %ecx,%eax
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
  11a581:	8b 8c 24 bc 00 00 00 	mov    0xbc(%esp),%ecx
  11a588:	8b 49 34             	mov    0x34(%ecx),%ecx
  11a58b:	89 0c 24             	mov    %ecx,(%esp)
  11a58e:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  11a595:	00 
  11a596:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  11a59d:	00 
  11a59e:	89 44 24 60          	mov    %eax,0x60(%esp)
  11a5a2:	e8 69 18 00 00       	call   11be10 <lv_font_get_glyph_width>
  11a5a7:	0f b7 c8             	movzwl %ax,%ecx
  11a5aa:	6b c9 03             	imul   $0x3,%ecx,%ecx
  11a5ad:	8b 54 24 60          	mov    0x60(%esp),%edx
                ofs.x = ext->offset.x + size.x +
  11a5b1:	01 ca                	add    %ecx,%edx
  11a5b3:	66 89 94 24 90 00 00 	mov    %dx,0x90(%esp)
  11a5ba:	00 
                ofs.y = ext->offset.y;
  11a5bb:	8b 8c 24 b4 00 00 00 	mov    0xb4(%esp),%ecx
  11a5c2:	66 8b 41 0c          	mov    0xc(%ecx),%ax
  11a5c6:	66 89 84 24 92 00 00 	mov    %ax,0x92(%esp)
  11a5cd:	00 

                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
  11a5ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11a5d1:	8b b4 24 bc 00 00 00 	mov    0xbc(%esp),%esi
  11a5d8:	8a 9c 24 bb 00 00 00 	mov    0xbb(%esp),%bl
  11a5df:	8b bc 24 b4 00 00 00 	mov    0xb4(%esp),%edi
  11a5e6:	8b 3f                	mov    (%edi),%edi
  11a5e8:	8a bc 24 a7 00 00 00 	mov    0xa7(%esp),%bh
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
  11a5ef:	8b 45 08             	mov    0x8(%ebp),%eax
  11a5f2:	89 04 24             	mov    %eax,(%esp)
  11a5f5:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
  11a5f9:	89 74 24 58          	mov    %esi,0x58(%esp)
  11a5fd:	88 5c 24 57          	mov    %bl,0x57(%esp)
  11a601:	89 7c 24 50          	mov    %edi,0x50(%esp)
  11a605:	88 7c 24 4f          	mov    %bh,0x4f(%esp)
  11a609:	e8 c2 15 00 00       	call   11bbd0 <lv_label_get_text_sel_start>
  11a60e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a611:	89 0c 24             	mov    %ecx,(%esp)
  11a614:	66 89 44 24 4c       	mov    %ax,0x4c(%esp)
  11a619:	e8 d2 15 00 00       	call   11bbf0 <lv_label_get_text_sel_end>
  11a61e:	31 c9                	xor    %ecx,%ecx
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
  11a620:	8d b4 24 c0 00 00 00 	lea    0xc0(%esp),%esi
  11a627:	89 34 24             	mov    %esi,(%esp)
  11a62a:	8b 74 24 5c          	mov    0x5c(%esp),%esi
  11a62e:	89 74 24 04          	mov    %esi,0x4(%esp)
  11a632:	8b 74 24 58          	mov    0x58(%esp),%esi
  11a636:	89 74 24 08          	mov    %esi,0x8(%esp)
  11a63a:	8a 5c 24 57          	mov    0x57(%esp),%bl
  11a63e:	0f b6 f3             	movzbl %bl,%esi
  11a641:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11a645:	8b 74 24 50          	mov    0x50(%esp),%esi
  11a649:	89 74 24 10          	mov    %esi,0x10(%esp)
  11a64d:	8a 7c 24 4f          	mov    0x4f(%esp),%bh
  11a651:	0f b6 f7             	movzbl %bh,%esi
  11a654:	89 74 24 14          	mov    %esi,0x14(%esp)
  11a658:	8d b4 24 90 00 00 00 	lea    0x90(%esp),%esi
  11a65f:	89 74 24 18          	mov    %esi,0x18(%esp)
  11a663:	66 8b 54 24 4c       	mov    0x4c(%esp),%dx
  11a668:	0f b7 f2             	movzwl %dx,%esi
  11a66b:	89 74 24 1c          	mov    %esi,0x1c(%esp)
  11a66f:	0f b7 f0             	movzwl %ax,%esi
  11a672:	89 74 24 20          	mov    %esi,0x20(%esp)
  11a676:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  11a67d:	00 
  11a67e:	89 4c 24 48          	mov    %ecx,0x48(%esp)
  11a682:	e8 19 ab ff ff       	call   1151a0 <lv_draw_label>
            }

            /*Draw the text again below the original to make an circular effect */
            if(size.y > lv_obj_get_height(label)) {
  11a687:	0f bf 84 24 9a 00 00 	movswl 0x9a(%esp),%eax
  11a68e:	00 
  11a68f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a692:	89 0c 24             	mov    %ecx,(%esp)
  11a695:	89 44 24 44          	mov    %eax,0x44(%esp)
  11a699:	e8 42 4b ff ff       	call   10f1e0 <lv_obj_get_height>
  11a69e:	0f bf c8             	movswl %ax,%ecx
  11a6a1:	8b 54 24 44          	mov    0x44(%esp),%edx
  11a6a5:	39 ca                	cmp    %ecx,%edx
  11a6a7:	0f 8e 08 01 00 00    	jle    11a7b5 <lv_label_design+0x735>
                ofs.x = ext->offset.x;
  11a6ad:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a6b4:	66 8b 48 0a          	mov    0xa(%eax),%cx
  11a6b8:	66 89 8c 24 90 00 00 	mov    %cx,0x90(%esp)
  11a6bf:	00 
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
  11a6c0:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
  11a6c7:	0f bf 40 0c          	movswl 0xc(%eax),%eax
  11a6cb:	0f bf 94 24 9a 00 00 	movswl 0x9a(%esp),%edx
  11a6d2:	00 
  11a6d3:	01 d0                	add    %edx,%eax
  11a6d5:	8b 94 24 bc 00 00 00 	mov    0xbc(%esp),%edx
  11a6dc:	8b 52 34             	mov    0x34(%edx),%edx
  11a6df:	89 14 24             	mov    %edx,(%esp)
  11a6e2:	89 44 24 40          	mov    %eax,0x40(%esp)
  11a6e6:	e8 65 11 00 00       	call   11b850 <lv_font_get_line_height>
  11a6eb:	0f b6 d0             	movzbl %al,%edx
  11a6ee:	8b 74 24 40          	mov    0x40(%esp),%esi
  11a6f2:	01 d6                	add    %edx,%esi
  11a6f4:	66 89 b4 24 92 00 00 	mov    %si,0x92(%esp)
  11a6fb:	00 
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
  11a6fc:	8b 55 0c             	mov    0xc(%ebp),%edx
  11a6ff:	8b bc 24 bc 00 00 00 	mov    0xbc(%esp),%edi
  11a706:	8a 84 24 bb 00 00 00 	mov    0xbb(%esp),%al
  11a70d:	8b 9c 24 b4 00 00 00 	mov    0xb4(%esp),%ebx
  11a714:	8b 1b                	mov    (%ebx),%ebx
  11a716:	8a a4 24 a7 00 00 00 	mov    0xa7(%esp),%ah
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
  11a71d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a720:	89 0c 24             	mov    %ecx,(%esp)
  11a723:	89 54 24 3c          	mov    %edx,0x3c(%esp)
  11a727:	89 7c 24 38          	mov    %edi,0x38(%esp)
  11a72b:	88 44 24 37          	mov    %al,0x37(%esp)
  11a72f:	89 5c 24 30          	mov    %ebx,0x30(%esp)
  11a733:	88 64 24 2f          	mov    %ah,0x2f(%esp)
  11a737:	e8 94 14 00 00       	call   11bbd0 <lv_label_get_text_sel_start>
  11a73c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a73f:	89 0c 24             	mov    %ecx,(%esp)
  11a742:	66 89 44 24 2c       	mov    %ax,0x2c(%esp)
  11a747:	e8 a4 14 00 00       	call   11bbf0 <lv_label_get_text_sel_end>
  11a74c:	31 c9                	xor    %ecx,%ecx
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
  11a74e:	8d 94 24 c0 00 00 00 	lea    0xc0(%esp),%edx
  11a755:	89 14 24             	mov    %edx,(%esp)
  11a758:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  11a75c:	89 54 24 04          	mov    %edx,0x4(%esp)
  11a760:	8b 54 24 38          	mov    0x38(%esp),%edx
  11a764:	89 54 24 08          	mov    %edx,0x8(%esp)
  11a768:	8a 54 24 37          	mov    0x37(%esp),%dl
  11a76c:	0f b6 fa             	movzbl %dl,%edi
  11a76f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  11a773:	8b 7c 24 30          	mov    0x30(%esp),%edi
  11a777:	89 7c 24 10          	mov    %edi,0x10(%esp)
  11a77b:	8a 74 24 2f          	mov    0x2f(%esp),%dh
  11a77f:	0f b6 fe             	movzbl %dh,%edi
  11a782:	89 7c 24 14          	mov    %edi,0x14(%esp)
  11a786:	8d bc 24 90 00 00 00 	lea    0x90(%esp),%edi
  11a78d:	89 7c 24 18          	mov    %edi,0x18(%esp)
  11a791:	66 8b 74 24 2c       	mov    0x2c(%esp),%si
  11a796:	0f b7 fe             	movzwl %si,%edi
  11a799:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
  11a79d:	0f b7 f8             	movzwl %ax,%edi
  11a7a0:	89 7c 24 20          	mov    %edi,0x20(%esp)
  11a7a4:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  11a7ab:	00 
  11a7ac:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  11a7b0:	e8 eb a9 ff ff       	call   1151a0 <lv_draw_label>
            }
        }
  11a7b5:	e9 00 00 00 00       	jmp    11a7ba <lv_label_design+0x73a>
    }
  11a7ba:	e9 00 00 00 00       	jmp    11a7bf <lv_label_design+0x73f>
  11a7bf:	e9 00 00 00 00       	jmp    11a7c4 <lv_label_design+0x744>
    return true;
  11a7c4:	c6 84 24 cb 00 00 00 	movb   $0x1,0xcb(%esp)
  11a7cb:	01 
}
  11a7cc:	8a 84 24 cb 00 00 00 	mov    0xcb(%esp),%al
  11a7d3:	24 01                	and    $0x1,%al
  11a7d5:	0f b6 c0             	movzbl %al,%eax
  11a7d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11a7db:	5e                   	pop    %esi
  11a7dc:	5f                   	pop    %edi
  11a7dd:	5b                   	pop    %ebx
  11a7de:	5d                   	pop    %ebp
  11a7df:	c3                   	ret    

0011a7e0 <lv_label_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_label_signal(lv_obj_t * label, lv_signal_t sign, void * param)
{
  11a7e0:	55                   	push   %ebp
  11a7e1:	89 e5                	mov    %esp,%ebp
  11a7e3:	53                   	push   %ebx
  11a7e4:	57                   	push   %edi
  11a7e5:	56                   	push   %esi
  11a7e6:	83 ec 48             	sub    $0x48,%esp
  11a7e9:	8b 45 10             	mov    0x10(%ebp),%eax
  11a7ec:	8a 4d 0c             	mov    0xc(%ebp),%cl
  11a7ef:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(label, sign, param);
  11a7f2:	8b 35 b8 55 13 00    	mov    0x1355b8,%esi
  11a7f8:	8b 7d 08             	mov    0x8(%ebp),%edi
  11a7fb:	8a 6d 0c             	mov    0xc(%ebp),%ch
  11a7fe:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11a801:	89 3c 24             	mov    %edi,(%esp)
  11a804:	0f b6 fd             	movzbl %ch,%edi
  11a807:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11a80b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11a80f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  11a812:	88 4d db             	mov    %cl,-0x25(%ebp)
  11a815:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  11a818:	ff d6                	call   *%esi
  11a81a:	88 45 f2             	mov    %al,-0xe(%ebp)
    if(res != LV_RES_OK) return res;
  11a81d:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
  11a821:	83 fa 01             	cmp    $0x1,%edx
  11a824:	0f 84 0b 00 00 00    	je     11a835 <lv_label_signal+0x55>
  11a82a:	8a 45 f2             	mov    -0xe(%ebp),%al
  11a82d:	88 45 f3             	mov    %al,-0xd(%ebp)
  11a830:	e9 a5 02 00 00       	jmp    11aada <lv_label_signal+0x2fa>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11a835:	8b 45 08             	mov    0x8(%ebp),%eax
  11a838:	89 04 24             	mov    %eax,(%esp)
  11a83b:	e8 40 54 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11a840:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(sign == LV_SIGNAL_CLEANUP) {
  11a843:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11a847:	83 f8 00             	cmp    $0x0,%eax
  11a84a:	0f 85 41 00 00 00    	jne    11a891 <lv_label_signal+0xb1>
        if(ext->static_txt == 0) {
  11a850:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a853:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a857:	66 c1 e9 03          	shr    $0x3,%cx
  11a85b:	66 83 e1 01          	and    $0x1,%cx
  11a85f:	0f b6 c1             	movzbl %cl,%eax
  11a862:	83 f8 00             	cmp    $0x0,%eax
  11a865:	0f 85 16 00 00 00    	jne    11a881 <lv_label_signal+0xa1>
            lv_mem_free(ext->text);
  11a86b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a86e:	8b 00                	mov    (%eax),%eax
  11a870:	89 04 24             	mov    %eax,(%esp)
  11a873:	e8 e8 df ff ff       	call   118860 <lv_mem_free>
            ext->text = NULL;
  11a878:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a87b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }
        lv_label_dot_tmp_free(label);
  11a881:	8b 45 08             	mov    0x8(%ebp),%eax
  11a884:	89 04 24             	mov    %eax,(%esp)
  11a887:	e8 84 13 00 00       	call   11bc10 <lv_label_dot_tmp_free>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
  11a88c:	e9 43 02 00 00       	jmp    11aad4 <lv_label_signal+0x2f4>
  11a891:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11a895:	83 f8 04             	cmp    $0x4,%eax
  11a898:	0f 85 1b 00 00 00    	jne    11a8b9 <lv_label_signal+0xd9>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(label);
  11a89e:	8b 45 08             	mov    0x8(%ebp),%eax
  11a8a1:	89 04 24             	mov    %eax,(%esp)
  11a8a4:	e8 a7 0e 00 00       	call   11b750 <lv_label_revert_dots>

        lv_label_refr_text(label);
  11a8a9:	8b 45 08             	mov    0x8(%ebp),%eax
  11a8ac:	89 04 24             	mov    %eax,(%esp)
  11a8af:	e8 2c 0a 00 00       	call   11b2e0 <lv_label_refr_text>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
  11a8b4:	e9 16 02 00 00       	jmp    11aacf <lv_label_signal+0x2ef>
  11a8b9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11a8bd:	83 f8 02             	cmp    $0x2,%eax
  11a8c0:	0f 85 75 00 00 00    	jne    11a93b <lv_label_signal+0x15b>
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
  11a8c6:	8b 45 08             	mov    0x8(%ebp),%eax
  11a8c9:	83 c0 10             	add    $0x10,%eax
  11a8cc:	89 04 24             	mov    %eax,(%esp)
  11a8cf:	e8 ac 13 00 00       	call   11bc80 <lv_area_get_width>
  11a8d4:	0f bf c8             	movswl %ax,%ecx
  11a8d7:	8b 55 10             	mov    0x10(%ebp),%edx
  11a8da:	89 14 24             	mov    %edx,(%esp)
  11a8dd:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  11a8e0:	e8 9b 13 00 00       	call   11bc80 <lv_area_get_width>
  11a8e5:	0f bf c8             	movswl %ax,%ecx
  11a8e8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  11a8eb:	39 ca                	cmp    %ecx,%edx
  11a8ed:	0f 85 2d 00 00 00    	jne    11a920 <lv_label_signal+0x140>
           lv_area_get_height(&label->coords) != lv_area_get_height(param)) {
  11a8f3:	8b 45 08             	mov    0x8(%ebp),%eax
  11a8f6:	83 c0 10             	add    $0x10,%eax
  11a8f9:	89 04 24             	mov    %eax,(%esp)
  11a8fc:	e8 af 13 00 00       	call   11bcb0 <lv_area_get_height>
  11a901:	0f bf c8             	movswl %ax,%ecx
  11a904:	8b 55 10             	mov    0x10(%ebp),%edx
  11a907:	89 14 24             	mov    %edx,(%esp)
  11a90a:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  11a90d:	e8 9e 13 00 00       	call   11bcb0 <lv_area_get_height>
  11a912:	0f bf c8             	movswl %ax,%ecx
  11a915:	8b 55 cc             	mov    -0x34(%ebp),%edx
  11a918:	39 ca                	cmp    %ecx,%edx
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
  11a91a:	0f 84 16 00 00 00    	je     11a936 <lv_label_signal+0x156>
            lv_label_revert_dots(label);
  11a920:	8b 45 08             	mov    0x8(%ebp),%eax
  11a923:	89 04 24             	mov    %eax,(%esp)
  11a926:	e8 25 0e 00 00       	call   11b750 <lv_label_revert_dots>
            lv_label_refr_text(label);
  11a92b:	8b 45 08             	mov    0x8(%ebp),%eax
  11a92e:	89 04 24             	mov    %eax,(%esp)
  11a931:	e8 aa 09 00 00       	call   11b2e0 <lv_label_refr_text>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
  11a936:	e9 8f 01 00 00       	jmp    11aaca <lv_label_signal+0x2ea>
  11a93b:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11a93f:	83 f8 05             	cmp    $0x5,%eax
  11a942:	0f 85 1c 01 00 00    	jne    11aa64 <lv_label_signal+0x284>
        if(ext->body_draw) {
  11a948:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11a94b:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11a94f:	66 c1 e9 08          	shr    $0x8,%cx
  11a953:	66 83 e1 01          	and    $0x1,%cx
  11a957:	80 f9 00             	cmp    $0x0,%cl
  11a95a:	0f 84 ff 00 00 00    	je     11aa5f <lv_label_signal+0x27f>
  11a960:	31 c0                	xor    %eax,%eax
            const lv_style_t * style = lv_label_get_style(label, LV_LABEL_STYLE_MAIN);
  11a962:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a965:	89 0c 24             	mov    %ecx,(%esp)
  11a968:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11a96f:	00 
  11a970:	89 45 c8             	mov    %eax,-0x38(%ebp)
  11a973:	e8 68 13 00 00       	call   11bce0 <lv_label_get_style>
  11a978:	89 45 e8             	mov    %eax,-0x18(%ebp)

            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.left);
  11a97b:	8b 45 08             	mov    0x8(%ebp),%eax
  11a97e:	0f bf 40 30          	movswl 0x30(%eax),%eax
  11a982:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11a985:	0f bf 49 24          	movswl 0x24(%ecx),%ecx
  11a989:	39 c8                	cmp    %ecx,%eax
  11a98b:	0f 8e 0f 00 00 00    	jle    11a9a0 <lv_label_signal+0x1c0>
  11a991:	8b 45 08             	mov    0x8(%ebp),%eax
  11a994:	0f bf 40 30          	movswl 0x30(%eax),%eax
  11a998:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  11a99b:	e9 0a 00 00 00       	jmp    11a9aa <lv_label_signal+0x1ca>
  11a9a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11a9a3:	0f bf 40 24          	movswl 0x24(%eax),%eax
  11a9a7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  11a9aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11a9ad:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a9b0:	66 89 41 30          	mov    %ax,0x30(%ecx)
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
  11a9b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a9b7:	0f bf 49 30          	movswl 0x30(%ecx),%ecx
  11a9bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11a9be:	0f bf 52 26          	movswl 0x26(%edx),%edx
  11a9c2:	39 d1                	cmp    %edx,%ecx
  11a9c4:	0f 8e 0f 00 00 00    	jle    11a9d9 <lv_label_signal+0x1f9>
  11a9ca:	8b 45 08             	mov    0x8(%ebp),%eax
  11a9cd:	0f bf 40 30          	movswl 0x30(%eax),%eax
  11a9d1:	89 45 c0             	mov    %eax,-0x40(%ebp)
  11a9d4:	e9 0a 00 00 00       	jmp    11a9e3 <lv_label_signal+0x203>
  11a9d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11a9dc:	0f bf 40 26          	movswl 0x26(%eax),%eax
  11a9e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
  11a9e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  11a9e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a9e9:	66 89 41 30          	mov    %ax,0x30(%ecx)
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
  11a9ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11a9f0:	0f bf 49 30          	movswl 0x30(%ecx),%ecx
  11a9f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11a9f7:	0f bf 52 20          	movswl 0x20(%edx),%edx
  11a9fb:	39 d1                	cmp    %edx,%ecx
  11a9fd:	0f 8e 0f 00 00 00    	jle    11aa12 <lv_label_signal+0x232>
  11aa03:	8b 45 08             	mov    0x8(%ebp),%eax
  11aa06:	0f bf 40 30          	movswl 0x30(%eax),%eax
  11aa0a:	89 45 bc             	mov    %eax,-0x44(%ebp)
  11aa0d:	e9 0a 00 00 00       	jmp    11aa1c <lv_label_signal+0x23c>
  11aa12:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11aa15:	0f bf 40 20          	movswl 0x20(%eax),%eax
  11aa19:	89 45 bc             	mov    %eax,-0x44(%ebp)
  11aa1c:	8b 45 bc             	mov    -0x44(%ebp),%eax
  11aa1f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11aa22:	66 89 41 30          	mov    %ax,0x30(%ecx)
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
  11aa26:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11aa29:	0f bf 49 30          	movswl 0x30(%ecx),%ecx
  11aa2d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11aa30:	0f bf 52 22          	movswl 0x22(%edx),%edx
  11aa34:	39 d1                	cmp    %edx,%ecx
  11aa36:	0f 8e 0f 00 00 00    	jle    11aa4b <lv_label_signal+0x26b>
  11aa3c:	8b 45 08             	mov    0x8(%ebp),%eax
  11aa3f:	0f bf 40 30          	movswl 0x30(%eax),%eax
  11aa43:	89 45 b8             	mov    %eax,-0x48(%ebp)
  11aa46:	e9 0a 00 00 00       	jmp    11aa55 <lv_label_signal+0x275>
  11aa4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11aa4e:	0f bf 40 22          	movswl 0x22(%eax),%eax
  11aa52:	89 45 b8             	mov    %eax,-0x48(%ebp)
  11aa55:	8b 45 b8             	mov    -0x48(%ebp),%eax
  11aa58:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11aa5b:	66 89 41 30          	mov    %ax,0x30(%ecx)
        }
    } else if(sign == LV_SIGNAL_GET_TYPE) {
  11aa5f:	e9 61 00 00 00       	jmp    11aac5 <lv_label_signal+0x2e5>
  11aa64:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11aa68:	83 f8 06             	cmp    $0x6,%eax
  11aa6b:	0f 85 4f 00 00 00    	jne    11aac0 <lv_label_signal+0x2e0>
        lv_obj_type_t * buf = param;
  11aa71:	8b 45 10             	mov    0x10(%ebp),%eax
  11aa74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
  11aa77:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  11aa7b:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  11aa7f:	83 f8 07             	cmp    $0x7,%eax
  11aa82:	0f 8d 28 00 00 00    	jge    11aab0 <lv_label_signal+0x2d0>
            if(buf->type[i] == NULL) break;
  11aa88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11aa8b:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
  11aa8f:	83 3c 88 00          	cmpl   $0x0,(%eax,%ecx,4)
  11aa93:	0f 85 05 00 00 00    	jne    11aa9e <lv_label_signal+0x2be>
  11aa99:	e9 12 00 00 00       	jmp    11aab0 <lv_label_signal+0x2d0>
        }
  11aa9e:	e9 00 00 00 00       	jmp    11aaa3 <lv_label_signal+0x2c3>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
  11aaa3:	8a 45 e3             	mov    -0x1d(%ebp),%al
  11aaa6:	04 01                	add    $0x1,%al
  11aaa8:	88 45 e3             	mov    %al,-0x1d(%ebp)
  11aaab:	e9 cb ff ff ff       	jmp    11aa7b <lv_label_signal+0x29b>
        buf->type[i] = "lv_label";
  11aab0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11aab3:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
  11aab7:	8d 15 60 46 12 00    	lea    0x124660,%edx
  11aabd:	89 14 88             	mov    %edx,(%eax,%ecx,4)
  11aac0:	e9 00 00 00 00       	jmp    11aac5 <lv_label_signal+0x2e5>
  11aac5:	e9 00 00 00 00       	jmp    11aaca <lv_label_signal+0x2ea>
  11aaca:	e9 00 00 00 00       	jmp    11aacf <lv_label_signal+0x2ef>
  11aacf:	e9 00 00 00 00       	jmp    11aad4 <lv_label_signal+0x2f4>
    }

    return res;
  11aad4:	8a 45 f2             	mov    -0xe(%ebp),%al
  11aad7:	88 45 f3             	mov    %al,-0xd(%ebp)
}
  11aada:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  11aade:	83 c4 48             	add    $0x48,%esp
  11aae1:	5e                   	pop    %esi
  11aae2:	5f                   	pop    %edi
  11aae3:	5b                   	pop    %ebx
  11aae4:	5d                   	pop    %ebp
  11aae5:	c3                   	ret    
  11aae6:	66 90                	xchg   %ax,%ax
  11aae8:	66 90                	xchg   %ax,%ax
  11aaea:	66 90                	xchg   %ax,%ax
  11aaec:	66 90                	xchg   %ax,%ax
  11aaee:	66 90                	xchg   %ax,%ax

0011aaf0 <lv_label_set_long_mode>:
{
  11aaf0:	55                   	push   %ebp
  11aaf1:	89 e5                	mov    %esp,%ebp
  11aaf3:	56                   	push   %esi
  11aaf4:	83 ec 10             	sub    $0x10,%esp
  11aaf7:	8a 45 0c             	mov    0xc(%ebp),%al
  11aafa:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11aafd:	8b 55 08             	mov    0x8(%ebp),%edx
  11ab00:	89 14 24             	mov    %edx,(%esp)
  11ab03:	88 45 f7             	mov    %al,-0x9(%ebp)
  11ab06:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11ab09:	e8 72 51 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11ab0e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    ext->offset.x = 0;
  11ab11:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab14:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
    ext->offset.y = 0;
  11ab1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab1d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
  11ab23:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11ab27:	83 f8 03             	cmp    $0x3,%eax
  11ab2a:	0f 84 1a 00 00 00    	je     11ab4a <lv_label_set_long_mode+0x5a>
  11ab30:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11ab34:	83 f8 04             	cmp    $0x4,%eax
  11ab37:	0f 84 0d 00 00 00    	je     11ab4a <lv_label_set_long_mode+0x5a>
  11ab3d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  11ab41:	83 f8 05             	cmp    $0x5,%eax
  11ab44:	0f 85 1a 00 00 00    	jne    11ab64 <lv_label_set_long_mode+0x74>
        ext->expand = 1;
  11ab4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab4d:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11ab51:	66 81 e1 7f ff       	and    $0xff7f,%cx
  11ab56:	66 81 c9 80 00       	or     $0x80,%cx
  11ab5b:	66 89 48 0e          	mov    %cx,0xe(%eax)
  11ab5f:	e9 10 00 00 00       	jmp    11ab74 <lv_label_set_long_mode+0x84>
        ext->expand = 0;
  11ab64:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab67:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11ab6b:	66 81 e1 7f ff       	and    $0xff7f,%cx
  11ab70:	66 89 48 0e          	mov    %cx,0xe(%eax)
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
  11ab74:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab77:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11ab7b:	66 83 e1 07          	and    $0x7,%cx
  11ab7f:	0f b6 c1             	movzbl %cl,%eax
  11ab82:	83 f8 02             	cmp    $0x2,%eax
  11ab85:	0f 85 1d 00 00 00    	jne    11aba8 <lv_label_set_long_mode+0xb8>
  11ab8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ab8e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11ab92:	3d ff ff 00 00       	cmp    $0xffff,%eax
  11ab97:	0f 84 0b 00 00 00    	je     11aba8 <lv_label_set_long_mode+0xb8>
        lv_label_revert_dots(label);
  11ab9d:	8b 45 08             	mov    0x8(%ebp),%eax
  11aba0:	89 04 24             	mov    %eax,(%esp)
  11aba3:	e8 a8 0b 00 00       	call   11b750 <lv_label_revert_dots>
    ext->long_mode = long_mode;
  11aba8:	8a 45 0c             	mov    0xc(%ebp),%al
  11abab:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11abae:	0f b6 d0             	movzbl %al,%edx
  11abb1:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11abb5:	66 83 e2 07          	and    $0x7,%dx
  11abb9:	66 83 e6 f8          	and    $0xfff8,%si
  11abbd:	66 09 d6             	or     %dx,%si
  11abc0:	66 89 71 0e          	mov    %si,0xe(%ecx)
    lv_label_refr_text(label);
  11abc4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11abc7:	89 0c 24             	mov    %ecx,(%esp)
  11abca:	e8 11 07 00 00       	call   11b2e0 <lv_label_refr_text>
}
  11abcf:	83 c4 10             	add    $0x10,%esp
  11abd2:	5e                   	pop    %esi
  11abd3:	5d                   	pop    %ebp
  11abd4:	c3                   	ret    
  11abd5:	66 90                	xchg   %ax,%ax
  11abd7:	66 90                	xchg   %ax,%ax
  11abd9:	66 90                	xchg   %ax,%ax
  11abdb:	66 90                	xchg   %ax,%ax
  11abdd:	66 90                	xchg   %ax,%ax
  11abdf:	90                   	nop

0011abe0 <lv_label_set_text>:
{
  11abe0:	55                   	push   %ebp
  11abe1:	89 e5                	mov    %esp,%ebp
  11abe3:	83 ec 24             	sub    $0x24,%esp
  11abe6:	8b 45 0c             	mov    0xc(%ebp),%eax
  11abe9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_obj_invalidate(label);
  11abec:	8b 55 08             	mov    0x8(%ebp),%edx
  11abef:	89 14 24             	mov    %edx,(%esp)
  11abf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11abf5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11abf8:	e8 73 3f ff ff       	call   10eb70 <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11abfd:	8b 45 08             	mov    0x8(%ebp),%eax
  11ac00:	89 04 24             	mov    %eax,(%esp)
  11ac03:	e8 78 50 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11ac08:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(text == NULL) {
  11ac0b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11ac0f:	0f 85 10 00 00 00    	jne    11ac25 <lv_label_set_text+0x45>
        lv_label_refr_text(label);
  11ac15:	8b 45 08             	mov    0x8(%ebp),%eax
  11ac18:	89 04 24             	mov    %eax,(%esp)
  11ac1b:	e8 c0 06 00 00       	call   11b2e0 <lv_label_refr_text>
        return;
  11ac20:	e9 5f 01 00 00       	jmp    11ad84 <lv_label_set_text+0x1a4>
    if(ext->text == text) {
  11ac25:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ac28:	8b 00                	mov    (%eax),%eax
  11ac2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
  11ac2d:	0f 85 7b 00 00 00    	jne    11acae <lv_label_set_text+0xce>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
  11ac33:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ac36:	8b 00                	mov    (%eax),%eax
  11ac38:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11ac3b:	8b 09                	mov    (%ecx),%ecx
  11ac3d:	89 0c 24             	mov    %ecx,(%esp)
  11ac40:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11ac43:	e8 58 f6 fe ff       	call   10a2a0 <strlen>
  11ac48:	83 c0 01             	add    $0x1,%eax
  11ac4b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  11ac4e:	89 0c 24             	mov    %ecx,(%esp)
  11ac51:	89 44 24 04          	mov    %eax,0x4(%esp)
  11ac55:	e8 e6 dc ff ff       	call   118940 <lv_mem_realloc>
  11ac5a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11ac5d:	89 01                	mov    %eax,(%ecx)
        lv_mem_assert(ext->text);
  11ac5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ac62:	83 38 00             	cmpl   $0x0,(%eax)
  11ac65:	0f 85 2d 00 00 00    	jne    11ac98 <lv_label_set_text+0xb8>
  11ac6b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11ac72:	8d 05 07 46 12 00    	lea    0x124607,%eax
  11ac78:	89 44 24 04          	mov    %eax,0x4(%esp)
  11ac7c:	c7 44 24 08 b9 00 00 	movl   $0xb9,0x8(%esp)
  11ac83:	00 
  11ac84:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  11ac8a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11ac8e:	e8 ad ed ff ff       	call   119a40 <lv_log_add>
  11ac93:	e9 fb ff ff ff       	jmp    11ac93 <lv_label_set_text+0xb3>
        if(ext->text == NULL) return;
  11ac98:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ac9b:	83 38 00             	cmpl   $0x0,(%eax)
  11ac9e:	0f 85 05 00 00 00    	jne    11aca9 <lv_label_set_text+0xc9>
  11aca4:	e9 db 00 00 00       	jmp    11ad84 <lv_label_set_text+0x1a4>
    } else {
  11aca9:	e9 cb 00 00 00       	jmp    11ad79 <lv_label_set_text+0x199>
        uint32_t len = strlen(text) + 1;
  11acae:	8b 45 0c             	mov    0xc(%ebp),%eax
  11acb1:	89 04 24             	mov    %eax,(%esp)
  11acb4:	e8 e7 f5 fe ff       	call   10a2a0 <strlen>
  11acb9:	83 c0 01             	add    $0x1,%eax
  11acbc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(ext->text != NULL && ext->static_txt == 0) {
  11acbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11acc2:	83 38 00             	cmpl   $0x0,(%eax)
  11acc5:	0f 84 31 00 00 00    	je     11acfc <lv_label_set_text+0x11c>
  11accb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11acce:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11acd2:	66 c1 e9 03          	shr    $0x3,%cx
  11acd6:	66 83 e1 01          	and    $0x1,%cx
  11acda:	0f b6 c1             	movzbl %cl,%eax
  11acdd:	83 f8 00             	cmp    $0x0,%eax
  11ace0:	0f 85 16 00 00 00    	jne    11acfc <lv_label_set_text+0x11c>
            lv_mem_free(ext->text);
  11ace6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ace9:	8b 00                	mov    (%eax),%eax
  11aceb:	89 04 24             	mov    %eax,(%esp)
  11acee:	e8 6d db ff ff       	call   118860 <lv_mem_free>
            ext->text = NULL;
  11acf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11acf6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        ext->text = lv_mem_alloc(len);
  11acfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11acff:	89 04 24             	mov    %eax,(%esp)
  11ad02:	e8 59 da ff ff       	call   118760 <lv_mem_alloc>
  11ad07:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11ad0a:	89 01                	mov    %eax,(%ecx)
        lv_mem_assert(ext->text);
  11ad0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ad0f:	83 38 00             	cmpl   $0x0,(%eax)
  11ad12:	0f 85 2d 00 00 00    	jne    11ad45 <lv_label_set_text+0x165>
  11ad18:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11ad1f:	8d 05 07 46 12 00    	lea    0x124607,%eax
  11ad25:	89 44 24 04          	mov    %eax,0x4(%esp)
  11ad29:	c7 44 24 08 c4 00 00 	movl   $0xc4,0x8(%esp)
  11ad30:	00 
  11ad31:	8d 05 e8 3d 12 00    	lea    0x123de8,%eax
  11ad37:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11ad3b:	e8 00 ed ff ff       	call   119a40 <lv_log_add>
  11ad40:	e9 fb ff ff ff       	jmp    11ad40 <lv_label_set_text+0x160>
        if(ext->text == NULL) return;
  11ad45:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ad48:	83 38 00             	cmpl   $0x0,(%eax)
  11ad4b:	0f 85 05 00 00 00    	jne    11ad56 <lv_label_set_text+0x176>
  11ad51:	e9 2e 00 00 00       	jmp    11ad84 <lv_label_set_text+0x1a4>
        strcpy(ext->text, text);
  11ad56:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ad59:	8b 00                	mov    (%eax),%eax
  11ad5b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11ad5e:	89 04 24             	mov    %eax,(%esp)
  11ad61:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11ad65:	e8 a6 f3 fe ff       	call   10a110 <strcpy>
        ext->static_txt = 0; /*Now the text is dynamically allocated*/
  11ad6a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11ad6d:	66 8b 51 0e          	mov    0xe(%ecx),%dx
  11ad71:	66 83 e2 f7          	and    $0xfff7,%dx
  11ad75:	66 89 51 0e          	mov    %dx,0xe(%ecx)
    lv_label_refr_text(label);
  11ad79:	8b 45 08             	mov    0x8(%ebp),%eax
  11ad7c:	89 04 24             	mov    %eax,(%esp)
  11ad7f:	e8 5c 05 00 00       	call   11b2e0 <lv_label_refr_text>
}
  11ad84:	83 c4 24             	add    $0x24,%esp
  11ad87:	5d                   	pop    %ebp
  11ad88:	c3                   	ret    
  11ad89:	66 90                	xchg   %ax,%ax
  11ad8b:	66 90                	xchg   %ax,%ax
  11ad8d:	66 90                	xchg   %ax,%ax
  11ad8f:	90                   	nop

0011ad90 <lv_label_set_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @param style pointer to a style
 */
static inline void lv_label_set_style(lv_obj_t * label, lv_label_style_t type, const lv_style_t * style)
{
  11ad90:	55                   	push   %ebp
  11ad91:	89 e5                	mov    %esp,%ebp
  11ad93:	57                   	push   %edi
  11ad94:	56                   	push   %esi
  11ad95:	83 ec 14             	sub    $0x14,%esp
  11ad98:	8b 45 10             	mov    0x10(%ebp),%eax
  11ad9b:	8a 4d 0c             	mov    0xc(%ebp),%cl
  11ad9e:	8b 55 08             	mov    0x8(%ebp),%edx
    (void)type; /*Unused*/
    lv_obj_set_style(label, style);
  11ada1:	8b 75 08             	mov    0x8(%ebp),%esi
  11ada4:	8b 7d 10             	mov    0x10(%ebp),%edi
  11ada7:	89 34 24             	mov    %esi,(%esp)
  11adaa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11adae:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11adb1:	88 4d f3             	mov    %cl,-0xd(%ebp)
  11adb4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  11adb7:	e8 d4 4a ff ff       	call   10f890 <lv_obj_set_style>
}
  11adbc:	83 c4 14             	add    $0x14,%esp
  11adbf:	5e                   	pop    %esi
  11adc0:	5f                   	pop    %edi
  11adc1:	5d                   	pop    %ebp
  11adc2:	c3                   	ret    
  11adc3:	66 90                	xchg   %ax,%ax
  11adc5:	66 90                	xchg   %ax,%ax
  11adc7:	66 90                	xchg   %ax,%ax
  11adc9:	66 90                	xchg   %ax,%ax
  11adcb:	66 90                	xchg   %ax,%ax
  11adcd:	66 90                	xchg   %ax,%ax
  11adcf:	90                   	nop

0011add0 <lv_label_get_long_mode>:
{
  11add0:	55                   	push   %ebp
  11add1:	89 e5                	mov    %esp,%ebp
  11add3:	83 ec 0c             	sub    $0xc,%esp
  11add6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11add9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11addc:	89 0c 24             	mov    %ecx,(%esp)
  11addf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11ade2:	e8 99 4e ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11ade7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return ext->long_mode;
  11adea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11aded:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11adf1:	66 83 e2 07          	and    $0x7,%dx
  11adf5:	0f b6 c2             	movzbl %dl,%eax
  11adf8:	83 c4 0c             	add    $0xc,%esp
  11adfb:	5d                   	pop    %ebp
  11adfc:	c3                   	ret    
  11adfd:	66 90                	xchg   %ax,%ax
  11adff:	90                   	nop

0011ae00 <lv_label_set_recolor>:
{
  11ae00:	55                   	push   %ebp
  11ae01:	89 e5                	mov    %esp,%ebp
  11ae03:	53                   	push   %ebx
  11ae04:	56                   	push   %esi
  11ae05:	83 ec 18             	sub    $0x18,%esp
  11ae08:	8a 45 0c             	mov    0xc(%ebp),%al
  11ae0b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ae0e:	24 01                	and    $0x1,%al
  11ae10:	88 45 f7             	mov    %al,-0x9(%ebp)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11ae13:	8b 55 08             	mov    0x8(%ebp),%edx
  11ae16:	89 14 24             	mov    %edx,(%esp)
  11ae19:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11ae1c:	e8 5f 4e ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11ae21:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(ext->recolor == en) return;
  11ae24:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ae27:	66 8b 70 0e          	mov    0xe(%eax),%si
  11ae2b:	66 c1 ee 06          	shr    $0x6,%si
  11ae2f:	66 89 f3             	mov    %si,%bx
  11ae32:	66 83 e3 01          	and    $0x1,%bx
  11ae36:	0f b6 c3             	movzbl %bl,%eax
  11ae39:	8a 5d f7             	mov    -0x9(%ebp),%bl
  11ae3c:	80 e3 01             	and    $0x1,%bl
  11ae3f:	0f b6 cb             	movzbl %bl,%ecx
  11ae42:	39 c8                	cmp    %ecx,%eax
  11ae44:	0f 85 05 00 00 00    	jne    11ae4f <lv_label_set_recolor+0x4f>
  11ae4a:	e9 50 00 00 00       	jmp    11ae9f <lv_label_set_recolor+0x9f>
  11ae4f:	31 c0                	xor    %eax,%eax
    ext->recolor = en == false ? 0 : 1;
  11ae51:	8a 4d f7             	mov    -0x9(%ebp),%cl
  11ae54:	80 e1 01             	and    $0x1,%cl
  11ae57:	0f b6 d1             	movzbl %cl,%edx
  11ae5a:	83 fa 00             	cmp    $0x0,%edx
  11ae5d:	ba 01 00 00 00       	mov    $0x1,%edx
  11ae62:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11ae65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11ae68:	0f 84 06 00 00 00    	je     11ae74 <lv_label_set_recolor+0x74>
  11ae6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11ae71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11ae74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11ae77:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11ae7a:	0f b6 d0             	movzbl %al,%edx
  11ae7d:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11ae81:	66 83 e2 01          	and    $0x1,%dx
  11ae85:	66 c1 e2 06          	shl    $0x6,%dx
  11ae89:	66 83 e6 bf          	and    $0xffbf,%si
  11ae8d:	66 09 d6             	or     %dx,%si
  11ae90:	66 89 71 0e          	mov    %si,0xe(%ecx)
    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
  11ae94:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ae97:	89 0c 24             	mov    %ecx,(%esp)
  11ae9a:	e8 41 04 00 00       	call   11b2e0 <lv_label_refr_text>
}
  11ae9f:	83 c4 18             	add    $0x18,%esp
  11aea2:	5e                   	pop    %esi
  11aea3:	5b                   	pop    %ebx
  11aea4:	5d                   	pop    %ebp
  11aea5:	c3                   	ret    
  11aea6:	66 90                	xchg   %ax,%ax
  11aea8:	66 90                	xchg   %ax,%ax
  11aeaa:	66 90                	xchg   %ax,%ax
  11aeac:	66 90                	xchg   %ax,%ax
  11aeae:	66 90                	xchg   %ax,%ax

0011aeb0 <lv_label_get_recolor>:
{
  11aeb0:	55                   	push   %ebp
  11aeb1:	89 e5                	mov    %esp,%ebp
  11aeb3:	83 ec 14             	sub    $0x14,%esp
  11aeb6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11aeb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11aebc:	89 0c 24             	mov    %ecx,(%esp)
  11aebf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11aec2:	e8 b9 4d ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11aec7:	31 c9                	xor    %ecx,%ecx
  11aec9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return ext->recolor == 0 ? false : true;
  11aecc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11aecf:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11aed3:	66 c1 ea 06          	shr    $0x6,%dx
  11aed7:	66 83 e2 01          	and    $0x1,%dx
  11aedb:	0f b6 c2             	movzbl %dl,%eax
  11aede:	83 f8 00             	cmp    $0x0,%eax
  11aee1:	b8 01 00 00 00       	mov    $0x1,%eax
  11aee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11aee9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11aeec:	0f 84 06 00 00 00    	je     11aef8 <lv_label_get_recolor+0x48>
  11aef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11aef5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11aef8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11aefb:	83 f8 00             	cmp    $0x0,%eax
  11aefe:	0f 95 c1             	setne  %cl
  11af01:	80 e1 01             	and    $0x1,%cl
  11af04:	0f b6 c1             	movzbl %cl,%eax
  11af07:	83 c4 14             	add    $0x14,%esp
  11af0a:	5d                   	pop    %ebp
  11af0b:	c3                   	ret    
  11af0c:	66 90                	xchg   %ax,%ax
  11af0e:	66 90                	xchg   %ax,%ax

0011af10 <lv_label_set_body_draw>:
{
  11af10:	55                   	push   %ebp
  11af11:	89 e5                	mov    %esp,%ebp
  11af13:	53                   	push   %ebx
  11af14:	56                   	push   %esi
  11af15:	83 ec 18             	sub    $0x18,%esp
  11af18:	8a 45 0c             	mov    0xc(%ebp),%al
  11af1b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11af1e:	24 01                	and    $0x1,%al
  11af20:	88 45 f7             	mov    %al,-0x9(%ebp)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11af23:	8b 55 08             	mov    0x8(%ebp),%edx
  11af26:	89 14 24             	mov    %edx,(%esp)
  11af29:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11af2c:	e8 4f 4d ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11af31:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(ext->body_draw == en) return;
  11af34:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11af37:	66 8b 70 0e          	mov    0xe(%eax),%si
  11af3b:	66 c1 ee 08          	shr    $0x8,%si
  11af3f:	66 89 f3             	mov    %si,%bx
  11af42:	66 83 e3 01          	and    $0x1,%bx
  11af46:	0f b6 c3             	movzbl %bl,%eax
  11af49:	8a 5d f7             	mov    -0x9(%ebp),%bl
  11af4c:	80 e3 01             	and    $0x1,%bl
  11af4f:	0f b6 cb             	movzbl %bl,%ecx
  11af52:	39 c8                	cmp    %ecx,%eax
  11af54:	0f 85 05 00 00 00    	jne    11af5f <lv_label_set_body_draw+0x4f>
  11af5a:	e9 5c 00 00 00       	jmp    11afbb <lv_label_set_body_draw+0xab>
  11af5f:	31 c0                	xor    %eax,%eax
    ext->body_draw = en == false ? 0 : 1;
  11af61:	8a 4d f7             	mov    -0x9(%ebp),%cl
  11af64:	80 e1 01             	and    $0x1,%cl
  11af67:	0f b6 d1             	movzbl %cl,%edx
  11af6a:	83 fa 00             	cmp    $0x0,%edx
  11af6d:	ba 01 00 00 00       	mov    $0x1,%edx
  11af72:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11af75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11af78:	0f 84 06 00 00 00    	je     11af84 <lv_label_set_body_draw+0x74>
  11af7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11af81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11af84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11af87:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11af8a:	0f b6 d0             	movzbl %al,%edx
  11af8d:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11af91:	66 83 e2 01          	and    $0x1,%dx
  11af95:	66 c1 e2 08          	shl    $0x8,%dx
  11af99:	66 81 e6 ff fe       	and    $0xfeff,%si
  11af9e:	66 09 d6             	or     %dx,%si
  11afa1:	66 89 71 0e          	mov    %si,0xe(%ecx)
    lv_obj_refresh_ext_draw_pad(label);
  11afa5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11afa8:	89 0c 24             	mov    %ecx,(%esp)
  11afab:	e8 b0 4a ff ff       	call   10fa60 <lv_obj_refresh_ext_draw_pad>
    lv_obj_invalidate(label);
  11afb0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11afb3:	89 0c 24             	mov    %ecx,(%esp)
  11afb6:	e8 b5 3b ff ff       	call   10eb70 <lv_obj_invalidate>
}
  11afbb:	83 c4 18             	add    $0x18,%esp
  11afbe:	5e                   	pop    %esi
  11afbf:	5b                   	pop    %ebx
  11afc0:	5d                   	pop    %ebp
  11afc1:	c3                   	ret    
  11afc2:	66 90                	xchg   %ax,%ax
  11afc4:	66 90                	xchg   %ax,%ax
  11afc6:	66 90                	xchg   %ax,%ax
  11afc8:	66 90                	xchg   %ax,%ax
  11afca:	66 90                	xchg   %ax,%ax
  11afcc:	66 90                	xchg   %ax,%ax
  11afce:	66 90                	xchg   %ax,%ax

0011afd0 <lv_label_get_body_draw>:
{
  11afd0:	55                   	push   %ebp
  11afd1:	89 e5                	mov    %esp,%ebp
  11afd3:	83 ec 14             	sub    $0x14,%esp
  11afd6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11afd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11afdc:	89 0c 24             	mov    %ecx,(%esp)
  11afdf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11afe2:	e8 99 4c ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11afe7:	31 c9                	xor    %ecx,%ecx
  11afe9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return ext->body_draw == 0 ? false : true;
  11afec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11afef:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11aff3:	66 c1 ea 08          	shr    $0x8,%dx
  11aff7:	66 83 e2 01          	and    $0x1,%dx
  11affb:	0f b6 c2             	movzbl %dl,%eax
  11affe:	83 f8 00             	cmp    $0x0,%eax
  11b001:	b8 01 00 00 00       	mov    $0x1,%eax
  11b006:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11b009:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11b00c:	0f 84 06 00 00 00    	je     11b018 <lv_label_get_body_draw+0x48>
  11b012:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b015:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11b018:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b01b:	83 f8 00             	cmp    $0x0,%eax
  11b01e:	0f 95 c1             	setne  %cl
  11b021:	80 e1 01             	and    $0x1,%cl
  11b024:	0f b6 c1             	movzbl %cl,%eax
  11b027:	83 c4 14             	add    $0x14,%esp
  11b02a:	5d                   	pop    %ebp
  11b02b:	c3                   	ret    
  11b02c:	66 90                	xchg   %ax,%ax
  11b02e:	66 90                	xchg   %ax,%ax

0011b030 <lv_label_set_align>:
{
  11b030:	55                   	push   %ebp
  11b031:	89 e5                	mov    %esp,%ebp
  11b033:	53                   	push   %ebx
  11b034:	56                   	push   %esi
  11b035:	83 ec 10             	sub    $0x10,%esp
  11b038:	8a 45 0c             	mov    0xc(%ebp),%al
  11b03b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b03e:	8b 55 08             	mov    0x8(%ebp),%edx
  11b041:	89 14 24             	mov    %edx,(%esp)
  11b044:	88 45 f3             	mov    %al,-0xd(%ebp)
  11b047:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11b04a:	e8 31 4c ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b04f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(ext->align == align) return;
  11b052:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b055:	66 8b 70 0e          	mov    0xe(%eax),%si
  11b059:	66 c1 ee 04          	shr    $0x4,%si
  11b05d:	66 89 f3             	mov    %si,%bx
  11b060:	66 83 e3 03          	and    $0x3,%bx
  11b064:	0f b6 c3             	movzbl %bl,%eax
  11b067:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  11b06b:	39 c8                	cmp    %ecx,%eax
  11b06d:	0f 85 05 00 00 00    	jne    11b078 <lv_label_set_align+0x48>
  11b073:	e9 2b 00 00 00       	jmp    11b0a3 <lv_label_set_align+0x73>
    ext->align = align;
  11b078:	8a 45 0c             	mov    0xc(%ebp),%al
  11b07b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11b07e:	0f b6 d0             	movzbl %al,%edx
  11b081:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11b085:	66 83 e2 03          	and    $0x3,%dx
  11b089:	66 c1 e2 04          	shl    $0x4,%dx
  11b08d:	66 83 e6 cf          	and    $0xffcf,%si
  11b091:	66 09 d6             	or     %dx,%si
  11b094:	66 89 71 0e          	mov    %si,0xe(%ecx)
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
  11b098:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b09b:	89 0c 24             	mov    %ecx,(%esp)
  11b09e:	e8 cd 3a ff ff       	call   10eb70 <lv_obj_invalidate>
}
  11b0a3:	83 c4 10             	add    $0x10,%esp
  11b0a6:	5e                   	pop    %esi
  11b0a7:	5b                   	pop    %ebx
  11b0a8:	5d                   	pop    %ebp
  11b0a9:	c3                   	ret    
  11b0aa:	66 90                	xchg   %ax,%ax
  11b0ac:	66 90                	xchg   %ax,%ax
  11b0ae:	66 90                	xchg   %ax,%ax

0011b0b0 <lv_label_get_align>:
{
  11b0b0:	55                   	push   %ebp
  11b0b1:	89 e5                	mov    %esp,%ebp
  11b0b3:	83 ec 0c             	sub    $0xc,%esp
  11b0b6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b0b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b0bc:	89 0c 24             	mov    %ecx,(%esp)
  11b0bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11b0c2:	e8 b9 4b ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b0c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return ext->align;
  11b0ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11b0cd:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11b0d1:	66 c1 ea 04          	shr    $0x4,%dx
  11b0d5:	66 83 e2 03          	and    $0x3,%dx
  11b0d9:	0f b6 c2             	movzbl %dl,%eax
  11b0dc:	83 c4 0c             	add    $0xc,%esp
  11b0df:	5d                   	pop    %ebp
  11b0e0:	c3                   	ret    
  11b0e1:	66 90                	xchg   %ax,%ax
  11b0e3:	66 90                	xchg   %ax,%ax
  11b0e5:	66 90                	xchg   %ax,%ax
  11b0e7:	66 90                	xchg   %ax,%ax
  11b0e9:	66 90                	xchg   %ax,%ax
  11b0eb:	66 90                	xchg   %ax,%ax
  11b0ed:	66 90                	xchg   %ax,%ax
  11b0ef:	90                   	nop

0011b0f0 <lv_label_get_text>:
{
  11b0f0:	55                   	push   %ebp
  11b0f1:	89 e5                	mov    %esp,%ebp
  11b0f3:	83 ec 0c             	sub    $0xc,%esp
  11b0f6:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b0f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b0fc:	89 0c 24             	mov    %ecx,(%esp)
  11b0ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11b102:	e8 79 4b ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b107:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return ext->text;
  11b10a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11b10d:	8b 00                	mov    (%eax),%eax
  11b10f:	83 c4 0c             	add    $0xc,%esp
  11b112:	5d                   	pop    %ebp
  11b113:	c3                   	ret    
  11b114:	66 90                	xchg   %ax,%ax
  11b116:	66 90                	xchg   %ax,%ax
  11b118:	66 90                	xchg   %ax,%ax
  11b11a:	66 90                	xchg   %ax,%ax
  11b11c:	66 90                	xchg   %ax,%ax
  11b11e:	66 90                	xchg   %ax,%ax

0011b120 <lv_label_set_static_text>:
{
  11b120:	55                   	push   %ebp
  11b121:	89 e5                	mov    %esp,%ebp
  11b123:	53                   	push   %ebx
  11b124:	56                   	push   %esi
  11b125:	83 ec 10             	sub    $0x10,%esp
  11b128:	8b 45 0c             	mov    0xc(%ebp),%eax
  11b12b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b12e:	8b 55 08             	mov    0x8(%ebp),%edx
  11b131:	89 14 24             	mov    %edx,(%esp)
  11b134:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11b137:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11b13a:	e8 41 4b ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b13f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(ext->static_txt == 0 && ext->text != NULL) {
  11b142:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b145:	66 8b 70 0e          	mov    0xe(%eax),%si
  11b149:	66 c1 ee 03          	shr    $0x3,%si
  11b14d:	66 89 f3             	mov    %si,%bx
  11b150:	66 83 e3 01          	and    $0x1,%bx
  11b154:	0f b6 c3             	movzbl %bl,%eax
  11b157:	83 f8 00             	cmp    $0x0,%eax
  11b15a:	0f 85 22 00 00 00    	jne    11b182 <lv_label_set_static_text+0x62>
  11b160:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b163:	83 38 00             	cmpl   $0x0,(%eax)
  11b166:	0f 84 16 00 00 00    	je     11b182 <lv_label_set_static_text+0x62>
        lv_mem_free(ext->text);
  11b16c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b16f:	8b 00                	mov    (%eax),%eax
  11b171:	89 04 24             	mov    %eax,(%esp)
  11b174:	e8 e7 d6 ff ff       	call   118860 <lv_mem_free>
        ext->text = NULL;
  11b179:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b17c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(text != NULL) {
  11b182:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11b186:	0f 84 1b 00 00 00    	je     11b1a7 <lv_label_set_static_text+0x87>
        ext->static_txt = 1;
  11b18c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b18f:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b193:	66 83 e1 f7          	and    $0xfff7,%cx
  11b197:	66 83 c9 08          	or     $0x8,%cx
  11b19b:	66 89 48 0e          	mov    %cx,0xe(%eax)
        ext->text       = (char *)text;
  11b19f:	8b 45 0c             	mov    0xc(%ebp),%eax
  11b1a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11b1a5:	89 02                	mov    %eax,(%edx)
    lv_label_refr_text(label);
  11b1a7:	8b 45 08             	mov    0x8(%ebp),%eax
  11b1aa:	89 04 24             	mov    %eax,(%esp)
  11b1ad:	e8 2e 01 00 00       	call   11b2e0 <lv_label_refr_text>
}
  11b1b2:	83 c4 10             	add    $0x10,%esp
  11b1b5:	5e                   	pop    %esi
  11b1b6:	5b                   	pop    %ebx
  11b1b7:	5d                   	pop    %ebp
  11b1b8:	c3                   	ret    
  11b1b9:	66 90                	xchg   %ax,%ax
  11b1bb:	66 90                	xchg   %ax,%ax
  11b1bd:	66 90                	xchg   %ax,%ax
  11b1bf:	90                   	nop

0011b1c0 <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * label, char * data, uint16_t len)
{
  11b1c0:	55                   	push   %ebp
  11b1c1:	89 e5                	mov    %esp,%ebp
  11b1c3:	56                   	push   %esi
  11b1c4:	83 ec 24             	sub    $0x24,%esp
  11b1c7:	66 8b 45 10          	mov    0x10(%ebp),%ax
  11b1cb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11b1ce:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b1d1:	8b 75 08             	mov    0x8(%ebp),%esi
  11b1d4:	89 34 24             	mov    %esi,(%esp)
  11b1d7:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  11b1db:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11b1de:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11b1e1:	e8 9a 4a ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b1e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
  11b1e9:	8b 45 08             	mov    0x8(%ebp),%eax
  11b1ec:	89 04 24             	mov    %eax,(%esp)
  11b1ef:	e8 1c 0a 00 00       	call   11bc10 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
  11b1f4:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  11b1f8:	83 f8 04             	cmp    $0x4,%eax
  11b1fb:	0f 86 98 00 00 00    	jbe    11b299 <lv_label_set_dot_tmp+0xd9>
        /* Memory needs to be allocated. Allocates an additional byte
         * for a NULL-terminator so it can be copied. */
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
  11b201:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  11b205:	83 c0 01             	add    $0x1,%eax
  11b208:	89 04 24             	mov    %eax,(%esp)
  11b20b:	e8 50 d5 ff ff       	call   118760 <lv_mem_alloc>
  11b210:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11b213:	89 41 04             	mov    %eax,0x4(%ecx)
        if(ext->dot.tmp_ptr == NULL) {
  11b216:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b219:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11b21d:	0f 85 31 00 00 00    	jne    11b254 <lv_label_set_dot_tmp+0x94>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
  11b223:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11b22a:	8d 05 07 46 12 00    	lea    0x124607,%eax
  11b230:	89 44 24 04          	mov    %eax,0x4(%esp)
  11b234:	c7 44 24 08 99 04 00 	movl   $0x499,0x8(%esp)
  11b23b:	00 
  11b23c:	8d 05 69 46 12 00    	lea    0x124669,%eax
  11b242:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11b246:	e8 f5 e7 ff ff       	call   119a40 <lv_log_add>
            return false;
  11b24b:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
  11b24f:	e9 76 00 00 00       	jmp    11b2ca <lv_label_set_dot_tmp+0x10a>
        }
        memcpy(ext->dot.tmp_ptr, data, len);
  11b254:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b257:	8b 40 04             	mov    0x4(%eax),%eax
  11b25a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11b25d:	0f b7 55 10          	movzwl 0x10(%ebp),%edx
  11b261:	89 04 24             	mov    %eax,(%esp)
  11b264:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11b268:	89 54 24 08          	mov    %edx,0x8(%esp)
  11b26c:	e8 df f0 fe ff       	call   10a350 <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
  11b271:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11b274:	8b 49 04             	mov    0x4(%ecx),%ecx
  11b277:	0f b7 55 10          	movzwl 0x10(%ebp),%edx
  11b27b:	c6 04 11 00          	movb   $0x0,(%ecx,%edx,1)
        ext->dot_tmp_alloc    = true;
  11b27f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11b282:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11b286:	66 81 e6 ff fd       	and    $0xfdff,%si
  11b28b:	66 81 ce 00 02       	or     $0x200,%si
  11b290:	66 89 71 0e          	mov    %si,0xe(%ecx)
    } else {
  11b294:	e9 2d 00 00 00       	jmp    11b2c6 <lv_label_set_dot_tmp+0x106>
        /* Characters can be directly stored in object */
        ext->dot_tmp_alloc = false;
  11b299:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b29c:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b2a0:	66 81 e1 ff fd       	and    $0xfdff,%cx
  11b2a5:	66 89 48 0e          	mov    %cx,0xe(%eax)
        memcpy(ext->dot.tmp, data, len);
  11b2a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b2ac:	83 c0 04             	add    $0x4,%eax
  11b2af:	8b 55 0c             	mov    0xc(%ebp),%edx
  11b2b2:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  11b2b6:	89 04 24             	mov    %eax,(%esp)
  11b2b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  11b2bd:	89 74 24 08          	mov    %esi,0x8(%esp)
  11b2c1:	e8 8a f0 fe ff       	call   10a350 <memcpy>
    }
    return true;
  11b2c6:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
}
  11b2ca:	8a 45 fb             	mov    -0x5(%ebp),%al
  11b2cd:	24 01                	and    $0x1,%al
  11b2cf:	0f b6 c0             	movzbl %al,%eax
  11b2d2:	83 c4 24             	add    $0x24,%esp
  11b2d5:	5e                   	pop    %esi
  11b2d6:	5d                   	pop    %ebp
  11b2d7:	c3                   	ret    
  11b2d8:	66 90                	xchg   %ax,%ax
  11b2da:	66 90                	xchg   %ax,%ax
  11b2dc:	66 90                	xchg   %ax,%ax
  11b2de:	66 90                	xchg   %ax,%ax

0011b2e0 <lv_label_refr_text>:
{
  11b2e0:	55                   	push   %ebp
  11b2e1:	89 e5                	mov    %esp,%ebp
  11b2e3:	53                   	push   %ebx
  11b2e4:	57                   	push   %edi
  11b2e5:	56                   	push   %esi
  11b2e6:	83 e4 f8             	and    $0xfffffff8,%esp
  11b2e9:	83 ec 60             	sub    $0x60,%esp
  11b2ec:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b2ef:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b2f2:	89 0c 24             	mov    %ecx,(%esp)
  11b2f5:	89 44 24 28          	mov    %eax,0x28(%esp)
  11b2f9:	e8 82 49 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b2fe:	89 44 24 58          	mov    %eax,0x58(%esp)
    if(ext->text == NULL) return;
  11b302:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b306:	83 38 00             	cmpl   $0x0,(%eax)
  11b309:	0f 85 05 00 00 00    	jne    11b314 <lv_label_refr_text+0x34>
  11b30f:	e9 2b 04 00 00       	jmp    11b73f <lv_label_refr_text+0x45f>
    lv_coord_t max_w         = lv_obj_get_width(label);
  11b314:	8b 45 08             	mov    0x8(%ebp),%eax
  11b317:	89 04 24             	mov    %eax,(%esp)
  11b31a:	e8 a1 3e ff ff       	call   10f1c0 <lv_obj_get_width>
  11b31f:	66 89 44 24 56       	mov    %ax,0x56(%esp)
    const lv_style_t * style = lv_obj_get_style(label);
  11b324:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b327:	89 0c 24             	mov    %ecx,(%esp)
  11b32a:	e8 81 47 ff ff       	call   10fab0 <lv_obj_get_style>
  11b32f:	89 44 24 50          	mov    %eax,0x50(%esp)
    const lv_font_t * font   = style->text.font;
  11b333:	8b 44 24 50          	mov    0x50(%esp),%eax
  11b337:	8b 40 34             	mov    0x34(%eax),%eax
  11b33a:	89 44 24 4c          	mov    %eax,0x4c(%esp)
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
  11b33e:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b342:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11b346:	66 83 e2 07          	and    $0x7,%dx
  11b34a:	0f b6 c2             	movzbl %dl,%eax
  11b34d:	83 f8 00             	cmp    $0x0,%eax
  11b350:	0f 85 07 00 00 00    	jne    11b35d <lv_label_refr_text+0x7d>
        max_w = LV_COORD_MAX;
  11b356:	66 c7 44 24 56 18 7c 	movw   $0x7c18,0x56(%esp)
    lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
  11b35d:	c6 44 24 47 00       	movb   $0x0,0x47(%esp)
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
  11b362:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b366:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b36a:	66 c1 e9 06          	shr    $0x6,%cx
  11b36e:	66 83 e1 01          	and    $0x1,%cx
  11b372:	0f b6 c1             	movzbl %cl,%eax
  11b375:	83 f8 00             	cmp    $0x0,%eax
  11b378:	0f 84 0c 00 00 00    	je     11b38a <lv_label_refr_text+0xaa>
  11b37e:	0f b6 44 24 47       	movzbl 0x47(%esp),%eax
  11b383:	83 c8 01             	or     $0x1,%eax
  11b386:	88 44 24 47          	mov    %al,0x47(%esp)
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
  11b38a:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b38e:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b392:	66 c1 e9 07          	shr    $0x7,%cx
  11b396:	66 83 e1 01          	and    $0x1,%cx
  11b39a:	0f b6 c1             	movzbl %cl,%eax
  11b39d:	83 f8 00             	cmp    $0x0,%eax
  11b3a0:	0f 84 0c 00 00 00    	je     11b3b2 <lv_label_refr_text+0xd2>
  11b3a6:	0f b6 44 24 47       	movzbl 0x47(%esp),%eax
  11b3ab:	83 c8 02             	or     $0x2,%eax
  11b3ae:	88 44 24 47          	mov    %al,0x47(%esp)
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
  11b3b2:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b3b6:	8b 00                	mov    (%eax),%eax
  11b3b8:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  11b3bc:	8b 54 24 50          	mov    0x50(%esp),%edx
  11b3c0:	66 8b 72 38          	mov    0x38(%edx),%si
  11b3c4:	8b 54 24 50          	mov    0x50(%esp),%edx
  11b3c8:	66 8b 7a 3a          	mov    0x3a(%edx),%di
  11b3cc:	66 8b 5c 24 56       	mov    0x56(%esp),%bx
  11b3d1:	8d 54 24 48          	lea    0x48(%esp),%edx
  11b3d5:	89 14 24             	mov    %edx,(%esp)
  11b3d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  11b3dc:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11b3e0:	0f bf c6             	movswl %si,%eax
  11b3e3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11b3e7:	0f bf c7             	movswl %di,%eax
  11b3ea:	89 44 24 10          	mov    %eax,0x10(%esp)
  11b3ee:	0f bf c3             	movswl %bx,%eax
  11b3f1:	89 44 24 14          	mov    %eax,0x14(%esp)
  11b3f5:	0f b6 44 24 47       	movzbl 0x47(%esp),%eax
  11b3fa:	89 44 24 18          	mov    %eax,0x18(%esp)
  11b3fe:	e8 1d df ff ff       	call   119320 <lv_txt_get_size>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
  11b403:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b407:	66 8b 70 0e          	mov    0xe(%eax),%si
  11b40b:	66 89 f3             	mov    %si,%bx
  11b40e:	66 83 e3 07          	and    $0x7,%bx
  11b412:	0f b6 c3             	movzbl %bl,%eax
  11b415:	83 f8 00             	cmp    $0x0,%eax
  11b418:	0f 85 25 00 00 00    	jne    11b443 <lv_label_refr_text+0x163>
        lv_obj_set_size(label, size.x, size.y);
  11b41e:	8b 45 08             	mov    0x8(%ebp),%eax
  11b421:	66 8b 4c 24 48       	mov    0x48(%esp),%cx
  11b426:	89 04 24             	mov    %eax,(%esp)
  11b429:	0f bf c1             	movswl %cx,%eax
  11b42c:	89 44 24 04          	mov    %eax,0x4(%esp)
  11b430:	0f bf 44 24 4a       	movswl 0x4a(%esp),%eax
  11b435:	89 44 24 08          	mov    %eax,0x8(%esp)
  11b439:	e8 02 3c ff ff       	call   10f040 <lv_obj_set_size>
    }
  11b43e:	e9 f1 02 00 00       	jmp    11b734 <lv_label_refr_text+0x454>
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
  11b443:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b447:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b44b:	66 83 e1 07          	and    $0x7,%cx
  11b44f:	0f b6 c1             	movzbl %cl,%eax
  11b452:	83 f8 03             	cmp    $0x3,%eax
  11b455:	0f 85 05 00 00 00    	jne    11b460 <lv_label_refr_text+0x180>
    }
  11b45b:	e9 cf 02 00 00       	jmp    11b72f <lv_label_refr_text+0x44f>
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
  11b460:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b464:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b468:	66 83 e1 07          	and    $0x7,%cx
  11b46c:	0f b6 c1             	movzbl %cl,%eax
  11b46f:	83 f8 04             	cmp    $0x4,%eax
  11b472:	0f 85 05 00 00 00    	jne    11b47d <lv_label_refr_text+0x19d>
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
  11b478:	e9 ad 02 00 00       	jmp    11b72a <lv_label_refr_text+0x44a>
  11b47d:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b481:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b485:	66 83 e1 07          	and    $0x7,%cx
  11b489:	0f b6 c1             	movzbl %cl,%eax
  11b48c:	83 f8 02             	cmp    $0x2,%eax
  11b48f:	0f 85 38 02 00 00    	jne    11b6cd <lv_label_refr_text+0x3ed>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
  11b495:	0f bf 44 24 4a       	movswl 0x4a(%esp),%eax
  11b49a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b49d:	89 0c 24             	mov    %ecx,(%esp)
  11b4a0:	89 44 24 24          	mov    %eax,0x24(%esp)
  11b4a4:	e8 37 3d ff ff       	call   10f1e0 <lv_obj_get_height>
  11b4a9:	0f bf c8             	movswl %ax,%ecx
  11b4ac:	8b 54 24 24          	mov    0x24(%esp),%edx
  11b4b0:	39 ca                	cmp    %ecx,%edx
  11b4b2:	0f 8f 0f 00 00 00    	jg     11b4c7 <lv_label_refr_text+0x1e7>
            ext->dot_end = LV_LABEL_DOT_END_INV;
  11b4b8:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b4bc:	66 c7 40 08 ff ff    	movw   $0xffff,0x8(%eax)
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
  11b4c2:	e9 01 02 00 00       	jmp    11b6c8 <lv_label_refr_text+0x3e8>
  11b4c7:	a1 54 30 14 00       	mov    0x143054,%eax
  11b4cc:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11b4d0:	8b 09                	mov    (%ecx),%ecx
  11b4d2:	89 0c 24             	mov    %ecx,(%esp)
  11b4d5:	ff d0                	call   *%eax
  11b4d7:	83 f8 03             	cmp    $0x3,%eax
  11b4da:	0f 87 0f 00 00 00    	ja     11b4ef <lv_label_refr_text+0x20f>
            ext->dot_end = LV_LABEL_DOT_END_INV;
  11b4e0:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b4e4:	66 c7 40 08 ff ff    	movw   $0xffff,0x8(%eax)
        } else {
  11b4ea:	e9 d4 01 00 00       	jmp    11b6c3 <lv_label_refr_text+0x3e3>
            p.x = lv_obj_get_width(label) -
  11b4ef:	8b 45 08             	mov    0x8(%ebp),%eax
  11b4f2:	89 04 24             	mov    %eax,(%esp)
  11b4f5:	e8 c6 3c ff ff       	call   10f1c0 <lv_obj_get_width>
  11b4fa:	0f bf c8             	movswl %ax,%ecx
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
  11b4fd:	8b 54 24 50          	mov    0x50(%esp),%edx
  11b501:	8b 52 34             	mov    0x34(%edx),%edx
  11b504:	89 14 24             	mov    %edx,(%esp)
  11b507:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  11b50e:	00 
  11b50f:	c7 44 24 08 2e 00 00 	movl   $0x2e,0x8(%esp)
  11b516:	00 
  11b517:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  11b51b:	e8 f0 08 00 00       	call   11be10 <lv_font_get_glyph_width>
  11b520:	0f b7 c8             	movzwl %ax,%ecx
  11b523:	8b 54 24 50          	mov    0x50(%esp),%edx
  11b527:	0f bf 52 38          	movswl 0x38(%edx),%edx
  11b52b:	01 d1                	add    %edx,%ecx
  11b52d:	6b c9 03             	imul   $0x3,%ecx,%ecx
  11b530:	8b 54 24 20          	mov    0x20(%esp),%edx
            p.x = lv_obj_get_width(label) -
  11b534:	29 ca                	sub    %ecx,%edx
  11b536:	66 89 54 24 40       	mov    %dx,0x40(%esp)
            p.y = lv_obj_get_height(label);
  11b53b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b53e:	89 0c 24             	mov    %ecx,(%esp)
  11b541:	e8 9a 3c ff ff       	call   10f1e0 <lv_obj_get_height>
  11b546:	66 89 44 24 42       	mov    %ax,0x42(%esp)
            p.y -= p.y %
  11b54b:	0f bf 44 24 42       	movswl 0x42(%esp),%eax
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
  11b550:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  11b554:	8b 49 34             	mov    0x34(%ecx),%ecx
  11b557:	89 0c 24             	mov    %ecx,(%esp)
  11b55a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11b55e:	e8 ed 02 00 00       	call   11b850 <lv_font_get_line_height>
  11b563:	0f b6 c8             	movzbl %al,%ecx
  11b566:	8b 74 24 50          	mov    0x50(%esp),%esi
  11b56a:	0f bf 76 3a          	movswl 0x3a(%esi),%esi
  11b56e:	01 f1                	add    %esi,%ecx
  11b570:	8b 44 24 1c          	mov    0x1c(%esp),%eax
            p.y -= p.y %
  11b574:	99                   	cltd   
  11b575:	f7 f9                	idiv   %ecx
  11b577:	0f bf 4c 24 42       	movswl 0x42(%esp),%ecx
  11b57c:	29 d1                	sub    %edx,%ecx
  11b57e:	66 89 4c 24 42       	mov    %cx,0x42(%esp)
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
  11b583:	8b 54 24 50          	mov    0x50(%esp),%edx
  11b587:	0f bf 52 3a          	movswl 0x3a(%edx),%edx
  11b58b:	0f bf 74 24 42       	movswl 0x42(%esp),%esi
  11b590:	29 d6                	sub    %edx,%esi
  11b592:	66 89 74 24 42       	mov    %si,0x42(%esp)
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
  11b597:	8b 55 08             	mov    0x8(%ebp),%edx
  11b59a:	89 14 24             	mov    %edx,(%esp)
  11b59d:	8d 54 24 40          	lea    0x40(%esp),%edx
  11b5a1:	89 54 24 04          	mov    %edx,0x4(%esp)
  11b5a5:	e8 c6 02 00 00       	call   11b870 <lv_label_get_letter_on>
  11b5aa:	0f b7 d0             	movzwl %ax,%edx
  11b5ad:	89 54 24 3c          	mov    %edx,0x3c(%esp)
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
  11b5b1:	8b 15 4c 30 14 00    	mov    0x14304c,%edx
  11b5b7:	8b 7c 24 58          	mov    0x58(%esp),%edi
  11b5bb:	8b 3f                	mov    (%edi),%edi
  11b5bd:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
  11b5c1:	89 3c 24             	mov    %edi,(%esp)
  11b5c4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  11b5c8:	ff d2                	call   *%edx
  11b5ca:	89 44 24 34          	mov    %eax,0x34(%esp)
            uint32_t byte_id_ori = byte_id;
  11b5ce:	8b 44 24 34          	mov    0x34(%esp),%eax
  11b5d2:	89 44 24 30          	mov    %eax,0x30(%esp)
            uint8_t len          = 0;
  11b5d6:	c6 44 24 2f 00       	movb   $0x0,0x2f(%esp)
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
  11b5db:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
  11b5e2:	00 
  11b5e3:	83 7c 24 38 03       	cmpl   $0x3,0x38(%esp)
  11b5e8:	0f 87 4b 00 00 00    	ja     11b639 <lv_label_refr_text+0x359>
                len += lv_txt_encoded_size(&ext->text[byte_id]);
  11b5ee:	a1 40 30 14 00       	mov    0x143040,%eax
  11b5f3:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11b5f7:	8b 09                	mov    (%ecx),%ecx
  11b5f9:	03 4c 24 34          	add    0x34(%esp),%ecx
  11b5fd:	89 0c 24             	mov    %ecx,(%esp)
  11b600:	ff d0                	call   *%eax
  11b602:	0f b6 c8             	movzbl %al,%ecx
  11b605:	0f b6 54 24 2f       	movzbl 0x2f(%esp),%edx
  11b60a:	01 ca                	add    %ecx,%edx
  11b60c:	88 54 24 2f          	mov    %dl,0x2f(%esp)
                lv_txt_encoded_next(ext->text, &byte_id);
  11b610:	8b 0d 44 30 14 00    	mov    0x143044,%ecx
  11b616:	8b 74 24 58          	mov    0x58(%esp),%esi
  11b61a:	8b 36                	mov    (%esi),%esi
  11b61c:	89 34 24             	mov    %esi,(%esp)
  11b61f:	8d 74 24 34          	lea    0x34(%esp),%esi
  11b623:	89 74 24 04          	mov    %esi,0x4(%esp)
  11b627:	ff d1                	call   *%ecx
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
  11b629:	8b 44 24 38          	mov    0x38(%esp),%eax
  11b62d:	83 c0 01             	add    $0x1,%eax
  11b630:	89 44 24 38          	mov    %eax,0x38(%esp)
  11b634:	e9 aa ff ff ff       	jmp    11b5e3 <lv_label_refr_text+0x303>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
  11b639:	8b 45 08             	mov    0x8(%ebp),%eax
  11b63c:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11b640:	8b 09                	mov    (%ecx),%ecx
  11b642:	03 4c 24 30          	add    0x30(%esp),%ecx
  11b646:	0f b6 54 24 2f       	movzbl 0x2f(%esp),%edx
  11b64b:	89 04 24             	mov    %eax,(%esp)
  11b64e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11b652:	0f b7 c2             	movzwl %dx,%eax
  11b655:	89 44 24 08          	mov    %eax,0x8(%esp)
  11b659:	e8 62 fb ff ff       	call   11b1c0 <lv_label_set_dot_tmp>
  11b65e:	a8 01                	test   $0x1,%al
  11b660:	0f 85 05 00 00 00    	jne    11b66b <lv_label_refr_text+0x38b>
  11b666:	e9 53 00 00 00       	jmp    11b6be <lv_label_refr_text+0x3de>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
  11b66b:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
  11b672:	00 
  11b673:	83 7c 24 38 03       	cmpl   $0x3,0x38(%esp)
  11b678:	0f 83 22 00 00 00    	jae    11b6a0 <lv_label_refr_text+0x3c0>
                    ext->text[byte_id_ori + i] = '.';
  11b67e:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b682:	8b 00                	mov    (%eax),%eax
  11b684:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  11b688:	03 4c 24 38          	add    0x38(%esp),%ecx
  11b68c:	c6 04 08 2e          	movb   $0x2e,(%eax,%ecx,1)
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
  11b690:	8b 44 24 38          	mov    0x38(%esp),%eax
  11b694:	83 c0 01             	add    $0x1,%eax
  11b697:	89 44 24 38          	mov    %eax,0x38(%esp)
  11b69b:	e9 d3 ff ff ff       	jmp    11b673 <lv_label_refr_text+0x393>
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
  11b6a0:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b6a4:	8b 00                	mov    (%eax),%eax
  11b6a6:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  11b6aa:	c6 44 08 03 00       	movb   $0x0,0x3(%eax,%ecx,1)
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
  11b6af:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11b6b3:	83 c0 03             	add    $0x3,%eax
  11b6b6:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11b6ba:	66 89 41 08          	mov    %ax,0x8(%ecx)
  11b6be:	e9 00 00 00 00       	jmp    11b6c3 <lv_label_refr_text+0x3e3>
  11b6c3:	e9 00 00 00 00       	jmp    11b6c8 <lv_label_refr_text+0x3e8>
    }
  11b6c8:	e9 58 00 00 00       	jmp    11b725 <lv_label_refr_text+0x445>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
  11b6cd:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b6d1:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b6d5:	66 83 e1 07          	and    $0x7,%cx
  11b6d9:	0f b6 c1             	movzbl %cl,%eax
  11b6dc:	83 f8 01             	cmp    $0x1,%eax
  11b6df:	0f 85 19 00 00 00    	jne    11b6fe <lv_label_refr_text+0x41e>
        lv_obj_set_height(label, size.y);
  11b6e5:	8b 45 08             	mov    0x8(%ebp),%eax
  11b6e8:	89 04 24             	mov    %eax,(%esp)
  11b6eb:	0f bf 44 24 4a       	movswl 0x4a(%esp),%eax
  11b6f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  11b6f4:	e8 07 3b ff ff       	call   10f200 <lv_obj_set_height>
    }
  11b6f9:	e9 22 00 00 00       	jmp    11b720 <lv_label_refr_text+0x440>
    else if(ext->long_mode == LV_LABEL_LONG_CROP) {
  11b6fe:	8b 44 24 58          	mov    0x58(%esp),%eax
  11b702:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b706:	66 83 e1 07          	and    $0x7,%cx
  11b70a:	0f b6 c1             	movzbl %cl,%eax
  11b70d:	83 f8 05             	cmp    $0x5,%eax
  11b710:	0f 85 05 00 00 00    	jne    11b71b <lv_label_refr_text+0x43b>
    }
  11b716:	e9 00 00 00 00       	jmp    11b71b <lv_label_refr_text+0x43b>
  11b71b:	e9 00 00 00 00       	jmp    11b720 <lv_label_refr_text+0x440>
  11b720:	e9 00 00 00 00       	jmp    11b725 <lv_label_refr_text+0x445>
  11b725:	e9 00 00 00 00       	jmp    11b72a <lv_label_refr_text+0x44a>
  11b72a:	e9 00 00 00 00       	jmp    11b72f <lv_label_refr_text+0x44f>
  11b72f:	e9 00 00 00 00       	jmp    11b734 <lv_label_refr_text+0x454>
    lv_obj_invalidate(label);
  11b734:	8b 45 08             	mov    0x8(%ebp),%eax
  11b737:	89 04 24             	mov    %eax,(%esp)
  11b73a:	e8 31 34 ff ff       	call   10eb70 <lv_obj_invalidate>
}
  11b73f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b742:	5e                   	pop    %esi
  11b743:	5f                   	pop    %edi
  11b744:	5b                   	pop    %ebx
  11b745:	5d                   	pop    %ebp
  11b746:	c3                   	ret    
  11b747:	66 90                	xchg   %ax,%ax
  11b749:	66 90                	xchg   %ax,%ax
  11b74b:	66 90                	xchg   %ax,%ax
  11b74d:	66 90                	xchg   %ax,%ax
  11b74f:	90                   	nop

0011b750 <lv_label_revert_dots>:
{
  11b750:	55                   	push   %ebp
  11b751:	89 e5                	mov    %esp,%ebp
  11b753:	56                   	push   %esi
  11b754:	83 ec 20             	sub    $0x20,%esp
  11b757:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11b75a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b75d:	89 0c 24             	mov    %ecx,(%esp)
  11b760:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11b763:	e8 18 45 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b768:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
  11b76b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b76e:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11b772:	66 83 e2 07          	and    $0x7,%dx
  11b776:	0f b6 c2             	movzbl %dl,%eax
  11b779:	83 f8 02             	cmp    $0x2,%eax
  11b77c:	0f 84 05 00 00 00    	je     11b787 <lv_label_revert_dots+0x37>
  11b782:	e9 c2 00 00 00       	jmp    11b849 <lv_label_revert_dots+0xf9>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
  11b787:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b78a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11b78e:	3d ff ff 00 00       	cmp    $0xffff,%eax
  11b793:	0f 85 05 00 00 00    	jne    11b79e <lv_label_revert_dots+0x4e>
  11b799:	e9 ab 00 00 00       	jmp    11b849 <lv_label_revert_dots+0xf9>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
  11b79e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b7a1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11b7a5:	83 e8 03             	sub    $0x3,%eax
  11b7a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
  11b7ab:	a1 4c 30 14 00       	mov    0x14304c,%eax
  11b7b0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11b7b3:	8b 09                	mov    (%ecx),%ecx
  11b7b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11b7b8:	89 0c 24             	mov    %ecx,(%esp)
  11b7bb:	89 54 24 04          	mov    %edx,0x4(%esp)
  11b7bf:	ff d0                	call   *%eax
  11b7c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t i      = 0;
  11b7c4:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
    char * dot_tmp = lv_label_get_dot_tmp(label);
  11b7c8:	8b 45 08             	mov    0x8(%ebp),%eax
  11b7cb:	89 04 24             	mov    %eax,(%esp)
  11b7ce:	e8 3d 05 00 00       	call   11bd10 <lv_label_get_dot_tmp>
  11b7d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while(ext->text[byte_i + i] != '\0') {
  11b7d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b7d9:	8b 00                	mov    (%eax),%eax
  11b7db:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11b7de:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
  11b7e2:	01 d1                	add    %edx,%ecx
  11b7e4:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  11b7e8:	83 f8 00             	cmp    $0x0,%eax
  11b7eb:	0f 84 29 00 00 00    	je     11b81a <lv_label_revert_dots+0xca>
        ext->text[byte_i + i] = dot_tmp[i];
  11b7f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11b7f4:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  11b7f8:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11b7fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b7fe:	8b 00                	mov    (%eax),%eax
  11b800:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11b803:	0f b6 75 ef          	movzbl -0x11(%ebp),%esi
  11b807:	01 f1                	add    %esi,%ecx
  11b809:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        i++;
  11b80c:	8a 55 ef             	mov    -0x11(%ebp),%dl
  11b80f:	80 c2 01             	add    $0x1,%dl
  11b812:	88 55 ef             	mov    %dl,-0x11(%ebp)
    while(ext->text[byte_i + i] != '\0') {
  11b815:	e9 bc ff ff ff       	jmp    11b7d6 <lv_label_revert_dots+0x86>
    ext->text[byte_i + i] = dot_tmp[i];
  11b81a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11b81d:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  11b821:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11b824:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b827:	8b 00                	mov    (%eax),%eax
  11b829:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11b82c:	0f b6 75 ef          	movzbl -0x11(%ebp),%esi
  11b830:	01 f1                	add    %esi,%ecx
  11b832:	88 14 08             	mov    %dl,(%eax,%ecx,1)
    lv_label_dot_tmp_free(label);
  11b835:	8b 45 08             	mov    0x8(%ebp),%eax
  11b838:	89 04 24             	mov    %eax,(%esp)
  11b83b:	e8 d0 03 00 00       	call   11bc10 <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
  11b840:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b843:	66 c7 40 08 ff ff    	movw   $0xffff,0x8(%eax)
}
  11b849:	83 c4 20             	add    $0x20,%esp
  11b84c:	5e                   	pop    %esi
  11b84d:	5d                   	pop    %ebp
  11b84e:	c3                   	ret    
  11b84f:	90                   	nop

0011b850 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
  11b850:	55                   	push   %ebp
  11b851:	89 e5                	mov    %esp,%ebp
  11b853:	50                   	push   %eax
  11b854:	8b 45 08             	mov    0x8(%ebp),%eax
    return font_p->line_height;
  11b857:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b85a:	0f b6 49 08          	movzbl 0x8(%ecx),%ecx
  11b85e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11b861:	89 c8                	mov    %ecx,%eax
  11b863:	83 c4 04             	add    $0x4,%esp
  11b866:	5d                   	pop    %ebp
  11b867:	c3                   	ret    
  11b868:	66 90                	xchg   %ax,%ax
  11b86a:	66 90                	xchg   %ax,%ax
  11b86c:	66 90                	xchg   %ax,%ax
  11b86e:	66 90                	xchg   %ax,%ax

0011b870 <lv_label_get_letter_on>:
{
  11b870:	55                   	push   %ebp
  11b871:	89 e5                	mov    %esp,%ebp
  11b873:	53                   	push   %ebx
  11b874:	57                   	push   %edi
  11b875:	56                   	push   %esi
  11b876:	83 ec 5c             	sub    $0x5c,%esp
  11b879:	8b 45 0c             	mov    0xc(%ebp),%eax
  11b87c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    const char * txt         = lv_label_get_text(label);
  11b87f:	8b 55 08             	mov    0x8(%ebp),%edx
  11b882:	89 14 24             	mov    %edx,(%esp)
  11b885:	89 45 b8             	mov    %eax,-0x48(%ebp)
  11b888:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  11b88b:	e8 60 f8 ff ff       	call   11b0f0 <lv_label_get_text>
  11b890:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
  11b893:	8b 45 08             	mov    0x8(%ebp),%eax
  11b896:	89 04 24             	mov    %eax,(%esp)
  11b899:	e8 e2 43 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11b89e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t line_start      = 0;
  11b8a1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    uint32_t new_line_start  = 0;
  11b8a8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    lv_coord_t max_w         = lv_obj_get_width(label);
  11b8af:	8b 45 08             	mov    0x8(%ebp),%eax
  11b8b2:	89 04 24             	mov    %eax,(%esp)
  11b8b5:	e8 06 39 ff ff       	call   10f1c0 <lv_obj_get_width>
  11b8ba:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    const lv_style_t * style = lv_obj_get_style(label);
  11b8be:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11b8c1:	89 0c 24             	mov    %ecx,(%esp)
  11b8c4:	e8 e7 41 ff ff       	call   10fab0 <lv_obj_get_style>
  11b8c9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const lv_font_t * font   = style->text.font;
  11b8cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11b8cf:	8b 40 34             	mov    0x34(%eax),%eax
  11b8d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uint8_t letter_height    = lv_font_get_line_height(font);
  11b8d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11b8d8:	89 04 24             	mov    %eax,(%esp)
  11b8db:	e8 70 ff ff ff       	call   11b850 <lv_font_get_line_height>
  11b8e0:	88 45 d7             	mov    %al,-0x29(%ebp)
    lv_coord_t y             = 0;
  11b8e3:	66 c7 45 d4 00 00    	movw   $0x0,-0x2c(%ebp)
    lv_txt_flag_t flag       = LV_TXT_FLAG_NONE;
  11b8e9:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
  11b8ed:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  11b8f0:	66 8b 71 0e          	mov    0xe(%ecx),%si
  11b8f4:	66 c1 ee 06          	shr    $0x6,%si
  11b8f8:	66 89 f3             	mov    %si,%bx
  11b8fb:	66 83 e3 01          	and    $0x1,%bx
  11b8ff:	0f b6 cb             	movzbl %bl,%ecx
  11b902:	83 f9 00             	cmp    $0x0,%ecx
  11b905:	0f 84 0a 00 00 00    	je     11b915 <lv_label_get_letter_on+0xa5>
  11b90b:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11b90f:	83 c8 01             	or     $0x1,%eax
  11b912:	88 45 d3             	mov    %al,-0x2d(%ebp)
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
  11b915:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b918:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b91c:	66 c1 e9 07          	shr    $0x7,%cx
  11b920:	66 83 e1 01          	and    $0x1,%cx
  11b924:	0f b6 c1             	movzbl %cl,%eax
  11b927:	83 f8 00             	cmp    $0x0,%eax
  11b92a:	0f 84 0a 00 00 00    	je     11b93a <lv_label_get_letter_on+0xca>
  11b930:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11b934:	83 c8 02             	or     $0x2,%eax
  11b937:	88 45 d3             	mov    %al,-0x2d(%ebp)
    if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
  11b93a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b93d:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b941:	66 c1 e9 04          	shr    $0x4,%cx
  11b945:	66 83 e1 03          	and    $0x3,%cx
  11b949:	0f b6 c1             	movzbl %cl,%eax
  11b94c:	83 f8 01             	cmp    $0x1,%eax
  11b94f:	0f 85 0a 00 00 00    	jne    11b95f <lv_label_get_letter_on+0xef>
  11b955:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11b959:	83 c8 04             	or     $0x4,%eax
  11b95c:	88 45 d3             	mov    %al,-0x2d(%ebp)
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
  11b95f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b962:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11b966:	66 83 e1 07          	and    $0x7,%cx
  11b96a:	0f b6 c1             	movzbl %cl,%eax
  11b96d:	83 f8 00             	cmp    $0x0,%eax
  11b970:	0f 85 06 00 00 00    	jne    11b97c <lv_label_get_letter_on+0x10c>
        max_w = LV_COORD_MAX;
  11b976:	66 c7 45 e2 18 7c    	movw   $0x7c18,-0x1e(%ebp)
    while(txt[line_start] != '\0') {
  11b97c:	e9 00 00 00 00       	jmp    11b981 <lv_label_get_letter_on+0x111>
  11b981:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b984:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11b987:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  11b98b:	83 f8 00             	cmp    $0x0,%eax
  11b98e:	0f 84 7f 00 00 00    	je     11ba13 <lv_label_get_letter_on+0x1a3>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
  11b994:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b997:	03 45 e8             	add    -0x18(%ebp),%eax
  11b99a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  11b99d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  11b9a0:	66 8b 72 38          	mov    0x38(%edx),%si
  11b9a4:	66 8b 7d e2          	mov    -0x1e(%ebp),%di
  11b9a8:	89 04 24             	mov    %eax,(%esp)
  11b9ab:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11b9af:	0f bf c6             	movswl %si,%eax
  11b9b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  11b9b6:	0f bf c7             	movswl %di,%eax
  11b9b9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11b9bd:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11b9c1:	89 44 24 10          	mov    %eax,0x10(%esp)
  11b9c5:	e8 76 db ff ff       	call   119540 <lv_txt_get_next_line>
  11b9ca:	0f b7 c8             	movzwl %ax,%ecx
  11b9cd:	03 4d e4             	add    -0x1c(%ebp),%ecx
  11b9d0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/
  11b9d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11b9d6:	0f bf 49 02          	movswl 0x2(%ecx),%ecx
  11b9da:	0f bf 55 d4          	movswl -0x2c(%ebp),%edx
  11b9de:	0f b6 5d d7          	movzbl -0x29(%ebp),%ebx
  11b9e2:	01 da                	add    %ebx,%edx
  11b9e4:	39 d1                	cmp    %edx,%ecx
  11b9e6:	0f 8f 05 00 00 00    	jg     11b9f1 <lv_label_get_letter_on+0x181>
  11b9ec:	e9 22 00 00 00       	jmp    11ba13 <lv_label_get_letter_on+0x1a3>
        y += letter_height + style->text.line_space;
  11b9f1:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  11b9f5:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  11b9f8:	0f bf 49 3a          	movswl 0x3a(%ecx),%ecx
  11b9fc:	01 c8                	add    %ecx,%eax
  11b9fe:	0f bf 4d d4          	movswl -0x2c(%ebp),%ecx
  11ba02:	01 c1                	add    %eax,%ecx
  11ba04:	66 89 4d d4          	mov    %cx,-0x2c(%ebp)
        line_start = new_line_start;
  11ba08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11ba0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while(txt[line_start] != '\0') {
  11ba0e:	e9 6e ff ff ff       	jmp    11b981 <lv_label_get_letter_on+0x111>
    lv_coord_t x = 0;
  11ba13:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%ebp)
    if(ext->align == LV_LABEL_ALIGN_CENTER) {
  11ba19:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11ba1c:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11ba20:	66 c1 e9 04          	shr    $0x4,%cx
  11ba24:	66 83 e1 03          	and    $0x3,%cx
  11ba28:	0f b6 c1             	movzbl %cl,%eax
  11ba2b:	83 f8 01             	cmp    $0x1,%eax
  11ba2e:	0f 85 6b 00 00 00    	jne    11ba9f <lv_label_get_letter_on+0x22f>
        line_w = lv_txt_get_width(&txt[line_start], new_line_start - line_start, font, style->text.letter_space, flag);
  11ba34:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ba37:	03 45 e8             	add    -0x18(%ebp),%eax
  11ba3a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  11ba3d:	2b 4d e8             	sub    -0x18(%ebp),%ecx
  11ba40:	8b 55 d8             	mov    -0x28(%ebp),%edx
  11ba43:	8b 75 dc             	mov    -0x24(%ebp),%esi
  11ba46:	66 8b 7e 38          	mov    0x38(%esi),%di
  11ba4a:	89 04 24             	mov    %eax,(%esp)
  11ba4d:	0f b7 c1             	movzwl %cx,%eax
  11ba50:	89 44 24 04          	mov    %eax,0x4(%esp)
  11ba54:	89 54 24 08          	mov    %edx,0x8(%esp)
  11ba58:	0f bf c7             	movswl %di,%eax
  11ba5b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11ba5f:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11ba63:	89 44 24 10          	mov    %eax,0x10(%esp)
  11ba67:	e8 14 dd ff ff       	call   119780 <lv_txt_get_width>
  11ba6c:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
        x += lv_obj_get_width(label) / 2 - line_w / 2;
  11ba70:	8b 55 08             	mov    0x8(%ebp),%edx
  11ba73:	89 14 24             	mov    %edx,(%esp)
  11ba76:	e8 45 37 ff ff       	call   10f1c0 <lv_obj_get_width>
  11ba7b:	98                   	cwtl   
  11ba7c:	99                   	cltd   
  11ba7d:	be 02 00 00 00       	mov    $0x2,%esi
  11ba82:	f7 fe                	idiv   %esi
  11ba84:	0f bf 5d ce          	movswl -0x32(%ebp),%ebx
  11ba88:	89 45 b0             	mov    %eax,-0x50(%ebp)
  11ba8b:	89 d8                	mov    %ebx,%eax
  11ba8d:	99                   	cltd   
  11ba8e:	f7 fe                	idiv   %esi
  11ba90:	8b 75 b0             	mov    -0x50(%ebp),%esi
  11ba93:	29 c6                	sub    %eax,%esi
  11ba95:	0f bf 45 d0          	movswl -0x30(%ebp),%eax
  11ba99:	01 f0                	add    %esi,%eax
  11ba9b:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
  11ba9f:	c6 45 cd 00          	movb   $0x0,-0x33(%ebp)
    uint32_t i         = line_start;
  11baa3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11baa6:	89 45 c8             	mov    %eax,-0x38(%ebp)
    uint32_t i_current = i;
  11baa9:	8b 45 c8             	mov    -0x38(%ebp),%eax
  11baac:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    if(new_line_start > 0) {
  11baaf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  11bab3:	0f 86 f2 00 00 00    	jbe    11bbab <lv_label_get_letter_on+0x33b>
        while(i <= new_line_start - 1) {
  11bab9:	e9 00 00 00 00       	jmp    11babe <lv_label_get_letter_on+0x24e>
  11babe:	8b 45 c8             	mov    -0x38(%ebp),%eax
  11bac1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  11bac4:	83 e9 01             	sub    $0x1,%ecx
  11bac7:	39 c8                	cmp    %ecx,%eax
  11bac9:	0f 87 d7 00 00 00    	ja     11bba6 <lv_label_get_letter_on+0x336>
            letter = lv_txt_encoded_next(txt, &i);
  11bacf:	a1 44 30 14 00       	mov    0x143044,%eax
  11bad4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11bad7:	89 0c 24             	mov    %ecx,(%esp)
  11bada:	8d 4d c8             	lea    -0x38(%ebp),%ecx
  11badd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11bae1:	ff d0                	call   *%eax
  11bae3:	31 c9                	xor    %ecx,%ecx
  11bae5:	89 45 c0             	mov    %eax,-0x40(%ebp)
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
  11bae8:	a1 44 30 14 00       	mov    0x143044,%eax
  11baed:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11baf0:	03 55 c8             	add    -0x38(%ebp),%edx
  11baf3:	89 14 24             	mov    %edx,(%esp)
  11baf6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11bafd:	00 
  11bafe:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  11bb01:	ff d0                	call   *%eax
  11bb03:	89 45 bc             	mov    %eax,-0x44(%ebp)
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
  11bb06:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
  11bb0a:	83 e0 01             	and    $0x1,%eax
  11bb0d:	83 f8 00             	cmp    $0x0,%eax
  11bb10:	0f 84 31 00 00 00    	je     11bb47 <lv_label_get_letter_on+0x2d7>
                if(lv_txt_is_cmd(&cmd_state, txt[i]) != false) {
  11bb16:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11bb19:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  11bb1c:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  11bb20:	8d 4d cd             	lea    -0x33(%ebp),%ecx
  11bb23:	89 0c 24             	mov    %ecx,(%esp)
  11bb26:	89 44 24 04          	mov    %eax,0x4(%esp)
  11bb2a:	e8 c1 dd ff ff       	call   1198f0 <lv_txt_is_cmd>
  11bb2f:	24 01                	and    $0x1,%al
  11bb31:	0f b6 c8             	movzbl %al,%ecx
  11bb34:	83 f9 00             	cmp    $0x0,%ecx
  11bb37:	0f 84 05 00 00 00    	je     11bb42 <lv_label_get_letter_on+0x2d2>
                    continue; /*Skip the letter is it is part of a command*/
  11bb3d:	e9 7c ff ff ff       	jmp    11babe <lv_label_get_letter_on+0x24e>
            }
  11bb42:	e9 00 00 00 00       	jmp    11bb47 <lv_label_get_letter_on+0x2d7>
            x += lv_font_get_glyph_width(font, letter, letter_next);
  11bb47:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11bb4a:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  11bb4d:	8b 55 bc             	mov    -0x44(%ebp),%edx
  11bb50:	89 04 24             	mov    %eax,(%esp)
  11bb53:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11bb57:	89 54 24 08          	mov    %edx,0x8(%esp)
  11bb5b:	e8 b0 02 00 00       	call   11be10 <lv_font_get_glyph_width>
  11bb60:	0f b7 c8             	movzwl %ax,%ecx
  11bb63:	0f bf 55 d0          	movswl -0x30(%ebp),%edx
  11bb67:	01 ca                	add    %ecx,%edx
  11bb69:	66 89 55 d0          	mov    %dx,-0x30(%ebp)
            if(pos->x < x) {
  11bb6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11bb70:	0f bf 09             	movswl (%ecx),%ecx
  11bb73:	0f bf 75 d0          	movswl -0x30(%ebp),%esi
  11bb77:	39 f1                	cmp    %esi,%ecx
  11bb79:	0f 8d 0b 00 00 00    	jge    11bb8a <lv_label_get_letter_on+0x31a>
                i = i_current;
  11bb7f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11bb82:	89 45 c8             	mov    %eax,-0x38(%ebp)
                break;
  11bb85:	e9 1c 00 00 00       	jmp    11bba6 <lv_label_get_letter_on+0x336>
            x += style->text.letter_space;
  11bb8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11bb8d:	0f bf 40 38          	movswl 0x38(%eax),%eax
  11bb91:	0f bf 4d d0          	movswl -0x30(%ebp),%ecx
  11bb95:	01 c1                	add    %eax,%ecx
  11bb97:	66 89 4d d0          	mov    %cx,-0x30(%ebp)
            i_current = i;
  11bb9b:	8b 45 c8             	mov    -0x38(%ebp),%eax
  11bb9e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        while(i <= new_line_start - 1) {
  11bba1:	e9 18 ff ff ff       	jmp    11babe <lv_label_get_letter_on+0x24e>
    }
  11bba6:	e9 00 00 00 00       	jmp    11bbab <lv_label_get_letter_on+0x33b>
    return lv_encoded_get_char_id(txt, i);
  11bbab:	a1 50 30 14 00       	mov    0x143050,%eax
  11bbb0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11bbb3:	8b 55 c8             	mov    -0x38(%ebp),%edx
  11bbb6:	89 0c 24             	mov    %ecx,(%esp)
  11bbb9:	89 54 24 04          	mov    %edx,0x4(%esp)
  11bbbd:	ff d0                	call   *%eax
  11bbbf:	0f b7 c0             	movzwl %ax,%eax
  11bbc2:	83 c4 5c             	add    $0x5c,%esp
  11bbc5:	5e                   	pop    %esi
  11bbc6:	5f                   	pop    %edi
  11bbc7:	5b                   	pop    %ebx
  11bbc8:	5d                   	pop    %ebp
  11bbc9:	c3                   	ret    
  11bbca:	66 90                	xchg   %ax,%ax
  11bbcc:	66 90                	xchg   %ax,%ax
  11bbce:	66 90                	xchg   %ax,%ax

0011bbd0 <lv_label_get_text_sel_start>:
{
  11bbd0:	55                   	push   %ebp
  11bbd1:	89 e5                	mov    %esp,%ebp
  11bbd3:	50                   	push   %eax
  11bbd4:	8b 45 08             	mov    0x8(%ebp),%eax
    return LV_LABEL_TEXT_SEL_OFF;
  11bbd7:	66 b9 ff ff          	mov    $0xffff,%cx
  11bbdb:	0f b7 d1             	movzwl %cx,%edx
  11bbde:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11bbe1:	89 d0                	mov    %edx,%eax
  11bbe3:	83 c4 04             	add    $0x4,%esp
  11bbe6:	5d                   	pop    %ebp
  11bbe7:	c3                   	ret    
  11bbe8:	66 90                	xchg   %ax,%ax
  11bbea:	66 90                	xchg   %ax,%ax
  11bbec:	66 90                	xchg   %ax,%ax
  11bbee:	66 90                	xchg   %ax,%ax

0011bbf0 <lv_label_get_text_sel_end>:
{
  11bbf0:	55                   	push   %ebp
  11bbf1:	89 e5                	mov    %esp,%ebp
  11bbf3:	50                   	push   %eax
  11bbf4:	8b 45 08             	mov    0x8(%ebp),%eax
    return LV_LABEL_TEXT_SEL_OFF;
  11bbf7:	66 b9 ff ff          	mov    $0xffff,%cx
  11bbfb:	0f b7 d1             	movzwl %cx,%edx
  11bbfe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11bc01:	89 d0                	mov    %edx,%eax
  11bc03:	83 c4 04             	add    $0x4,%esp
  11bc06:	5d                   	pop    %ebp
  11bc07:	c3                   	ret    
  11bc08:	66 90                	xchg   %ax,%ax
  11bc0a:	66 90                	xchg   %ax,%ax
  11bc0c:	66 90                	xchg   %ax,%ax
  11bc0e:	66 90                	xchg   %ax,%ax

0011bc10 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
  11bc10:	55                   	push   %ebp
  11bc11:	89 e5                	mov    %esp,%ebp
  11bc13:	83 ec 0c             	sub    $0xc,%esp
  11bc16:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11bc19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11bc1c:	89 0c 24             	mov    %ecx,(%esp)
  11bc1f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11bc22:	e8 59 40 ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11bc27:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
  11bc2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bc2d:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11bc31:	66 c1 ea 09          	shr    $0x9,%dx
  11bc35:	66 83 e2 01          	and    $0x1,%dx
  11bc39:	0f b6 c2             	movzbl %dl,%eax
  11bc3c:	83 f8 00             	cmp    $0x0,%eax
  11bc3f:	0f 84 1b 00 00 00    	je     11bc60 <lv_label_dot_tmp_free+0x50>
  11bc45:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bc48:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11bc4c:	0f 84 0e 00 00 00    	je     11bc60 <lv_label_dot_tmp_free+0x50>
        lv_mem_free(ext->dot.tmp_ptr);
  11bc52:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bc55:	8b 40 04             	mov    0x4(%eax),%eax
  11bc58:	89 04 24             	mov    %eax,(%esp)
  11bc5b:	e8 00 cc ff ff       	call   118860 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
  11bc60:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bc63:	66 8b 48 0e          	mov    0xe(%eax),%cx
  11bc67:	66 81 e1 ff fd       	and    $0xfdff,%cx
  11bc6c:	66 89 48 0e          	mov    %cx,0xe(%eax)
    ext->dot.tmp_ptr   = NULL;
  11bc70:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bc73:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
  11bc7a:	83 c4 0c             	add    $0xc,%esp
  11bc7d:	5d                   	pop    %ebp
  11bc7e:	c3                   	ret    
  11bc7f:	90                   	nop

0011bc80 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
  11bc80:	55                   	push   %ebp
  11bc81:	89 e5                	mov    %esp,%ebp
  11bc83:	50                   	push   %eax
  11bc84:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->x2 - area_p->x1 + 1;
  11bc87:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11bc8a:	0f bf 49 04          	movswl 0x4(%ecx),%ecx
  11bc8e:	8b 55 08             	mov    0x8(%ebp),%edx
  11bc91:	0f bf 12             	movswl (%edx),%edx
  11bc94:	29 d1                	sub    %edx,%ecx
  11bc96:	83 c1 01             	add    $0x1,%ecx
  11bc99:	0f bf d1             	movswl %cx,%edx
  11bc9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11bc9f:	89 d0                	mov    %edx,%eax
  11bca1:	83 c4 04             	add    $0x4,%esp
  11bca4:	5d                   	pop    %ebp
  11bca5:	c3                   	ret    
  11bca6:	66 90                	xchg   %ax,%ax
  11bca8:	66 90                	xchg   %ax,%ax
  11bcaa:	66 90                	xchg   %ax,%ax
  11bcac:	66 90                	xchg   %ax,%ax
  11bcae:	66 90                	xchg   %ax,%ax

0011bcb0 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
  11bcb0:	55                   	push   %ebp
  11bcb1:	89 e5                	mov    %esp,%ebp
  11bcb3:	50                   	push   %eax
  11bcb4:	8b 45 08             	mov    0x8(%ebp),%eax
    return area_p->y2 - area_p->y1 + 1;
  11bcb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11bcba:	0f bf 49 06          	movswl 0x6(%ecx),%ecx
  11bcbe:	8b 55 08             	mov    0x8(%ebp),%edx
  11bcc1:	0f bf 52 02          	movswl 0x2(%edx),%edx
  11bcc5:	29 d1                	sub    %edx,%ecx
  11bcc7:	83 c1 01             	add    $0x1,%ecx
  11bcca:	0f bf d1             	movswl %cx,%edx
  11bccd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11bcd0:	89 d0                	mov    %edx,%eax
  11bcd2:	83 c4 04             	add    $0x4,%esp
  11bcd5:	5d                   	pop    %ebp
  11bcd6:	c3                   	ret    
  11bcd7:	66 90                	xchg   %ax,%ax
  11bcd9:	66 90                	xchg   %ax,%ax
  11bcdb:	66 90                	xchg   %ax,%ax
  11bcdd:	66 90                	xchg   %ax,%ax
  11bcdf:	90                   	nop

0011bce0 <lv_label_get_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
  11bce0:	55                   	push   %ebp
  11bce1:	89 e5                	mov    %esp,%ebp
  11bce3:	83 ec 0c             	sub    $0xc,%esp
  11bce6:	8a 45 0c             	mov    0xc(%ebp),%al
  11bce9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
  11bcec:	8b 55 08             	mov    0x8(%ebp),%edx
  11bcef:	89 14 24             	mov    %edx,(%esp)
  11bcf2:	88 45 ff             	mov    %al,-0x1(%ebp)
  11bcf5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11bcf8:	e8 b3 3d ff ff       	call   10fab0 <lv_obj_get_style>
  11bcfd:	83 c4 0c             	add    $0xc,%esp
  11bd00:	5d                   	pop    %ebp
  11bd01:	c3                   	ret    
  11bd02:	66 90                	xchg   %ax,%ax
  11bd04:	66 90                	xchg   %ax,%ax
  11bd06:	66 90                	xchg   %ax,%ax
  11bd08:	66 90                	xchg   %ax,%ax
  11bd0a:	66 90                	xchg   %ax,%ax
  11bd0c:	66 90                	xchg   %ax,%ax
  11bd0e:	66 90                	xchg   %ax,%ax

0011bd10 <lv_label_get_dot_tmp>:
{
  11bd10:	55                   	push   %ebp
  11bd11:	89 e5                	mov    %esp,%ebp
  11bd13:	83 ec 10             	sub    $0x10,%esp
  11bd16:	8b 45 08             	mov    0x8(%ebp),%eax
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
  11bd19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11bd1c:	89 0c 24             	mov    %ecx,(%esp)
  11bd1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11bd22:	e8 59 3f ff ff       	call   10fc80 <lv_obj_get_ext_attr>
  11bd27:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(ext->dot_tmp_alloc) {
  11bd2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11bd2d:	66 8b 50 0e          	mov    0xe(%eax),%dx
  11bd31:	66 c1 ea 09          	shr    $0x9,%dx
  11bd35:	66 83 e2 01          	and    $0x1,%dx
  11bd39:	80 fa 00             	cmp    $0x0,%dl
  11bd3c:	0f 84 0e 00 00 00    	je     11bd50 <lv_label_get_dot_tmp+0x40>
        return ext->dot.tmp_ptr;
  11bd42:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11bd45:	8b 40 04             	mov    0x4(%eax),%eax
  11bd48:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11bd4b:	e9 09 00 00 00       	jmp    11bd59 <lv_label_get_dot_tmp+0x49>
        return ext->dot.tmp;
  11bd50:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11bd53:	83 c0 04             	add    $0x4,%eax
  11bd56:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  11bd59:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11bd5c:	83 c4 10             	add    $0x10,%esp
  11bd5f:	5d                   	pop    %ebp
  11bd60:	c3                   	ret    
  11bd61:	66 90                	xchg   %ax,%ax
  11bd63:	66 90                	xchg   %ax,%ax
  11bd65:	66 90                	xchg   %ax,%ax
  11bd67:	66 90                	xchg   %ax,%ax
  11bd69:	66 90                	xchg   %ax,%ax
  11bd6b:	66 90                	xchg   %ax,%ax
  11bd6d:	66 90                	xchg   %ax,%ax
  11bd6f:	90                   	nop

0011bd70 <lv_theme_get_current>:
/**
 * Get the current system theme.
 * @return pointer to the current system theme. NULL if not set.
 */
lv_theme_t * lv_theme_get_current(void)
{
  11bd70:	55                   	push   %ebp
  11bd71:	89 e5                	mov    %esp,%ebp
#if LV_THEME_LIVE_UPDATE == 0
    return current_theme;
  11bd73:	a1 bc 55 13 00       	mov    0x1355bc,%eax
  11bd78:	5d                   	pop    %ebp
  11bd79:	c3                   	ret    
  11bd7a:	66 90                	xchg   %ax,%ax
  11bd7c:	66 90                	xchg   %ax,%ax
  11bd7e:	66 90                	xchg   %ax,%ax

0011bd80 <lv_font_get_glyph_bitmap>:
 * @param font_p pointer to a font
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
  11bd80:	55                   	push   %ebp
  11bd81:	89 e5                	mov    %esp,%ebp
  11bd83:	57                   	push   %edi
  11bd84:	56                   	push   %esi
  11bd85:	83 ec 10             	sub    $0x10,%esp
  11bd88:	8b 45 0c             	mov    0xc(%ebp),%eax
  11bd8b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    return font_p->get_glyph_bitmap(font_p, letter);
  11bd8e:	8b 55 08             	mov    0x8(%ebp),%edx
  11bd91:	8b 52 04             	mov    0x4(%edx),%edx
  11bd94:	8b 75 08             	mov    0x8(%ebp),%esi
  11bd97:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11bd9a:	89 34 24             	mov    %esi,(%esp)
  11bd9d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11bda1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11bda4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11bda7:	ff d2                	call   *%edx
  11bda9:	83 c4 10             	add    $0x10,%esp
  11bdac:	5e                   	pop    %esi
  11bdad:	5f                   	pop    %edi
  11bdae:	5d                   	pop    %ebp
  11bdaf:	c3                   	ret    

0011bdb0 <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
  11bdb0:	55                   	push   %ebp
  11bdb1:	89 e5                	mov    %esp,%ebp
  11bdb3:	53                   	push   %ebx
  11bdb4:	57                   	push   %edi
  11bdb5:	56                   	push   %esi
  11bdb6:	83 ec 28             	sub    $0x28,%esp
  11bdb9:	8b 45 14             	mov    0x14(%ebp),%eax
  11bdbc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11bdbf:	8b 55 0c             	mov    0xc(%ebp),%edx
  11bdc2:	8b 75 08             	mov    0x8(%ebp),%esi
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
  11bdc5:	8b 7d 08             	mov    0x8(%ebp),%edi
  11bdc8:	8b 3f                	mov    (%edi),%edi
  11bdca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11bdcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11bdd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  11bdd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11bdd6:	8b 45 10             	mov    0x10(%ebp),%eax
  11bdd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11bddc:	8b 45 14             	mov    0x14(%ebp),%eax
  11bddf:	89 1c 24             	mov    %ebx,(%esp)
  11bde2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  11bde5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  11bde9:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  11bdec:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11bdf0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11bdf4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  11bdf7:	89 55 e0             	mov    %edx,-0x20(%ebp)
  11bdfa:	89 75 dc             	mov    %esi,-0x24(%ebp)
  11bdfd:	ff d7                	call   *%edi
  11bdff:	24 01                	and    $0x1,%al
  11be01:	0f b6 c0             	movzbl %al,%eax
  11be04:	83 c4 28             	add    $0x28,%esp
  11be07:	5e                   	pop    %esi
  11be08:	5f                   	pop    %edi
  11be09:	5b                   	pop    %ebx
  11be0a:	5d                   	pop    %ebp
  11be0b:	c3                   	ret    
  11be0c:	66 90                	xchg   %ax,%ax
  11be0e:	66 90                	xchg   %ax,%ax

0011be10 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
  11be10:	55                   	push   %ebp
  11be11:	89 e5                	mov    %esp,%ebp
  11be13:	53                   	push   %ebx
  11be14:	57                   	push   %edi
  11be15:	56                   	push   %esi
  11be16:	83 e4 f8             	and    $0xfffffff8,%esp
  11be19:	83 ec 30             	sub    $0x30,%esp
  11be1c:	8b 45 10             	mov    0x10(%ebp),%eax
  11be1f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11be22:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
  11be25:	8b 75 08             	mov    0x8(%ebp),%esi
  11be28:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11be2b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11be2e:	89 34 24             	mov    %esi,(%esp)
  11be31:	8d 74 24 20          	lea    0x20(%esp),%esi
  11be35:	89 74 24 04          	mov    %esi,0x4(%esp)
  11be39:	89 7c 24 08          	mov    %edi,0x8(%esp)
  11be3d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  11be41:	89 44 24 18          	mov    %eax,0x18(%esp)
  11be45:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  11be49:	89 54 24 10          	mov    %edx,0x10(%esp)
  11be4d:	e8 5e ff ff ff       	call   11bdb0 <lv_font_get_glyph_dsc>
  11be52:	24 01                	and    $0x1,%al
  11be54:	88 44 24 1f          	mov    %al,0x1f(%esp)
    if(ret) return g.adv_w;
  11be58:	f6 44 24 1f 01       	testb  $0x1,0x1f(%esp)
  11be5d:	0f 84 0f 00 00 00    	je     11be72 <lv_font_get_glyph_width+0x62>
  11be63:	66 8b 44 24 20       	mov    0x20(%esp),%ax
  11be68:	66 89 44 24 2a       	mov    %ax,0x2a(%esp)
  11be6d:	e9 07 00 00 00       	jmp    11be79 <lv_font_get_glyph_width+0x69>
    else return 0;
  11be72:	66 c7 44 24 2a 00 00 	movw   $0x0,0x2a(%esp)
}
  11be79:	0f b7 44 24 2a       	movzwl 0x2a(%esp),%eax
  11be7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11be81:	5e                   	pop    %esi
  11be82:	5f                   	pop    %edi
  11be83:	5b                   	pop    %ebx
  11be84:	5d                   	pop    %ebp
  11be85:	c3                   	ret    
  11be86:	66 90                	xchg   %ax,%ax
  11be88:	66 90                	xchg   %ax,%ax
  11be8a:	66 90                	xchg   %ax,%ax
  11be8c:	66 90                	xchg   %ax,%ax
  11be8e:	66 90                	xchg   %ax,%ax

0011be90 <lv_font_get_bitmap_fmt_txt>:
 * @param font pointer to font
 * @param unicode_letter an unicode letter which bitmap should be get
 * @return pointer to the bitmap or NULL if not found
 */
const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)
{
  11be90:	55                   	push   %ebp
  11be91:	89 e5                	mov    %esp,%ebp
  11be93:	56                   	push   %esi
  11be94:	83 ec 20             	sub    $0x20,%esp
  11be97:	8b 45 0c             	mov    0xc(%ebp),%eax
  11be9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
  11be9d:	8b 55 08             	mov    0x8(%ebp),%edx
  11bea0:	8b 52 0c             	mov    0xc(%edx),%edx
  11bea3:	89 55 f4             	mov    %edx,-0xc(%ebp)
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
  11bea6:	8b 55 08             	mov    0x8(%ebp),%edx
  11bea9:	8b 75 0c             	mov    0xc(%ebp),%esi
  11beac:	89 14 24             	mov    %edx,(%esp)
  11beaf:	89 74 24 04          	mov    %esi,0x4(%esp)
  11beb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11beb6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  11beb9:	e8 62 00 00 00       	call   11bf20 <get_glyph_dsc_id>
  11bebe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!gid) return false;
  11bec1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  11bec5:	0f 85 0c 00 00 00    	jne    11bed7 <lv_font_get_bitmap_fmt_txt+0x47>
  11becb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11bed2:	e9 3c 00 00 00       	jmp    11bf13 <lv_font_get_bitmap_fmt_txt+0x83>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
  11bed7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11beda:	8b 40 04             	mov    0x4(%eax),%eax
  11bedd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11bee0:	c1 e1 03             	shl    $0x3,%ecx
  11bee3:	01 c8                	add    %ecx,%eax
  11bee5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
  11bee8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  11beec:	0f 84 1a 00 00 00    	je     11bf0c <lv_font_get_bitmap_fmt_txt+0x7c>
  11bef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11bef5:	8b 00                	mov    (%eax),%eax
  11bef7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  11befa:	8b 09                	mov    (%ecx),%ecx
  11befc:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  11bf02:	01 c8                	add    %ecx,%eax
  11bf04:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11bf07:	e9 07 00 00 00       	jmp    11bf13 <lv_font_get_bitmap_fmt_txt+0x83>

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
  11bf0c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  11bf13:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11bf16:	83 c4 20             	add    $0x20,%esp
  11bf19:	5e                   	pop    %esi
  11bf1a:	5d                   	pop    %ebp
  11bf1b:	c3                   	ret    
  11bf1c:	66 90                	xchg   %ax,%ax
  11bf1e:	66 90                	xchg   %ax,%ax

0011bf20 <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
  11bf20:	55                   	push   %ebp
  11bf21:	89 e5                	mov    %esp,%ebp
  11bf23:	56                   	push   %esi
  11bf24:	83 ec 40             	sub    $0x40,%esp
  11bf27:	8b 45 0c             	mov    0xc(%ebp),%eax
  11bf2a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if(letter == '\0') return 0;
  11bf2d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11bf31:	0f 85 0c 00 00 00    	jne    11bf43 <get_glyph_dsc_id+0x23>
  11bf37:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11bf3e:	e9 0b 03 00 00       	jmp    11c24e <get_glyph_dsc_id+0x32e>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
  11bf43:	8b 45 08             	mov    0x8(%ebp),%eax
  11bf46:	8b 40 0c             	mov    0xc(%eax),%eax
  11bf49:	89 45 f4             	mov    %eax,-0xc(%ebp)

    /*Check the cache first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
  11bf4c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11bf4f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11bf52:	3b 41 14             	cmp    0x14(%ecx),%eax
  11bf55:	0f 85 0e 00 00 00    	jne    11bf69 <get_glyph_dsc_id+0x49>
  11bf5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11bf5e:	8b 40 18             	mov    0x18(%eax),%eax
  11bf61:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11bf64:	e9 e5 02 00 00       	jmp    11c24e <get_glyph_dsc_id+0x32e>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
  11bf69:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
  11bf6f:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  11bf73:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11bf76:	66 8b 51 12          	mov    0x12(%ecx),%dx
  11bf7a:	66 81 e2 ff 03       	and    $0x3ff,%dx
  11bf7f:	0f b7 ca             	movzwl %dx,%ecx
  11bf82:	39 c8                	cmp    %ecx,%eax
  11bf84:	0f 8d aa 02 00 00    	jge    11c234 <get_glyph_dsc_id+0x314>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
  11bf8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11bf8d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11bf90:	8b 49 08             	mov    0x8(%ecx),%ecx
  11bf93:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11bf97:	6b d2 14             	imul   $0x14,%edx,%edx
  11bf9a:	01 d1                	add    %edx,%ecx
  11bf9c:	2b 01                	sub    (%ecx),%eax
  11bf9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(rcp > fdsc->cmaps[i].range_length) continue;
  11bfa1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11bfa4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11bfa7:	8b 49 08             	mov    0x8(%ecx),%ecx
  11bfaa:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11bfae:	6b d2 14             	imul   $0x14,%edx,%edx
  11bfb1:	01 d1                	add    %edx,%ecx
  11bfb3:	0f b7 49 04          	movzwl 0x4(%ecx),%ecx
  11bfb7:	39 c8                	cmp    %ecx,%eax
  11bfb9:	0f 86 05 00 00 00    	jbe    11bfc4 <get_glyph_dsc_id+0xa4>
  11bfbf:	e9 5f 02 00 00       	jmp    11c223 <get_glyph_dsc_id+0x303>
        uint32_t glyph_id = 0;
  11bfc4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
  11bfcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11bfce:	8b 40 08             	mov    0x8(%eax),%eax
  11bfd1:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11bfd5:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11bfd8:	01 c8                	add    %ecx,%eax
  11bfda:	8a 50 12             	mov    0x12(%eax),%dl
  11bfdd:	80 e2 03             	and    $0x3,%dl
  11bfe0:	0f b6 c2             	movzbl %dl,%eax
  11bfe3:	83 f8 00             	cmp    $0x0,%eax
  11bfe6:	0f 85 1e 00 00 00    	jne    11c00a <get_glyph_dsc_id+0xea>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
  11bfec:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11bfef:	8b 40 08             	mov    0x8(%eax),%eax
  11bff2:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11bff6:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11bff9:	01 c8                	add    %ecx,%eax
  11bffb:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  11bfff:	03 45 ec             	add    -0x14(%ebp),%eax
  11c002:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
  11c005:	e9 fc 01 00 00       	jmp    11c206 <get_glyph_dsc_id+0x2e6>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
  11c00a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c00d:	8b 40 08             	mov    0x8(%eax),%eax
  11c010:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c014:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c017:	01 c8                	add    %ecx,%eax
  11c019:	8a 50 12             	mov    0x12(%eax),%dl
  11c01c:	80 e2 03             	and    $0x3,%dl
  11c01f:	0f b6 c2             	movzbl %dl,%eax
  11c022:	83 f8 01             	cmp    $0x1,%eax
  11c025:	0f 85 3c 00 00 00    	jne    11c067 <get_glyph_dsc_id+0x147>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
  11c02b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c02e:	8b 40 08             	mov    0x8(%eax),%eax
  11c031:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c035:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c038:	01 c8                	add    %ecx,%eax
  11c03a:	8b 40 0c             	mov    0xc(%eax),%eax
  11c03d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
  11c040:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c043:	8b 40 08             	mov    0x8(%eax),%eax
  11c046:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c04a:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c04d:	01 c8                	add    %ecx,%eax
  11c04f:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  11c053:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  11c056:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11c059:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  11c05d:	01 c8                	add    %ecx,%eax
  11c05f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
  11c062:	e9 9a 01 00 00       	jmp    11c201 <get_glyph_dsc_id+0x2e1>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
  11c067:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c06a:	8b 40 08             	mov    0x8(%eax),%eax
  11c06d:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c071:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c074:	01 c8                	add    %ecx,%eax
  11c076:	8a 50 12             	mov    0x12(%eax),%dl
  11c079:	80 e2 03             	and    $0x3,%dl
  11c07c:	0f b6 c2             	movzbl %dl,%eax
  11c07f:	83 f8 02             	cmp    $0x2,%eax
  11c082:	0f 85 98 00 00 00    	jne    11c120 <get_glyph_dsc_id+0x200>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
  11c088:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11c08b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c08e:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c091:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11c095:	6b d2 14             	imul   $0x14,%edx,%edx
  11c098:	01 d1                	add    %edx,%ecx
  11c09a:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c09d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11c0a0:	8b 52 08             	mov    0x8(%edx),%edx
  11c0a3:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
  11c0a7:	6b f6 14             	imul   $0x14,%esi,%esi
  11c0aa:	01 f2                	add    %esi,%edx
  11c0ac:	0f b7 52 10          	movzwl 0x10(%edx),%edx
  11c0b0:	89 04 24             	mov    %eax,(%esp)
  11c0b3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c0b7:	89 54 24 08          	mov    %edx,0x8(%esp)
  11c0bb:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  11c0c2:	00 
  11c0c3:	8d 05 90 c5 11 00    	lea    0x11c590,%eax
  11c0c9:	89 44 24 10          	mov    %eax,0x10(%esp)
  11c0cd:	e8 ee d9 ff ff       	call   119ac0 <lv_utils_bsearch>
  11c0d2:	89 45 e0             	mov    %eax,-0x20(%ebp)

            if(p) {
  11c0d5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  11c0d9:	0f 84 3c 00 00 00    	je     11c11b <get_glyph_dsc_id+0x1fb>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
  11c0df:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11c0e2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c0e5:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c0e8:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11c0ec:	6b d2 14             	imul   $0x14,%edx,%edx
  11c0ef:	01 d1                	add    %edx,%ecx
  11c0f1:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c0f4:	29 c8                	sub    %ecx,%eax
  11c0f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
  11c0f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11c0fc:	c1 e8 01             	shr    $0x1,%eax
  11c0ff:	89 45 dc             	mov    %eax,-0x24(%ebp)
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
  11c102:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c105:	8b 40 08             	mov    0x8(%eax),%eax
  11c108:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c10c:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c10f:	01 c8                	add    %ecx,%eax
  11c111:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  11c115:	03 45 dc             	add    -0x24(%ebp),%eax
  11c118:	89 45 e8             	mov    %eax,-0x18(%ebp)
            }
        }
  11c11b:	e9 dc 00 00 00       	jmp    11c1fc <get_glyph_dsc_id+0x2dc>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
  11c120:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c123:	8b 40 08             	mov    0x8(%eax),%eax
  11c126:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c12a:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c12d:	01 c8                	add    %ecx,%eax
  11c12f:	8a 50 12             	mov    0x12(%eax),%dl
  11c132:	80 e2 03             	and    $0x3,%dl
  11c135:	0f b6 c2             	movzbl %dl,%eax
  11c138:	83 f8 03             	cmp    $0x3,%eax
  11c13b:	0f 85 b6 00 00 00    	jne    11c1f7 <get_glyph_dsc_id+0x2d7>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
  11c141:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11c144:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c147:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c14a:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11c14e:	6b d2 14             	imul   $0x14,%edx,%edx
  11c151:	01 d1                	add    %edx,%ecx
  11c153:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c156:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11c159:	8b 52 08             	mov    0x8(%edx),%edx
  11c15c:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
  11c160:	6b f6 14             	imul   $0x14,%esi,%esi
  11c163:	01 f2                	add    %esi,%edx
  11c165:	0f b7 52 10          	movzwl 0x10(%edx),%edx
  11c169:	89 04 24             	mov    %eax,(%esp)
  11c16c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c170:	89 54 24 08          	mov    %edx,0x8(%esp)
  11c174:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  11c17b:	00 
  11c17c:	8d 05 90 c5 11 00    	lea    0x11c590,%eax
  11c182:	89 44 24 10          	mov    %eax,0x10(%esp)
  11c186:	e8 35 d9 ff ff       	call   119ac0 <lv_utils_bsearch>
  11c18b:	89 45 d8             	mov    %eax,-0x28(%ebp)

            if(p) {
  11c18e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  11c192:	0f 84 5a 00 00 00    	je     11c1f2 <get_glyph_dsc_id+0x2d2>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
  11c198:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11c19b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c19e:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c1a1:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  11c1a5:	6b d2 14             	imul   $0x14,%edx,%edx
  11c1a8:	01 d1                	add    %edx,%ecx
  11c1aa:	8b 49 08             	mov    0x8(%ecx),%ecx
  11c1ad:	29 c8                	sub    %ecx,%eax
  11c1af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
  11c1b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  11c1b5:	c1 e8 01             	shr    $0x1,%eax
  11c1b8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                const uint8_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
  11c1bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c1be:	8b 40 08             	mov    0x8(%eax),%eax
  11c1c1:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c1c5:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c1c8:	01 c8                	add    %ecx,%eax
  11c1ca:	8b 40 0c             	mov    0xc(%eax),%eax
  11c1cd:	89 45 d0             	mov    %eax,-0x30(%ebp)
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
  11c1d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c1d3:	8b 40 08             	mov    0x8(%eax),%eax
  11c1d6:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  11c1da:	6b c9 14             	imul   $0x14,%ecx,%ecx
  11c1dd:	01 c8                	add    %ecx,%eax
  11c1df:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  11c1e3:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  11c1e6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  11c1e9:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  11c1ed:	01 c8                	add    %ecx,%eax
  11c1ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
            }
        }
  11c1f2:	e9 00 00 00 00       	jmp    11c1f7 <get_glyph_dsc_id+0x2d7>
  11c1f7:	e9 00 00 00 00       	jmp    11c1fc <get_glyph_dsc_id+0x2dc>
  11c1fc:	e9 00 00 00 00       	jmp    11c201 <get_glyph_dsc_id+0x2e1>
  11c201:	e9 00 00 00 00       	jmp    11c206 <get_glyph_dsc_id+0x2e6>

        /*Update the cache*/
        fdsc->last_letter = letter;
  11c206:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c209:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c20c:	89 41 14             	mov    %eax,0x14(%ecx)
        fdsc->last_glyph_id = glyph_id;
  11c20f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c212:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c215:	89 41 18             	mov    %eax,0x18(%ecx)
        return glyph_id;
  11c218:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c21b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c21e:	e9 2b 00 00 00       	jmp    11c24e <get_glyph_dsc_id+0x32e>
    for(i = 0; i < fdsc->cmap_num; i++) {
  11c223:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  11c227:	66 83 c0 01          	add    $0x1,%ax
  11c22b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  11c22f:	e9 3b fd ff ff       	jmp    11bf6f <get_glyph_dsc_id+0x4f>
    }

    fdsc->last_letter = letter;
  11c234:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c237:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11c23a:	89 41 14             	mov    %eax,0x14(%ecx)
    fdsc->last_glyph_id = 0;
  11c23d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c240:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    return 0;
  11c247:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

}
  11c24e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c251:	83 c4 40             	add    $0x40,%esp
  11c254:	5e                   	pop    %esi
  11c255:	5d                   	pop    %ebp
  11c256:	c3                   	ret    
  11c257:	66 90                	xchg   %ax,%ax
  11c259:	66 90                	xchg   %ax,%ax
  11c25b:	66 90                	xchg   %ax,%ax
  11c25d:	66 90                	xchg   %ax,%ax
  11c25f:	90                   	nop

0011c260 <lv_font_get_glyph_dsc_fmt_txt>:
{
  11c260:	55                   	push   %ebp
  11c261:	89 e5                	mov    %esp,%ebp
  11c263:	53                   	push   %ebx
  11c264:	57                   	push   %edi
  11c265:	56                   	push   %esi
  11c266:	83 ec 38             	sub    $0x38,%esp
  11c269:	8b 45 14             	mov    0x14(%ebp),%eax
  11c26c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11c26f:	8b 55 0c             	mov    0xc(%ebp),%edx
  11c272:	8b 75 08             	mov    0x8(%ebp),%esi
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
  11c275:	8b 7d 08             	mov    0x8(%ebp),%edi
  11c278:	8b 7f 0c             	mov    0xc(%edi),%edi
  11c27b:	89 7d ec             	mov    %edi,-0x14(%ebp)
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
  11c27e:	8b 7d 08             	mov    0x8(%ebp),%edi
  11c281:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11c284:	89 3c 24             	mov    %edi,(%esp)
  11c287:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  11c28b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  11c28e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  11c291:	89 55 cc             	mov    %edx,-0x34(%ebp)
  11c294:	89 75 c8             	mov    %esi,-0x38(%ebp)
  11c297:	e8 84 fc ff ff       	call   11bf20 <get_glyph_dsc_id>
  11c29c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!gid) return false;
  11c29f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11c2a3:	0f 85 09 00 00 00    	jne    11c2b2 <lv_font_get_glyph_dsc_fmt_txt+0x52>
  11c2a9:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  11c2ad:	e9 de 00 00 00       	jmp    11c390 <lv_font_get_glyph_dsc_fmt_txt+0x130>
    int8_t kvalue = 0;
  11c2b2:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
    if(fdsc->kern_dsc) {
  11c2b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11c2b9:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  11c2bd:	0f 84 40 00 00 00    	je     11c303 <lv_font_get_glyph_dsc_fmt_txt+0xa3>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
  11c2c3:	8b 45 08             	mov    0x8(%ebp),%eax
  11c2c6:	8b 4d 14             	mov    0x14(%ebp),%ecx
  11c2c9:	89 04 24             	mov    %eax,(%esp)
  11c2cc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c2d0:	e8 4b fc ff ff       	call   11bf20 <get_glyph_dsc_id>
  11c2d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(gid_next) {
  11c2d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  11c2dc:	0f 84 1c 00 00 00    	je     11c2fe <lv_font_get_glyph_dsc_fmt_txt+0x9e>
            kvalue = get_kern_value(font, gid, gid_next);
  11c2e2:	8b 45 08             	mov    0x8(%ebp),%eax
  11c2e5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11c2e8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  11c2eb:	89 04 24             	mov    %eax,(%esp)
  11c2ee:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c2f2:	89 54 24 08          	mov    %edx,0x8(%esp)
  11c2f6:	e8 a5 00 00 00       	call   11c3a0 <get_kern_value>
  11c2fb:	88 45 e7             	mov    %al,-0x19(%ebp)
    }
  11c2fe:	e9 00 00 00 00       	jmp    11c303 <lv_font_get_glyph_dsc_fmt_txt+0xa3>
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
  11c303:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11c306:	8b 40 04             	mov    0x4(%eax),%eax
  11c309:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11c30c:	c1 e1 03             	shl    $0x3,%ecx
  11c30f:	01 c8                	add    %ecx,%eax
  11c311:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uint32_t adv_w = gdsc->adv_w + ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
  11c314:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11c317:	8b 00                	mov    (%eax),%eax
  11c319:	c1 e8 14             	shr    $0x14,%eax
  11c31c:	0f be 4d e7          	movsbl -0x19(%ebp),%ecx
  11c320:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11c323:	0f b7 52 10          	movzwl 0x10(%edx),%edx
  11c327:	0f af ca             	imul   %edx,%ecx
  11c32a:	c1 f9 04             	sar    $0x4,%ecx
  11c32d:	01 c8                	add    %ecx,%eax
  11c32f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    adv_w  = (adv_w + (1 << 3)) >> 4;
  11c332:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11c335:	83 c0 08             	add    $0x8,%eax
  11c338:	c1 e8 04             	shr    $0x4,%eax
  11c33b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    dsc_out->adv_w = adv_w;
  11c33e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11c341:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c344:	66 89 01             	mov    %ax,(%ecx)
    dsc_out->box_h = gdsc->box_h;
  11c347:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  11c34a:	8a 59 05             	mov    0x5(%ecx),%bl
  11c34d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c350:	88 59 03             	mov    %bl,0x3(%ecx)
    dsc_out->box_w = gdsc->box_w;
  11c353:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  11c356:	8a 59 04             	mov    0x4(%ecx),%bl
  11c359:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c35c:	88 59 02             	mov    %bl,0x2(%ecx)
    dsc_out->ofs_x = gdsc->ofs_x;
  11c35f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  11c362:	8a 59 06             	mov    0x6(%ecx),%bl
  11c365:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c368:	88 59 04             	mov    %bl,0x4(%ecx)
    dsc_out->ofs_y = gdsc->ofs_y;
  11c36b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  11c36e:	8a 59 07             	mov    0x7(%ecx),%bl
  11c371:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c374:	88 59 05             	mov    %bl,0x5(%ecx)
    dsc_out->bpp   = fdsc->bpp;
  11c377:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  11c37a:	66 8b 41 12          	mov    0x12(%ecx),%ax
  11c37e:	66 c1 e8 0a          	shr    $0xa,%ax
  11c382:	66 83 e0 07          	and    $0x7,%ax
  11c386:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c389:	88 41 06             	mov    %al,0x6(%ecx)
    return true;
  11c38c:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
}
  11c390:	8a 45 f3             	mov    -0xd(%ebp),%al
  11c393:	24 01                	and    $0x1,%al
  11c395:	0f b6 c0             	movzbl %al,%eax
  11c398:	83 c4 38             	add    $0x38,%esp
  11c39b:	5e                   	pop    %esi
  11c39c:	5f                   	pop    %edi
  11c39d:	5b                   	pop    %ebx
  11c39e:	5d                   	pop    %ebp
  11c39f:	c3                   	ret    

0011c3a0 <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
  11c3a0:	55                   	push   %ebp
  11c3a1:	89 e5                	mov    %esp,%ebp
  11c3a3:	53                   	push   %ebx
  11c3a4:	57                   	push   %edi
  11c3a5:	56                   	push   %esi
  11c3a6:	83 ec 48             	sub    $0x48,%esp
  11c3a9:	8b 45 10             	mov    0x10(%ebp),%eax
  11c3ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c3af:	8b 55 08             	mov    0x8(%ebp),%edx
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
  11c3b2:	8b 75 08             	mov    0x8(%ebp),%esi
  11c3b5:	8b 76 0c             	mov    0xc(%esi),%esi
  11c3b8:	89 75 f0             	mov    %esi,-0x10(%ebp)

    int8_t value = 0;
  11c3bb:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)

    if(fdsc->kern_classes == 0) {
  11c3bf:	8b 75 f0             	mov    -0x10(%ebp),%esi
  11c3c2:	66 8b 7e 12          	mov    0x12(%esi),%di
  11c3c6:	66 c1 ef 0d          	shr    $0xd,%di
  11c3ca:	66 83 e7 01          	and    $0x1,%di
  11c3ce:	0f b7 f7             	movzwl %di,%esi
  11c3d1:	83 fe 00             	cmp    $0x0,%esi
  11c3d4:	0f 85 3d 01 00 00    	jne    11c517 <get_kern_value+0x177>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
  11c3da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11c3dd:	8b 40 0c             	mov    0xc(%eax),%eax
  11c3e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(kdsc->glyph_ids_size == 0) {
  11c3e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c3e6:	8b 40 08             	mov    0x8(%eax),%eax
  11c3e9:	c1 e8 18             	shr    $0x18,%eax
  11c3ec:	83 e0 03             	and    $0x3,%eax
  11c3ef:	83 f8 00             	cmp    $0x0,%eax
  11c3f2:	0f 85 7e 00 00 00    	jne    11c476 <get_kern_value+0xd6>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
  11c3f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c3fb:	8b 00                	mov    (%eax),%eax
  11c3fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
  11c400:	8b 45 10             	mov    0x10(%ebp),%eax
  11c403:	c1 e0 08             	shl    $0x8,%eax
  11c406:	03 45 0c             	add    0xc(%ebp),%eax
  11c409:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
  11c40d:	8d 4d e2             	lea    -0x1e(%ebp),%ecx
  11c410:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  11c413:	8b 75 e8             	mov    -0x18(%ebp),%esi
  11c416:	8b 76 08             	mov    0x8(%esi),%esi
  11c419:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
  11c41f:	89 0c 24             	mov    %ecx,(%esp)
  11c422:	89 54 24 04          	mov    %edx,0x4(%esp)
  11c426:	89 74 24 08          	mov    %esi,0x8(%esp)
  11c42a:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  11c431:	00 
  11c432:	8d 0d c0 c5 11 00    	lea    0x11c5c0,%ecx
  11c438:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11c43c:	e8 7f d6 ff ff       	call   119ac0 <lv_utils_bsearch>
  11c441:	89 45 dc             	mov    %eax,-0x24(%ebp)

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
  11c444:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  11c448:	0f 84 23 00 00 00    	je     11c471 <get_kern_value+0xd1>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
  11c44e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11c451:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  11c454:	29 c8                	sub    %ecx,%eax
  11c456:	89 45 d8             	mov    %eax,-0x28(%ebp)
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
  11c459:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11c45c:	c1 e8 01             	shr    $0x1,%eax
  11c45f:	89 45 d8             	mov    %eax,-0x28(%ebp)
                value = kdsc->values[ofs];
  11c462:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c465:	8b 40 04             	mov    0x4(%eax),%eax
  11c468:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  11c46b:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11c46e:	88 55 ef             	mov    %dl,-0x11(%ebp)
            }
        } else if(kdsc->glyph_ids_size == 1) {
  11c471:	e9 9c 00 00 00       	jmp    11c512 <get_kern_value+0x172>
  11c476:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c479:	8b 40 08             	mov    0x8(%eax),%eax
  11c47c:	c1 e8 18             	shr    $0x18,%eax
  11c47f:	83 e0 03             	and    $0x3,%eax
  11c482:	83 f8 01             	cmp    $0x1,%eax
  11c485:	0f 85 7d 00 00 00    	jne    11c508 <get_kern_value+0x168>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint16_t * g_ids = kdsc->glyph_ids;
  11c48b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c48e:	8b 00                	mov    (%eax),%eax
  11c490:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            uint32_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
  11c493:	8b 45 10             	mov    0x10(%ebp),%eax
  11c496:	c1 e0 08             	shl    $0x8,%eax
  11c499:	03 45 0c             	add    0xc(%ebp),%eax
  11c49c:	89 45 d0             	mov    %eax,-0x30(%ebp)
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
  11c49f:	8d 45 d0             	lea    -0x30(%ebp),%eax
  11c4a2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  11c4a5:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11c4a8:	8b 52 08             	mov    0x8(%edx),%edx
  11c4ab:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
  11c4b1:	89 04 24             	mov    %eax,(%esp)
  11c4b4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c4b8:	89 54 24 08          	mov    %edx,0x8(%esp)
  11c4bc:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  11c4c3:	00 
  11c4c4:	8d 05 20 c6 11 00    	lea    0x11c620,%eax
  11c4ca:	89 44 24 10          	mov    %eax,0x10(%esp)
  11c4ce:	e8 ed d5 ff ff       	call   119ac0 <lv_utils_bsearch>
  11c4d3:	89 45 cc             	mov    %eax,-0x34(%ebp)

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
  11c4d6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  11c4da:	0f 84 23 00 00 00    	je     11c503 <get_kern_value+0x163>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
  11c4e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  11c4e3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  11c4e6:	29 c8                	sub    %ecx,%eax
  11c4e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
  11c4eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
  11c4ee:	c1 e8 04             	shr    $0x4,%eax
  11c4f1:	89 45 c8             	mov    %eax,-0x38(%ebp)
                value = kdsc->values[ofs];
  11c4f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11c4f7:	8b 40 04             	mov    0x4(%eax),%eax
  11c4fa:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  11c4fd:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11c500:	88 55 ef             	mov    %dl,-0x11(%ebp)
            }

        } else {
  11c503:	e9 05 00 00 00       	jmp    11c50d <get_kern_value+0x16d>
  11c508:	e9 00 00 00 00       	jmp    11c50d <get_kern_value+0x16d>
  11c50d:	e9 00 00 00 00       	jmp    11c512 <get_kern_value+0x172>
            /*Invalid value*/
        }
    } else {
  11c512:	e9 6b 00 00 00       	jmp    11c582 <get_kern_value+0x1e2>
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
  11c517:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11c51a:	8b 40 0c             	mov    0xc(%eax),%eax
  11c51d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
  11c520:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11c523:	8b 40 04             	mov    0x4(%eax),%eax
  11c526:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11c529:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11c52c:	88 55 c3             	mov    %dl,-0x3d(%ebp)
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
  11c52f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11c532:	8b 40 04             	mov    0x4(%eax),%eax
  11c535:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11c538:	8a 14 08             	mov    (%eax,%ecx,1),%dl
  11c53b:	88 55 c2             	mov    %dl,-0x3e(%ebp)

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
  11c53e:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
  11c542:	83 f8 00             	cmp    $0x0,%eax
  11c545:	0f 8e 32 00 00 00    	jle    11c57d <get_kern_value+0x1dd>
  11c54b:	0f b6 45 c2          	movzbl -0x3e(%ebp),%eax
  11c54f:	83 f8 00             	cmp    $0x0,%eax
  11c552:	0f 8e 25 00 00 00    	jle    11c57d <get_kern_value+0x1dd>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
  11c558:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11c55b:	8b 00                	mov    (%eax),%eax
  11c55d:	0f b6 4d c3          	movzbl -0x3d(%ebp),%ecx
  11c561:	83 e9 01             	sub    $0x1,%ecx
  11c564:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  11c567:	0f b6 52 0d          	movzbl 0xd(%edx),%edx
  11c56b:	0f af ca             	imul   %edx,%ecx
  11c56e:	0f b6 55 c2          	movzbl -0x3e(%ebp),%edx
  11c572:	83 ea 01             	sub    $0x1,%edx
  11c575:	01 d1                	add    %edx,%ecx
  11c577:	8a 1c 08             	mov    (%eax,%ecx,1),%bl
  11c57a:	88 5d ef             	mov    %bl,-0x11(%ebp)
  11c57d:	e9 00 00 00 00       	jmp    11c582 <get_kern_value+0x1e2>
        }

    }
    return value;
  11c582:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  11c586:	83 c4 48             	add    $0x48,%esp
  11c589:	5e                   	pop    %esi
  11c58a:	5f                   	pop    %edi
  11c58b:	5b                   	pop    %ebx
  11c58c:	5d                   	pop    %ebp
  11c58d:	c3                   	ret    
  11c58e:	66 90                	xchg   %ax,%ax

0011c590 <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
  11c590:	55                   	push   %ebp
  11c591:	89 e5                	mov    %esp,%ebp
  11c593:	56                   	push   %esi
  11c594:	50                   	push   %eax
  11c595:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c598:	8b 4d 08             	mov    0x8(%ebp),%ecx
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
  11c59b:	8b 55 08             	mov    0x8(%ebp),%edx
  11c59e:	0f b7 12             	movzwl (%edx),%edx
  11c5a1:	8b 75 0c             	mov    0xc(%ebp),%esi
  11c5a4:	0f b7 36             	movzwl (%esi),%esi
  11c5a7:	29 f2                	sub    %esi,%edx
  11c5a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c5ac:	89 d0                	mov    %edx,%eax
  11c5ae:	83 c4 04             	add    $0x4,%esp
  11c5b1:	5e                   	pop    %esi
  11c5b2:	5d                   	pop    %ebp
  11c5b3:	c3                   	ret    
  11c5b4:	66 90                	xchg   %ax,%ax
  11c5b6:	66 90                	xchg   %ax,%ax
  11c5b8:	66 90                	xchg   %ax,%ax
  11c5ba:	66 90                	xchg   %ax,%ax
  11c5bc:	66 90                	xchg   %ax,%ax
  11c5be:	66 90                	xchg   %ax,%ax

0011c5c0 <kern_pair_8_compare>:
{
  11c5c0:	55                   	push   %ebp
  11c5c1:	89 e5                	mov    %esp,%ebp
  11c5c3:	56                   	push   %esi
  11c5c4:	83 ec 0c             	sub    $0xc,%esp
  11c5c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c5ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
    const uint8_t * ref8_p = ref;
  11c5cd:	8b 55 08             	mov    0x8(%ebp),%edx
  11c5d0:	89 55 f4             	mov    %edx,-0xc(%ebp)
    const uint8_t * element8_p = element;
  11c5d3:	8b 55 0c             	mov    0xc(%ebp),%edx
  11c5d6:	89 55 f0             	mov    %edx,-0x10(%ebp)
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
  11c5d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11c5dc:	0f b6 12             	movzbl (%edx),%edx
  11c5df:	8b 75 f0             	mov    -0x10(%ebp),%esi
  11c5e2:	0f b6 36             	movzbl (%esi),%esi
  11c5e5:	39 f2                	cmp    %esi,%edx
  11c5e7:	0f 84 16 00 00 00    	je     11c603 <kern_pair_8_compare+0x43>
  11c5ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c5f0:	0f b6 00             	movzbl (%eax),%eax
  11c5f3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11c5f6:	0f b6 09             	movzbl (%ecx),%ecx
  11c5f9:	29 c8                	sub    %ecx,%eax
  11c5fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c5fe:	e9 13 00 00 00       	jmp    11c616 <kern_pair_8_compare+0x56>
    else return (int32_t) ref8_p[1] - element8_p[1];
  11c603:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c606:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  11c60a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11c60d:	0f b6 49 01          	movzbl 0x1(%ecx),%ecx
  11c611:	29 c8                	sub    %ecx,%eax
  11c613:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  11c616:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c619:	83 c4 0c             	add    $0xc,%esp
  11c61c:	5e                   	pop    %esi
  11c61d:	5d                   	pop    %ebp
  11c61e:	c3                   	ret    
  11c61f:	90                   	nop

0011c620 <kern_pair_16_compare>:
{
  11c620:	55                   	push   %ebp
  11c621:	89 e5                	mov    %esp,%ebp
  11c623:	56                   	push   %esi
  11c624:	83 ec 0c             	sub    $0xc,%esp
  11c627:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c62a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    const uint16_t * ref16_p = ref;
  11c62d:	8b 55 08             	mov    0x8(%ebp),%edx
  11c630:	89 55 f4             	mov    %edx,-0xc(%ebp)
    const uint16_t * element16_p = element;
  11c633:	8b 55 0c             	mov    0xc(%ebp),%edx
  11c636:	89 55 f0             	mov    %edx,-0x10(%ebp)
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
  11c639:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11c63c:	0f b7 12             	movzwl (%edx),%edx
  11c63f:	8b 75 f0             	mov    -0x10(%ebp),%esi
  11c642:	0f b7 36             	movzwl (%esi),%esi
  11c645:	39 f2                	cmp    %esi,%edx
  11c647:	0f 84 16 00 00 00    	je     11c663 <kern_pair_16_compare+0x43>
  11c64d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c650:	0f b7 00             	movzwl (%eax),%eax
  11c653:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11c656:	0f b7 09             	movzwl (%ecx),%ecx
  11c659:	29 c8                	sub    %ecx,%eax
  11c65b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c65e:	e9 13 00 00 00       	jmp    11c676 <kern_pair_16_compare+0x56>
    else return (int32_t) ref16_p[1] - element16_p[1];
  11c663:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c666:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  11c66a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11c66d:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  11c671:	29 c8                	sub    %ecx,%eax
  11c673:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  11c676:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c679:	83 c4 0c             	add    $0xc,%esp
  11c67c:	5e                   	pop    %esi
  11c67d:	5d                   	pop    %ebp
  11c67e:	c3                   	ret    
  11c67f:	90                   	nop

0011c680 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
  11c680:	55                   	push   %ebp
  11c681:	89 e5                	mov    %esp,%ebp
  11c683:	83 ec 10             	sub    $0x10,%esp
  11c686:	8b 45 08             	mov    0x8(%ebp),%eax
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
  11c689:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c68c:	8b 0c 8d 90 33 14 00 	mov    0x143390(,%ecx,4),%ecx
  11c693:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  11c696:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c699:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c69c:	3b 04 8d 94 33 14 00 	cmp    0x143394(,%ecx,4),%eax
  11c6a3:	0f 83 50 00 00 00    	jae    11c6f9 <z_sys_device_do_config_level+0x79>
								info++) {
		int retval;
		struct device_config *device_conf = info->config;
  11c6a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c6ac:	8b 00                	mov    (%eax),%eax
  11c6ae:	89 45 f4             	mov    %eax,-0xc(%ebp)

		retval = device_conf->init(info);
  11c6b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11c6b4:	8b 40 04             	mov    0x4(%eax),%eax
  11c6b7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11c6ba:	89 0c 24             	mov    %ecx,(%esp)
  11c6bd:	ff d0                	call   *%eax
  11c6bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if (retval != 0) {
  11c6c2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  11c6c6:	0f 84 0f 00 00 00    	je     11c6db <z_sys_device_do_config_level+0x5b>
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
  11c6cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c6cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		} else {
  11c6d6:	e9 0b 00 00 00       	jmp    11c6e6 <z_sys_device_do_config_level+0x66>
			z_object_init(info);
  11c6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c6de:	89 04 24             	mov    %eax,(%esp)
  11c6e1:	e8 1a 00 00 00       	call   11c700 <z_object_init>
		}
	}
  11c6e6:	e9 00 00 00 00       	jmp    11c6eb <z_sys_device_do_config_level+0x6b>
								info++) {
  11c6eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c6ee:	83 c0 0c             	add    $0xc,%eax
  11c6f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (info = config_levels[level]; info < config_levels[level+1];
  11c6f4:	e9 9d ff ff ff       	jmp    11c696 <z_sys_device_do_config_level+0x16>
}
  11c6f9:	83 c4 10             	add    $0x10,%esp
  11c6fc:	5d                   	pop    %ebp
  11c6fd:	c3                   	ret    
  11c6fe:	66 90                	xchg   %ax,%ax

0011c700 <z_object_init>:
{
  11c700:	55                   	push   %ebp
  11c701:	89 e5                	mov    %esp,%ebp
  11c703:	8b 45 08             	mov    0x8(%ebp),%eax
}
  11c706:	5d                   	pop    %ebp
  11c707:	c3                   	ret    
  11c708:	66 90                	xchg   %ax,%ax
  11c70a:	66 90                	xchg   %ax,%ax
  11c70c:	66 90                	xchg   %ax,%ax
  11c70e:	66 90                	xchg   %ax,%ax

0011c710 <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
  11c710:	55                   	push   %ebp
  11c711:	89 e5                	mov    %esp,%ebp
  11c713:	83 ec 10             	sub    $0x10,%esp
  11c716:	8b 45 08             	mov    0x8(%ebp),%eax
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
  11c719:	8d 0d b4 33 14 00    	lea    0x1433b4,%ecx
  11c71f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11c722:	8d 05 38 34 14 00    	lea    0x143438,%eax
  11c728:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  11c72b:	0f 84 3b 00 00 00    	je     11c76c <z_impl_device_get_binding+0x5c>
		if ((info->driver_api != NULL) &&
  11c731:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c734:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11c738:	0f 84 1b 00 00 00    	je     11c759 <z_impl_device_get_binding+0x49>
		    (info->config->name == name)) {
  11c73e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c741:	8b 00                	mov    (%eax),%eax
  11c743:	8b 00                	mov    (%eax),%eax
  11c745:	3b 45 08             	cmp    0x8(%ebp),%eax
		if ((info->driver_api != NULL) &&
  11c748:	0f 85 0b 00 00 00    	jne    11c759 <z_impl_device_get_binding+0x49>
			return info;
  11c74e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c751:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11c754:	e9 81 00 00 00       	jmp    11c7da <z_impl_device_get_binding+0xca>
		}
	}
  11c759:	e9 00 00 00 00       	jmp    11c75e <z_impl_device_get_binding+0x4e>
	for (info = __device_init_start; info != __device_init_end; info++) {
  11c75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c761:	83 c0 0c             	add    $0xc,%eax
  11c764:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c767:	e9 b6 ff ff ff       	jmp    11c722 <z_impl_device_get_binding+0x12>

	for (info = __device_init_start; info != __device_init_end; info++) {
  11c76c:	8d 05 b4 33 14 00    	lea    0x1433b4,%eax
  11c772:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c775:	8d 05 38 34 14 00    	lea    0x143438,%eax
  11c77b:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  11c77e:	0f 84 4f 00 00 00    	je     11c7d3 <z_impl_device_get_binding+0xc3>
		if (info->driver_api == NULL) {
  11c784:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c787:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  11c78b:	0f 85 05 00 00 00    	jne    11c796 <z_impl_device_get_binding+0x86>
			continue;
  11c791:	e9 2f 00 00 00       	jmp    11c7c5 <z_impl_device_get_binding+0xb5>
		}

		if (strcmp(name, info->config->name) == 0) {
  11c796:	8b 45 08             	mov    0x8(%ebp),%eax
  11c799:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11c79c:	8b 09                	mov    (%ecx),%ecx
  11c79e:	8b 09                	mov    (%ecx),%ecx
  11c7a0:	89 04 24             	mov    %eax,(%esp)
  11c7a3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c7a7:	e8 34 db fe ff       	call   10a2e0 <strcmp>
  11c7ac:	83 f8 00             	cmp    $0x0,%eax
  11c7af:	0f 85 0b 00 00 00    	jne    11c7c0 <z_impl_device_get_binding+0xb0>
			return info;
  11c7b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c7b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11c7bb:	e9 1a 00 00 00       	jmp    11c7da <z_impl_device_get_binding+0xca>
		}
	}
  11c7c0:	e9 00 00 00 00       	jmp    11c7c5 <z_impl_device_get_binding+0xb5>
	for (info = __device_init_start; info != __device_init_end; info++) {
  11c7c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11c7c8:	83 c0 0c             	add    $0xc,%eax
  11c7cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11c7ce:	e9 a2 ff ff ff       	jmp    11c775 <z_impl_device_get_binding+0x65>

	return NULL;
  11c7d3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  11c7da:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11c7dd:	83 c4 10             	add    $0x10,%esp
  11c7e0:	5d                   	pop    %ebp
  11c7e1:	c3                   	ret    
  11c7e2:	66 90                	xchg   %ax,%ax
  11c7e4:	66 90                	xchg   %ax,%ax
  11c7e6:	66 90                	xchg   %ax,%ax
  11c7e8:	66 90                	xchg   %ax,%ax
  11c7ea:	66 90                	xchg   %ax,%ax
  11c7ec:	66 90                	xchg   %ax,%ax
  11c7ee:	66 90                	xchg   %ax,%ax

0011c7f0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  11c7f0:	55                   	push   %ebp
  11c7f1:	89 e5                	mov    %esp,%ebp
  11c7f3:	83 e4 f8             	and    $0xfffffff8,%esp
  11c7f6:	83 ec 18             	sub    $0x18,%esp
  11c7f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c7fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c7ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11c803:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	ARG_UNUSED(esf);

	LOG_PANIC();
  11c807:	e8 d4 00 00 00       	call   11c8e0 <log_panic>
	LOG_ERR("Halting system");
  11c80c:	e8 df 00 00 00       	call   11c8f0 <_is_user_context>
  11c811:	24 01                	and    $0x1,%al
  11c813:	88 44 24 17          	mov    %al,0x17(%esp)
  11c817:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  11c81c:	0f 85 0f 00 00 00    	jne    11c831 <k_sys_fatal_error_handler+0x41>
  11c822:	b0 01                	mov    $0x1,%al
  11c824:	a8 01                	test   $0x1,%al
  11c826:	0f 85 05 00 00 00    	jne    11c831 <k_sys_fatal_error_handler+0x41>
  11c82c:	e9 95 00 00 00       	jmp    11c8c6 <k_sys_fatal_error_handler+0xd6>
  11c831:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  11c836:	66 83 e0 f8          	and    $0xfff8,%ax
  11c83a:	66 83 c8 01          	or     $0x1,%ax
  11c83e:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  11c843:	66 8b 44 24 10       	mov    0x10(%esp),%ax
  11c848:	66 83 e0 c7          	and    $0xffc7,%ax
  11c84c:	66 89 44 24 10       	mov    %ax,0x10(%esp)
  11c851:	8b 0d a4 33 14 00    	mov    0x1433a4,%ecx
  11c857:	89 0c 24             	mov    %ecx,(%esp)
  11c85a:	e8 a1 00 00 00       	call   11c900 <log_const_source_id>
  11c85f:	66 8b 54 24 10       	mov    0x10(%esp),%dx
  11c864:	66 25 ff 03          	and    $0x3ff,%ax
  11c868:	66 c1 e0 06          	shl    $0x6,%ax
  11c86c:	66 83 e2 3f          	and    $0x3f,%dx
  11c870:	66 09 c2             	or     %ax,%dx
  11c873:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  11c878:	f6 44 24 17 01       	testb  $0x1,0x17(%esp)
  11c87d:	0f 84 1f 00 00 00    	je     11c8a2 <k_sys_fatal_error_handler+0xb2>
  11c883:	8d 44 24 10          	lea    0x10(%esp),%eax
  11c887:	66 8b 08             	mov    (%eax),%cx
  11c88a:	66 89 0c 24          	mov    %cx,(%esp)
  11c88e:	8d 05 38 48 12 00    	lea    0x124838,%eax
  11c894:	89 44 24 04          	mov    %eax,0x4(%esp)
  11c898:	e8 a3 77 fe ff       	call   104040 <log_from_user>
  11c89d:	e9 1a 00 00 00       	jmp    11c8bc <k_sys_fatal_error_handler+0xcc>
  11c8a2:	8d 05 38 48 12 00    	lea    0x124838,%eax
  11c8a8:	89 04 24             	mov    %eax,(%esp)
  11c8ab:	8d 44 24 10          	lea    0x10(%esp),%eax
  11c8af:	66 8b 08             	mov    (%eax),%cx
  11c8b2:	66 89 4c 24 04       	mov    %cx,0x4(%esp)
  11c8b7:	e8 e4 68 fe ff       	call   1031a0 <log_0>
  11c8bc:	e9 00 00 00 00       	jmp    11c8c1 <k_sys_fatal_error_handler+0xd1>
  11c8c1:	e9 00 00 00 00       	jmp    11c8c6 <k_sys_fatal_error_handler+0xd6>
  11c8c6:	e9 00 00 00 00       	jmp    11c8cb <k_sys_fatal_error_handler+0xdb>
	arch_system_halt(reason);
  11c8cb:	8b 45 08             	mov    0x8(%ebp),%eax
  11c8ce:	89 04 24             	mov    %eax,(%esp)
  11c8d1:	e8 1a d1 fe ff       	call   1099f0 <arch_system_halt>
  11c8d6:	66 90                	xchg   %ax,%ax
  11c8d8:	66 90                	xchg   %ax,%ax
  11c8da:	66 90                	xchg   %ax,%ax
  11c8dc:	66 90                	xchg   %ax,%ax
  11c8de:	66 90                	xchg   %ax,%ax

0011c8e0 <log_panic>:
{
  11c8e0:	55                   	push   %ebp
  11c8e1:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  11c8e3:	e9 00 00 00 00       	jmp    11c8e8 <log_panic+0x8>
	z_impl_log_panic();
  11c8e8:	e8 53 70 fe ff       	call   103940 <z_impl_log_panic>
}
  11c8ed:	5d                   	pop    %ebp
  11c8ee:	c3                   	ret    
  11c8ef:	90                   	nop

0011c8f0 <_is_user_context>:
{
  11c8f0:	55                   	push   %ebp
  11c8f1:	89 e5                	mov    %esp,%ebp
  11c8f3:	31 c0                	xor    %eax,%eax
	return false;
  11c8f5:	24 01                	and    $0x1,%al
  11c8f7:	0f b6 c0             	movzbl %al,%eax
  11c8fa:	5d                   	pop    %ebp
  11c8fb:	c3                   	ret    
  11c8fc:	66 90                	xchg   %ax,%ax
  11c8fe:	66 90                	xchg   %ax,%ax

0011c900 <log_const_source_id>:
{
  11c900:	55                   	push   %ebp
  11c901:	89 e5                	mov    %esp,%ebp
  11c903:	50                   	push   %eax
  11c904:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  11c907:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c90a:	8d 15 84 30 12 00    	lea    0x123084,%edx
  11c910:	29 d1                	sub    %edx,%ecx
  11c912:	c1 e9 03             	shr    $0x3,%ecx
  11c915:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11c918:	89 c8                	mov    %ecx,%eax
  11c91a:	83 c4 04             	add    $0x4,%esp
  11c91d:	5d                   	pop    %ebp
  11c91e:	c3                   	ret    
  11c91f:	90                   	nop

0011c920 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  11c920:	55                   	push   %ebp
  11c921:	89 e5                	mov    %esp,%ebp
  11c923:	83 e4 f8             	and    $0xfffffff8,%esp
  11c926:	83 ec 48             	sub    $0x48,%esp
  11c929:	8b 45 0c             	mov    0xc(%ebp),%eax
  11c92c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c92f:	89 44 24 34          	mov    %eax,0x34(%esp)
  11c933:	89 4c 24 30          	mov    %ecx,0x30(%esp)
	struct k_thread *thread = k_current_get();
  11c937:	e8 64 02 00 00       	call   11cba0 <k_current_get>
  11c93c:	89 44 24 44          	mov    %eax,0x44(%esp)

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  11c940:	e8 ab ff ff ff       	call   11c8f0 <_is_user_context>
  11c945:	24 01                	and    $0x1,%al
  11c947:	88 44 24 43          	mov    %al,0x43(%esp)
  11c94b:	f6 44 24 43 01       	testb  $0x1,0x43(%esp)
  11c950:	0f 85 0f 00 00 00    	jne    11c965 <z_fatal_error+0x45>
  11c956:	b0 01                	mov    $0x1,%al
  11c958:	a8 01                	test   $0x1,%al
  11c95a:	0f 85 05 00 00 00    	jne    11c965 <z_fatal_error+0x45>
  11c960:	e9 f3 00 00 00       	jmp    11ca58 <z_fatal_error+0x138>
  11c965:	66 8b 44 24 40       	mov    0x40(%esp),%ax
  11c96a:	66 83 e0 f8          	and    $0xfff8,%ax
  11c96e:	66 83 c8 01          	or     $0x1,%ax
  11c972:	66 89 44 24 40       	mov    %ax,0x40(%esp)
  11c977:	66 8b 44 24 40       	mov    0x40(%esp),%ax
  11c97c:	66 83 e0 c7          	and    $0xffc7,%ax
  11c980:	66 89 44 24 40       	mov    %ax,0x40(%esp)
  11c985:	8b 0d a4 33 14 00    	mov    0x1433a4,%ecx
  11c98b:	89 0c 24             	mov    %ecx,(%esp)
  11c98e:	e8 6d ff ff ff       	call   11c900 <log_const_source_id>
  11c993:	66 8b 54 24 40       	mov    0x40(%esp),%dx
  11c998:	66 25 ff 03          	and    $0x3ff,%ax
  11c99c:	66 c1 e0 06          	shl    $0x6,%ax
  11c9a0:	66 83 e2 3f          	and    $0x3f,%dx
  11c9a4:	66 09 c2             	or     %ax,%dx
  11c9a7:	66 89 54 24 40       	mov    %dx,0x40(%esp)
  11c9ac:	f6 44 24 43 01       	testb  $0x1,0x43(%esp)
  11c9b1:	0f 84 4e 00 00 00    	je     11ca05 <z_fatal_error+0xe5>
  11c9b7:	8b 45 08             	mov    0x8(%ebp),%eax
  11c9ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11c9bd:	89 0c 24             	mov    %ecx,(%esp)
  11c9c0:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11c9c4:	e8 e7 01 00 00       	call   11cbb0 <reason_to_str>
  11c9c9:	89 44 24 28          	mov    %eax,0x28(%esp)
  11c9cd:	e8 5e 02 00 00       	call   11cc30 <get_cpu>
  11c9d2:	8d 4c 24 40          	lea    0x40(%esp),%ecx
  11c9d6:	66 8b 11             	mov    (%ecx),%dx
  11c9d9:	66 89 14 24          	mov    %dx,(%esp)
  11c9dd:	8d 0d 47 48 12 00    	lea    0x124847,%ecx
  11c9e3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11c9e7:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  11c9eb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11c9ef:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  11c9f3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11c9f7:	89 44 24 10          	mov    %eax,0x10(%esp)
  11c9fb:	e8 40 76 fe ff       	call   104040 <log_from_user>
  11ca00:	e9 49 00 00 00       	jmp    11ca4e <z_fatal_error+0x12e>
  11ca05:	8b 45 08             	mov    0x8(%ebp),%eax
  11ca08:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ca0b:	89 0c 24             	mov    %ecx,(%esp)
  11ca0e:	89 44 24 24          	mov    %eax,0x24(%esp)
  11ca12:	e8 99 01 00 00       	call   11cbb0 <reason_to_str>
  11ca17:	89 44 24 20          	mov    %eax,0x20(%esp)
  11ca1b:	e8 10 02 00 00       	call   11cc30 <get_cpu>
  11ca20:	8d 0d 47 48 12 00    	lea    0x124847,%ecx
  11ca26:	89 0c 24             	mov    %ecx,(%esp)
  11ca29:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  11ca2d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11ca31:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  11ca35:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11ca39:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11ca3d:	8d 44 24 40          	lea    0x40(%esp),%eax
  11ca41:	66 8b 10             	mov    (%eax),%dx
  11ca44:	66 89 54 24 10       	mov    %dx,0x10(%esp)
  11ca49:	e8 b2 6a fe ff       	call   103500 <log_3>
  11ca4e:	e9 00 00 00 00       	jmp    11ca53 <z_fatal_error+0x133>
  11ca53:	e9 00 00 00 00       	jmp    11ca58 <z_fatal_error+0x138>
  11ca58:	e9 00 00 00 00       	jmp    11ca5d <z_fatal_error+0x13d>
	if (arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  11ca5d:	e9 00 00 00 00       	jmp    11ca62 <z_fatal_error+0x142>
  11ca62:	e8 89 fe ff ff       	call   11c8f0 <_is_user_context>
  11ca67:	24 01                	and    $0x1,%al
  11ca69:	88 44 24 3f          	mov    %al,0x3f(%esp)
  11ca6d:	f6 44 24 3f 01       	testb  $0x1,0x3f(%esp)
  11ca72:	0f 85 0f 00 00 00    	jne    11ca87 <z_fatal_error+0x167>
  11ca78:	b0 01                	mov    $0x1,%al
  11ca7a:	a8 01                	test   $0x1,%al
  11ca7c:	0f 85 05 00 00 00    	jne    11ca87 <z_fatal_error+0x167>
  11ca82:	e9 e5 00 00 00       	jmp    11cb6c <z_fatal_error+0x24c>
  11ca87:	66 8b 44 24 38       	mov    0x38(%esp),%ax
  11ca8c:	66 83 e0 f8          	and    $0xfff8,%ax
  11ca90:	66 83 c8 01          	or     $0x1,%ax
  11ca94:	66 89 44 24 38       	mov    %ax,0x38(%esp)
  11ca99:	66 8b 44 24 38       	mov    0x38(%esp),%ax
  11ca9e:	66 83 e0 c7          	and    $0xffc7,%ax
  11caa2:	66 89 44 24 38       	mov    %ax,0x38(%esp)
  11caa7:	8b 0d a4 33 14 00    	mov    0x1433a4,%ecx
  11caad:	89 0c 24             	mov    %ecx,(%esp)
  11cab0:	e8 4b fe ff ff       	call   11c900 <log_const_source_id>
  11cab5:	66 8b 54 24 38       	mov    0x38(%esp),%dx
  11caba:	66 25 ff 03          	and    $0x3ff,%ax
  11cabe:	66 c1 e0 06          	shl    $0x6,%ax
  11cac2:	66 83 e2 3f          	and    $0x3f,%dx
  11cac6:	66 09 c2             	or     %ax,%dx
  11cac9:	66 89 54 24 38       	mov    %dx,0x38(%esp)
  11cace:	f6 44 24 3f 01       	testb  $0x1,0x3f(%esp)
  11cad3:	0f 84 47 00 00 00    	je     11cb20 <z_fatal_error+0x200>
  11cad9:	8b 44 24 44          	mov    0x44(%esp),%eax
  11cadd:	8b 4c 24 44          	mov    0x44(%esp),%ecx
  11cae1:	89 0c 24             	mov    %ecx,(%esp)
  11cae4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11cae8:	e8 53 01 00 00       	call   11cc40 <thread_name_get>
  11caed:	89 04 24             	mov    %eax,(%esp)
  11caf0:	e8 8b 73 fe ff       	call   103e80 <log_strdup>
  11caf5:	8d 4c 24 38          	lea    0x38(%esp),%ecx
  11caf9:	66 8b 11             	mov    (%ecx),%dx
  11cafc:	66 89 14 24          	mov    %dx,(%esp)
  11cb00:	8d 0d 6f 48 12 00    	lea    0x12486f,%ecx
  11cb06:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11cb0a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11cb0e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  11cb12:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11cb16:	e8 25 75 fe ff       	call   104040 <log_from_user>
  11cb1b:	e9 42 00 00 00       	jmp    11cb62 <z_fatal_error+0x242>
  11cb20:	8b 44 24 44          	mov    0x44(%esp),%eax
  11cb24:	8b 4c 24 44          	mov    0x44(%esp),%ecx
  11cb28:	89 0c 24             	mov    %ecx,(%esp)
  11cb2b:	89 44 24 18          	mov    %eax,0x18(%esp)
  11cb2f:	e8 0c 01 00 00       	call   11cc40 <thread_name_get>
  11cb34:	89 04 24             	mov    %eax,(%esp)
  11cb37:	e8 44 73 fe ff       	call   103e80 <log_strdup>
  11cb3c:	8d 0d 6f 48 12 00    	lea    0x12486f,%ecx
  11cb42:	89 0c 24             	mov    %ecx,(%esp)
  11cb45:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  11cb49:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11cb4d:	89 44 24 08          	mov    %eax,0x8(%esp)
  11cb51:	8d 44 24 38          	lea    0x38(%esp),%eax
  11cb55:	66 8b 10             	mov    (%eax),%dx
  11cb58:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
  11cb5d:	e8 be 68 fe ff       	call   103420 <log_2>
  11cb62:	e9 00 00 00 00       	jmp    11cb67 <z_fatal_error+0x247>
  11cb67:	e9 00 00 00 00       	jmp    11cb6c <z_fatal_error+0x24c>
  11cb6c:	e9 00 00 00 00       	jmp    11cb71 <z_fatal_error+0x251>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
  11cb71:	8b 45 08             	mov    0x8(%ebp),%eax
  11cb74:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11cb77:	89 04 24             	mov    %eax,(%esp)
  11cb7a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11cb7e:	e8 6d fc ff ff       	call   11c7f0 <k_sys_fatal_error_handler>
#endif /* CONFIG_STACK_SENTINEL */
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
  11cb83:	8b 44 24 44          	mov    0x44(%esp),%eax
  11cb87:	89 04 24             	mov    %eax,(%esp)
  11cb8a:	e8 01 01 00 00       	call   11cc90 <k_thread_abort>
}
  11cb8f:	89 ec                	mov    %ebp,%esp
  11cb91:	5d                   	pop    %ebp
  11cb92:	c3                   	ret    
  11cb93:	66 90                	xchg   %ax,%ax
  11cb95:	66 90                	xchg   %ax,%ax
  11cb97:	66 90                	xchg   %ax,%ax
  11cb99:	66 90                	xchg   %ax,%ax
  11cb9b:	66 90                	xchg   %ax,%ax
  11cb9d:	66 90                	xchg   %ax,%ax
  11cb9f:	90                   	nop

0011cba0 <k_current_get>:
{
  11cba0:	55                   	push   %ebp
  11cba1:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  11cba3:	e9 00 00 00 00       	jmp    11cba8 <k_current_get+0x8>
	return z_impl_k_current_get();
  11cba8:	e8 43 30 00 00       	call   11fbf0 <z_impl_k_current_get>
  11cbad:	5d                   	pop    %ebp
  11cbae:	c3                   	ret    
  11cbaf:	90                   	nop

0011cbb0 <reason_to_str>:
{
  11cbb0:	55                   	push   %ebp
  11cbb1:	89 e5                	mov    %esp,%ebp
  11cbb3:	83 ec 08             	sub    $0x8,%esp
  11cbb6:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (reason) {
  11cbb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cbbc:	89 ca                	mov    %ecx,%edx
  11cbbe:	83 ea 04             	sub    $0x4,%edx
  11cbc1:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11cbc4:	0f 87 52 00 00 00    	ja     11cc1c <reason_to_str+0x6c>
  11cbca:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11cbcd:	8b 0c 85 a8 36 12 00 	mov    0x1236a8(,%eax,4),%ecx
  11cbd4:	ff e1                	jmp    *%ecx
		return "CPU exception";
  11cbd6:	8d 05 87 48 12 00    	lea    0x124887,%eax
  11cbdc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11cbdf:	e9 41 00 00 00       	jmp    11cc25 <reason_to_str+0x75>
		return "Unhandled interrupt";
  11cbe4:	8d 05 95 48 12 00    	lea    0x124895,%eax
  11cbea:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11cbed:	e9 33 00 00 00       	jmp    11cc25 <reason_to_str+0x75>
		return "Stack overflow";
  11cbf2:	8d 05 a9 48 12 00    	lea    0x1248a9,%eax
  11cbf8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11cbfb:	e9 25 00 00 00       	jmp    11cc25 <reason_to_str+0x75>
		return "Kernel oops";
  11cc00:	8d 05 b8 48 12 00    	lea    0x1248b8,%eax
  11cc06:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11cc09:	e9 17 00 00 00       	jmp    11cc25 <reason_to_str+0x75>
		return "Kernel panic";
  11cc0e:	8d 05 c4 48 12 00    	lea    0x1248c4,%eax
  11cc14:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11cc17:	e9 09 00 00 00       	jmp    11cc25 <reason_to_str+0x75>
		return "Unknown error";
  11cc1c:	8d 05 d1 48 12 00    	lea    0x1248d1,%eax
  11cc22:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  11cc25:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11cc28:	83 c4 08             	add    $0x8,%esp
  11cc2b:	5d                   	pop    %ebp
  11cc2c:	c3                   	ret    
  11cc2d:	66 90                	xchg   %ax,%ax
  11cc2f:	90                   	nop

0011cc30 <get_cpu>:
{
  11cc30:	55                   	push   %ebp
  11cc31:	89 e5                	mov    %esp,%ebp
  11cc33:	31 c0                	xor    %eax,%eax
	return 0;
  11cc35:	5d                   	pop    %ebp
  11cc36:	c3                   	ret    
  11cc37:	66 90                	xchg   %ax,%ax
  11cc39:	66 90                	xchg   %ax,%ax
  11cc3b:	66 90                	xchg   %ax,%ax
  11cc3d:	66 90                	xchg   %ax,%ax
  11cc3f:	90                   	nop

0011cc40 <thread_name_get>:
{
  11cc40:	55                   	push   %ebp
  11cc41:	89 e5                	mov    %esp,%ebp
  11cc43:	83 ec 0c             	sub    $0xc,%esp
  11cc46:	8b 45 08             	mov    0x8(%ebp),%eax
	const char *thread_name = k_thread_name_get(thread);
  11cc49:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cc4c:	89 0c 24             	mov    %ecx,(%esp)
  11cc4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11cc52:	e8 79 36 00 00       	call   1202d0 <k_thread_name_get>
  11cc57:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (thread_name == NULL || thread_name[0] == '\0') {
  11cc5a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  11cc5e:	0f 84 0f 00 00 00    	je     11cc73 <thread_name_get+0x33>
  11cc64:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11cc67:	0f be 00             	movsbl (%eax),%eax
  11cc6a:	83 f8 00             	cmp    $0x0,%eax
  11cc6d:	0f 85 09 00 00 00    	jne    11cc7c <thread_name_get+0x3c>
		thread_name = "unknown";
  11cc73:	8d 05 df 48 12 00    	lea    0x1248df,%eax
  11cc79:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return thread_name;
  11cc7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11cc7f:	83 c4 0c             	add    $0xc,%esp
  11cc82:	5d                   	pop    %ebp
  11cc83:	c3                   	ret    
  11cc84:	66 90                	xchg   %ax,%ax
  11cc86:	66 90                	xchg   %ax,%ax
  11cc88:	66 90                	xchg   %ax,%ax
  11cc8a:	66 90                	xchg   %ax,%ax
  11cc8c:	66 90                	xchg   %ax,%ax
  11cc8e:	66 90                	xchg   %ax,%ax

0011cc90 <k_thread_abort>:
{
  11cc90:	55                   	push   %ebp
  11cc91:	89 e5                	mov    %esp,%ebp
  11cc93:	50                   	push   %eax
  11cc94:	8b 45 08             	mov    0x8(%ebp),%eax
	z_impl_k_thread_abort(thread);
  11cc97:	8b 45 08             	mov    0x8(%ebp),%eax
  11cc9a:	89 04 24             	mov    %eax,(%esp)
  11cc9d:	e8 2e 43 00 00       	call   120fd0 <z_impl_k_thread_abort>
}
  11cca2:	83 c4 04             	add    $0x4,%esp
  11cca5:	5d                   	pop    %ebp
  11cca6:	c3                   	ret    
  11cca7:	66 90                	xchg   %ax,%ax
  11cca9:	66 90                	xchg   %ax,%ax
  11ccab:	66 90                	xchg   %ax,%ax
  11ccad:	66 90                	xchg   %ax,%ax
  11ccaf:	90                   	nop

0011ccb0 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
  11ccb0:	55                   	push   %ebp
  11ccb1:	89 e5                	mov    %esp,%ebp
  11ccb3:	83 e4 f8             	and    $0xfffffff8,%esp
  11ccb6:	83 ec 58             	sub    $0x58,%esp
#ifdef CONFIG_STACK_CANARIES
	uintptr_t stack_guard;
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();
  11ccb9:	e8 72 00 00 00       	call   11cd30 <gcov_static_init>

	LOG_CORE_INIT();
  11ccbe:	e8 2d 6a fe ff       	call   1036f0 <log_core_init>

	/* perform any architecture-specific initialization */
	arch_kernel_init();
  11ccc3:	e8 78 00 00 00       	call   11cd40 <arch_kernel_init>
  11ccc8:	31 c0                	xor    %eax,%eax

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
  11ccca:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  11ccce:	89 ca                	mov    %ecx,%edx
  11ccd0:	89 14 24             	mov    %edx,(%esp)
  11ccd3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11ccda:	00 
  11ccdb:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  11cce2:	00 
  11cce3:	89 44 24 14          	mov    %eax,0x14(%esp)
  11cce7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11cceb:	e8 80 d7 fe ff       	call   10a470 <memset>
  11ccf0:	c6 44 24 25 01       	movb   $0x1,0x25(%esp)
  11ccf5:	8b 44 24 10          	mov    0x10(%esp),%eax
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
  11ccf9:	a3 b0 96 13 00       	mov    %eax,0x1396b0
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  11ccfe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11cd05:	e8 76 f9 ff ff       	call   11c680 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  11cd0a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11cd11:	e8 6a f9 ff ff       	call   11c680 <z_sys_device_do_config_level>
	__stack_chk_guard = stack_guard;
	__stack_chk_guard <<= 8;
#endif	/* CONFIG_STACK_CANARIES */

#ifdef CONFIG_MULTITHREADING
	prepare_multithreading(&dummy_thread);
  11cd16:	8d 44 24 18          	lea    0x18(%esp),%eax
  11cd1a:	89 04 24             	mov    %eax,(%esp)
  11cd1d:	e8 2e 00 00 00       	call   11cd50 <prepare_multithreading>
	switch_to_main_thread();
  11cd22:	e8 29 01 00 00       	call   11ce50 <switch_to_main_thread>
  11cd27:	66 90                	xchg   %ax,%ax
  11cd29:	66 90                	xchg   %ax,%ax
  11cd2b:	66 90                	xchg   %ax,%ax
  11cd2d:	66 90                	xchg   %ax,%ax
  11cd2f:	90                   	nop

0011cd30 <gcov_static_init>:
#ifdef CONFIG_COVERAGE_GCOV
void gcov_coverage_dump(void);
void gcov_static_init(void);
#else
static inline void gcov_coverage_dump(void) { }
static inline void gcov_static_init(void) { }
  11cd30:	55                   	push   %ebp
  11cd31:	89 e5                	mov    %esp,%ebp
  11cd33:	5d                   	pop    %ebp
  11cd34:	c3                   	ret    
  11cd35:	66 90                	xchg   %ax,%ax
  11cd37:	66 90                	xchg   %ax,%ax
  11cd39:	66 90                	xchg   %ax,%ax
  11cd3b:	66 90                	xchg   %ax,%ax
  11cd3d:	66 90                	xchg   %ax,%ax
  11cd3f:	90                   	nop

0011cd40 <arch_kernel_init>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void arch_kernel_init(void)
{
  11cd40:	55                   	push   %ebp
  11cd41:	89 e5                	mov    %esp,%ebp
	/* No-op on this arch */
}
  11cd43:	5d                   	pop    %ebp
  11cd44:	c3                   	ret    
  11cd45:	66 90                	xchg   %ax,%ax
  11cd47:	66 90                	xchg   %ax,%ax
  11cd49:	66 90                	xchg   %ax,%ax
  11cd4b:	66 90                	xchg   %ax,%ax
  11cd4d:	66 90                	xchg   %ax,%ax
  11cd4f:	90                   	nop

0011cd50 <prepare_multithreading>:
{
  11cd50:	55                   	push   %ebp
  11cd51:	89 e5                	mov    %esp,%ebp
  11cd53:	83 ec 34             	sub    $0x34,%esp
  11cd56:	8b 45 08             	mov    0x8(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
  11cd59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cd5c:	c6 41 0c 01          	movb   $0x1,0xc(%ecx)
	dummy_thread->base.thread_state = _THREAD_DUMMY;
  11cd60:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cd63:	c6 41 0d 01          	movb   $0x1,0xd(%ecx)
  11cd67:	89 45 f8             	mov    %eax,-0x8(%ebp)
	z_sched_init();
  11cd6a:	e8 41 27 00 00       	call   11f4b0 <z_sched_init>
  11cd6f:	31 c0                	xor    %eax,%eax
	_kernel.ready_q.cache = &z_main_thread;
  11cd71:	8d 0d c0 55 13 00    	lea    0x1355c0,%ecx
  11cd77:	89 0d c8 96 13 00    	mov    %ecx,0x1396c8
	z_setup_new_thread(&z_main_thread, z_main_stack,
  11cd7d:	89 0c 24             	mov    %ecx,(%esp)
  11cd80:	8d 0d 90 16 14 00    	lea    0x141690,%ecx
  11cd86:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11cd8a:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
  11cd91:	00 
  11cd92:	8d 0d 60 ce 11 00    	lea    0x11ce60,%ecx
  11cd98:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11cd9c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11cda3:	00 
  11cda4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11cdab:	00 
  11cdac:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  11cdb3:	00 
  11cdb4:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  11cdbb:	00 
  11cdbc:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11cdc3:	00 
  11cdc4:	8d 0d ea 48 12 00    	lea    0x1248ea,%ecx
  11cdca:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  11cdce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11cdd1:	e8 0a 37 00 00       	call   1204e0 <z_setup_new_thread>
	z_mark_thread_as_started(&z_main_thread);
  11cdd6:	8d 05 c0 55 13 00    	lea    0x1355c0,%eax
  11cddc:	89 04 24             	mov    %eax,(%esp)
  11cddf:	e8 0c 01 00 00       	call   11cef0 <z_mark_thread_as_started>
  11cde4:	8d 05 c0 55 13 00    	lea    0x1355c0,%eax
  11cdea:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
  11cded:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11cdf0:	89 04 24             	mov    %eax,(%esp)
  11cdf3:	e8 f8 01 00 00       	call   11cff0 <z_is_thread_ready>
  11cdf8:	a8 01                	test   $0x1,%al
  11cdfa:	0f 85 05 00 00 00    	jne    11ce05 <prepare_multithreading+0xb5>
  11ce00:	e9 0b 00 00 00       	jmp    11ce10 <prepare_multithreading+0xc0>
		z_add_thread_to_ready_q(thread);
  11ce05:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ce08:	89 04 24             	mov    %eax,(%esp)
  11ce0b:	e8 c0 14 00 00       	call   11e2d0 <z_add_thread_to_ready_q>
	init_idle_thread(&z_idle_thread, z_idle_stack);
  11ce10:	8d 05 00 56 13 00    	lea    0x135600,%eax
  11ce16:	89 04 24             	mov    %eax,(%esp)
  11ce19:	8d 05 90 1a 14 00    	lea    0x141a90,%eax
  11ce1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  11ce23:	e8 e8 00 00 00       	call   11cf10 <init_idle_thread>
	_kernel.cpus[0].idle_thread = &z_idle_thread;
  11ce28:	8d 05 00 56 13 00    	lea    0x135600,%eax
  11ce2e:	a3 b4 96 13 00       	mov    %eax,0x1396b4
  11ce33:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11ce39:	83 c0 18             	add    $0x18,%eax
	initialize_timeouts();
  11ce3c:	89 04 24             	mov    %eax,(%esp)
  11ce3f:	e8 5c 01 00 00       	call   11cfa0 <sys_dlist_init>
}
  11ce44:	83 c4 34             	add    $0x34,%esp
  11ce47:	5d                   	pop    %ebp
  11ce48:	c3                   	ret    
  11ce49:	66 90                	xchg   %ax,%ax
  11ce4b:	66 90                	xchg   %ax,%ax
  11ce4d:	66 90                	xchg   %ax,%ax
  11ce4f:	90                   	nop

0011ce50 <switch_to_main_thread>:
{
  11ce50:	55                   	push   %ebp
  11ce51:	89 e5                	mov    %esp,%ebp
	z_swap_unlocked();
  11ce53:	e8 98 02 00 00       	call   11d0f0 <z_swap_unlocked>
  11ce58:	66 90                	xchg   %ax,%ax
  11ce5a:	66 90                	xchg   %ax,%ax
  11ce5c:	66 90                	xchg   %ax,%ax
  11ce5e:	66 90                	xchg   %ax,%ax

0011ce60 <bg_thread_main>:
{
  11ce60:	55                   	push   %ebp
  11ce61:	89 e5                	mov    %esp,%ebp
  11ce63:	83 ec 14             	sub    $0x14,%esp
  11ce66:	8b 45 10             	mov    0x10(%ebp),%eax
  11ce69:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11ce6c:	8b 55 08             	mov    0x8(%ebp),%edx
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  11ce6f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  11ce76:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11ce79:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11ce7c:	89 55 f4             	mov    %edx,-0xc(%ebp)
  11ce7f:	e8 fc f7 ff ff       	call   11c680 <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
  11ce84:	83 3d bc 36 12 00 00 	cmpl   $0x0,0x1236bc
  11ce8b:	0f 86 1f 00 00 00    	jbe    11ceb0 <bg_thread_main+0x50>
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
  11ce91:	8d 05 ef 48 12 00    	lea    0x1248ef,%eax
  11ce97:	89 04 24             	mov    %eax,(%esp)
  11ce9a:	e8 f1 61 fe ff       	call   103090 <printk>
  11ce9f:	31 c0                	xor    %eax,%eax
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
  11cea1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11cea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11ceab:	e8 10 01 00 00       	call   11cfc0 <k_busy_wait>
	PRINT_BOOT_BANNER();
  11ceb0:	8d 05 28 49 12 00    	lea    0x124928,%eax
  11ceb6:	89 04 24             	mov    %eax,(%esp)
  11ceb9:	e8 d2 61 fe ff       	call   103090 <printk>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  11cebe:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  11cec5:	e8 b6 f7 ff ff       	call   11c680 <z_sys_device_do_config_level>
	z_init_static_threads();
  11ceca:	e8 c1 3a 00 00       	call   120990 <z_init_static_threads>
	main();
  11cecf:	e8 1c 33 fe ff       	call   1001f0 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  11ced4:	0f b6 05 cc 55 13 00 	movzbl 0x1355cc,%eax
  11cedb:	83 e0 fe             	and    $0xfffffffe,%eax
  11cede:	a2 cc 55 13 00       	mov    %al,0x1355cc
	gcov_coverage_dump();
  11cee3:	e8 f8 00 00 00       	call   11cfe0 <gcov_coverage_dump>
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  11cee8:	83 c4 14             	add    $0x14,%esp
  11ceeb:	5d                   	pop    %ebp
  11ceec:	c3                   	ret    
  11ceed:	66 90                	xchg   %ax,%ax
  11ceef:	90                   	nop

0011cef0 <z_mark_thread_as_started>:
{
  11cef0:	55                   	push   %ebp
  11cef1:	89 e5                	mov    %esp,%ebp
  11cef3:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_PRESTART;
  11cef6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cef9:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11cefd:	83 e2 fb             	and    $0xfffffffb,%edx
  11cf00:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11cf03:	5d                   	pop    %ebp
  11cf04:	c3                   	ret    
  11cf05:	66 90                	xchg   %ax,%ax
  11cf07:	66 90                	xchg   %ax,%ax
  11cf09:	66 90                	xchg   %ax,%ax
  11cf0b:	66 90                	xchg   %ax,%ax
  11cf0d:	66 90                	xchg   %ax,%ax
  11cf0f:	90                   	nop

0011cf10 <init_idle_thread>:
{
  11cf10:	55                   	push   %ebp
  11cf11:	89 e5                	mov    %esp,%ebp
  11cf13:	57                   	push   %edi
  11cf14:	56                   	push   %esi
  11cf15:	83 ec 34             	sub    $0x34,%esp
  11cf18:	8b 45 0c             	mov    0xc(%ebp),%eax
  11cf1b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cf1e:	31 d2                	xor    %edx,%edx
	z_setup_new_thread(thr, stack,
  11cf20:	8b 75 08             	mov    0x8(%ebp),%esi
  11cf23:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11cf26:	89 34 24             	mov    %esi,(%esp)
  11cf29:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11cf2d:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  11cf34:	00 
  11cf35:	8d 35 f0 27 12 00    	lea    0x1227f0,%esi
  11cf3b:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11cf3f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11cf46:	00 
  11cf47:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11cf4e:	00 
  11cf4f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  11cf56:	00 
  11cf57:	c7 44 24 1c 0f 00 00 	movl   $0xf,0x1c(%esp)
  11cf5e:	00 
  11cf5f:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11cf66:	00 
  11cf67:	8d 35 6a 49 12 00    	lea    0x12496a,%esi
  11cf6d:	89 74 24 24          	mov    %esi,0x24(%esp)
  11cf71:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11cf74:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11cf77:	89 55 ec             	mov    %edx,-0x14(%ebp)
  11cf7a:	e8 61 35 00 00       	call   1204e0 <z_setup_new_thread>
	z_mark_thread_as_started(thr);
  11cf7f:	8b 45 08             	mov    0x8(%ebp),%eax
  11cf82:	89 04 24             	mov    %eax,(%esp)
  11cf85:	e8 66 ff ff ff       	call   11cef0 <z_mark_thread_as_started>
}
  11cf8a:	83 c4 34             	add    $0x34,%esp
  11cf8d:	5e                   	pop    %esi
  11cf8e:	5f                   	pop    %edi
  11cf8f:	5d                   	pop    %ebp
  11cf90:	c3                   	ret    
  11cf91:	66 90                	xchg   %ax,%ax
  11cf93:	66 90                	xchg   %ax,%ax
  11cf95:	66 90                	xchg   %ax,%ax
  11cf97:	66 90                	xchg   %ax,%ax
  11cf99:	66 90                	xchg   %ax,%ax
  11cf9b:	66 90                	xchg   %ax,%ax
  11cf9d:	66 90                	xchg   %ax,%ax
  11cf9f:	90                   	nop

0011cfa0 <sys_dlist_init>:
{
  11cfa0:	55                   	push   %ebp
  11cfa1:	89 e5                	mov    %esp,%ebp
  11cfa3:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
  11cfa6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cfa9:	8b 55 08             	mov    0x8(%ebp),%edx
  11cfac:	89 0a                	mov    %ecx,(%edx)
	list->tail = (sys_dnode_t *)list;
  11cfae:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cfb1:	8b 55 08             	mov    0x8(%ebp),%edx
  11cfb4:	89 4a 04             	mov    %ecx,0x4(%edx)
}
  11cfb7:	5d                   	pop    %ebp
  11cfb8:	c3                   	ret    
  11cfb9:	66 90                	xchg   %ax,%ax
  11cfbb:	66 90                	xchg   %ax,%ax
  11cfbd:	66 90                	xchg   %ax,%ax
  11cfbf:	90                   	nop

0011cfc0 <k_busy_wait>:
{
  11cfc0:	55                   	push   %ebp
  11cfc1:	89 e5                	mov    %esp,%ebp
  11cfc3:	50                   	push   %eax
  11cfc4:	8b 45 08             	mov    0x8(%ebp),%eax
	z_impl_k_busy_wait(usec_to_wait);
  11cfc7:	8b 45 08             	mov    0x8(%ebp),%eax
  11cfca:	89 04 24             	mov    %eax,(%esp)
  11cfcd:	e8 3e 32 00 00       	call   120210 <z_impl_k_busy_wait>
}
  11cfd2:	83 c4 04             	add    $0x4,%esp
  11cfd5:	5d                   	pop    %ebp
  11cfd6:	c3                   	ret    
  11cfd7:	66 90                	xchg   %ax,%ax
  11cfd9:	66 90                	xchg   %ax,%ax
  11cfdb:	66 90                	xchg   %ax,%ax
  11cfdd:	66 90                	xchg   %ax,%ax
  11cfdf:	90                   	nop

0011cfe0 <gcov_coverage_dump>:
static inline void gcov_coverage_dump(void) { }
  11cfe0:	55                   	push   %ebp
  11cfe1:	89 e5                	mov    %esp,%ebp
  11cfe3:	5d                   	pop    %ebp
  11cfe4:	c3                   	ret    
  11cfe5:	66 90                	xchg   %ax,%ax
  11cfe7:	66 90                	xchg   %ax,%ax
  11cfe9:	66 90                	xchg   %ax,%ax
  11cfeb:	66 90                	xchg   %ax,%ax
  11cfed:	66 90                	xchg   %ax,%ax
  11cfef:	90                   	nop

0011cff0 <z_is_thread_ready>:
{
  11cff0:	55                   	push   %ebp
  11cff1:	89 e5                	mov    %esp,%ebp
  11cff3:	83 ec 0c             	sub    $0xc,%esp
  11cff6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11cff9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11cffc:	89 0c 24             	mov    %ecx,(%esp)
  11cfff:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d002:	e8 39 00 00 00       	call   11d040 <z_is_thread_prevented_from_running>
  11d007:	24 01                	and    $0x1,%al
  11d009:	0f b6 c8             	movzbl %al,%ecx
  11d00c:	83 f9 00             	cmp    $0x0,%ecx
  11d00f:	b0 01                	mov    $0x1,%al
  11d011:	88 45 fb             	mov    %al,-0x5(%ebp)
  11d014:	0f 85 0e 00 00 00    	jne    11d028 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  11d01a:	8b 45 08             	mov    0x8(%ebp),%eax
  11d01d:	89 04 24             	mov    %eax,(%esp)
  11d020:	e8 4b 00 00 00       	call   11d070 <z_is_thread_timeout_active>
  11d025:	88 45 fb             	mov    %al,-0x5(%ebp)
  11d028:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11d02b:	34 ff                	xor    $0xff,%al
  11d02d:	24 01                	and    $0x1,%al
  11d02f:	0f b6 c0             	movzbl %al,%eax
  11d032:	83 c4 0c             	add    $0xc,%esp
  11d035:	5d                   	pop    %ebp
  11d036:	c3                   	ret    
  11d037:	66 90                	xchg   %ax,%ax
  11d039:	66 90                	xchg   %ax,%ax
  11d03b:	66 90                	xchg   %ax,%ax
  11d03d:	66 90                	xchg   %ax,%ax
  11d03f:	90                   	nop

0011d040 <z_is_thread_prevented_from_running>:
{
  11d040:	55                   	push   %ebp
  11d041:	89 e5                	mov    %esp,%ebp
  11d043:	83 ec 08             	sub    $0x8,%esp
  11d046:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  11d049:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d04c:	8a 51 0d             	mov    0xd(%ecx),%dl
  11d04f:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11d052:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  11d056:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  11d059:	83 f9 00             	cmp    $0x0,%ecx
  11d05c:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11d05f:	80 e2 01             	and    $0x1,%dl
  11d062:	0f b6 ca             	movzbl %dl,%ecx
  11d065:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11d068:	89 c8                	mov    %ecx,%eax
  11d06a:	83 c4 08             	add    $0x8,%esp
  11d06d:	5d                   	pop    %ebp
  11d06e:	c3                   	ret    
  11d06f:	90                   	nop

0011d070 <z_is_thread_timeout_active>:
{
  11d070:	55                   	push   %ebp
  11d071:	89 e5                	mov    %esp,%ebp
  11d073:	83 ec 08             	sub    $0x8,%esp
  11d076:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  11d079:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d07c:	83 c1 18             	add    $0x18,%ecx
  11d07f:	89 0c 24             	mov    %ecx,(%esp)
  11d082:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d085:	e8 16 00 00 00       	call   11d0a0 <z_is_inactive_timeout>
  11d08a:	34 ff                	xor    $0xff,%al
  11d08c:	24 01                	and    $0x1,%al
  11d08e:	0f b6 c0             	movzbl %al,%eax
  11d091:	83 c4 08             	add    $0x8,%esp
  11d094:	5d                   	pop    %ebp
  11d095:	c3                   	ret    
  11d096:	66 90                	xchg   %ax,%ax
  11d098:	66 90                	xchg   %ax,%ax
  11d09a:	66 90                	xchg   %ax,%ax
  11d09c:	66 90                	xchg   %ax,%ax
  11d09e:	66 90                	xchg   %ax,%ax

0011d0a0 <z_is_inactive_timeout>:
void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks);

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(struct _timeout *t)
{
  11d0a0:	55                   	push   %ebp
  11d0a1:	89 e5                	mov    %esp,%ebp
  11d0a3:	83 ec 08             	sub    $0x8,%esp
  11d0a6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  11d0a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d0ac:	89 0c 24             	mov    %ecx,(%esp)
  11d0af:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d0b2:	e8 19 00 00 00       	call   11d0d0 <sys_dnode_is_linked>
  11d0b7:	34 ff                	xor    $0xff,%al
  11d0b9:	24 01                	and    $0x1,%al
  11d0bb:	0f b6 c0             	movzbl %al,%eax
  11d0be:	83 c4 08             	add    $0x8,%esp
  11d0c1:	5d                   	pop    %ebp
  11d0c2:	c3                   	ret    
  11d0c3:	66 90                	xchg   %ax,%ax
  11d0c5:	66 90                	xchg   %ax,%ax
  11d0c7:	66 90                	xchg   %ax,%ax
  11d0c9:	66 90                	xchg   %ax,%ax
  11d0cb:	66 90                	xchg   %ax,%ax
  11d0cd:	66 90                	xchg   %ax,%ax
  11d0cf:	90                   	nop

0011d0d0 <sys_dnode_is_linked>:
{
  11d0d0:	55                   	push   %ebp
  11d0d1:	89 e5                	mov    %esp,%ebp
  11d0d3:	50                   	push   %eax
  11d0d4:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  11d0d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d0da:	83 39 00             	cmpl   $0x0,(%ecx)
  11d0dd:	0f 95 c2             	setne  %dl
  11d0e0:	80 e2 01             	and    $0x1,%dl
  11d0e3:	0f b6 ca             	movzbl %dl,%ecx
  11d0e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d0e9:	89 c8                	mov    %ecx,%eax
  11d0eb:	83 c4 04             	add    $0x4,%esp
  11d0ee:	5d                   	pop    %ebp
  11d0ef:	c3                   	ret    

0011d0f0 <z_swap_unlocked>:
	k_spin_release(lock);
	return z_swap_irqlock(key.key);
}

static inline void z_swap_unlocked(void)
{
  11d0f0:	55                   	push   %ebp
  11d0f1:	89 e5                	mov    %esp,%ebp
  11d0f3:	83 ec 08             	sub    $0x8,%esp
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11d0f6:	9c                   	pushf  
  11d0f7:	fa                   	cli    
  11d0f8:	8f 45 fc             	popl   -0x4(%ebp)
	return key;
  11d0fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
	(void) z_swap_irqlock(arch_irq_lock());
  11d0fe:	89 04 24             	mov    %eax,(%esp)
  11d101:	e8 0a 00 00 00       	call   11d110 <z_swap_irqlock>
}
  11d106:	83 c4 08             	add    $0x8,%esp
  11d109:	5d                   	pop    %ebp
  11d10a:	c3                   	ret    
  11d10b:	66 90                	xchg   %ax,%ax
  11d10d:	66 90                	xchg   %ax,%ax
  11d10f:	90                   	nop

0011d110 <z_swap_irqlock>:
{
  11d110:	55                   	push   %ebp
  11d111:	89 e5                	mov    %esp,%ebp
  11d113:	83 ec 0c             	sub    $0xc,%esp
  11d116:	8b 45 08             	mov    0x8(%ebp),%eax
	ret = arch_swap(key);
  11d119:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d11c:	89 0c 24             	mov    %ecx,(%esp)
  11d11f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11d122:	e8 89 c7 fe ff       	call   1098b0 <arch_swap>
  11d127:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return ret;
  11d12a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d12d:	83 c4 0c             	add    $0xc,%esp
  11d130:	5d                   	pop    %ebp
  11d131:	c3                   	ret    
  11d132:	66 90                	xchg   %ax,%ax
  11d134:	66 90                	xchg   %ax,%ax
  11d136:	66 90                	xchg   %ax,%ax
  11d138:	66 90                	xchg   %ax,%ax
  11d13a:	66 90                	xchg   %ax,%ax
  11d13c:	66 90                	xchg   %ax,%ax
  11d13e:	66 90                	xchg   %ax,%ax

0011d140 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
  11d140:	55                   	push   %ebp
  11d141:	89 e5                	mov    %esp,%ebp
  11d143:	83 ec 0c             	sub    $0xc,%esp
  11d146:	8b 45 08             	mov    0x8(%ebp),%eax
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  11d149:	8d 0d 38 34 14 00    	lea    0x143438,%ecx
  11d14f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  11d152:	8d 05 38 34 14 00    	lea    0x143438,%eax
  11d158:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  11d15b:	0f 92 c1             	setb   %cl
  11d15e:	80 e1 01             	and    $0x1,%cl
  11d161:	0f b6 c1             	movzbl %cl,%eax
  11d164:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11d167:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  11d16b:	0f 84 29 00 00 00    	je     11d19a <init_mem_slab_module+0x5a>
		create_free_list(slab);
  11d171:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d174:	89 04 24             	mov    %eax,(%esp)
  11d177:	e8 b4 00 00 00       	call   11d230 <create_free_list>
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
  11d17c:	e9 00 00 00 00       	jmp    11d181 <init_mem_slab_module+0x41>
		z_object_init(slab);
  11d181:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d184:	89 04 24             	mov    %eax,(%esp)
  11d187:	e8 64 01 00 00       	call   11d2f0 <z_object_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  11d18c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d18f:	83 c0 24             	add    $0x24,%eax
  11d192:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d195:	e9 b8 ff ff ff       	jmp    11d152 <init_mem_slab_module+0x12>
  11d19a:	31 c0                	xor    %eax,%eax
	}
	return 0;
  11d19c:	83 c4 0c             	add    $0xc,%esp
  11d19f:	5d                   	pop    %ebp
  11d1a0:	c3                   	ret    
  11d1a1:	66 90                	xchg   %ax,%ax
  11d1a3:	66 90                	xchg   %ax,%ax
  11d1a5:	66 90                	xchg   %ax,%ax
  11d1a7:	66 90                	xchg   %ax,%ax
  11d1a9:	66 90                	xchg   %ax,%ax
  11d1ab:	66 90                	xchg   %ax,%ax
  11d1ad:	66 90                	xchg   %ax,%ax
  11d1af:	90                   	nop

0011d1b0 <k_mem_slab_init>:
SYS_INIT(init_mem_slab_module, PRE_KERNEL_1,
	 CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, u32_t num_blocks)
{
  11d1b0:	55                   	push   %ebp
  11d1b1:	89 e5                	mov    %esp,%ebp
  11d1b3:	53                   	push   %ebx
  11d1b4:	57                   	push   %edi
  11d1b5:	56                   	push   %esi
  11d1b6:	83 ec 14             	sub    $0x14,%esp
  11d1b9:	8b 45 14             	mov    0x14(%ebp),%eax
  11d1bc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11d1bf:	8b 55 0c             	mov    0xc(%ebp),%edx
  11d1c2:	8b 75 08             	mov    0x8(%ebp),%esi
	slab->num_blocks = num_blocks;
  11d1c5:	8b 7d 14             	mov    0x14(%ebp),%edi
  11d1c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11d1cb:	89 7b 10             	mov    %edi,0x10(%ebx)
	slab->block_size = block_size;
  11d1ce:	8b 7d 10             	mov    0x10(%ebp),%edi
  11d1d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11d1d4:	89 7b 14             	mov    %edi,0x14(%ebx)
	slab->buffer = buffer;
  11d1d7:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11d1da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11d1dd:	89 7b 18             	mov    %edi,0x18(%ebx)
	slab->num_used = 0U;
  11d1e0:	8b 7d 08             	mov    0x8(%ebp),%edi
  11d1e3:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%edi)
	create_free_list(slab);
  11d1ea:	8b 7d 08             	mov    0x8(%ebp),%edi
  11d1ed:	89 3c 24             	mov    %edi,(%esp)
  11d1f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11d1f3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11d1f6:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11d1f9:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  11d1fc:	e8 2f 00 00 00       	call   11d230 <create_free_list>
	z_waitq_init(&slab->wait_q);
  11d201:	8b 45 08             	mov    0x8(%ebp),%eax
  11d204:	89 04 24             	mov    %eax,(%esp)
  11d207:	e8 94 00 00 00       	call   11d2a0 <z_waitq_init>
	SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
  11d20c:	e9 00 00 00 00       	jmp    11d211 <k_mem_slab_init+0x61>

	z_object_init(slab);
  11d211:	8b 45 08             	mov    0x8(%ebp),%eax
  11d214:	89 04 24             	mov    %eax,(%esp)
  11d217:	e8 d4 00 00 00       	call   11d2f0 <z_object_init>
}
  11d21c:	83 c4 14             	add    $0x14,%esp
  11d21f:	5e                   	pop    %esi
  11d220:	5f                   	pop    %edi
  11d221:	5b                   	pop    %ebx
  11d222:	5d                   	pop    %ebp
  11d223:	c3                   	ret    
  11d224:	66 90                	xchg   %ax,%ax
  11d226:	66 90                	xchg   %ax,%ax
  11d228:	66 90                	xchg   %ax,%ax
  11d22a:	66 90                	xchg   %ax,%ax
  11d22c:	66 90                	xchg   %ax,%ax
  11d22e:	66 90                	xchg   %ax,%ax

0011d230 <create_free_list>:
{
  11d230:	55                   	push   %ebp
  11d231:	89 e5                	mov    %esp,%ebp
  11d233:	83 ec 08             	sub    $0x8,%esp
  11d236:	8b 45 08             	mov    0x8(%ebp),%eax
	slab->free_list = NULL;
  11d239:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d23c:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	p = slab->buffer;
  11d243:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d246:	8b 49 18             	mov    0x18(%ecx),%ecx
  11d249:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	for (j = 0U; j < slab->num_blocks; j++) {
  11d24c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  11d253:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d256:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d259:	3b 41 10             	cmp    0x10(%ecx),%eax
  11d25c:	0f 83 2e 00 00 00    	jae    11d290 <create_free_list+0x60>
		*(char **)p = slab->free_list;
  11d262:	8b 45 08             	mov    0x8(%ebp),%eax
  11d265:	8b 40 1c             	mov    0x1c(%eax),%eax
  11d268:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11d26b:	89 01                	mov    %eax,(%ecx)
		slab->free_list = p;
  11d26d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11d270:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d273:	89 41 1c             	mov    %eax,0x1c(%ecx)
		p += slab->block_size;
  11d276:	8b 45 08             	mov    0x8(%ebp),%eax
  11d279:	8b 40 14             	mov    0x14(%eax),%eax
  11d27c:	03 45 f8             	add    -0x8(%ebp),%eax
  11d27f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (j = 0U; j < slab->num_blocks; j++) {
  11d282:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d285:	83 c0 01             	add    $0x1,%eax
  11d288:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d28b:	e9 c3 ff ff ff       	jmp    11d253 <create_free_list+0x23>
}
  11d290:	83 c4 08             	add    $0x8,%esp
  11d293:	5d                   	pop    %ebp
  11d294:	c3                   	ret    
  11d295:	66 90                	xchg   %ax,%ax
  11d297:	66 90                	xchg   %ax,%ax
  11d299:	66 90                	xchg   %ax,%ax
  11d29b:	66 90                	xchg   %ax,%ax
  11d29d:	66 90                	xchg   %ax,%ax
  11d29f:	90                   	nop

0011d2a0 <z_waitq_init>:

#define _WAIT_Q_FOR_EACH(wq, thread_ptr) \
	RB_FOR_EACH_CONTAINER(&(wq)->waitq.tree, thread_ptr, base.qnode_rb)

static inline void z_waitq_init(_wait_q_t *w)
{
  11d2a0:	55                   	push   %ebp
  11d2a1:	89 e5                	mov    %esp,%ebp
  11d2a3:	83 e4 f8             	and    $0xfffffff8,%esp
  11d2a6:	83 ec 10             	sub    $0x10,%esp
  11d2a9:	8b 45 08             	mov    0x8(%ebp),%eax
	w->waitq = (struct _priq_rb) {
  11d2ac:	8b 4d 08             	mov    0x8(%ebp),%ecx
		.tree = {
  11d2af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11d2b6:	8d 15 30 f3 11 00    	lea    0x11f330,%edx
  11d2bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  11d2c0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11d2c7:	00 
	w->waitq = (struct _priq_rb) {
  11d2c8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  11d2cf:	00 
  11d2d0:	8b 14 24             	mov    (%esp),%edx
  11d2d3:	89 11                	mov    %edx,(%ecx)
  11d2d5:	8b 54 24 04          	mov    0x4(%esp),%edx
  11d2d9:	89 51 04             	mov    %edx,0x4(%ecx)
  11d2dc:	8b 54 24 08          	mov    0x8(%esp),%edx
  11d2e0:	89 51 08             	mov    %edx,0x8(%ecx)
  11d2e3:	8b 54 24 0c          	mov    0xc(%esp),%edx
  11d2e7:	89 51 0c             	mov    %edx,0xc(%ecx)
			.lessthan_fn = z_priq_rb_lessthan
		}
	};
}
  11d2ea:	89 ec                	mov    %ebp,%esp
  11d2ec:	5d                   	pop    %ebp
  11d2ed:	c3                   	ret    
  11d2ee:	66 90                	xchg   %ax,%ax

0011d2f0 <z_object_init>:
{
  11d2f0:	55                   	push   %ebp
  11d2f1:	89 e5                	mov    %esp,%ebp
  11d2f3:	8b 45 08             	mov    0x8(%ebp),%eax
}
  11d2f6:	5d                   	pop    %ebp
  11d2f7:	c3                   	ret    
  11d2f8:	66 90                	xchg   %ax,%ax
  11d2fa:	66 90                	xchg   %ax,%ax
  11d2fc:	66 90                	xchg   %ax,%ax
  11d2fe:	66 90                	xchg   %ax,%ax

0011d300 <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
  11d300:	55                   	push   %ebp
  11d301:	89 e5                	mov    %esp,%ebp
  11d303:	56                   	push   %esi
  11d304:	83 e4 f8             	and    $0xfffffff8,%esp
  11d307:	83 ec 40             	sub    $0x40,%esp
  11d30a:	8b 45 10             	mov    0x10(%ebp),%eax
  11d30d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d310:	8b 55 08             	mov    0x8(%ebp),%edx
  11d313:	8d 74 24 18          	lea    0x18(%esp),%esi
  11d317:	89 74 24 24          	mov    %esi,0x24(%esp)
  11d31b:	8d 35 ef 0e 14 00    	lea    0x140eef,%esi
  11d321:	89 74 24 20          	mov    %esi,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11d325:	9c                   	pushf  
  11d326:	fa                   	cli    
  11d327:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  11d32b:	8b 74 24 28          	mov    0x28(%esp),%esi
	k.key = arch_irq_lock();
  11d32f:	89 74 24 18          	mov    %esi,0x18(%esp)
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
  11d333:	8b 75 08             	mov    0x8(%ebp),%esi
  11d336:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  11d33a:	0f 84 32 00 00 00    	je     11d372 <k_mem_slab_alloc+0x72>
		/* take a free block */
		*mem = slab->free_list;
  11d340:	8b 45 08             	mov    0x8(%ebp),%eax
  11d343:	8b 40 1c             	mov    0x1c(%eax),%eax
  11d346:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d349:	89 01                	mov    %eax,(%ecx)
		slab->free_list = *(char **)(slab->free_list);
  11d34b:	8b 45 08             	mov    0x8(%ebp),%eax
  11d34e:	8b 40 1c             	mov    0x1c(%eax),%eax
  11d351:	8b 00                	mov    (%eax),%eax
  11d353:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d356:	89 41 1c             	mov    %eax,0x1c(%ecx)
		slab->num_used++;
  11d359:	8b 45 08             	mov    0x8(%ebp),%eax
  11d35c:	8b 48 20             	mov    0x20(%eax),%ecx
  11d35f:	83 c1 01             	add    $0x1,%ecx
  11d362:	89 48 20             	mov    %ecx,0x20(%eax)
		result = 0;
  11d365:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  11d36c:	00 
	} else if (timeout == K_NO_WAIT) {
  11d36d:	e9 72 00 00 00       	jmp    11d3e4 <k_mem_slab_alloc+0xe4>
  11d372:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  11d376:	0f 85 16 00 00 00    	jne    11d392 <k_mem_slab_alloc+0x92>
		/* don't wait for a free block to become available */
		*mem = NULL;
  11d37c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11d37f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		result = -ENOMEM;
  11d385:	c7 44 24 14 f4 ff ff 	movl   $0xfffffff4,0x14(%esp)
  11d38c:	ff 
	} else {
  11d38d:	e9 4d 00 00 00       	jmp    11d3df <k_mem_slab_alloc+0xdf>
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
  11d392:	8b 45 08             	mov    0x8(%ebp),%eax
  11d395:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11d398:	8b 54 24 18          	mov    0x18(%esp),%edx
  11d39c:	8d 35 ef 0e 14 00    	lea    0x140eef,%esi
  11d3a2:	89 34 24             	mov    %esi,(%esp)
  11d3a5:	89 54 24 04          	mov    %edx,0x4(%esp)
  11d3a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  11d3ad:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11d3b1:	e8 ba 18 00 00       	call   11ec70 <z_pend_curr>
  11d3b6:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (result == 0) {
  11d3ba:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
  11d3bf:	0f 85 0d 00 00 00    	jne    11d3d2 <k_mem_slab_alloc+0xd2>
			*mem = _current->base.swap_data;
  11d3c5:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11d3ca:	8b 40 14             	mov    0x14(%eax),%eax
  11d3cd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d3d0:	89 01                	mov    %eax,(%ecx)
		}
		return result;
  11d3d2:	8b 44 24 14          	mov    0x14(%esp),%eax
  11d3d6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11d3da:	e9 3a 00 00 00       	jmp    11d419 <k_mem_slab_alloc+0x119>
  11d3df:	e9 00 00 00 00       	jmp    11d3e4 <k_mem_slab_alloc+0xe4>
	}

	k_spin_unlock(&lock, key);
  11d3e4:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d3e8:	89 44 24 30          	mov    %eax,0x30(%esp)
  11d3ec:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11d3f2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  11d3f6:	8b 44 24 30          	mov    0x30(%esp),%eax
  11d3fa:	89 44 24 38          	mov    %eax,0x38(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11d3fe:	8b 44 24 38          	mov    0x38(%esp),%eax
  11d402:	25 00 02 00 00       	and    $0x200,%eax
  11d407:	83 f8 00             	cmp    $0x0,%eax
  11d40a:	0f 84 01 00 00 00    	je     11d411 <k_mem_slab_alloc+0x111>
		__asm__ volatile ("sti" ::: "memory");
  11d410:	fb                   	sti    

	return result;
  11d411:	8b 44 24 14          	mov    0x14(%esp),%eax
  11d415:	89 44 24 1c          	mov    %eax,0x1c(%esp)
}
  11d419:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  11d41d:	8d 65 fc             	lea    -0x4(%ebp),%esp
  11d420:	5e                   	pop    %esi
  11d421:	5d                   	pop    %ebp
  11d422:	c3                   	ret    
  11d423:	66 90                	xchg   %ax,%ax
  11d425:	66 90                	xchg   %ax,%ax
  11d427:	66 90                	xchg   %ax,%ax
  11d429:	66 90                	xchg   %ax,%ax
  11d42b:	66 90                	xchg   %ax,%ax
  11d42d:	66 90                	xchg   %ax,%ax
  11d42f:	90                   	nop

0011d430 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  11d430:	55                   	push   %ebp
  11d431:	89 e5                	mov    %esp,%ebp
  11d433:	83 e4 f8             	and    $0xfffffff8,%esp
  11d436:	83 ec 50             	sub    $0x50,%esp
  11d439:	8b 45 0c             	mov    0xc(%ebp),%eax
  11d43c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d43f:	8d 54 24 18          	lea    0x18(%esp),%edx
  11d443:	89 54 24 20          	mov    %edx,0x20(%esp)
  11d447:	8d 15 ef 0e 14 00    	lea    0x140eef,%edx
  11d44d:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11d451:	9c                   	pushf  
  11d452:	fa                   	cli    
  11d453:	8f 44 24 24          	popl   0x24(%esp)
	return key;
  11d457:	8b 54 24 24          	mov    0x24(%esp),%edx
	k.key = arch_irq_lock();
  11d45b:	89 54 24 18          	mov    %edx,0x18(%esp)
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  11d45f:	8b 55 08             	mov    0x8(%ebp),%edx
  11d462:	89 14 24             	mov    %edx,(%esp)
  11d465:	89 44 24 10          	mov    %eax,0x10(%esp)
  11d469:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11d46d:	e8 6e 18 00 00       	call   11ece0 <z_unpend_first_thread>
  11d472:	89 44 24 14          	mov    %eax,0x14(%esp)

	if (pending_thread != NULL) {
  11d476:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
  11d47b:	0f 84 89 00 00 00    	je     11d50a <k_mem_slab_free+0xda>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  11d481:	8b 44 24 14          	mov    0x14(%esp),%eax
  11d485:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d488:	8b 09                	mov    (%ecx),%ecx
  11d48a:	89 44 24 30          	mov    %eax,0x30(%esp)
  11d48e:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11d495:	00 
  11d496:	89 4c 24 28          	mov    %ecx,0x28(%esp)
static ALWAYS_INLINE void
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
  11d49a:	8b 44 24 30          	mov    0x30(%esp),%eax
  11d49e:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  11d4a2:	89 44 24 38          	mov    %eax,0x38(%esp)
  11d4a6:	89 4c 24 34          	mov    %ecx,0x34(%esp)
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in z_swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  11d4aa:	8b 44 24 34          	mov    0x34(%esp),%eax
  11d4ae:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  11d4b2:	8b 49 28             	mov    0x28(%ecx),%ecx
  11d4b5:	89 01                	mov    %eax,(%ecx)
	thread->base.swap_data = data;
  11d4b7:	8b 44 24 28          	mov    0x28(%esp),%eax
  11d4bb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  11d4bf:	89 41 14             	mov    %eax,0x14(%ecx)
		z_ready_thread(pending_thread);
  11d4c2:	8b 44 24 14          	mov    0x14(%esp),%eax
  11d4c6:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	if (z_is_thread_ready(thread)) {
  11d4ca:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  11d4ce:	89 04 24             	mov    %eax,(%esp)
  11d4d1:	e8 9a 00 00 00       	call   11d570 <z_is_thread_ready>
  11d4d6:	a8 01                	test   $0x1,%al
  11d4d8:	0f 85 05 00 00 00    	jne    11d4e3 <k_mem_slab_free+0xb3>
  11d4de:	e9 0c 00 00 00       	jmp    11d4ef <k_mem_slab_free+0xbf>
		z_add_thread_to_ready_q(thread);
  11d4e3:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  11d4e7:	89 04 24             	mov    %eax,(%esp)
  11d4ea:	e8 e1 0d 00 00       	call   11e2d0 <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
  11d4ef:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d4f3:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  11d4f9:	89 0c 24             	mov    %ecx,(%esp)
  11d4fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  11d500:	e8 5b 1b 00 00       	call   11f060 <z_reschedule>
	} else {
  11d505:	e9 56 00 00 00       	jmp    11d560 <k_mem_slab_free+0x130>
		**(char ***)mem = slab->free_list;
  11d50a:	8b 45 08             	mov    0x8(%ebp),%eax
  11d50d:	8b 40 1c             	mov    0x1c(%eax),%eax
  11d510:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d513:	8b 09                	mov    (%ecx),%ecx
  11d515:	89 01                	mov    %eax,(%ecx)
		slab->free_list = *(char **)mem;
  11d517:	8b 45 0c             	mov    0xc(%ebp),%eax
  11d51a:	8b 00                	mov    (%eax),%eax
  11d51c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d51f:	89 41 1c             	mov    %eax,0x1c(%ecx)
		slab->num_used--;
  11d522:	8b 45 08             	mov    0x8(%ebp),%eax
  11d525:	8b 48 20             	mov    0x20(%eax),%ecx
  11d528:	83 c1 ff             	add    $0xffffffff,%ecx
  11d52b:	89 48 20             	mov    %ecx,0x20(%eax)
		k_spin_unlock(&lock, key);
  11d52e:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d532:	89 44 24 40          	mov    %eax,0x40(%esp)
  11d536:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11d53c:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	arch_irq_unlock(key.key);
  11d540:	8b 44 24 40          	mov    0x40(%esp),%eax
  11d544:	89 44 24 48          	mov    %eax,0x48(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11d548:	8b 44 24 48          	mov    0x48(%esp),%eax
  11d54c:	25 00 02 00 00       	and    $0x200,%eax
  11d551:	83 f8 00             	cmp    $0x0,%eax
  11d554:	0f 84 01 00 00 00    	je     11d55b <k_mem_slab_free+0x12b>
		__asm__ volatile ("sti" ::: "memory");
  11d55a:	fb                   	sti    
  11d55b:	e9 00 00 00 00       	jmp    11d560 <k_mem_slab_free+0x130>
	}
}
  11d560:	89 ec                	mov    %ebp,%esp
  11d562:	5d                   	pop    %ebp
  11d563:	c3                   	ret    
  11d564:	66 90                	xchg   %ax,%ax
  11d566:	66 90                	xchg   %ax,%ax
  11d568:	66 90                	xchg   %ax,%ax
  11d56a:	66 90                	xchg   %ax,%ax
  11d56c:	66 90                	xchg   %ax,%ax
  11d56e:	66 90                	xchg   %ax,%ax

0011d570 <z_is_thread_ready>:
{
  11d570:	55                   	push   %ebp
  11d571:	89 e5                	mov    %esp,%ebp
  11d573:	83 ec 0c             	sub    $0xc,%esp
  11d576:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11d579:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d57c:	89 0c 24             	mov    %ecx,(%esp)
  11d57f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d582:	e8 39 00 00 00       	call   11d5c0 <z_is_thread_prevented_from_running>
  11d587:	24 01                	and    $0x1,%al
  11d589:	0f b6 c8             	movzbl %al,%ecx
  11d58c:	83 f9 00             	cmp    $0x0,%ecx
  11d58f:	b0 01                	mov    $0x1,%al
  11d591:	88 45 fb             	mov    %al,-0x5(%ebp)
  11d594:	0f 85 0e 00 00 00    	jne    11d5a8 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  11d59a:	8b 45 08             	mov    0x8(%ebp),%eax
  11d59d:	89 04 24             	mov    %eax,(%esp)
  11d5a0:	e8 4b 00 00 00       	call   11d5f0 <z_is_thread_timeout_active>
  11d5a5:	88 45 fb             	mov    %al,-0x5(%ebp)
  11d5a8:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11d5ab:	34 ff                	xor    $0xff,%al
  11d5ad:	24 01                	and    $0x1,%al
  11d5af:	0f b6 c0             	movzbl %al,%eax
  11d5b2:	83 c4 0c             	add    $0xc,%esp
  11d5b5:	5d                   	pop    %ebp
  11d5b6:	c3                   	ret    
  11d5b7:	66 90                	xchg   %ax,%ax
  11d5b9:	66 90                	xchg   %ax,%ax
  11d5bb:	66 90                	xchg   %ax,%ax
  11d5bd:	66 90                	xchg   %ax,%ax
  11d5bf:	90                   	nop

0011d5c0 <z_is_thread_prevented_from_running>:
{
  11d5c0:	55                   	push   %ebp
  11d5c1:	89 e5                	mov    %esp,%ebp
  11d5c3:	83 ec 08             	sub    $0x8,%esp
  11d5c6:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  11d5c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d5cc:	8a 51 0d             	mov    0xd(%ecx),%dl
  11d5cf:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11d5d2:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  11d5d6:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  11d5d9:	83 f9 00             	cmp    $0x0,%ecx
  11d5dc:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11d5df:	80 e2 01             	and    $0x1,%dl
  11d5e2:	0f b6 ca             	movzbl %dl,%ecx
  11d5e5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11d5e8:	89 c8                	mov    %ecx,%eax
  11d5ea:	83 c4 08             	add    $0x8,%esp
  11d5ed:	5d                   	pop    %ebp
  11d5ee:	c3                   	ret    
  11d5ef:	90                   	nop

0011d5f0 <z_is_thread_timeout_active>:
{
  11d5f0:	55                   	push   %ebp
  11d5f1:	89 e5                	mov    %esp,%ebp
  11d5f3:	83 ec 08             	sub    $0x8,%esp
  11d5f6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  11d5f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d5fc:	83 c1 18             	add    $0x18,%ecx
  11d5ff:	89 0c 24             	mov    %ecx,(%esp)
  11d602:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d605:	e8 16 00 00 00       	call   11d620 <z_is_inactive_timeout>
  11d60a:	34 ff                	xor    $0xff,%al
  11d60c:	24 01                	and    $0x1,%al
  11d60e:	0f b6 c0             	movzbl %al,%eax
  11d611:	83 c4 08             	add    $0x8,%esp
  11d614:	5d                   	pop    %ebp
  11d615:	c3                   	ret    
  11d616:	66 90                	xchg   %ax,%ax
  11d618:	66 90                	xchg   %ax,%ax
  11d61a:	66 90                	xchg   %ax,%ax
  11d61c:	66 90                	xchg   %ax,%ax
  11d61e:	66 90                	xchg   %ax,%ax

0011d620 <z_is_inactive_timeout>:
{
  11d620:	55                   	push   %ebp
  11d621:	89 e5                	mov    %esp,%ebp
  11d623:	83 ec 08             	sub    $0x8,%esp
  11d626:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  11d629:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d62c:	89 0c 24             	mov    %ecx,(%esp)
  11d62f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d632:	e8 19 00 00 00       	call   11d650 <sys_dnode_is_linked>
  11d637:	34 ff                	xor    $0xff,%al
  11d639:	24 01                	and    $0x1,%al
  11d63b:	0f b6 c0             	movzbl %al,%eax
  11d63e:	83 c4 08             	add    $0x8,%esp
  11d641:	5d                   	pop    %ebp
  11d642:	c3                   	ret    
  11d643:	66 90                	xchg   %ax,%ax
  11d645:	66 90                	xchg   %ax,%ax
  11d647:	66 90                	xchg   %ax,%ax
  11d649:	66 90                	xchg   %ax,%ax
  11d64b:	66 90                	xchg   %ax,%ax
  11d64d:	66 90                	xchg   %ax,%ax
  11d64f:	90                   	nop

0011d650 <sys_dnode_is_linked>:
{
  11d650:	55                   	push   %ebp
  11d651:	89 e5                	mov    %esp,%ebp
  11d653:	50                   	push   %eax
  11d654:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  11d657:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d65a:	83 39 00             	cmpl   $0x0,(%ecx)
  11d65d:	0f 95 c2             	setne  %dl
  11d660:	80 e2 01             	and    $0x1,%dl
  11d663:	0f b6 ca             	movzbl %dl,%ecx
  11d666:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d669:	89 c8                	mov    %ecx,%eax
  11d66b:	83 c4 04             	add    $0x4,%esp
  11d66e:	5d                   	pop    %ebp
  11d66f:	c3                   	ret    

0011d670 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
  11d670:	55                   	push   %ebp
  11d671:	89 e5                	mov    %esp,%ebp
  11d673:	83 ec 0c             	sub    $0xc,%esp
  11d676:	8b 45 08             	mov    0x8(%ebp),%eax
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
  11d679:	8d 0d 38 34 14 00    	lea    0x143438,%ecx
  11d67f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  11d682:	8d 05 5c 34 14 00    	lea    0x14345c,%eax
  11d688:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  11d68b:	0f 92 c1             	setb   %cl
  11d68e:	80 e1 01             	and    $0x1,%cl
  11d691:	0f b6 c1             	movzbl %cl,%eax
  11d694:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11d697:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  11d69b:	0f 84 19 00 00 00    	je     11d6ba <init_static_pools+0x4a>
		k_mem_pool_init(p);
  11d6a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d6a4:	89 04 24             	mov    %eax,(%esp)
  11d6a7:	e8 24 00 00 00       	call   11d6d0 <k_mem_pool_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
  11d6ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11d6af:	83 c0 24             	add    $0x24,%eax
  11d6b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d6b5:	e9 c8 ff ff ff       	jmp    11d682 <init_static_pools+0x12>
  11d6ba:	31 c0                	xor    %eax,%eax
	}

	return 0;
  11d6bc:	83 c4 0c             	add    $0xc,%esp
  11d6bf:	5d                   	pop    %ebp
  11d6c0:	c3                   	ret    
  11d6c1:	66 90                	xchg   %ax,%ax
  11d6c3:	66 90                	xchg   %ax,%ax
  11d6c5:	66 90                	xchg   %ax,%ax
  11d6c7:	66 90                	xchg   %ax,%ax
  11d6c9:	66 90                	xchg   %ax,%ax
  11d6cb:	66 90                	xchg   %ax,%ax
  11d6cd:	66 90                	xchg   %ax,%ax
  11d6cf:	90                   	nop

0011d6d0 <k_mem_pool_init>:
{
  11d6d0:	55                   	push   %ebp
  11d6d1:	89 e5                	mov    %esp,%ebp
  11d6d3:	83 ec 08             	sub    $0x8,%esp
  11d6d6:	8b 45 08             	mov    0x8(%ebp),%eax
	z_waitq_init(&p->wait_q);
  11d6d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d6dc:	83 c1 14             	add    $0x14,%ecx
  11d6df:	89 0c 24             	mov    %ecx,(%esp)
  11d6e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d6e5:	e8 66 04 00 00       	call   11db50 <z_waitq_init>
	z_sys_mem_pool_base_init(&p->base);
  11d6ea:	8b 45 08             	mov    0x8(%ebp),%eax
  11d6ed:	89 04 24             	mov    %eax,(%esp)
  11d6f0:	e8 1b 2e fe ff       	call   100510 <z_sys_mem_pool_base_init>
}
  11d6f5:	83 c4 08             	add    $0x8,%esp
  11d6f8:	5d                   	pop    %ebp
  11d6f9:	c3                   	ret    
  11d6fa:	66 90                	xchg   %ax,%ax
  11d6fc:	66 90                	xchg   %ax,%ax
  11d6fe:	66 90                	xchg   %ax,%ax

0011d700 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
  11d700:	55                   	push   %ebp
  11d701:	89 e5                	mov    %esp,%ebp
  11d703:	56                   	push   %esi
  11d704:	83 e4 f8             	and    $0xfffffff8,%esp
  11d707:	83 ec 38             	sub    $0x38,%esp
  11d70a:	8b 45 14             	mov    0x14(%ebp),%eax
  11d70d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11d710:	8b 55 0c             	mov    0xc(%ebp),%edx
  11d713:	8b 75 08             	mov    0x8(%ebp),%esi
	int ret;
	s64_t end = 0;
  11d716:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  11d71d:	00 
  11d71e:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
  11d725:	00 

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
  11d726:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  11d72a:	0f 8e 19 00 00 00    	jle    11d749 <k_mem_pool_alloc+0x49>
		end = k_uptime_get() + timeout;
  11d730:	e8 3b 01 00 00       	call   11d870 <k_uptime_get>
  11d735:	8b 4d 14             	mov    0x14(%ebp),%ecx
  11d738:	89 ce                	mov    %ecx,%esi
  11d73a:	c1 fe 1f             	sar    $0x1f,%esi
  11d73d:	01 c8                	add    %ecx,%eax
  11d73f:	11 f2                	adc    %esi,%edx
  11d741:	89 44 24 20          	mov    %eax,0x20(%esp)
  11d745:	89 54 24 24          	mov    %edx,0x24(%esp)
	}

	while (true) {
  11d749:	e9 00 00 00 00       	jmp    11d74e <k_mem_pool_alloc+0x4e>
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
  11d74e:	8b 45 08             	mov    0x8(%ebp),%eax
  11d751:	8b 4d 10             	mov    0x10(%ebp),%ecx
						 &level_num, &block_num,
						 &block->data);
  11d754:	8b 55 0c             	mov    0xc(%ebp),%edx
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
  11d757:	89 04 24             	mov    %eax,(%esp)
  11d75a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11d75e:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  11d762:	89 44 24 08          	mov    %eax,0x8(%esp)
  11d766:	8d 44 24 18          	lea    0x18(%esp),%eax
  11d76a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11d76e:	89 54 24 10          	mov    %edx,0x10(%esp)
  11d772:	e8 59 2f fe ff       	call   1006d0 <z_sys_mem_pool_block_alloc>
  11d777:	89 44 24 2c          	mov    %eax,0x2c(%esp)
		block->id.pool = pool_id(p);
  11d77b:	8b 45 08             	mov    0x8(%ebp),%eax
  11d77e:	89 04 24             	mov    %eax,(%esp)
  11d781:	e8 fa 00 00 00       	call   11d880 <pool_id>
  11d786:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d789:	8b 51 04             	mov    0x4(%ecx),%edx
  11d78c:	25 ff 00 00 00       	and    $0xff,%eax
  11d791:	81 e2 00 ff ff ff    	and    $0xffffff00,%edx
  11d797:	09 c2                	or     %eax,%edx
  11d799:	89 51 04             	mov    %edx,0x4(%ecx)
		block->id.level = level_num;
  11d79c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  11d7a0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d7a3:	8b 51 04             	mov    0x4(%ecx),%edx
  11d7a6:	83 e0 0f             	and    $0xf,%eax
  11d7a9:	c1 e0 08             	shl    $0x8,%eax
  11d7ac:	81 e2 ff f0 ff ff    	and    $0xfffff0ff,%edx
  11d7b2:	09 c2                	or     %eax,%edx
  11d7b4:	89 51 04             	mov    %edx,0x4(%ecx)
		block->id.block = block_num;
  11d7b7:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d7bb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11d7be:	8b 51 04             	mov    0x4(%ecx),%edx
  11d7c1:	25 ff ff 0f 00       	and    $0xfffff,%eax
  11d7c6:	c1 e0 0c             	shl    $0xc,%eax
  11d7c9:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  11d7cf:	09 c2                	or     %eax,%edx
  11d7d1:	89 51 04             	mov    %edx,0x4(%ecx)

		if (ret == 0 || timeout == K_NO_WAIT ||
  11d7d4:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
  11d7d9:	0f 84 15 00 00 00    	je     11d7f4 <k_mem_pool_alloc+0xf4>
  11d7df:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  11d7e3:	0f 84 0b 00 00 00    	je     11d7f4 <k_mem_pool_alloc+0xf4>
		    ret != -ENOMEM) {
  11d7e9:	83 7c 24 2c f4       	cmpl   $0xfffffff4,0x2c(%esp)
		if (ret == 0 || timeout == K_NO_WAIT ||
  11d7ee:	0f 84 0d 00 00 00    	je     11d801 <k_mem_pool_alloc+0x101>
			return ret;
  11d7f4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  11d7f8:	89 44 24 30          	mov    %eax,0x30(%esp)
  11d7fc:	e9 56 00 00 00       	jmp    11d857 <k_mem_pool_alloc+0x157>
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
  11d801:	8b 45 08             	mov    0x8(%ebp),%eax
  11d804:	83 c0 14             	add    $0x14,%eax
  11d807:	8b 4d 14             	mov    0x14(%ebp),%ecx
  11d80a:	89 04 24             	mov    %eax,(%esp)
  11d80d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11d811:	e8 9a 00 00 00       	call   11d8b0 <z_pend_curr_unlocked>

		if (timeout != K_FOREVER) {
  11d816:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
  11d81a:	0f 84 2a 00 00 00    	je     11d84a <k_mem_pool_alloc+0x14a>
			timeout = end - k_uptime_get();
  11d820:	8b 44 24 20          	mov    0x20(%esp),%eax
  11d824:	89 44 24 14          	mov    %eax,0x14(%esp)
  11d828:	e8 43 00 00 00       	call   11d870 <k_uptime_get>
  11d82d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  11d831:	29 c1                	sub    %eax,%ecx
  11d833:	89 4d 14             	mov    %ecx,0x14(%ebp)
			if (timeout <= 0) {
  11d836:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  11d83a:	0f 8f 05 00 00 00    	jg     11d845 <k_mem_pool_alloc+0x145>
				break;
  11d840:	e9 0a 00 00 00       	jmp    11d84f <k_mem_pool_alloc+0x14f>
			}
		}
  11d845:	e9 00 00 00 00       	jmp    11d84a <k_mem_pool_alloc+0x14a>
	while (true) {
  11d84a:	e9 ff fe ff ff       	jmp    11d74e <k_mem_pool_alloc+0x4e>
	}

	return -EAGAIN;
  11d84f:	c7 44 24 30 f5 ff ff 	movl   $0xfffffff5,0x30(%esp)
  11d856:	ff 
}
  11d857:	8b 44 24 30          	mov    0x30(%esp),%eax
  11d85b:	8d 65 fc             	lea    -0x4(%ebp),%esp
  11d85e:	5e                   	pop    %esi
  11d85f:	5d                   	pop    %ebp
  11d860:	c3                   	ret    
  11d861:	66 90                	xchg   %ax,%ax
  11d863:	66 90                	xchg   %ax,%ax
  11d865:	66 90                	xchg   %ax,%ax
  11d867:	66 90                	xchg   %ax,%ax
  11d869:	66 90                	xchg   %ax,%ax
  11d86b:	66 90                	xchg   %ax,%ax
  11d86d:	66 90                	xchg   %ax,%ax
  11d86f:	90                   	nop

0011d870 <k_uptime_get>:
{
  11d870:	55                   	push   %ebp
  11d871:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  11d873:	e9 00 00 00 00       	jmp    11d878 <k_uptime_get+0x8>
	return z_impl_k_uptime_get();
  11d878:	e8 d3 41 00 00       	call   121a50 <z_impl_k_uptime_get>
  11d87d:	5d                   	pop    %ebp
  11d87e:	c3                   	ret    
  11d87f:	90                   	nop

0011d880 <pool_id>:
{
  11d880:	55                   	push   %ebp
  11d881:	89 e5                	mov    %esp,%ebp
  11d883:	50                   	push   %eax
  11d884:	8b 45 08             	mov    0x8(%ebp),%eax
	return pool - &_k_mem_pool_list_start[0];
  11d887:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d88a:	8d 15 38 34 14 00    	lea    0x143438,%edx
  11d890:	29 d1                	sub    %edx,%ecx
  11d892:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d895:	89 c8                	mov    %ecx,%eax
  11d897:	99                   	cltd   
  11d898:	b9 24 00 00 00       	mov    $0x24,%ecx
  11d89d:	f7 f9                	idiv   %ecx
  11d89f:	83 c4 04             	add    $0x4,%esp
  11d8a2:	5d                   	pop    %ebp
  11d8a3:	c3                   	ret    
  11d8a4:	66 90                	xchg   %ax,%ax
  11d8a6:	66 90                	xchg   %ax,%ax
  11d8a8:	66 90                	xchg   %ax,%ax
  11d8aa:	66 90                	xchg   %ax,%ax
  11d8ac:	66 90                	xchg   %ax,%ax
  11d8ae:	66 90                	xchg   %ax,%ax

0011d8b0 <z_pend_curr_unlocked>:
{
  11d8b0:	55                   	push   %ebp
  11d8b1:	89 e5                	mov    %esp,%ebp
  11d8b3:	57                   	push   %edi
  11d8b4:	56                   	push   %esi
  11d8b5:	83 ec 18             	sub    $0x18,%esp
  11d8b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  11d8bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11d8be:	9c                   	pushf  
  11d8bf:	fa                   	cli    
  11d8c0:	8f 45 f4             	popl   -0xc(%ebp)
	return key;
  11d8c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
  11d8c6:	8b 75 08             	mov    0x8(%ebp),%esi
  11d8c9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11d8cc:	89 14 24             	mov    %edx,(%esp)
  11d8cf:	89 74 24 04          	mov    %esi,0x4(%esp)
  11d8d3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  11d8d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11d8da:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11d8dd:	e8 0e 13 00 00       	call   11ebf0 <z_pend_curr_irqlock>
}
  11d8e2:	83 c4 18             	add    $0x18,%esp
  11d8e5:	5e                   	pop    %esi
  11d8e6:	5f                   	pop    %edi
  11d8e7:	5d                   	pop    %ebp
  11d8e8:	c3                   	ret    
  11d8e9:	66 90                	xchg   %ax,%ax
  11d8eb:	66 90                	xchg   %ax,%ax
  11d8ed:	66 90                	xchg   %ax,%ax
  11d8ef:	90                   	nop

0011d8f0 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
  11d8f0:	55                   	push   %ebp
  11d8f1:	89 e5                	mov    %esp,%ebp
  11d8f3:	83 e4 f8             	and    $0xfffffff8,%esp
  11d8f6:	83 ec 38             	sub    $0x38,%esp
  11d8f9:	8b 45 08             	mov    0x8(%ebp),%eax
	int need_sched = 0;
  11d8fc:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  11d903:	00 
	struct k_mem_pool *p = get_pool(id->pool);
  11d904:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d907:	8b 09                	mov    (%ecx),%ecx
  11d909:	81 e1 ff 00 00 00    	and    $0xff,%ecx
  11d90f:	89 0c 24             	mov    %ecx,(%esp)
  11d912:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11d916:	e8 c5 00 00 00       	call   11d9e0 <get_pool>
  11d91b:	89 44 24 18          	mov    %eax,0x18(%esp)

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
  11d91f:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d923:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11d926:	8b 09                	mov    (%ecx),%ecx
  11d928:	c1 e9 08             	shr    $0x8,%ecx
  11d92b:	83 e1 0f             	and    $0xf,%ecx
  11d92e:	8b 55 08             	mov    0x8(%ebp),%edx
  11d931:	8b 12                	mov    (%edx),%edx
  11d933:	c1 ea 0c             	shr    $0xc,%edx
  11d936:	89 04 24             	mov    %eax,(%esp)
  11d939:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11d93d:	89 54 24 08          	mov    %edx,0x8(%esp)
  11d941:	e8 0a 32 fe ff       	call   100b50 <z_sys_mem_pool_block_free>
  11d946:	8d 44 24 10          	lea    0x10(%esp),%eax
  11d94a:	89 44 24 24          	mov    %eax,0x24(%esp)
  11d94e:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11d954:	89 44 24 20          	mov    %eax,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11d958:	9c                   	pushf  
  11d959:	fa                   	cli    
  11d95a:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  11d95e:	8b 44 24 28          	mov    0x28(%esp),%eax
	k.key = arch_irq_lock();
  11d962:	89 44 24 10          	mov    %eax,0x10(%esp)
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
  11d966:	8b 44 24 18          	mov    0x18(%esp),%eax
  11d96a:	83 c0 14             	add    $0x14,%eax
  11d96d:	89 04 24             	mov    %eax,(%esp)
  11d970:	e8 ab 1a 00 00       	call   11f420 <z_unpend_all>
  11d975:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	if (need_sched != 0) {
  11d979:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  11d97e:	0f 84 1b 00 00 00    	je     11d99f <k_mem_pool_free_id+0xaf>
		z_reschedule(&lock, key);
  11d984:	8b 44 24 10          	mov    0x10(%esp),%eax
  11d988:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  11d98e:	89 0c 24             	mov    %ecx,(%esp)
  11d991:	89 44 24 04          	mov    %eax,0x4(%esp)
  11d995:	e8 c6 16 00 00       	call   11f060 <z_reschedule>
	} else {
  11d99a:	e9 32 00 00 00       	jmp    11d9d1 <k_mem_pool_free_id+0xe1>
		k_spin_unlock(&lock, key);
  11d99f:	8b 44 24 10          	mov    0x10(%esp),%eax
  11d9a3:	89 44 24 30          	mov    %eax,0x30(%esp)
  11d9a7:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11d9ad:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  11d9b1:	8b 44 24 30          	mov    0x30(%esp),%eax
  11d9b5:	89 44 24 34          	mov    %eax,0x34(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11d9b9:	8b 44 24 34          	mov    0x34(%esp),%eax
  11d9bd:	25 00 02 00 00       	and    $0x200,%eax
  11d9c2:	83 f8 00             	cmp    $0x0,%eax
  11d9c5:	0f 84 01 00 00 00    	je     11d9cc <k_mem_pool_free_id+0xdc>
		__asm__ volatile ("sti" ::: "memory");
  11d9cb:	fb                   	sti    
  11d9cc:	e9 00 00 00 00       	jmp    11d9d1 <k_mem_pool_free_id+0xe1>
	}
}
  11d9d1:	89 ec                	mov    %ebp,%esp
  11d9d3:	5d                   	pop    %ebp
  11d9d4:	c3                   	ret    
  11d9d5:	66 90                	xchg   %ax,%ax
  11d9d7:	66 90                	xchg   %ax,%ax
  11d9d9:	66 90                	xchg   %ax,%ax
  11d9db:	66 90                	xchg   %ax,%ax
  11d9dd:	66 90                	xchg   %ax,%ax
  11d9df:	90                   	nop

0011d9e0 <get_pool>:
{
  11d9e0:	55                   	push   %ebp
  11d9e1:	89 e5                	mov    %esp,%ebp
  11d9e3:	50                   	push   %eax
  11d9e4:	8b 45 08             	mov    0x8(%ebp),%eax
	return &_k_mem_pool_list_start[id];
  11d9e7:	6b 4d 08 24          	imul   $0x24,0x8(%ebp),%ecx
  11d9eb:	8d 15 38 34 14 00    	lea    0x143438,%edx
  11d9f1:	01 ca                	add    %ecx,%edx
  11d9f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11d9f6:	89 d0                	mov    %edx,%eax
  11d9f8:	83 c4 04             	add    $0x4,%esp
  11d9fb:	5d                   	pop    %ebp
  11d9fc:	c3                   	ret    
  11d9fd:	66 90                	xchg   %ax,%ax
  11d9ff:	90                   	nop

0011da00 <k_mem_pool_malloc>:
{
	k_mem_pool_free_id(&block->id);
}

void *k_mem_pool_malloc(struct k_mem_pool *pool, size_t size)
{
  11da00:	55                   	push   %ebp
  11da01:	89 e5                	mov    %esp,%ebp
  11da03:	83 e4 f8             	and    $0xfffffff8,%esp
  11da06:	83 ec 30             	sub    $0x30,%esp
  11da09:	8b 45 0c             	mov    0xc(%ebp),%eax
  11da0c:	8b 4d 08             	mov    0x8(%ebp),%ecx

	/*
	 * get a block large enough to hold an initial (hidden) block
	 * descriptor, as well as the space the caller requested
	 */
	if (size_add_overflow(size, WB_UP(sizeof(struct k_mem_block_id)),
  11da0f:	8b 55 0c             	mov    0xc(%ebp),%edx
  11da12:	89 14 24             	mov    %edx,(%esp)
  11da15:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  11da1c:	00 
  11da1d:	8d 55 0c             	lea    0xc(%ebp),%edx
  11da20:	89 54 24 08          	mov    %edx,0x8(%esp)
  11da24:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11da28:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  11da2c:	e8 8f 00 00 00       	call   11dac0 <size_add_overflow>
  11da31:	a8 01                	test   $0x1,%al
  11da33:	0f 85 05 00 00 00    	jne    11da3e <k_mem_pool_malloc+0x3e>
  11da39:	e9 0d 00 00 00       	jmp    11da4b <k_mem_pool_malloc+0x4b>
			      &size)) {
		return NULL;
  11da3e:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11da45:	00 
  11da46:	e9 68 00 00 00       	jmp    11dab3 <k_mem_pool_malloc+0xb3>
  11da4b:	31 c0                	xor    %eax,%eax
	}
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
  11da4d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11da50:	8b 55 0c             	mov    0xc(%ebp),%edx
  11da53:	89 0c 24             	mov    %ecx,(%esp)
  11da56:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  11da5a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11da5e:	89 54 24 08          	mov    %edx,0x8(%esp)
  11da62:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  11da69:	00 
  11da6a:	89 44 24 14          	mov    %eax,0x14(%esp)
  11da6e:	e8 8d fc ff ff       	call   11d700 <k_mem_pool_alloc>
  11da73:	83 f8 00             	cmp    $0x0,%eax
  11da76:	0f 84 0d 00 00 00    	je     11da89 <k_mem_pool_malloc+0x89>
		return NULL;
  11da7c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11da83:	00 
  11da84:	e9 2a 00 00 00       	jmp    11dab3 <k_mem_pool_malloc+0xb3>
	}

	/* save the block descriptor info at the start of the actual block */
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
  11da89:	8b 44 24 20          	mov    0x20(%esp),%eax
  11da8d:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  11da91:	83 c1 04             	add    $0x4,%ecx
  11da94:	89 04 24             	mov    %eax,(%esp)
  11da97:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11da9b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11daa2:	00 
  11daa3:	e8 a8 c8 fe ff       	call   10a350 <memcpy>

	/* return address of the user area part of the block to the caller */
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
  11daa8:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  11daac:	83 c1 04             	add    $0x4,%ecx
  11daaf:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
}
  11dab3:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  11dab7:	89 ec                	mov    %ebp,%esp
  11dab9:	5d                   	pop    %ebp
  11daba:	c3                   	ret    
  11dabb:	66 90                	xchg   %ax,%ax
  11dabd:	66 90                	xchg   %ax,%ax
  11dabf:	90                   	nop

0011dac0 <size_add_overflow>:
{
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
  11dac0:	55                   	push   %ebp
  11dac1:	89 e5                	mov    %esp,%ebp
  11dac3:	53                   	push   %ebx
  11dac4:	57                   	push   %edi
  11dac5:	56                   	push   %esi
  11dac6:	50                   	push   %eax
  11dac7:	8b 45 10             	mov    0x10(%ebp),%eax
  11daca:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11dacd:	8b 55 08             	mov    0x8(%ebp),%edx
	return __builtin_add_overflow(a, b, result);
  11dad0:	8b 75 08             	mov    0x8(%ebp),%esi
  11dad3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11dad6:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11dad9:	01 fe                	add    %edi,%esi
  11dadb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11dade:	0f 92 c0             	setb   %al
  11dae1:	89 33                	mov    %esi,(%ebx)
  11dae3:	24 01                	and    $0x1,%al
  11dae5:	0f b6 c0             	movzbl %al,%eax
  11dae8:	83 c4 04             	add    $0x4,%esp
  11daeb:	5e                   	pop    %esi
  11daec:	5f                   	pop    %edi
  11daed:	5b                   	pop    %ebx
  11daee:	5d                   	pop    %ebp
  11daef:	c3                   	ret    

0011daf0 <k_free>:

void k_free(void *ptr)
{
  11daf0:	55                   	push   %ebp
  11daf1:	89 e5                	mov    %esp,%ebp
  11daf3:	50                   	push   %eax
  11daf4:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ptr != NULL) {
  11daf7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11dafb:	0f 84 14 00 00 00    	je     11db15 <k_free+0x25>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - WB_UP(sizeof(struct k_mem_block_id));
  11db01:	8b 45 08             	mov    0x8(%ebp),%eax
  11db04:	83 c0 fc             	add    $0xfffffffc,%eax
  11db07:	89 45 08             	mov    %eax,0x8(%ebp)

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
  11db0a:	8b 45 08             	mov    0x8(%ebp),%eax
  11db0d:	89 04 24             	mov    %eax,(%esp)
  11db10:	e8 db fd ff ff       	call   11d8f0 <k_mem_pool_free_id>
	}
}
  11db15:	83 c4 04             	add    $0x4,%esp
  11db18:	5d                   	pop    %ebp
  11db19:	c3                   	ret    
  11db1a:	66 90                	xchg   %ax,%ax
  11db1c:	66 90                	xchg   %ax,%ax
  11db1e:	66 90                	xchg   %ax,%ax

0011db20 <k_malloc>:
K_MEM_POOL_DEFINE(_heap_mem_pool, CONFIG_HEAP_MEM_POOL_MIN_SIZE,
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
  11db20:	55                   	push   %ebp
  11db21:	89 e5                	mov    %esp,%ebp
  11db23:	83 ec 0c             	sub    $0xc,%esp
  11db26:	8b 45 08             	mov    0x8(%ebp),%eax
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
  11db29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11db2c:	8d 15 38 34 14 00    	lea    0x143438,%edx
  11db32:	89 14 24             	mov    %edx,(%esp)
  11db35:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11db39:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11db3c:	e8 bf fe ff ff       	call   11da00 <k_mem_pool_malloc>
  11db41:	83 c4 0c             	add    $0xc,%esp
  11db44:	5d                   	pop    %ebp
  11db45:	c3                   	ret    
  11db46:	66 90                	xchg   %ax,%ax
  11db48:	66 90                	xchg   %ax,%ax
  11db4a:	66 90                	xchg   %ax,%ax
  11db4c:	66 90                	xchg   %ax,%ax
  11db4e:	66 90                	xchg   %ax,%ax

0011db50 <z_waitq_init>:
{
  11db50:	55                   	push   %ebp
  11db51:	89 e5                	mov    %esp,%ebp
  11db53:	83 e4 f8             	and    $0xfffffff8,%esp
  11db56:	83 ec 10             	sub    $0x10,%esp
  11db59:	8b 45 08             	mov    0x8(%ebp),%eax
	w->waitq = (struct _priq_rb) {
  11db5c:	8b 4d 08             	mov    0x8(%ebp),%ecx
		.tree = {
  11db5f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11db66:	8d 15 30 f3 11 00    	lea    0x11f330,%edx
  11db6c:	89 54 24 04          	mov    %edx,0x4(%esp)
  11db70:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  11db77:	00 
	w->waitq = (struct _priq_rb) {
  11db78:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  11db7f:	00 
  11db80:	8b 14 24             	mov    (%esp),%edx
  11db83:	89 11                	mov    %edx,(%ecx)
  11db85:	8b 54 24 04          	mov    0x4(%esp),%edx
  11db89:	89 51 04             	mov    %edx,0x4(%ecx)
  11db8c:	8b 54 24 08          	mov    0x8(%esp),%edx
  11db90:	89 51 08             	mov    %edx,0x8(%ecx)
  11db93:	8b 54 24 0c          	mov    0xc(%esp),%edx
  11db97:	89 51 0c             	mov    %edx,0xc(%ecx)
}
  11db9a:	89 ec                	mov    %ebp,%esp
  11db9c:	5d                   	pop    %ebp
  11db9d:	c3                   	ret    
  11db9e:	66 90                	xchg   %ax,%ax

0011dba0 <z_is_t1_higher_prio_than_t2>:
	return (thread->base.thread_state & _THREAD_DUMMY) != 0U;
}
#endif

bool z_is_t1_higher_prio_than_t2(struct k_thread *t1, struct k_thread *t2)
{
  11dba0:	55                   	push   %ebp
  11dba1:	89 e5                	mov    %esp,%ebp
  11dba3:	56                   	push   %esi
  11dba4:	50                   	push   %eax
  11dba5:	8b 45 0c             	mov    0xc(%ebp),%eax
  11dba8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (t1->base.prio < t2->base.prio) {
  11dbab:	8b 55 08             	mov    0x8(%ebp),%edx
  11dbae:	0f be 52 0e          	movsbl 0xe(%edx),%edx
  11dbb2:	8b 75 0c             	mov    0xc(%ebp),%esi
  11dbb5:	0f be 76 0e          	movsbl 0xe(%esi),%esi
  11dbb9:	39 f2                	cmp    %esi,%edx
  11dbbb:	0f 8d 09 00 00 00    	jge    11dbca <z_is_t1_higher_prio_than_t2+0x2a>
		return true;
  11dbc1:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
  11dbc5:	e9 04 00 00 00       	jmp    11dbce <z_is_t1_higher_prio_than_t2+0x2e>

		return dt1 < dt2;
	}
#endif

	return false;
  11dbca:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
}
  11dbce:	8a 45 fb             	mov    -0x5(%ebp),%al
  11dbd1:	24 01                	and    $0x1,%al
  11dbd3:	0f b6 c0             	movzbl %al,%eax
  11dbd6:	83 c4 04             	add    $0x4,%esp
  11dbd9:	5e                   	pop    %esi
  11dbda:	5d                   	pop    %ebp
  11dbdb:	c3                   	ret    
  11dbdc:	66 90                	xchg   %ax,%ax
  11dbde:	66 90                	xchg   %ax,%ax

0011dbe0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
  11dbe0:	55                   	push   %ebp
  11dbe1:	89 e5                	mov    %esp,%ebp
  11dbe3:	83 ec 10             	sub    $0x10,%esp
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
  11dbe6:	83 3d a4 96 13 00 00 	cmpl   $0x0,0x1396a4
  11dbed:	0f 84 32 00 00 00    	je     11dc25 <z_reset_time_slice+0x45>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  11dbf3:	a1 a4 96 13 00       	mov    0x1396a4,%eax
  11dbf8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11dbfb:	e8 40 a0 fe ff       	call   107c40 <z_clock_elapsed>
  11dc00:	31 c9                	xor    %ecx,%ecx
  11dc02:	8b 55 fc             	mov    -0x4(%ebp),%edx
  11dc05:	01 c2                	add    %eax,%edx
  11dc07:	89 15 b8 96 13 00    	mov    %edx,0x1396b8
		z_set_timeout_expiry(slice_time, false);
  11dc0d:	a1 a4 96 13 00       	mov    0x1396a4,%eax
  11dc12:	89 04 24             	mov    %eax,(%esp)
  11dc15:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11dc1c:	00 
  11dc1d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11dc20:	e8 2b 3a 00 00       	call   121650 <z_set_timeout_expiry>
	}
}
  11dc25:	83 c4 10             	add    $0x10,%esp
  11dc28:	5d                   	pop    %ebp
  11dc29:	c3                   	ret    
  11dc2a:	66 90                	xchg   %ax,%ax
  11dc2c:	66 90                	xchg   %ax,%ax
  11dc2e:	66 90                	xchg   %ax,%ax

0011dc30 <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
  11dc30:	55                   	push   %ebp
  11dc31:	89 e5                	mov    %esp,%ebp
  11dc33:	56                   	push   %esi
  11dc34:	83 e4 f8             	and    $0xfffffff8,%esp
  11dc37:	83 ec 48             	sub    $0x48,%esp
  11dc3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11dc3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11dc40:	31 d2                	xor    %edx,%edx
	LOCKED(&sched_spinlock) {
  11dc42:	8d 74 24 20          	lea    0x20(%esp),%esi
  11dc46:	89 34 24             	mov    %esi,(%esp)
  11dc49:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11dc50:	00 
  11dc51:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11dc58:	00 
  11dc59:	89 44 24 14          	mov    %eax,0x14(%esp)
  11dc5d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11dc61:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11dc65:	e8 06 c8 fe ff       	call   10a470 <memset>
  11dc6a:	8d 44 24 18          	lea    0x18(%esp),%eax
  11dc6e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11dc72:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11dc78:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11dc7c:	9c                   	pushf  
  11dc7d:	fa                   	cli    
  11dc7e:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11dc82:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11dc86:	89 44 24 18          	mov    %eax,0x18(%esp)
  11dc8a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11dc8f:	0f 95 c0             	setne  %al
  11dc92:	34 ff                	xor    $0xff,%al
  11dc94:	a8 01                	test   $0x1,%al
  11dc96:	0f 85 05 00 00 00    	jne    11dca1 <k_sched_time_slice_set+0x71>
  11dc9c:	e9 61 00 00 00       	jmp    11dd02 <k_sched_time_slice_set+0xd2>
		_current_cpu->slice_ticks = 0;
  11dca1:	c7 05 b8 96 13 00 00 	movl   $0x0,0x1396b8
  11dca8:	00 00 00 
		slice_time = k_ms_to_ticks_ceil32(slice);
  11dcab:	8b 45 08             	mov    0x8(%ebp),%eax
  11dcae:	89 04 24             	mov    %eax,(%esp)
  11dcb1:	e8 5a 00 00 00       	call   11dd10 <k_ms_to_ticks_ceil32>
  11dcb6:	a3 a4 96 13 00       	mov    %eax,0x1396a4
		slice_max_prio = prio;
  11dcbb:	8b 45 0c             	mov    0xc(%ebp),%eax
  11dcbe:	a3 dc 96 13 00       	mov    %eax,0x1396dc
		z_reset_time_slice();
  11dcc3:	e8 18 ff ff ff       	call   11dbe0 <z_reset_time_slice>
	LOCKED(&sched_spinlock) {
  11dcc8:	8b 44 24 18          	mov    0x18(%esp),%eax
  11dccc:	89 44 24 38          	mov    %eax,0x38(%esp)
  11dcd0:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11dcd6:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11dcda:	8b 44 24 38          	mov    0x38(%esp),%eax
  11dcde:	89 44 24 40          	mov    %eax,0x40(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11dce2:	8b 44 24 40          	mov    0x40(%esp),%eax
  11dce6:	25 00 02 00 00       	and    $0x200,%eax
  11dceb:	83 f8 00             	cmp    $0x0,%eax
  11dcee:	0f 84 01 00 00 00    	je     11dcf5 <k_sched_time_slice_set+0xc5>
		__asm__ volatile ("sti" ::: "memory");
  11dcf4:	fb                   	sti    
  11dcf5:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11dcfc:	00 
  11dcfd:	e9 88 ff ff ff       	jmp    11dc8a <k_sched_time_slice_set+0x5a>
	}
}
  11dd02:	8d 65 fc             	lea    -0x4(%ebp),%esp
  11dd05:	5e                   	pop    %esi
  11dd06:	5d                   	pop    %ebp
  11dd07:	c3                   	ret    
  11dd08:	66 90                	xchg   %ax,%ax
  11dd0a:	66 90                	xchg   %ax,%ax
  11dd0c:	66 90                	xchg   %ax,%ax
  11dd0e:	66 90                	xchg   %ax,%ax

0011dd10 <k_ms_to_ticks_ceil32>:
 * Rounds up to the next highest output unit.
 *
 * @return The converted time value
 */
static inline u32_t k_ms_to_ticks_ceil32(u32_t t)
{
  11dd10:	55                   	push   %ebp
  11dd11:	89 e5                	mov    %esp,%ebp
  11dd13:	57                   	push   %edi
  11dd14:	56                   	push   %esi
  11dd15:	83 e4 f8             	and    $0xfffffff8,%esp
  11dd18:	83 ec 70             	sub    $0x70,%esp
  11dd1b:	8b 45 08             	mov    0x8(%ebp),%eax
  11dd1e:	31 c9                	xor    %ecx,%ecx
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  11dd20:	8b 55 08             	mov    0x8(%ebp),%edx
  11dd23:	89 54 24 60          	mov    %edx,0x60(%esp)
  11dd27:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  11dd2e:	00 
  11dd2f:	c7 44 24 5c e8 03 00 	movl   $0x3e8,0x5c(%esp)
  11dd36:	00 
  11dd37:	c7 44 24 58 64 00 00 	movl   $0x64,0x58(%esp)
  11dd3e:	00 
  11dd3f:	c6 44 24 57 01       	movb   $0x1,0x57(%esp)
  11dd44:	c6 44 24 56 01       	movb   $0x1,0x56(%esp)
  11dd49:	c6 44 24 55 01       	movb   $0x1,0x55(%esp)
  11dd4e:	c6 44 24 54 00       	movb   $0x0,0x54(%esp)
	bool mul_ratio = const_hz &&
  11dd53:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  11dd58:	88 4c 24 43          	mov    %cl,0x43(%esp)
  11dd5c:	0f 84 28 00 00 00    	je     11dd8a <k_ms_to_ticks_ceil32+0x7a>
  11dd62:	31 c0                	xor    %eax,%eax
		(to_hz > from_hz) && ((to_hz % from_hz) == 0);
  11dd64:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11dd68:	3b 4c 24 5c          	cmp    0x5c(%esp),%ecx
  11dd6c:	88 44 24 43          	mov    %al,0x43(%esp)
  11dd70:	0f 86 14 00 00 00    	jbe    11dd8a <k_ms_to_ticks_ceil32+0x7a>
  11dd76:	8b 44 24 58          	mov    0x58(%esp),%eax
  11dd7a:	31 d2                	xor    %edx,%edx
  11dd7c:	f7 74 24 5c          	divl   0x5c(%esp)
  11dd80:	83 fa 00             	cmp    $0x0,%edx
  11dd83:	0f 94 c1             	sete   %cl
  11dd86:	88 4c 24 43          	mov    %cl,0x43(%esp)
  11dd8a:	8a 44 24 43          	mov    0x43(%esp),%al
  11dd8e:	31 c9                	xor    %ecx,%ecx
	bool mul_ratio = const_hz &&
  11dd90:	24 01                	and    $0x1,%al
  11dd92:	88 44 24 53          	mov    %al,0x53(%esp)
	bool div_ratio = const_hz &&
  11dd96:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  11dd9b:	88 4c 24 42          	mov    %cl,0x42(%esp)
  11dd9f:	0f 84 28 00 00 00    	je     11ddcd <k_ms_to_ticks_ceil32+0xbd>
  11dda5:	31 c0                	xor    %eax,%eax
		(from_hz > to_hz) && ((from_hz % to_hz) == 0);
  11dda7:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11ddab:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  11ddaf:	88 44 24 42          	mov    %al,0x42(%esp)
  11ddb3:	0f 86 14 00 00 00    	jbe    11ddcd <k_ms_to_ticks_ceil32+0xbd>
  11ddb9:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11ddbd:	31 d2                	xor    %edx,%edx
  11ddbf:	f7 74 24 58          	divl   0x58(%esp)
  11ddc3:	83 fa 00             	cmp    $0x0,%edx
  11ddc6:	0f 94 c1             	sete   %cl
  11ddc9:	88 4c 24 42          	mov    %cl,0x42(%esp)
  11ddcd:	8a 44 24 42          	mov    0x42(%esp),%al
	bool div_ratio = const_hz &&
  11ddd1:	24 01                	and    $0x1,%al
  11ddd3:	88 44 24 52          	mov    %al,0x52(%esp)
	if (from_hz == to_hz) {
  11ddd7:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11dddb:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  11dddf:	0f 85 48 00 00 00    	jne    11de2d <k_ms_to_ticks_ceil32+0x11d>
		return result32 ? ((u32_t)t) : t;
  11dde5:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  11ddea:	0f 84 13 00 00 00    	je     11de03 <k_ms_to_ticks_ceil32+0xf3>
  11ddf0:	8b 44 24 60          	mov    0x60(%esp),%eax
  11ddf4:	31 c9                	xor    %ecx,%ecx
  11ddf6:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  11ddfa:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  11ddfe:	e9 15 00 00 00       	jmp    11de18 <k_ms_to_ticks_ceil32+0x108>
  11de03:	8b 44 24 60          	mov    0x60(%esp),%eax
  11de07:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11de0b:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  11de0f:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  11de13:	e9 00 00 00 00       	jmp    11de18 <k_ms_to_ticks_ceil32+0x108>
  11de18:	8b 44 24 38          	mov    0x38(%esp),%eax
  11de1c:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  11de20:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  11de24:	89 44 24 6c          	mov    %eax,0x6c(%esp)
  11de28:	e9 6b 02 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
	u64_t off = 0;
  11de2d:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  11de34:	00 
  11de35:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
  11de3c:	00 
	if (!mul_ratio) {
  11de3d:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  11de42:	0f 85 76 00 00 00    	jne    11debe <k_ms_to_ticks_ceil32+0x1ae>
		u32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
  11de48:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  11de4d:	0f 84 13 00 00 00    	je     11de66 <k_ms_to_ticks_ceil32+0x156>
  11de53:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11de57:	31 d2                	xor    %edx,%edx
  11de59:	f7 74 24 58          	divl   0x58(%esp)
  11de5d:	89 44 24 34          	mov    %eax,0x34(%esp)
  11de61:	e9 08 00 00 00       	jmp    11de6e <k_ms_to_ticks_ceil32+0x15e>
  11de66:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11de6a:	89 44 24 34          	mov    %eax,0x34(%esp)
  11de6e:	8b 44 24 34          	mov    0x34(%esp),%eax
  11de72:	89 44 24 44          	mov    %eax,0x44(%esp)
		if (round_up) {
  11de76:	f6 44 24 55 01       	testb  $0x1,0x55(%esp)
  11de7b:	0f 84 16 00 00 00    	je     11de97 <k_ms_to_ticks_ceil32+0x187>
			off = rdivisor - 1;
  11de81:	8b 44 24 44          	mov    0x44(%esp),%eax
  11de85:	48                   	dec    %eax
  11de86:	89 44 24 48          	mov    %eax,0x48(%esp)
  11de8a:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  11de91:	00 
		} else if (round_off) {
  11de92:	e9 22 00 00 00       	jmp    11deb9 <k_ms_to_ticks_ceil32+0x1a9>
  11de97:	f6 44 24 54 01       	testb  $0x1,0x54(%esp)
  11de9c:	0f 84 12 00 00 00    	je     11deb4 <k_ms_to_ticks_ceil32+0x1a4>
			off = rdivisor / 2;
  11dea2:	8b 44 24 44          	mov    0x44(%esp),%eax
  11dea6:	d1 e8                	shr    %eax
  11dea8:	89 44 24 48          	mov    %eax,0x48(%esp)
  11deac:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  11deb3:	00 
  11deb4:	e9 00 00 00 00       	jmp    11deb9 <k_ms_to_ticks_ceil32+0x1a9>
	}
  11deb9:	e9 00 00 00 00       	jmp    11debe <k_ms_to_ticks_ceil32+0x1ae>
	if (div_ratio) {
  11debe:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  11dec3:	0f 84 ad 00 00 00    	je     11df76 <k_ms_to_ticks_ceil32+0x266>
		t += off;
  11dec9:	8b 44 24 48          	mov    0x48(%esp),%eax
  11decd:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  11ded1:	8b 54 24 60          	mov    0x60(%esp),%edx
  11ded5:	8b 74 24 64          	mov    0x64(%esp),%esi
  11ded9:	01 c2                	add    %eax,%edx
  11dedb:	11 ce                	adc    %ecx,%esi
  11dedd:	89 54 24 60          	mov    %edx,0x60(%esp)
  11dee1:	89 74 24 64          	mov    %esi,0x64(%esp)
		if (result32) {
  11dee5:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  11deea:	0f 84 43 00 00 00    	je     11df33 <k_ms_to_ticks_ceil32+0x223>
			return ((u32_t)t) / (from_hz / to_hz);
  11def0:	8b 44 24 60          	mov    0x60(%esp),%eax
  11def4:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11def8:	8b 54 24 58          	mov    0x58(%esp),%edx
  11defc:	31 f6                	xor    %esi,%esi
  11defe:	89 44 24 30          	mov    %eax,0x30(%esp)
  11df02:	89 c8                	mov    %ecx,%eax
  11df04:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  11df08:	89 f2                	mov    %esi,%edx
  11df0a:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  11df0e:	f7 f1                	div    %ecx
  11df10:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  11df14:	89 44 24 28          	mov    %eax,0x28(%esp)
  11df18:	89 c8                	mov    %ecx,%eax
  11df1a:	89 f2                	mov    %esi,%edx
  11df1c:	8b 74 24 28          	mov    0x28(%esp),%esi
  11df20:	f7 f6                	div    %esi
  11df22:	89 44 24 68          	mov    %eax,0x68(%esp)
  11df26:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  11df2d:	00 
  11df2e:	e9 65 01 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
			return t / (from_hz / to_hz);
  11df33:	8b 44 24 60          	mov    0x60(%esp),%eax
  11df37:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11df3b:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  11df3f:	8b 74 24 58          	mov    0x58(%esp),%esi
  11df43:	31 ff                	xor    %edi,%edi
  11df45:	89 44 24 24          	mov    %eax,0x24(%esp)
  11df49:	89 d0                	mov    %edx,%eax
  11df4b:	89 fa                	mov    %edi,%edx
  11df4d:	f7 f6                	div    %esi
  11df4f:	89 e2                	mov    %esp,%edx
  11df51:	89 42 08             	mov    %eax,0x8(%edx)
  11df54:	89 4a 04             	mov    %ecx,0x4(%edx)
  11df57:	8b 44 24 24          	mov    0x24(%esp),%eax
  11df5b:	89 02                	mov    %eax,(%edx)
  11df5d:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  11df64:	e8 67 21 fe ff       	call   1000d0 <__udivdi3>
  11df69:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  11df6d:	89 44 24 68          	mov    %eax,0x68(%esp)
  11df71:	e9 22 01 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
	} else if (mul_ratio) {
  11df76:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  11df7b:	0f 84 81 00 00 00    	je     11e002 <k_ms_to_ticks_ceil32+0x2f2>
		if (result32) {
  11df81:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  11df86:	0f 84 38 00 00 00    	je     11dfc4 <k_ms_to_ticks_ceil32+0x2b4>
			return ((u32_t)t) * (to_hz / from_hz);
  11df8c:	8b 44 24 60          	mov    0x60(%esp),%eax
  11df90:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  11df94:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  11df98:	31 f6                	xor    %esi,%esi
  11df9a:	89 44 24 20          	mov    %eax,0x20(%esp)
  11df9e:	89 c8                	mov    %ecx,%eax
  11dfa0:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  11dfa4:	89 f2                	mov    %esi,%edx
  11dfa6:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11dfaa:	f7 f1                	div    %ecx
  11dfac:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  11dfb0:	0f af c8             	imul   %eax,%ecx
  11dfb3:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  11dfb7:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  11dfbe:	00 
  11dfbf:	e9 d4 00 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
			return t * (to_hz / from_hz);
  11dfc4:	8b 44 24 60          	mov    0x60(%esp),%eax
  11dfc8:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11dfcc:	8b 54 24 58          	mov    0x58(%esp),%edx
  11dfd0:	8b 74 24 5c          	mov    0x5c(%esp),%esi
  11dfd4:	31 ff                	xor    %edi,%edi
  11dfd6:	89 44 24 18          	mov    %eax,0x18(%esp)
  11dfda:	89 d0                	mov    %edx,%eax
  11dfdc:	89 fa                	mov    %edi,%edx
  11dfde:	f7 f6                	div    %esi
  11dfe0:	0f af c8             	imul   %eax,%ecx
  11dfe3:	8b 54 24 18          	mov    0x18(%esp),%edx
  11dfe7:	89 44 24 14          	mov    %eax,0x14(%esp)
  11dfeb:	89 d0                	mov    %edx,%eax
  11dfed:	8b 74 24 14          	mov    0x14(%esp),%esi
  11dff1:	f7 e6                	mul    %esi
  11dff3:	01 ca                	add    %ecx,%edx
  11dff5:	89 44 24 68          	mov    %eax,0x68(%esp)
  11dff9:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  11dffd:	e9 96 00 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
		if (result32) {
  11e002:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  11e007:	0f 84 4a 00 00 00    	je     11e057 <k_ms_to_ticks_ceil32+0x347>
			return (u32_t)((t * to_hz + off) / from_hz);
  11e00d:	8b 44 24 60          	mov    0x60(%esp),%eax
  11e011:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11e015:	8b 54 24 58          	mov    0x58(%esp),%edx
  11e019:	0f af ca             	imul   %edx,%ecx
  11e01c:	f7 e2                	mul    %edx
  11e01e:	01 ca                	add    %ecx,%edx
  11e020:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  11e024:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  11e028:	01 c8                	add    %ecx,%eax
  11e02a:	11 f2                	adc    %esi,%edx
  11e02c:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11e030:	89 e6                	mov    %esp,%esi
  11e032:	89 4e 08             	mov    %ecx,0x8(%esi)
  11e035:	89 06                	mov    %eax,(%esi)
  11e037:	89 56 04             	mov    %edx,0x4(%esi)
  11e03a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  11e041:	e8 8a 20 fe ff       	call   1000d0 <__udivdi3>
  11e046:	89 44 24 68          	mov    %eax,0x68(%esp)
  11e04a:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  11e051:	00 
  11e052:	e9 41 00 00 00       	jmp    11e098 <k_ms_to_ticks_ceil32+0x388>
			return (t * to_hz + off) / from_hz;
  11e057:	8b 44 24 60          	mov    0x60(%esp),%eax
  11e05b:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11e05f:	8b 54 24 58          	mov    0x58(%esp),%edx
  11e063:	0f af ca             	imul   %edx,%ecx
  11e066:	f7 e2                	mul    %edx
  11e068:	01 ca                	add    %ecx,%edx
  11e06a:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  11e06e:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  11e072:	01 c8                	add    %ecx,%eax
  11e074:	11 f2                	adc    %esi,%edx
  11e076:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11e07a:	89 e6                	mov    %esp,%esi
  11e07c:	89 4e 08             	mov    %ecx,0x8(%esi)
  11e07f:	89 06                	mov    %eax,(%esi)
  11e081:	89 56 04             	mov    %edx,0x4(%esi)
  11e084:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  11e08b:	e8 40 20 fe ff       	call   1000d0 <__udivdi3>
  11e090:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  11e094:	89 44 24 68          	mov    %eax,0x68(%esp)
}
  11e098:	8b 44 24 68          	mov    0x68(%esp),%eax
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  11e09c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11e09f:	5e                   	pop    %esi
  11e0a0:	5f                   	pop    %edi
  11e0a1:	5d                   	pop    %ebp
  11e0a2:	c3                   	ret    
  11e0a3:	66 90                	xchg   %ax,%ax
  11e0a5:	66 90                	xchg   %ax,%ax
  11e0a7:	66 90                	xchg   %ax,%ax
  11e0a9:	66 90                	xchg   %ax,%ax
  11e0ab:	66 90                	xchg   %ax,%ax
  11e0ad:	66 90                	xchg   %ax,%ax
  11e0af:	90                   	nop

0011e0b0 <z_time_slice>:
		&& !z_is_thread_timeout_active(t);
}

/* Called out of each timer interrupt */
void z_time_slice(int ticks)
{
  11e0b0:	55                   	push   %ebp
  11e0b1:	89 e5                	mov    %esp,%ebp
  11e0b3:	50                   	push   %eax
  11e0b4:	8b 45 08             	mov    0x8(%ebp),%eax
		return;
	}
	pending_current = NULL;
#endif

	if (slice_time && sliceable(_current)) {
  11e0b7:	83 3d a4 96 13 00 00 	cmpl   $0x0,0x1396a4
  11e0be:	0f 84 52 00 00 00    	je     11e116 <z_time_slice+0x66>
  11e0c4:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11e0c9:	89 04 24             	mov    %eax,(%esp)
  11e0cc:	e8 5f 00 00 00       	call   11e130 <sliceable>
  11e0d1:	83 f8 00             	cmp    $0x0,%eax
  11e0d4:	0f 84 3c 00 00 00    	je     11e116 <z_time_slice+0x66>
		if (ticks >= _current_cpu->slice_ticks) {
  11e0da:	8b 45 08             	mov    0x8(%ebp),%eax
  11e0dd:	3b 05 b8 96 13 00    	cmp    0x1396b8,%eax
  11e0e3:	0f 8c 17 00 00 00    	jl     11e100 <z_time_slice+0x50>
			z_move_thread_to_end_of_prio_q(_current);
  11e0e9:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11e0ee:	89 04 24             	mov    %eax,(%esp)
  11e0f1:	e8 ba 00 00 00       	call   11e1b0 <z_move_thread_to_end_of_prio_q>
			z_reset_time_slice();
  11e0f6:	e8 e5 fa ff ff       	call   11dbe0 <z_reset_time_slice>
		} else {
  11e0fb:	e9 11 00 00 00       	jmp    11e111 <z_time_slice+0x61>
			_current_cpu->slice_ticks -= ticks;
  11e100:	8b 45 08             	mov    0x8(%ebp),%eax
  11e103:	8b 0d b8 96 13 00    	mov    0x1396b8,%ecx
  11e109:	29 c1                	sub    %eax,%ecx
  11e10b:	89 0d b8 96 13 00    	mov    %ecx,0x1396b8
		}
	} else {
  11e111:	e9 0a 00 00 00       	jmp    11e120 <z_time_slice+0x70>
		_current_cpu->slice_ticks = 0;
  11e116:	c7 05 b8 96 13 00 00 	movl   $0x0,0x1396b8
  11e11d:	00 00 00 
	}
}
  11e120:	83 c4 04             	add    $0x4,%esp
  11e123:	5d                   	pop    %ebp
  11e124:	c3                   	ret    
  11e125:	66 90                	xchg   %ax,%ax
  11e127:	66 90                	xchg   %ax,%ax
  11e129:	66 90                	xchg   %ax,%ax
  11e12b:	66 90                	xchg   %ax,%ax
  11e12d:	66 90                	xchg   %ax,%ax
  11e12f:	90                   	nop

0011e130 <sliceable>:
{
  11e130:	55                   	push   %ebp
  11e131:	89 e5                	mov    %esp,%ebp
  11e133:	83 ec 10             	sub    $0x10,%esp
  11e136:	8b 45 08             	mov    0x8(%ebp),%eax
	return is_preempt(t)
  11e139:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e13c:	89 0c 24             	mov    %ecx,(%esp)
  11e13f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11e142:	e8 b9 1a 00 00       	call   11fc00 <is_preempt>
  11e147:	31 c9                	xor    %ecx,%ecx
  11e149:	83 f8 00             	cmp    $0x0,%eax
  11e14c:	88 4d fb             	mov    %cl,-0x5(%ebp)
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
  11e14f:	0f 84 4e 00 00 00    	je     11e1a3 <sliceable+0x73>
  11e155:	8b 45 08             	mov    0x8(%ebp),%eax
  11e158:	0f be 40 0e          	movsbl 0xe(%eax),%eax
  11e15c:	8b 0d dc 96 13 00    	mov    0x1396dc,%ecx
  11e162:	89 04 24             	mov    %eax,(%esp)
  11e165:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e169:	e8 c2 1a 00 00       	call   11fc30 <z_is_prio_higher>
  11e16e:	31 c9                	xor    %ecx,%ecx
		&& !z_is_idle_thread_object(t)
  11e170:	a8 01                	test   $0x1,%al
  11e172:	88 4d fb             	mov    %cl,-0x5(%ebp)
  11e175:	0f 85 28 00 00 00    	jne    11e1a3 <sliceable+0x73>
  11e17b:	8b 45 08             	mov    0x8(%ebp),%eax
  11e17e:	89 04 24             	mov    %eax,(%esp)
  11e181:	e8 ba 14 00 00       	call   11f640 <z_is_idle_thread_object>
  11e186:	31 c9                	xor    %ecx,%ecx
		&& !z_is_thread_timeout_active(t);
  11e188:	a8 01                	test   $0x1,%al
  11e18a:	88 4d fb             	mov    %cl,-0x5(%ebp)
  11e18d:	0f 85 10 00 00 00    	jne    11e1a3 <sliceable+0x73>
  11e193:	8b 45 08             	mov    0x8(%ebp),%eax
  11e196:	89 04 24             	mov    %eax,(%esp)
  11e199:	e8 c2 1a 00 00       	call   11fc60 <z_is_thread_timeout_active>
  11e19e:	34 ff                	xor    $0xff,%al
  11e1a0:	88 45 fb             	mov    %al,-0x5(%ebp)
  11e1a3:	8a 45 fb             	mov    -0x5(%ebp),%al
  11e1a6:	24 01                	and    $0x1,%al
  11e1a8:	0f b6 c0             	movzbl %al,%eax
	return is_preempt(t)
  11e1ab:	83 c4 10             	add    $0x10,%esp
  11e1ae:	5d                   	pop    %ebp
  11e1af:	c3                   	ret    

0011e1b0 <z_move_thread_to_end_of_prio_q>:
#endif
	}
}

void z_move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  11e1b0:	55                   	push   %ebp
  11e1b1:	89 e5                	mov    %esp,%ebp
  11e1b3:	83 e4 f8             	and    $0xfffffff8,%esp
  11e1b6:	83 ec 40             	sub    $0x40,%esp
  11e1b9:	8b 45 08             	mov    0x8(%ebp),%eax
  11e1bc:	31 c9                	xor    %ecx,%ecx
	LOCKED(&sched_spinlock) {
  11e1be:	8d 54 24 20          	lea    0x20(%esp),%edx
  11e1c2:	89 14 24             	mov    %edx,(%esp)
  11e1c5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11e1cc:	00 
  11e1cd:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11e1d4:	00 
  11e1d5:	89 44 24 14          	mov    %eax,0x14(%esp)
  11e1d9:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11e1dd:	e8 8e c2 fe ff       	call   10a470 <memset>
  11e1e2:	8d 44 24 18          	lea    0x18(%esp),%eax
  11e1e6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11e1ea:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e1f0:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11e1f4:	9c                   	pushf  
  11e1f5:	fa                   	cli    
  11e1f6:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11e1fa:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11e1fe:	89 44 24 18          	mov    %eax,0x18(%esp)
  11e202:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11e207:	0f 95 c0             	setne  %al
  11e20a:	34 ff                	xor    $0xff,%al
  11e20c:	a8 01                	test   $0x1,%al
  11e20e:	0f 85 05 00 00 00    	jne    11e219 <z_move_thread_to_end_of_prio_q+0x69>
  11e214:	e9 a7 00 00 00       	jmp    11e2c0 <z_move_thread_to_end_of_prio_q+0x110>
		if (z_is_thread_queued(thread)) {
  11e219:	8b 45 08             	mov    0x8(%ebp),%eax
  11e21c:	89 04 24             	mov    %eax,(%esp)
  11e21f:	e8 cc 03 00 00       	call   11e5f0 <z_is_thread_queued>
  11e224:	a8 01                	test   $0x1,%al
  11e226:	0f 85 05 00 00 00    	jne    11e231 <z_move_thread_to_end_of_prio_q+0x81>
  11e22c:	e9 18 00 00 00       	jmp    11e249 <z_move_thread_to_end_of_prio_q+0x99>
  11e231:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11e237:	83 c0 24             	add    $0x24,%eax
			_priq_run_remove(&_kernel.ready_q.runq, thread);
  11e23a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e23d:	89 04 24             	mov    %eax,(%esp)
  11e240:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e244:	e8 d7 03 00 00       	call   11e620 <z_priq_rb_remove>
  11e249:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11e24f:	83 c0 24             	add    $0x24,%eax
		}
		_priq_run_add(&_kernel.ready_q.runq, thread);
  11e252:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e255:	89 04 24             	mov    %eax,(%esp)
  11e258:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e25c:	e8 4f 01 00 00       	call   11e3b0 <z_priq_rb_add>
		z_mark_thread_as_queued(thread);
  11e261:	8b 45 08             	mov    0x8(%ebp),%eax
  11e264:	89 04 24             	mov    %eax,(%esp)
  11e267:	e8 44 02 00 00       	call   11e4b0 <z_mark_thread_as_queued>
		update_cache(thread == _current);
  11e26c:	8b 45 08             	mov    0x8(%ebp),%eax
  11e26f:	3b 05 b0 96 13 00    	cmp    0x1396b0,%eax
  11e275:	0f 94 c2             	sete   %dl
  11e278:	80 e2 01             	and    $0x1,%dl
  11e27b:	0f b6 c2             	movzbl %dl,%eax
  11e27e:	89 04 24             	mov    %eax,(%esp)
  11e281:	e8 5a 02 00 00       	call   11e4e0 <update_cache>
	LOCKED(&sched_spinlock) {
  11e286:	8b 44 24 18          	mov    0x18(%esp),%eax
  11e28a:	89 44 24 38          	mov    %eax,0x38(%esp)
  11e28e:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e294:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11e298:	8b 44 24 38          	mov    0x38(%esp),%eax
  11e29c:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11e2a0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11e2a4:	25 00 02 00 00       	and    $0x200,%eax
  11e2a9:	83 f8 00             	cmp    $0x0,%eax
  11e2ac:	0f 84 01 00 00 00    	je     11e2b3 <z_move_thread_to_end_of_prio_q+0x103>
		__asm__ volatile ("sti" ::: "memory");
  11e2b2:	fb                   	sti    
  11e2b3:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11e2ba:	00 
  11e2bb:	e9 42 ff ff ff       	jmp    11e202 <z_move_thread_to_end_of_prio_q+0x52>
	}
}
  11e2c0:	89 ec                	mov    %ebp,%esp
  11e2c2:	5d                   	pop    %ebp
  11e2c3:	c3                   	ret    
  11e2c4:	66 90                	xchg   %ax,%ax
  11e2c6:	66 90                	xchg   %ax,%ax
  11e2c8:	66 90                	xchg   %ax,%ax
  11e2ca:	66 90                	xchg   %ax,%ax
  11e2cc:	66 90                	xchg   %ax,%ax
  11e2ce:	66 90                	xchg   %ax,%ax

0011e2d0 <z_add_thread_to_ready_q>:
{
  11e2d0:	55                   	push   %ebp
  11e2d1:	89 e5                	mov    %esp,%ebp
  11e2d3:	83 e4 f8             	and    $0xfffffff8,%esp
  11e2d6:	83 ec 40             	sub    $0x40,%esp
  11e2d9:	8b 45 08             	mov    0x8(%ebp),%eax
  11e2dc:	31 c9                	xor    %ecx,%ecx
	LOCKED(&sched_spinlock) {
  11e2de:	8d 54 24 20          	lea    0x20(%esp),%edx
  11e2e2:	89 14 24             	mov    %edx,(%esp)
  11e2e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11e2ec:	00 
  11e2ed:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11e2f4:	00 
  11e2f5:	89 44 24 14          	mov    %eax,0x14(%esp)
  11e2f9:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11e2fd:	e8 6e c1 fe ff       	call   10a470 <memset>
  11e302:	8d 44 24 18          	lea    0x18(%esp),%eax
  11e306:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11e30a:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e310:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11e314:	9c                   	pushf  
  11e315:	fa                   	cli    
  11e316:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11e31a:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11e31e:	89 44 24 18          	mov    %eax,0x18(%esp)
  11e322:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11e327:	0f 95 c0             	setne  %al
  11e32a:	34 ff                	xor    $0xff,%al
  11e32c:	a8 01                	test   $0x1,%al
  11e32e:	0f 85 05 00 00 00    	jne    11e339 <z_add_thread_to_ready_q+0x69>
  11e334:	e9 6f 00 00 00       	jmp    11e3a8 <z_add_thread_to_ready_q+0xd8>
  11e339:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11e33f:	83 c0 24             	add    $0x24,%eax
		_priq_run_add(&_kernel.ready_q.runq, thread);
  11e342:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e345:	89 04 24             	mov    %eax,(%esp)
  11e348:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e34c:	e8 5f 00 00 00       	call   11e3b0 <z_priq_rb_add>
		z_mark_thread_as_queued(thread);
  11e351:	8b 45 08             	mov    0x8(%ebp),%eax
  11e354:	89 04 24             	mov    %eax,(%esp)
  11e357:	e8 54 01 00 00       	call   11e4b0 <z_mark_thread_as_queued>
  11e35c:	31 c0                	xor    %eax,%eax
		update_cache(0);
  11e35e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11e365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11e369:	e8 72 01 00 00       	call   11e4e0 <update_cache>
	LOCKED(&sched_spinlock) {
  11e36e:	8b 44 24 18          	mov    0x18(%esp),%eax
  11e372:	89 44 24 38          	mov    %eax,0x38(%esp)
  11e376:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e37c:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11e380:	8b 44 24 38          	mov    0x38(%esp),%eax
  11e384:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11e388:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11e38c:	25 00 02 00 00       	and    $0x200,%eax
  11e391:	83 f8 00             	cmp    $0x0,%eax
  11e394:	0f 84 01 00 00 00    	je     11e39b <z_add_thread_to_ready_q+0xcb>
		__asm__ volatile ("sti" ::: "memory");
  11e39a:	fb                   	sti    
  11e39b:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11e3a2:	00 
  11e3a3:	e9 7a ff ff ff       	jmp    11e322 <z_add_thread_to_ready_q+0x52>
}
  11e3a8:	89 ec                	mov    %ebp,%esp
  11e3aa:	5d                   	pop    %ebp
  11e3ab:	c3                   	ret    
  11e3ac:	66 90                	xchg   %ax,%ax
  11e3ae:	66 90                	xchg   %ax,%ax

0011e3b0 <z_priq_rb_add>:
		return ta->base.order_key < tb->base.order_key ? 1 : 0;
	}
}

void z_priq_rb_add(struct _priq_rb *pq, struct k_thread *thread)
{
  11e3b0:	55                   	push   %ebp
  11e3b1:	89 e5                	mov    %esp,%ebp
  11e3b3:	53                   	push   %ebx
  11e3b4:	57                   	push   %edi
  11e3b5:	56                   	push   %esi
  11e3b6:	83 e4 f0             	and    $0xfffffff0,%esp
  11e3b9:	83 ec 30             	sub    $0x30,%esp
  11e3bc:	89 e6                	mov    %esp,%esi
  11e3be:	8b 45 0c             	mov    0xc(%ebp),%eax
  11e3c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct k_thread *t;

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	thread->base.order_key = pq->next_order_key++;
  11e3c4:	8b 55 08             	mov    0x8(%ebp),%edx
  11e3c7:	8b 7a 0c             	mov    0xc(%edx),%edi
  11e3ca:	89 fb                	mov    %edi,%ebx
  11e3cc:	83 c3 01             	add    $0x1,%ebx
  11e3cf:	89 5a 0c             	mov    %ebx,0xc(%edx)
  11e3d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  11e3d5:	89 7a 10             	mov    %edi,0x10(%edx)
	 * will almost never be hit on real systems.  BUT on very
	 * long-running systems where a priq never completely empties
	 * AND that contains very large numbers of threads, it can be
	 * a latency glitch to loop over all the threads like this.
	 */
	if (!pq->next_order_key) {
  11e3d8:	8b 55 08             	mov    0x8(%ebp),%edx
  11e3db:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  11e3df:	0f 85 9f 00 00 00    	jne    11e484 <z_priq_rb_add+0xd4>
		RB_FOR_EACH_CONTAINER(&pq->tree, t, base.qnode_rb) {
  11e3e5:	8b 45 08             	mov    0x8(%ebp),%eax
  11e3e8:	8b 40 08             	mov    0x8(%eax),%eax
  11e3eb:	c1 e0 02             	shl    $0x2,%eax
  11e3ee:	89 e1                	mov    %esp,%ecx
  11e3f0:	29 c1                	sub    %eax,%ecx
  11e3f2:	83 e1 f0             	and    $0xfffffff0,%ecx
  11e3f5:	89 cc                	mov    %ecx,%esp
  11e3f7:	89 4e 18             	mov    %ecx,0x18(%esi)
  11e3fa:	8b 45 08             	mov    0x8(%ebp),%eax
  11e3fd:	8b 40 08             	mov    0x8(%eax),%eax
  11e400:	83 c0 03             	add    $0x3,%eax
  11e403:	83 e0 fc             	and    $0xfffffffc,%eax
  11e406:	89 e1                	mov    %esp,%ecx
  11e408:	29 c1                	sub    %eax,%ecx
  11e40a:	83 e1 f0             	and    $0xfffffff0,%ecx
  11e40d:	89 cc                	mov    %ecx,%esp
  11e40f:	89 4e 1c             	mov    %ecx,0x1c(%esi)
  11e412:	c7 46 20 ff ff ff ff 	movl   $0xffffffff,0x20(%esi)
  11e419:	8b 45 08             	mov    0x8(%ebp),%eax
  11e41c:	83 ec 08             	sub    $0x8,%esp
  11e41f:	89 04 24             	mov    %eax,(%esp)
  11e422:	8d 46 18             	lea    0x18(%esi),%eax
  11e425:	89 44 24 04          	mov    %eax,0x4(%esp)
  11e429:	e8 12 3d fe ff       	call   102140 <z_rb_foreach_next>
  11e42e:	83 c4 08             	add    $0x8,%esp
  11e431:	89 46 14             	mov    %eax,0x14(%esi)
  11e434:	83 7e 14 00          	cmpl   $0x0,0x14(%esi)
  11e438:	0f 84 0b 00 00 00    	je     11e449 <z_priq_rb_add+0x99>
  11e43e:	8b 46 14             	mov    0x14(%esi),%eax
  11e441:	89 46 0c             	mov    %eax,0xc(%esi)
  11e444:	e9 0a 00 00 00       	jmp    11e453 <z_priq_rb_add+0xa3>
  11e449:	31 c0                	xor    %eax,%eax
  11e44b:	89 46 0c             	mov    %eax,0xc(%esi)
  11e44e:	e9 00 00 00 00       	jmp    11e453 <z_priq_rb_add+0xa3>
  11e453:	8b 46 0c             	mov    0xc(%esi),%eax
  11e456:	89 46 28             	mov    %eax,0x28(%esi)
  11e459:	89 46 10             	mov    %eax,0x10(%esi)
  11e45c:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  11e460:	0f 84 19 00 00 00    	je     11e47f <z_priq_rb_add+0xcf>
			t->base.order_key = pq->next_order_key++;
  11e466:	8b 45 08             	mov    0x8(%ebp),%eax
  11e469:	8b 48 0c             	mov    0xc(%eax),%ecx
  11e46c:	89 ca                	mov    %ecx,%edx
  11e46e:	83 c2 01             	add    $0x1,%edx
  11e471:	89 50 0c             	mov    %edx,0xc(%eax)
  11e474:	8b 46 28             	mov    0x28(%esi),%eax
  11e477:	89 48 10             	mov    %ecx,0x10(%eax)
		RB_FOR_EACH_CONTAINER(&pq->tree, t, base.qnode_rb) {
  11e47a:	e9 9a ff ff ff       	jmp    11e419 <z_priq_rb_add+0x69>
		}
	}
  11e47f:	e9 00 00 00 00       	jmp    11e484 <z_priq_rb_add+0xd4>

	rb_insert(&pq->tree, &thread->base.qnode_rb);
  11e484:	8b 45 08             	mov    0x8(%ebp),%eax
  11e487:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11e48a:	83 ec 08             	sub    $0x8,%esp
  11e48d:	89 04 24             	mov    %eax,(%esp)
  11e490:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e494:	e8 97 2c fe ff       	call   101130 <rb_insert>
}
  11e499:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11e49c:	5e                   	pop    %esi
  11e49d:	5f                   	pop    %edi
  11e49e:	5b                   	pop    %ebx
  11e49f:	5d                   	pop    %ebp
  11e4a0:	c3                   	ret    
  11e4a1:	66 90                	xchg   %ax,%ax
  11e4a3:	66 90                	xchg   %ax,%ax
  11e4a5:	66 90                	xchg   %ax,%ax
  11e4a7:	66 90                	xchg   %ax,%ax
  11e4a9:	66 90                	xchg   %ax,%ax
  11e4ab:	66 90                	xchg   %ax,%ax
  11e4ad:	66 90                	xchg   %ax,%ax
  11e4af:	90                   	nop

0011e4b0 <z_mark_thread_as_queued>:
{
  11e4b0:	55                   	push   %ebp
  11e4b1:	89 e5                	mov    %esp,%ebp
  11e4b3:	83 ec 0c             	sub    $0xc,%esp
  11e4b6:	8b 45 08             	mov    0x8(%ebp),%eax
	z_set_thread_states(thread, _THREAD_QUEUED);
  11e4b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e4bc:	89 0c 24             	mov    %ecx,(%esp)
  11e4bf:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
  11e4c6:	00 
  11e4c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11e4ca:	e8 41 18 00 00       	call   11fd10 <z_set_thread_states>
}
  11e4cf:	83 c4 0c             	add    $0xc,%esp
  11e4d2:	5d                   	pop    %ebp
  11e4d3:	c3                   	ret    
  11e4d4:	66 90                	xchg   %ax,%ax
  11e4d6:	66 90                	xchg   %ax,%ax
  11e4d8:	66 90                	xchg   %ax,%ax
  11e4da:	66 90                	xchg   %ax,%ax
  11e4dc:	66 90                	xchg   %ax,%ax
  11e4de:	66 90                	xchg   %ax,%ax

0011e4e0 <update_cache>:
{
  11e4e0:	55                   	push   %ebp
  11e4e1:	89 e5                	mov    %esp,%ebp
  11e4e3:	83 ec 20             	sub    $0x20,%esp
  11e4e6:	8b 45 08             	mov    0x8(%ebp),%eax
  11e4e9:	8d 0d a8 96 13 00    	lea    0x1396a8,%ecx
  11e4ef:	83 c1 24             	add    $0x24,%ecx
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
  11e4f2:	89 0c 24             	mov    %ecx,(%esp)
  11e4f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11e4f8:	e8 13 04 00 00       	call   11e910 <z_priq_rb_best>
  11e4fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return th ? th : _current_cpu->idle_thread;
  11e500:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  11e504:	0f 84 0b 00 00 00    	je     11e515 <update_cache+0x35>
  11e50a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11e50d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11e510:	e9 08 00 00 00       	jmp    11e51d <update_cache+0x3d>
  11e515:	a1 b4 96 13 00       	mov    0x1396b4,%eax
  11e51a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11e51d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	struct k_thread *th = next_up();
  11e520:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (should_preempt(th, preempt_ok)) {
  11e523:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e526:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e529:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11e52c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	if (preempt_ok != 0) {
  11e52f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  11e533:	0f 84 09 00 00 00    	je     11e542 <update_cache+0x62>
		return true;
  11e539:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  11e53d:	e9 5a 00 00 00       	jmp    11e59c <update_cache+0xbc>
	if (z_is_thread_prevented_from_running(_current)) {
  11e542:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11e547:	89 04 24             	mov    %eax,(%esp)
  11e54a:	e8 01 18 00 00       	call   11fd50 <z_is_thread_prevented_from_running>
  11e54f:	a8 01                	test   $0x1,%al
  11e551:	0f 85 05 00 00 00    	jne    11e55c <update_cache+0x7c>
  11e557:	e9 09 00 00 00       	jmp    11e565 <update_cache+0x85>
		return true;
  11e55c:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  11e560:	e9 37 00 00 00       	jmp    11e59c <update_cache+0xbc>
	if (is_preempt(_current) || is_metairq(th)) {
  11e565:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11e56a:	89 04 24             	mov    %eax,(%esp)
  11e56d:	e8 8e 16 00 00       	call   11fc00 <is_preempt>
  11e572:	83 f8 00             	cmp    $0x0,%eax
  11e575:	0f 85 14 00 00 00    	jne    11e58f <update_cache+0xaf>
  11e57b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11e57e:	89 04 24             	mov    %eax,(%esp)
  11e581:	e8 fa 17 00 00       	call   11fd80 <is_metairq>
  11e586:	83 f8 00             	cmp    $0x0,%eax
  11e589:	0f 84 09 00 00 00    	je     11e598 <update_cache+0xb8>
		return true;
  11e58f:	c6 45 ff 01          	movb   $0x1,-0x1(%ebp)
  11e593:	e9 04 00 00 00       	jmp    11e59c <update_cache+0xbc>
	return false;
  11e598:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
	if (should_preempt(th, preempt_ok)) {
  11e59c:	f6 45 ff 01          	testb  $0x1,-0x1(%ebp)
  11e5a0:	0f 85 05 00 00 00    	jne    11e5ab <update_cache+0xcb>
  11e5a6:	e9 2c 00 00 00       	jmp    11e5d7 <update_cache+0xf7>
		if (th != _current) {
  11e5ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e5ae:	3b 05 b0 96 13 00    	cmp    0x1396b0,%eax
  11e5b4:	0f 84 05 00 00 00    	je     11e5bf <update_cache+0xdf>
			z_reset_time_slice();
  11e5ba:	e8 21 f6 ff ff       	call   11dbe0 <z_reset_time_slice>
		update_metairq_preempt(th);
  11e5bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e5c2:	89 04 24             	mov    %eax,(%esp)
  11e5c5:	e8 76 17 00 00       	call   11fd40 <update_metairq_preempt>
		_kernel.ready_q.cache = th;
  11e5ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e5cd:	a3 c8 96 13 00       	mov    %eax,0x1396c8
	} else {
  11e5d2:	e9 0a 00 00 00       	jmp    11e5e1 <update_cache+0x101>
		_kernel.ready_q.cache = _current;
  11e5d7:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11e5dc:	a3 c8 96 13 00       	mov    %eax,0x1396c8
}
  11e5e1:	83 c4 20             	add    $0x20,%esp
  11e5e4:	5d                   	pop    %ebp
  11e5e5:	c3                   	ret    
  11e5e6:	66 90                	xchg   %ax,%ax
  11e5e8:	66 90                	xchg   %ax,%ax
  11e5ea:	66 90                	xchg   %ax,%ax
  11e5ec:	66 90                	xchg   %ax,%ax
  11e5ee:	66 90                	xchg   %ax,%ax

0011e5f0 <z_is_thread_queued>:
{
  11e5f0:	55                   	push   %ebp
  11e5f1:	89 e5                	mov    %esp,%ebp
  11e5f3:	83 ec 0c             	sub    $0xc,%esp
  11e5f6:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
  11e5f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e5fc:	89 0c 24             	mov    %ecx,(%esp)
  11e5ff:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
  11e606:	00 
  11e607:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11e60a:	e8 91 17 00 00       	call   11fda0 <z_is_thread_state_set>
  11e60f:	24 01                	and    $0x1,%al
  11e611:	0f b6 c0             	movzbl %al,%eax
  11e614:	83 c4 0c             	add    $0xc,%esp
  11e617:	5d                   	pop    %ebp
  11e618:	c3                   	ret    
  11e619:	66 90                	xchg   %ax,%ax
  11e61b:	66 90                	xchg   %ax,%ax
  11e61d:	66 90                	xchg   %ax,%ax
  11e61f:	90                   	nop

0011e620 <z_priq_rb_remove>:

void z_priq_rb_remove(struct _priq_rb *pq, struct k_thread *thread)
{
  11e620:	55                   	push   %ebp
  11e621:	89 e5                	mov    %esp,%ebp
  11e623:	56                   	push   %esi
  11e624:	83 ec 10             	sub    $0x10,%esp
  11e627:	8b 45 0c             	mov    0xc(%ebp),%eax
  11e62a:	8b 4d 08             	mov    0x8(%ebp),%ecx
		return;
	}
#endif
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	rb_remove(&pq->tree, &thread->base.qnode_rb);
  11e62d:	8b 55 08             	mov    0x8(%ebp),%edx
  11e630:	8b 75 0c             	mov    0xc(%ebp),%esi
  11e633:	89 14 24             	mov    %edx,(%esp)
  11e636:	89 74 24 04          	mov    %esi,0x4(%esp)
  11e63a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11e63d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  11e640:	e8 db 2f fe ff       	call   101620 <rb_remove>

	if (!pq->tree.root) {
  11e645:	8b 45 08             	mov    0x8(%ebp),%eax
  11e648:	83 38 00             	cmpl   $0x0,(%eax)
  11e64b:	0f 85 0a 00 00 00    	jne    11e65b <z_priq_rb_remove+0x3b>
		pq->next_order_key = 0;
  11e651:	8b 45 08             	mov    0x8(%ebp),%eax
  11e654:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
  11e65b:	83 c4 10             	add    $0x10,%esp
  11e65e:	5e                   	pop    %esi
  11e65f:	5d                   	pop    %ebp
  11e660:	c3                   	ret    
  11e661:	66 90                	xchg   %ax,%ax
  11e663:	66 90                	xchg   %ax,%ax
  11e665:	66 90                	xchg   %ax,%ax
  11e667:	66 90                	xchg   %ax,%ax
  11e669:	66 90                	xchg   %ax,%ax
  11e66b:	66 90                	xchg   %ax,%ax
  11e66d:	66 90                	xchg   %ax,%ax
  11e66f:	90                   	nop

0011e670 <z_remove_thread_from_ready_q>:
{
  11e670:	55                   	push   %ebp
  11e671:	89 e5                	mov    %esp,%ebp
  11e673:	83 e4 f8             	and    $0xfffffff8,%esp
  11e676:	83 ec 40             	sub    $0x40,%esp
  11e679:	8b 45 08             	mov    0x8(%ebp),%eax
  11e67c:	31 c9                	xor    %ecx,%ecx
	LOCKED(&sched_spinlock) {
  11e67e:	8d 54 24 20          	lea    0x20(%esp),%edx
  11e682:	89 14 24             	mov    %edx,(%esp)
  11e685:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11e68c:	00 
  11e68d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11e694:	00 
  11e695:	89 44 24 14          	mov    %eax,0x14(%esp)
  11e699:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11e69d:	e8 ce bd fe ff       	call   10a470 <memset>
  11e6a2:	8d 44 24 18          	lea    0x18(%esp),%eax
  11e6a6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11e6aa:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e6b0:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11e6b4:	9c                   	pushf  
  11e6b5:	fa                   	cli    
  11e6b6:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11e6ba:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11e6be:	89 44 24 18          	mov    %eax,0x18(%esp)
  11e6c2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11e6c7:	0f 95 c0             	setne  %al
  11e6ca:	34 ff                	xor    $0xff,%al
  11e6cc:	a8 01                	test   $0x1,%al
  11e6ce:	0f 85 05 00 00 00    	jne    11e6d9 <z_remove_thread_from_ready_q+0x69>
  11e6d4:	e9 8f 00 00 00       	jmp    11e768 <z_remove_thread_from_ready_q+0xf8>
		if (z_is_thread_queued(thread)) {
  11e6d9:	8b 45 08             	mov    0x8(%ebp),%eax
  11e6dc:	89 04 24             	mov    %eax,(%esp)
  11e6df:	e8 0c ff ff ff       	call   11e5f0 <z_is_thread_queued>
  11e6e4:	a8 01                	test   $0x1,%al
  11e6e6:	0f 85 05 00 00 00    	jne    11e6f1 <z_remove_thread_from_ready_q+0x81>
  11e6ec:	e9 23 00 00 00       	jmp    11e714 <z_remove_thread_from_ready_q+0xa4>
  11e6f1:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11e6f7:	83 c0 24             	add    $0x24,%eax
			_priq_run_remove(&_kernel.ready_q.runq, thread);
  11e6fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e6fd:	89 04 24             	mov    %eax,(%esp)
  11e700:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e704:	e8 17 ff ff ff       	call   11e620 <z_priq_rb_remove>
			z_mark_thread_as_not_queued(thread);
  11e709:	8b 45 08             	mov    0x8(%ebp),%eax
  11e70c:	89 04 24             	mov    %eax,(%esp)
  11e70f:	e8 5c 00 00 00       	call   11e770 <z_mark_thread_as_not_queued>
		update_cache(thread == _current);
  11e714:	8b 45 08             	mov    0x8(%ebp),%eax
  11e717:	3b 05 b0 96 13 00    	cmp    0x1396b0,%eax
  11e71d:	0f 94 c1             	sete   %cl
  11e720:	80 e1 01             	and    $0x1,%cl
  11e723:	0f b6 c1             	movzbl %cl,%eax
  11e726:	89 04 24             	mov    %eax,(%esp)
  11e729:	e8 b2 fd ff ff       	call   11e4e0 <update_cache>
	LOCKED(&sched_spinlock) {
  11e72e:	8b 44 24 18          	mov    0x18(%esp),%eax
  11e732:	89 44 24 38          	mov    %eax,0x38(%esp)
  11e736:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e73c:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11e740:	8b 44 24 38          	mov    0x38(%esp),%eax
  11e744:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11e748:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11e74c:	25 00 02 00 00       	and    $0x200,%eax
  11e751:	83 f8 00             	cmp    $0x0,%eax
  11e754:	0f 84 01 00 00 00    	je     11e75b <z_remove_thread_from_ready_q+0xeb>
		__asm__ volatile ("sti" ::: "memory");
  11e75a:	fb                   	sti    
  11e75b:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11e762:	00 
  11e763:	e9 5a ff ff ff       	jmp    11e6c2 <z_remove_thread_from_ready_q+0x52>
}
  11e768:	89 ec                	mov    %ebp,%esp
  11e76a:	5d                   	pop    %ebp
  11e76b:	c3                   	ret    
  11e76c:	66 90                	xchg   %ax,%ax
  11e76e:	66 90                	xchg   %ax,%ax

0011e770 <z_mark_thread_as_not_queued>:
{
  11e770:	55                   	push   %ebp
  11e771:	89 e5                	mov    %esp,%ebp
  11e773:	83 ec 0c             	sub    $0xc,%esp
  11e776:	8b 45 08             	mov    0x8(%ebp),%eax
	z_reset_thread_states(thread, _THREAD_QUEUED);
  11e779:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e77c:	89 0c 24             	mov    %ecx,(%esp)
  11e77f:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
  11e786:	00 
  11e787:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11e78a:	e8 41 16 00 00       	call   11fdd0 <z_reset_thread_states>
}
  11e78f:	83 c4 0c             	add    $0xc,%esp
  11e792:	5d                   	pop    %ebp
  11e793:	c3                   	ret    
  11e794:	66 90                	xchg   %ax,%ax
  11e796:	66 90                	xchg   %ax,%ax
  11e798:	66 90                	xchg   %ax,%ax
  11e79a:	66 90                	xchg   %ax,%ax
  11e79c:	66 90                	xchg   %ax,%ax
  11e79e:	66 90                	xchg   %ax,%ax

0011e7a0 <pend>:
{
  11e7a0:	55                   	push   %ebp
  11e7a1:	89 e5                	mov    %esp,%ebp
  11e7a3:	56                   	push   %esi
  11e7a4:	83 ec 18             	sub    $0x18,%esp
  11e7a7:	8b 45 10             	mov    0x10(%ebp),%eax
  11e7aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11e7ad:	8b 55 08             	mov    0x8(%ebp),%edx
	z_remove_thread_from_ready_q(thread);
  11e7b0:	8b 75 08             	mov    0x8(%ebp),%esi
  11e7b3:	89 34 24             	mov    %esi,(%esp)
  11e7b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11e7b9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11e7bc:	89 55 ec             	mov    %edx,-0x14(%ebp)
  11e7bf:	e8 ac fe ff ff       	call   11e670 <z_remove_thread_from_ready_q>
	z_mark_thread_as_pending(thread);
  11e7c4:	8b 45 08             	mov    0x8(%ebp),%eax
  11e7c7:	89 04 24             	mov    %eax,(%esp)
  11e7ca:	e8 31 16 00 00       	call   11fe00 <z_mark_thread_as_pending>
	if (wait_q != NULL) {
  11e7cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  11e7d3:	0f 84 1b 00 00 00    	je     11e7f4 <pend+0x54>
		thread->base.pended_on = wait_q;
  11e7d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  11e7dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e7df:	89 41 08             	mov    %eax,0x8(%ecx)
		z_priq_wait_add(&wait_q->waitq, thread);
  11e7e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  11e7e5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e7e8:	89 04 24             	mov    %eax,(%esp)
  11e7eb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e7ef:	e8 bc fb ff ff       	call   11e3b0 <z_priq_rb_add>
	if (timeout != K_FOREVER) {
  11e7f4:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  11e7f8:	0f 84 34 00 00 00    	je     11e832 <pend+0x92>
		if (timeout < 0) {
  11e7fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  11e802:	0f 8d 07 00 00 00    	jge    11e80f <pend+0x6f>
			timeout = 0;
  11e808:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
		ticks = _TICK_ALIGN + k_ms_to_ticks_ceil32(timeout);
  11e80f:	8b 45 10             	mov    0x10(%ebp),%eax
  11e812:	89 04 24             	mov    %eax,(%esp)
  11e815:	e8 f6 f4 ff ff       	call   11dd10 <k_ms_to_ticks_ceil32>
  11e81a:	83 c0 01             	add    $0x1,%eax
  11e81d:	89 45 f8             	mov    %eax,-0x8(%ebp)
		z_add_thread_timeout(thread, ticks);
  11e820:	8b 45 08             	mov    0x8(%ebp),%eax
  11e823:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11e826:	89 04 24             	mov    %eax,(%esp)
  11e829:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e82d:	e8 ee 15 00 00       	call   11fe20 <z_add_thread_timeout>
}
  11e832:	83 c4 18             	add    $0x18,%esp
  11e835:	5e                   	pop    %esi
  11e836:	5d                   	pop    %ebp
  11e837:	c3                   	ret    
  11e838:	66 90                	xchg   %ax,%ax
  11e83a:	66 90                	xchg   %ax,%ax
  11e83c:	66 90                	xchg   %ax,%ax
  11e83e:	66 90                	xchg   %ax,%ax

0011e840 <z_find_first_thread_to_unpend>:
{
  11e840:	55                   	push   %ebp
  11e841:	89 e5                	mov    %esp,%ebp
  11e843:	56                   	push   %esi
  11e844:	83 e4 f8             	and    $0xfffffff8,%esp
  11e847:	83 ec 48             	sub    $0x48,%esp
  11e84a:	8b 45 0c             	mov    0xc(%ebp),%eax
  11e84d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e850:	31 d2                	xor    %edx,%edx
	struct k_thread *ret = NULL;
  11e852:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  11e859:	00 
	LOCKED(&sched_spinlock) {
  11e85a:	8d 74 24 20          	lea    0x20(%esp),%esi
  11e85e:	89 34 24             	mov    %esi,(%esp)
  11e861:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11e868:	00 
  11e869:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11e870:	00 
  11e871:	89 44 24 14          	mov    %eax,0x14(%esp)
  11e875:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11e879:	89 54 24 0c          	mov    %edx,0xc(%esp)
  11e87d:	e8 ee bb fe ff       	call   10a470 <memset>
  11e882:	8d 44 24 18          	lea    0x18(%esp),%eax
  11e886:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11e88a:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e890:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11e894:	9c                   	pushf  
  11e895:	fa                   	cli    
  11e896:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11e89a:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11e89e:	89 44 24 18          	mov    %eax,0x18(%esp)
  11e8a2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11e8a7:	0f 95 c0             	setne  %al
  11e8aa:	34 ff                	xor    $0xff,%al
  11e8ac:	a8 01                	test   $0x1,%al
  11e8ae:	0f 85 05 00 00 00    	jne    11e8b9 <z_find_first_thread_to_unpend+0x79>
  11e8b4:	e9 49 00 00 00       	jmp    11e902 <z_find_first_thread_to_unpend+0xc2>
		ret = _priq_wait_best(&wait_q->waitq);
  11e8b9:	8b 45 08             	mov    0x8(%ebp),%eax
  11e8bc:	89 04 24             	mov    %eax,(%esp)
  11e8bf:	e8 4c 00 00 00       	call   11e910 <z_priq_rb_best>
  11e8c4:	89 44 24 24          	mov    %eax,0x24(%esp)
	LOCKED(&sched_spinlock) {
  11e8c8:	8b 44 24 18          	mov    0x18(%esp),%eax
  11e8cc:	89 44 24 38          	mov    %eax,0x38(%esp)
  11e8d0:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e8d6:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11e8da:	8b 44 24 38          	mov    0x38(%esp),%eax
  11e8de:	89 44 24 40          	mov    %eax,0x40(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11e8e2:	8b 44 24 40          	mov    0x40(%esp),%eax
  11e8e6:	25 00 02 00 00       	and    $0x200,%eax
  11e8eb:	83 f8 00             	cmp    $0x0,%eax
  11e8ee:	0f 84 01 00 00 00    	je     11e8f5 <z_find_first_thread_to_unpend+0xb5>
		__asm__ volatile ("sti" ::: "memory");
  11e8f4:	fb                   	sti    
  11e8f5:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11e8fc:	00 
  11e8fd:	e9 a0 ff ff ff       	jmp    11e8a2 <z_find_first_thread_to_unpend+0x62>
	return ret;
  11e902:	8b 44 24 24          	mov    0x24(%esp),%eax
  11e906:	8d 65 fc             	lea    -0x4(%ebp),%esp
  11e909:	5e                   	pop    %esi
  11e90a:	5d                   	pop    %ebp
  11e90b:	c3                   	ret    
  11e90c:	66 90                	xchg   %ax,%ax
  11e90e:	66 90                	xchg   %ax,%ax

0011e910 <z_priq_rb_best>:

struct k_thread *z_priq_rb_best(struct _priq_rb *pq)
{
  11e910:	55                   	push   %ebp
  11e911:	89 e5                	mov    %esp,%ebp
  11e913:	83 ec 10             	sub    $0x10,%esp
  11e916:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_thread *t = NULL;
  11e919:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	struct rbnode *n = rb_get_min(&pq->tree);
  11e920:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e923:	89 0c 24             	mov    %ecx,(%esp)
  11e926:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11e929:	e8 c2 0a 00 00       	call   11f3f0 <rb_get_min>
  11e92e:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (n != NULL) {
  11e931:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  11e935:	0f 84 06 00 00 00    	je     11e941 <z_priq_rb_best+0x31>
		t = CONTAINER_OF(n, struct k_thread, base.qnode_rb);
  11e93b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11e93e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}
	return t;
  11e941:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11e944:	83 c4 10             	add    $0x10,%esp
  11e947:	5d                   	pop    %ebp
  11e948:	c3                   	ret    
  11e949:	66 90                	xchg   %ax,%ax
  11e94b:	66 90                	xchg   %ax,%ax
  11e94d:	66 90                	xchg   %ax,%ax
  11e94f:	90                   	nop

0011e950 <z_unpend_thread_no_timeout>:
{
  11e950:	55                   	push   %ebp
  11e951:	89 e5                	mov    %esp,%ebp
  11e953:	83 e4 f8             	and    $0xfffffff8,%esp
  11e956:	83 ec 40             	sub    $0x40,%esp
  11e959:	8b 45 08             	mov    0x8(%ebp),%eax
  11e95c:	31 c9                	xor    %ecx,%ecx
	LOCKED(&sched_spinlock) {
  11e95e:	8d 54 24 20          	lea    0x20(%esp),%edx
  11e962:	89 14 24             	mov    %edx,(%esp)
  11e965:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11e96c:	00 
  11e96d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11e974:	00 
  11e975:	89 44 24 14          	mov    %eax,0x14(%esp)
  11e979:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11e97d:	e8 ee ba fe ff       	call   10a470 <memset>
  11e982:	8d 44 24 18          	lea    0x18(%esp),%eax
  11e986:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11e98a:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e990:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11e994:	9c                   	pushf  
  11e995:	fa                   	cli    
  11e996:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11e99a:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11e99e:	89 44 24 18          	mov    %eax,0x18(%esp)
  11e9a2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11e9a7:	0f 95 c0             	setne  %al
  11e9aa:	34 ff                	xor    $0xff,%al
  11e9ac:	a8 01                	test   $0x1,%al
  11e9ae:	0f 85 05 00 00 00    	jne    11e9b9 <z_unpend_thread_no_timeout+0x69>
  11e9b4:	e9 5f 00 00 00       	jmp    11ea18 <z_unpend_thread_no_timeout+0xc8>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
  11e9b9:	8b 45 08             	mov    0x8(%ebp),%eax
  11e9bc:	89 04 24             	mov    %eax,(%esp)
  11e9bf:	e8 6c 00 00 00       	call   11ea30 <pended_on>
  11e9c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11e9c7:	89 04 24             	mov    %eax,(%esp)
  11e9ca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11e9ce:	e8 4d fc ff ff       	call   11e620 <z_priq_rb_remove>
		z_mark_thread_as_not_pending(thread);
  11e9d3:	8b 45 08             	mov    0x8(%ebp),%eax
  11e9d6:	89 04 24             	mov    %eax,(%esp)
  11e9d9:	e8 72 00 00 00       	call   11ea50 <z_mark_thread_as_not_pending>
	LOCKED(&sched_spinlock) {
  11e9de:	8b 44 24 18          	mov    0x18(%esp),%eax
  11e9e2:	89 44 24 38          	mov    %eax,0x38(%esp)
  11e9e6:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11e9ec:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11e9f0:	8b 44 24 38          	mov    0x38(%esp),%eax
  11e9f4:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11e9f8:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11e9fc:	25 00 02 00 00       	and    $0x200,%eax
  11ea01:	83 f8 00             	cmp    $0x0,%eax
  11ea04:	0f 84 01 00 00 00    	je     11ea0b <z_unpend_thread_no_timeout+0xbb>
		__asm__ volatile ("sti" ::: "memory");
  11ea0a:	fb                   	sti    
  11ea0b:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11ea12:	00 
  11ea13:	e9 8a ff ff ff       	jmp    11e9a2 <z_unpend_thread_no_timeout+0x52>
	thread->base.pended_on = NULL;
  11ea18:	8b 45 08             	mov    0x8(%ebp),%eax
  11ea1b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
  11ea22:	89 ec                	mov    %ebp,%esp
  11ea24:	5d                   	pop    %ebp
  11ea25:	c3                   	ret    
  11ea26:	66 90                	xchg   %ax,%ax
  11ea28:	66 90                	xchg   %ax,%ax
  11ea2a:	66 90                	xchg   %ax,%ax
  11ea2c:	66 90                	xchg   %ax,%ax
  11ea2e:	66 90                	xchg   %ax,%ax

0011ea30 <pended_on>:
{
  11ea30:	55                   	push   %ebp
  11ea31:	89 e5                	mov    %esp,%ebp
  11ea33:	50                   	push   %eax
  11ea34:	8b 45 08             	mov    0x8(%ebp),%eax
	return thread->base.pended_on;
  11ea37:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ea3a:	8b 49 08             	mov    0x8(%ecx),%ecx
  11ea3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11ea40:	89 c8                	mov    %ecx,%eax
  11ea42:	83 c4 04             	add    $0x4,%esp
  11ea45:	5d                   	pop    %ebp
  11ea46:	c3                   	ret    
  11ea47:	66 90                	xchg   %ax,%ax
  11ea49:	66 90                	xchg   %ax,%ax
  11ea4b:	66 90                	xchg   %ax,%ax
  11ea4d:	66 90                	xchg   %ax,%ax
  11ea4f:	90                   	nop

0011ea50 <z_mark_thread_as_not_pending>:
{
  11ea50:	55                   	push   %ebp
  11ea51:	89 e5                	mov    %esp,%ebp
  11ea53:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_PENDING;
  11ea56:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ea59:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11ea5d:	83 e2 fd             	and    $0xfffffffd,%edx
  11ea60:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11ea63:	5d                   	pop    %ebp
  11ea64:	c3                   	ret    
  11ea65:	66 90                	xchg   %ax,%ax
  11ea67:	66 90                	xchg   %ax,%ax
  11ea69:	66 90                	xchg   %ax,%ax
  11ea6b:	66 90                	xchg   %ax,%ax
  11ea6d:	66 90                	xchg   %ax,%ax
  11ea6f:	90                   	nop

0011ea70 <z_thread_timeout>:
{
  11ea70:	55                   	push   %ebp
  11ea71:	89 e5                	mov    %esp,%ebp
  11ea73:	83 e4 f8             	and    $0xfffffff8,%esp
  11ea76:	83 ec 48             	sub    $0x48,%esp
  11ea79:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
  11ea7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ea7f:	83 c1 e8             	add    $0xffffffe8,%ecx
  11ea82:	89 4c 24 14          	mov    %ecx,0x14(%esp)
	if (th->base.pended_on != NULL) {
  11ea86:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  11ea8a:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  11ea8e:	0f 84 ce 00 00 00    	je     11eb62 <z_thread_timeout+0xf2>
  11ea94:	31 c0                	xor    %eax,%eax
		z_unpend_thread_no_timeout(th);
  11ea96:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  11ea9a:	89 4c 24 24          	mov    %ecx,0x24(%esp)
	LOCKED(&sched_spinlock) {
  11ea9e:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  11eaa2:	89 0c 24             	mov    %ecx,(%esp)
  11eaa5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11eaac:	00 
  11eaad:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11eab4:	00 
  11eab5:	89 44 24 10          	mov    %eax,0x10(%esp)
  11eab9:	e8 b2 b9 fe ff       	call   10a470 <memset>
  11eabe:	8d 44 24 18          	lea    0x18(%esp),%eax
  11eac2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11eac6:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11eacc:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11ead0:	9c                   	pushf  
  11ead1:	fa                   	cli    
  11ead2:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11ead6:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11eada:	89 44 24 18          	mov    %eax,0x18(%esp)
  11eade:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11eae3:	0f 95 c0             	setne  %al
  11eae6:	34 ff                	xor    $0xff,%al
  11eae8:	a8 01                	test   $0x1,%al
  11eaea:	0f 85 05 00 00 00    	jne    11eaf5 <z_thread_timeout+0x85>
  11eaf0:	e9 62 00 00 00       	jmp    11eb57 <z_thread_timeout+0xe7>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
  11eaf5:	8b 44 24 24          	mov    0x24(%esp),%eax
  11eaf9:	89 04 24             	mov    %eax,(%esp)
  11eafc:	e8 2f ff ff ff       	call   11ea30 <pended_on>
  11eb01:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  11eb05:	89 04 24             	mov    %eax,(%esp)
  11eb08:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11eb0c:	e8 0f fb ff ff       	call   11e620 <z_priq_rb_remove>
		z_mark_thread_as_not_pending(thread);
  11eb11:	8b 44 24 24          	mov    0x24(%esp),%eax
  11eb15:	89 04 24             	mov    %eax,(%esp)
  11eb18:	e8 33 ff ff ff       	call   11ea50 <z_mark_thread_as_not_pending>
	LOCKED(&sched_spinlock) {
  11eb1d:	8b 44 24 18          	mov    0x18(%esp),%eax
  11eb21:	89 44 24 38          	mov    %eax,0x38(%esp)
  11eb25:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11eb2b:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11eb2f:	8b 44 24 38          	mov    0x38(%esp),%eax
  11eb33:	89 44 24 40          	mov    %eax,0x40(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11eb37:	8b 44 24 40          	mov    0x40(%esp),%eax
  11eb3b:	25 00 02 00 00       	and    $0x200,%eax
  11eb40:	83 f8 00             	cmp    $0x0,%eax
  11eb43:	0f 84 01 00 00 00    	je     11eb4a <z_thread_timeout+0xda>
		__asm__ volatile ("sti" ::: "memory");
  11eb49:	fb                   	sti    
  11eb4a:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11eb51:	00 
  11eb52:	e9 87 ff ff ff       	jmp    11eade <z_thread_timeout+0x6e>
	thread->base.pended_on = NULL;
  11eb57:	8b 44 24 24          	mov    0x24(%esp),%eax
  11eb5b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	z_mark_thread_as_started(th);
  11eb62:	8b 44 24 14          	mov    0x14(%esp),%eax
  11eb66:	89 04 24             	mov    %eax,(%esp)
  11eb69:	e8 42 00 00 00       	call   11ebb0 <z_mark_thread_as_started>
	z_mark_thread_as_not_suspended(th);
  11eb6e:	8b 44 24 14          	mov    0x14(%esp),%eax
  11eb72:	89 04 24             	mov    %eax,(%esp)
  11eb75:	e8 56 00 00 00       	call   11ebd0 <z_mark_thread_as_not_suspended>
	z_ready_thread(th);
  11eb7a:	8b 44 24 14          	mov    0x14(%esp),%eax
  11eb7e:	89 44 24 44          	mov    %eax,0x44(%esp)
	if (z_is_thread_ready(thread)) {
  11eb82:	8b 44 24 44          	mov    0x44(%esp),%eax
  11eb86:	89 04 24             	mov    %eax,(%esp)
  11eb89:	e8 62 04 00 00       	call   11eff0 <z_is_thread_ready>
  11eb8e:	a8 01                	test   $0x1,%al
  11eb90:	0f 85 05 00 00 00    	jne    11eb9b <z_thread_timeout+0x12b>
  11eb96:	e9 0c 00 00 00       	jmp    11eba7 <z_thread_timeout+0x137>
		z_add_thread_to_ready_q(thread);
  11eb9b:	8b 44 24 44          	mov    0x44(%esp),%eax
  11eb9f:	89 04 24             	mov    %eax,(%esp)
  11eba2:	e8 29 f7 ff ff       	call   11e2d0 <z_add_thread_to_ready_q>
}
  11eba7:	89 ec                	mov    %ebp,%esp
  11eba9:	5d                   	pop    %ebp
  11ebaa:	c3                   	ret    
  11ebab:	66 90                	xchg   %ax,%ax
  11ebad:	66 90                	xchg   %ax,%ax
  11ebaf:	90                   	nop

0011ebb0 <z_mark_thread_as_started>:
{
  11ebb0:	55                   	push   %ebp
  11ebb1:	89 e5                	mov    %esp,%ebp
  11ebb3:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_PRESTART;
  11ebb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ebb9:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11ebbd:	83 e2 fb             	and    $0xfffffffb,%edx
  11ebc0:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11ebc3:	5d                   	pop    %ebp
  11ebc4:	c3                   	ret    
  11ebc5:	66 90                	xchg   %ax,%ax
  11ebc7:	66 90                	xchg   %ax,%ax
  11ebc9:	66 90                	xchg   %ax,%ax
  11ebcb:	66 90                	xchg   %ax,%ax
  11ebcd:	66 90                	xchg   %ax,%ax
  11ebcf:	90                   	nop

0011ebd0 <z_mark_thread_as_not_suspended>:
{
  11ebd0:	55                   	push   %ebp
  11ebd1:	89 e5                	mov    %esp,%ebp
  11ebd3:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  11ebd6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ebd9:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11ebdd:	83 e2 ef             	and    $0xffffffef,%edx
  11ebe0:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11ebe3:	5d                   	pop    %ebp
  11ebe4:	c3                   	ret    
  11ebe5:	66 90                	xchg   %ax,%ax
  11ebe7:	66 90                	xchg   %ax,%ax
  11ebe9:	66 90                	xchg   %ax,%ax
  11ebeb:	66 90                	xchg   %ax,%ax
  11ebed:	66 90                	xchg   %ax,%ax
  11ebef:	90                   	nop

0011ebf0 <z_pend_curr_irqlock>:
{
  11ebf0:	55                   	push   %ebp
  11ebf1:	89 e5                	mov    %esp,%ebp
  11ebf3:	53                   	push   %ebx
  11ebf4:	57                   	push   %edi
  11ebf5:	56                   	push   %esi
  11ebf6:	83 ec 18             	sub    $0x18,%esp
  11ebf9:	8b 45 10             	mov    0x10(%ebp),%eax
  11ebfc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11ebff:	8b 55 08             	mov    0x8(%ebp),%edx
	pend(_current, wait_q, timeout);
  11ec02:	8b 35 b0 96 13 00    	mov    0x1396b0,%esi
  11ec08:	8b 7d 0c             	mov    0xc(%ebp),%edi
  11ec0b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11ec0e:	89 34 24             	mov    %esi,(%esp)
  11ec11:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11ec15:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11ec19:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11ec1c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11ec1f:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11ec22:	e8 79 fb ff ff       	call   11e7a0 <pend>
	return z_swap_irqlock(key);
  11ec27:	8b 45 08             	mov    0x8(%ebp),%eax
  11ec2a:	89 04 24             	mov    %eax,(%esp)
  11ec2d:	e8 0e 00 00 00       	call   11ec40 <z_swap_irqlock>
  11ec32:	83 c4 18             	add    $0x18,%esp
  11ec35:	5e                   	pop    %esi
  11ec36:	5f                   	pop    %edi
  11ec37:	5b                   	pop    %ebx
  11ec38:	5d                   	pop    %ebp
  11ec39:	c3                   	ret    
  11ec3a:	66 90                	xchg   %ax,%ax
  11ec3c:	66 90                	xchg   %ax,%ax
  11ec3e:	66 90                	xchg   %ax,%ax

0011ec40 <z_swap_irqlock>:
{
  11ec40:	55                   	push   %ebp
  11ec41:	89 e5                	mov    %esp,%ebp
  11ec43:	83 ec 0c             	sub    $0xc,%esp
  11ec46:	8b 45 08             	mov    0x8(%ebp),%eax
	ret = arch_swap(key);
  11ec49:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ec4c:	89 0c 24             	mov    %ecx,(%esp)
  11ec4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11ec52:	e8 59 ac fe ff       	call   1098b0 <arch_swap>
  11ec57:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return ret;
  11ec5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ec5d:	83 c4 0c             	add    $0xc,%esp
  11ec60:	5d                   	pop    %ebp
  11ec61:	c3                   	ret    
  11ec62:	66 90                	xchg   %ax,%ax
  11ec64:	66 90                	xchg   %ax,%ax
  11ec66:	66 90                	xchg   %ax,%ax
  11ec68:	66 90                	xchg   %ax,%ax
  11ec6a:	66 90                	xchg   %ax,%ax
  11ec6c:	66 90                	xchg   %ax,%ax
  11ec6e:	66 90                	xchg   %ax,%ax

0011ec70 <z_pend_curr>:
{
  11ec70:	55                   	push   %ebp
  11ec71:	89 e5                	mov    %esp,%ebp
  11ec73:	53                   	push   %ebx
  11ec74:	57                   	push   %edi
  11ec75:	56                   	push   %esi
  11ec76:	83 e4 f8             	and    $0xfffffff8,%esp
  11ec79:	83 ec 30             	sub    $0x30,%esp
  11ec7c:	8b 45 14             	mov    0x14(%ebp),%eax
  11ec7f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11ec82:	8b 55 0c             	mov    0xc(%ebp),%edx
  11ec85:	8b 75 08             	mov    0x8(%ebp),%esi
  11ec88:	89 54 24 18          	mov    %edx,0x18(%esp)
	pend(_current, wait_q, timeout);
  11ec8c:	8b 15 b0 96 13 00    	mov    0x1396b0,%edx
  11ec92:	8b 7d 10             	mov    0x10(%ebp),%edi
  11ec95:	8b 5d 14             	mov    0x14(%ebp),%ebx
  11ec98:	89 14 24             	mov    %edx,(%esp)
  11ec9b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  11ec9f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  11eca3:	89 44 24 14          	mov    %eax,0x14(%esp)
  11eca7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11ecab:	89 74 24 0c          	mov    %esi,0xc(%esp)
  11ecaf:	e8 ec fa ff ff       	call   11e7a0 <pend>
	return z_swap(lock, key);
  11ecb4:	8b 45 08             	mov    0x8(%ebp),%eax
  11ecb7:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  11ecbb:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  11ecbf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	k_spin_release(lock);
  11ecc3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  11ecc7:	89 44 24 28          	mov    %eax,0x28(%esp)
	return z_swap_irqlock(key.key);
  11eccb:	8b 44 24 20          	mov    0x20(%esp),%eax
  11eccf:	89 04 24             	mov    %eax,(%esp)
  11ecd2:	e8 69 ff ff ff       	call   11ec40 <z_swap_irqlock>
  11ecd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ecda:	5e                   	pop    %esi
  11ecdb:	5f                   	pop    %edi
  11ecdc:	5b                   	pop    %ebx
  11ecdd:	5d                   	pop    %ebp
  11ecde:	c3                   	ret    
  11ecdf:	90                   	nop

0011ece0 <z_unpend_first_thread>:
{
  11ece0:	55                   	push   %ebp
  11ece1:	89 e5                	mov    %esp,%ebp
  11ece3:	83 ec 0c             	sub    $0xc,%esp
  11ece6:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_thread *t = z_unpend1_no_timeout(wait_q);
  11ece9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ecec:	89 0c 24             	mov    %ecx,(%esp)
  11ecef:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11ecf2:	e8 29 00 00 00       	call   11ed20 <z_unpend1_no_timeout>
  11ecf7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (t != NULL) {
  11ecfa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  11ecfe:	0f 84 0b 00 00 00    	je     11ed0f <z_unpend_first_thread+0x2f>
		(void)z_abort_thread_timeout(t);
  11ed04:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ed07:	89 04 24             	mov    %eax,(%esp)
  11ed0a:	e8 d1 01 00 00       	call   11eee0 <z_abort_thread_timeout>
	return t;
  11ed0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11ed12:	83 c4 0c             	add    $0xc,%esp
  11ed15:	5d                   	pop    %ebp
  11ed16:	c3                   	ret    
  11ed17:	66 90                	xchg   %ax,%ax
  11ed19:	66 90                	xchg   %ax,%ax
  11ed1b:	66 90                	xchg   %ax,%ax
  11ed1d:	66 90                	xchg   %ax,%ax
  11ed1f:	90                   	nop

0011ed20 <z_unpend1_no_timeout>:
	return 0;
#endif
}

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
  11ed20:	55                   	push   %ebp
  11ed21:	89 e5                	mov    %esp,%ebp
  11ed23:	83 e4 f8             	and    $0xfffffff8,%esp
  11ed26:	83 ec 78             	sub    $0x78,%esp
  11ed29:	8b 45 08             	mov    0x8(%ebp),%eax
  11ed2c:	31 c9                	xor    %ecx,%ecx
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
  11ed2e:	8b 55 08             	mov    0x8(%ebp),%edx
  11ed31:	89 54 24 34          	mov    %edx,0x34(%esp)
  11ed35:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
  11ed3c:	00 
	struct k_thread *ret = NULL;
  11ed3d:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11ed44:	00 
	LOCKED(&sched_spinlock) {
  11ed45:	8d 54 24 28          	lea    0x28(%esp),%edx
  11ed49:	89 14 24             	mov    %edx,(%esp)
  11ed4c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11ed53:	00 
  11ed54:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11ed5b:	00 
  11ed5c:	89 44 24 18          	mov    %eax,0x18(%esp)
  11ed60:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  11ed64:	e8 07 b7 fe ff       	call   10a470 <memset>
  11ed69:	8d 44 24 20          	lea    0x20(%esp),%eax
  11ed6d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  11ed71:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11ed77:	89 44 24 38          	mov    %eax,0x38(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11ed7b:	9c                   	pushf  
  11ed7c:	fa                   	cli    
  11ed7d:	8f 44 24 40          	popl   0x40(%esp)
	return key;
  11ed81:	8b 44 24 40          	mov    0x40(%esp),%eax
	k.key = arch_irq_lock();
  11ed85:	89 44 24 20          	mov    %eax,0x20(%esp)
  11ed89:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  11ed8e:	0f 95 c0             	setne  %al
  11ed91:	34 ff                	xor    $0xff,%al
  11ed93:	a8 01                	test   $0x1,%al
  11ed95:	0f 85 05 00 00 00    	jne    11eda0 <z_unpend1_no_timeout+0x80>
  11ed9b:	e9 4a 00 00 00       	jmp    11edea <z_unpend1_no_timeout+0xca>
		ret = _priq_wait_best(&wait_q->waitq);
  11eda0:	8b 44 24 34          	mov    0x34(%esp),%eax
  11eda4:	89 04 24             	mov    %eax,(%esp)
  11eda7:	e8 64 fb ff ff       	call   11e910 <z_priq_rb_best>
  11edac:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	LOCKED(&sched_spinlock) {
  11edb0:	8b 44 24 20          	mov    0x20(%esp),%eax
  11edb4:	89 44 24 48          	mov    %eax,0x48(%esp)
  11edb8:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11edbe:	89 44 24 44          	mov    %eax,0x44(%esp)
	arch_irq_unlock(key.key);
  11edc2:	8b 44 24 48          	mov    0x48(%esp),%eax
  11edc6:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11edca:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  11edce:	25 00 02 00 00       	and    $0x200,%eax
  11edd3:	83 f8 00             	cmp    $0x0,%eax
  11edd6:	0f 84 01 00 00 00    	je     11eddd <z_unpend1_no_timeout+0xbd>
		__asm__ volatile ("sti" ::: "memory");
  11eddc:	fb                   	sti    
  11eddd:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
  11ede4:	00 
  11ede5:	e9 9f ff ff ff       	jmp    11ed89 <z_unpend1_no_timeout+0x69>
	return ret;
  11edea:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  11edee:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	if (thread != NULL) {
  11edf2:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  11edf7:	0f 84 ce 00 00 00    	je     11eecb <z_unpend1_no_timeout+0x1ab>
  11edfd:	31 c0                	xor    %eax,%eax
		z_unpend_thread_no_timeout(thread);
  11edff:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11ee03:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
	LOCKED(&sched_spinlock) {
  11ee07:	8d 4c 24 58          	lea    0x58(%esp),%ecx
  11ee0b:	89 0c 24             	mov    %ecx,(%esp)
  11ee0e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11ee15:	00 
  11ee16:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11ee1d:	00 
  11ee1e:	89 44 24 10          	mov    %eax,0x10(%esp)
  11ee22:	e8 49 b6 fe ff       	call   10a470 <memset>
  11ee27:	8d 44 24 50          	lea    0x50(%esp),%eax
  11ee2b:	89 44 24 64          	mov    %eax,0x64(%esp)
  11ee2f:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11ee35:	89 44 24 60          	mov    %eax,0x60(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11ee39:	9c                   	pushf  
  11ee3a:	fa                   	cli    
  11ee3b:	8f 44 24 68          	popl   0x68(%esp)
	return key;
  11ee3f:	8b 44 24 68          	mov    0x68(%esp),%eax
	k.key = arch_irq_lock();
  11ee43:	89 44 24 50          	mov    %eax,0x50(%esp)
  11ee47:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
  11ee4c:	0f 95 c0             	setne  %al
  11ee4f:	34 ff                	xor    $0xff,%al
  11ee51:	a8 01                	test   $0x1,%al
  11ee53:	0f 85 05 00 00 00    	jne    11ee5e <z_unpend1_no_timeout+0x13e>
  11ee59:	e9 62 00 00 00       	jmp    11eec0 <z_unpend1_no_timeout+0x1a0>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
  11ee5e:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11ee62:	89 04 24             	mov    %eax,(%esp)
  11ee65:	e8 c6 fb ff ff       	call   11ea30 <pended_on>
  11ee6a:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  11ee6e:	89 04 24             	mov    %eax,(%esp)
  11ee71:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11ee75:	e8 a6 f7 ff ff       	call   11e620 <z_priq_rb_remove>
		z_mark_thread_as_not_pending(thread);
  11ee7a:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11ee7e:	89 04 24             	mov    %eax,(%esp)
  11ee81:	e8 ca fb ff ff       	call   11ea50 <z_mark_thread_as_not_pending>
	LOCKED(&sched_spinlock) {
  11ee86:	8b 44 24 50          	mov    0x50(%esp),%eax
  11ee8a:	89 44 24 70          	mov    %eax,0x70(%esp)
  11ee8e:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11ee94:	89 44 24 6c          	mov    %eax,0x6c(%esp)
	arch_irq_unlock(key.key);
  11ee98:	8b 44 24 70          	mov    0x70(%esp),%eax
  11ee9c:	89 44 24 74          	mov    %eax,0x74(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11eea0:	8b 44 24 74          	mov    0x74(%esp),%eax
  11eea4:	25 00 02 00 00       	and    $0x200,%eax
  11eea9:	83 f8 00             	cmp    $0x0,%eax
  11eeac:	0f 84 01 00 00 00    	je     11eeb3 <z_unpend1_no_timeout+0x193>
		__asm__ volatile ("sti" ::: "memory");
  11eeb2:	fb                   	sti    
  11eeb3:	c7 44 24 58 01 00 00 	movl   $0x1,0x58(%esp)
  11eeba:	00 
  11eebb:	e9 87 ff ff ff       	jmp    11ee47 <z_unpend1_no_timeout+0x127>
	thread->base.pended_on = NULL;
  11eec0:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  11eec4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	}

	return thread;
  11eecb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  11eecf:	89 ec                	mov    %ebp,%esp
  11eed1:	5d                   	pop    %ebp
  11eed2:	c3                   	ret    
  11eed3:	66 90                	xchg   %ax,%ax
  11eed5:	66 90                	xchg   %ax,%ax
  11eed7:	66 90                	xchg   %ax,%ax
  11eed9:	66 90                	xchg   %ax,%ax
  11eedb:	66 90                	xchg   %ax,%ax
  11eedd:	66 90                	xchg   %ax,%ax
  11eedf:	90                   	nop

0011eee0 <z_abort_thread_timeout>:
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
  11eee0:	55                   	push   %ebp
  11eee1:	89 e5                	mov    %esp,%ebp
  11eee3:	83 ec 08             	sub    $0x8,%esp
  11eee6:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_abort_timeout(&thread->base.timeout);
  11eee9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11eeec:	83 c1 18             	add    $0x18,%ecx
  11eeef:	89 0c 24             	mov    %ecx,(%esp)
  11eef2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11eef5:	e8 56 25 00 00       	call   121450 <z_abort_timeout>
  11eefa:	83 c4 08             	add    $0x8,%esp
  11eefd:	5d                   	pop    %ebp
  11eefe:	c3                   	ret    
  11eeff:	90                   	nop

0011ef00 <z_unpend_thread>:
{
  11ef00:	55                   	push   %ebp
  11ef01:	89 e5                	mov    %esp,%ebp
  11ef03:	83 e4 f8             	and    $0xfffffff8,%esp
  11ef06:	83 ec 40             	sub    $0x40,%esp
  11ef09:	8b 45 08             	mov    0x8(%ebp),%eax
  11ef0c:	31 c9                	xor    %ecx,%ecx
	z_unpend_thread_no_timeout(thread);
  11ef0e:	8b 55 08             	mov    0x8(%ebp),%edx
  11ef11:	89 54 24 24          	mov    %edx,0x24(%esp)
	LOCKED(&sched_spinlock) {
  11ef15:	8d 54 24 20          	lea    0x20(%esp),%edx
  11ef19:	89 14 24             	mov    %edx,(%esp)
  11ef1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11ef23:	00 
  11ef24:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11ef2b:	00 
  11ef2c:	89 44 24 14          	mov    %eax,0x14(%esp)
  11ef30:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11ef34:	e8 37 b5 fe ff       	call   10a470 <memset>
  11ef39:	8d 44 24 18          	lea    0x18(%esp),%eax
  11ef3d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11ef41:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11ef47:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11ef4b:	9c                   	pushf  
  11ef4c:	fa                   	cli    
  11ef4d:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11ef51:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11ef55:	89 44 24 18          	mov    %eax,0x18(%esp)
  11ef59:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11ef5e:	0f 95 c0             	setne  %al
  11ef61:	34 ff                	xor    $0xff,%al
  11ef63:	a8 01                	test   $0x1,%al
  11ef65:	0f 85 05 00 00 00    	jne    11ef70 <z_unpend_thread+0x70>
  11ef6b:	e9 62 00 00 00       	jmp    11efd2 <z_unpend_thread+0xd2>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
  11ef70:	8b 44 24 24          	mov    0x24(%esp),%eax
  11ef74:	89 04 24             	mov    %eax,(%esp)
  11ef77:	e8 b4 fa ff ff       	call   11ea30 <pended_on>
  11ef7c:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  11ef80:	89 04 24             	mov    %eax,(%esp)
  11ef83:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11ef87:	e8 94 f6 ff ff       	call   11e620 <z_priq_rb_remove>
		z_mark_thread_as_not_pending(thread);
  11ef8c:	8b 44 24 24          	mov    0x24(%esp),%eax
  11ef90:	89 04 24             	mov    %eax,(%esp)
  11ef93:	e8 b8 fa ff ff       	call   11ea50 <z_mark_thread_as_not_pending>
	LOCKED(&sched_spinlock) {
  11ef98:	8b 44 24 18          	mov    0x18(%esp),%eax
  11ef9c:	89 44 24 38          	mov    %eax,0x38(%esp)
  11efa0:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11efa6:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11efaa:	8b 44 24 38          	mov    0x38(%esp),%eax
  11efae:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11efb2:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11efb6:	25 00 02 00 00       	and    $0x200,%eax
  11efbb:	83 f8 00             	cmp    $0x0,%eax
  11efbe:	0f 84 01 00 00 00    	je     11efc5 <z_unpend_thread+0xc5>
		__asm__ volatile ("sti" ::: "memory");
  11efc4:	fb                   	sti    
  11efc5:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11efcc:	00 
  11efcd:	e9 87 ff ff ff       	jmp    11ef59 <z_unpend_thread+0x59>
	thread->base.pended_on = NULL;
  11efd2:	8b 44 24 24          	mov    0x24(%esp),%eax
  11efd6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	(void)z_abort_thread_timeout(thread);
  11efdd:	8b 45 08             	mov    0x8(%ebp),%eax
  11efe0:	89 04 24             	mov    %eax,(%esp)
  11efe3:	e8 f8 fe ff ff       	call   11eee0 <z_abort_thread_timeout>
}
  11efe8:	89 ec                	mov    %ebp,%esp
  11efea:	5d                   	pop    %ebp
  11efeb:	c3                   	ret    
  11efec:	66 90                	xchg   %ax,%ax
  11efee:	66 90                	xchg   %ax,%ax

0011eff0 <z_is_thread_ready>:
{
  11eff0:	55                   	push   %ebp
  11eff1:	89 e5                	mov    %esp,%ebp
  11eff3:	83 ec 0c             	sub    $0xc,%esp
  11eff6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11eff9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11effc:	89 0c 24             	mov    %ecx,(%esp)
  11efff:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11f002:	e8 49 0d 00 00       	call   11fd50 <z_is_thread_prevented_from_running>
  11f007:	24 01                	and    $0x1,%al
  11f009:	0f b6 c8             	movzbl %al,%ecx
  11f00c:	83 f9 00             	cmp    $0x0,%ecx
  11f00f:	b0 01                	mov    $0x1,%al
  11f011:	88 45 fb             	mov    %al,-0x5(%ebp)
  11f014:	0f 85 0e 00 00 00    	jne    11f028 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  11f01a:	8b 45 08             	mov    0x8(%ebp),%eax
  11f01d:	89 04 24             	mov    %eax,(%esp)
  11f020:	e8 3b 0c 00 00       	call   11fc60 <z_is_thread_timeout_active>
  11f025:	88 45 fb             	mov    %al,-0x5(%ebp)
  11f028:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  11f02b:	34 ff                	xor    $0xff,%al
  11f02d:	24 01                	and    $0x1,%al
  11f02f:	0f b6 c0             	movzbl %al,%eax
  11f032:	83 c4 0c             	add    $0xc,%esp
  11f035:	5d                   	pop    %ebp
  11f036:	c3                   	ret    
  11f037:	66 90                	xchg   %ax,%ax
  11f039:	66 90                	xchg   %ax,%ax
  11f03b:	66 90                	xchg   %ax,%ax
  11f03d:	66 90                	xchg   %ax,%ax
  11f03f:	90                   	nop

0011f040 <z_reschedule_unlocked>:
{
  11f040:	55                   	push   %ebp
  11f041:	89 e5                	mov    %esp,%ebp
  11f043:	83 ec 08             	sub    $0x8,%esp
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f046:	9c                   	pushf  
  11f047:	fa                   	cli    
  11f048:	8f 45 fc             	popl   -0x4(%ebp)
	return key;
  11f04b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	(void) z_reschedule_irqlock(arch_irq_lock());
  11f04e:	89 04 24             	mov    %eax,(%esp)
  11f051:	e8 da 00 00 00       	call   11f130 <z_reschedule_irqlock>
}
  11f056:	83 c4 08             	add    $0x8,%esp
  11f059:	5d                   	pop    %ebp
  11f05a:	c3                   	ret    
  11f05b:	66 90                	xchg   %ax,%ax
  11f05d:	66 90                	xchg   %ax,%ax
  11f05f:	90                   	nop

0011f060 <z_reschedule>:
{
  11f060:	55                   	push   %ebp
  11f061:	89 e5                	mov    %esp,%ebp
  11f063:	83 e4 f8             	and    $0xfffffff8,%esp
  11f066:	83 ec 28             	sub    $0x28,%esp
  11f069:	8b 45 0c             	mov    0xc(%ebp),%eax
  11f06c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11f06f:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (resched(key.key)) {
  11f073:	8b 44 24 08          	mov    0x8(%esp),%eax
  11f077:	89 04 24             	mov    %eax,(%esp)
  11f07a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11f07e:	e8 6d 00 00 00       	call   11f0f0 <resched>
  11f083:	83 f8 00             	cmp    $0x0,%eax
  11f086:	0f 84 28 00 00 00    	je     11f0b4 <z_reschedule+0x54>
		z_swap(lock, key);
  11f08c:	8b 45 08             	mov    0x8(%ebp),%eax
  11f08f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  11f093:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  11f097:	89 44 24 0c          	mov    %eax,0xc(%esp)
	k_spin_release(lock);
  11f09b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  11f09f:	89 44 24 18          	mov    %eax,0x18(%esp)
	return z_swap_irqlock(key.key);
  11f0a3:	8b 44 24 10          	mov    0x10(%esp),%eax
  11f0a7:	89 04 24             	mov    %eax,(%esp)
  11f0aa:	e8 91 fb ff ff       	call   11ec40 <z_swap_irqlock>
	} else {
  11f0af:	e9 2f 00 00 00       	jmp    11f0e3 <z_reschedule+0x83>
		k_spin_unlock(lock, key);
  11f0b4:	8b 45 08             	mov    0x8(%ebp),%eax
  11f0b7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  11f0bb:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  11f0bf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11f0c3:	8b 44 24 20          	mov    0x20(%esp),%eax
  11f0c7:	89 44 24 24          	mov    %eax,0x24(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11f0cb:	8b 44 24 24          	mov    0x24(%esp),%eax
  11f0cf:	25 00 02 00 00       	and    $0x200,%eax
  11f0d4:	83 f8 00             	cmp    $0x0,%eax
  11f0d7:	0f 84 01 00 00 00    	je     11f0de <z_reschedule+0x7e>
		__asm__ volatile ("sti" ::: "memory");
  11f0dd:	fb                   	sti    
  11f0de:	e9 00 00 00 00       	jmp    11f0e3 <z_reschedule+0x83>
}
  11f0e3:	89 ec                	mov    %ebp,%esp
  11f0e5:	5d                   	pop    %ebp
  11f0e6:	c3                   	ret    
  11f0e7:	66 90                	xchg   %ax,%ax
  11f0e9:	66 90                	xchg   %ax,%ax
  11f0eb:	66 90                	xchg   %ax,%ax
  11f0ed:	66 90                	xchg   %ax,%ax
  11f0ef:	90                   	nop

0011f0f0 <resched>:
{
  11f0f0:	55                   	push   %ebp
  11f0f1:	89 e5                	mov    %esp,%ebp
  11f0f3:	83 ec 08             	sub    $0x8,%esp
  11f0f6:	8b 45 08             	mov    0x8(%ebp),%eax
  11f0f9:	31 c9                	xor    %ecx,%ecx
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  11f0fb:	8b 55 08             	mov    0x8(%ebp),%edx
  11f0fe:	89 55 fc             	mov    %edx,-0x4(%ebp)
}

static ALWAYS_INLINE bool arch_irq_unlocked(unsigned int key)
{
	return (key & 0x200) != 0;
  11f101:	8b 55 fc             	mov    -0x4(%ebp),%edx
  11f104:	81 e2 00 02 00 00    	and    $0x200,%edx
  11f10a:	83 fa 00             	cmp    $0x0,%edx
  11f10d:	88 4d fb             	mov    %cl,-0x5(%ebp)
  11f110:	0f 84 0a 00 00 00    	je     11f120 <resched+0x30>
  11f116:	e8 b5 0a 00 00       	call   11fbd0 <arch_is_in_isr>
  11f11b:	34 ff                	xor    $0xff,%al
  11f11d:	88 45 fb             	mov    %al,-0x5(%ebp)
  11f120:	8a 45 fb             	mov    -0x5(%ebp),%al
  11f123:	24 01                	and    $0x1,%al
  11f125:	0f b6 c0             	movzbl %al,%eax
  11f128:	83 c4 08             	add    $0x8,%esp
  11f12b:	5d                   	pop    %ebp
  11f12c:	c3                   	ret    
  11f12d:	66 90                	xchg   %ax,%ax
  11f12f:	90                   	nop

0011f130 <z_reschedule_irqlock>:
{
  11f130:	55                   	push   %ebp
  11f131:	89 e5                	mov    %esp,%ebp
  11f133:	83 ec 0c             	sub    $0xc,%esp
  11f136:	8b 45 08             	mov    0x8(%ebp),%eax
	if (resched(key)) {
  11f139:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11f13c:	89 0c 24             	mov    %ecx,(%esp)
  11f13f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11f142:	e8 a9 ff ff ff       	call   11f0f0 <resched>
  11f147:	83 f8 00             	cmp    $0x0,%eax
  11f14a:	0f 84 10 00 00 00    	je     11f160 <z_reschedule_irqlock+0x30>
		z_swap_irqlock(key);
  11f150:	8b 45 08             	mov    0x8(%ebp),%eax
  11f153:	89 04 24             	mov    %eax,(%esp)
  11f156:	e8 e5 fa ff ff       	call   11ec40 <z_swap_irqlock>
	} else {
  11f15b:	e9 1d 00 00 00       	jmp    11f17d <z_reschedule_irqlock+0x4d>
		irq_unlock(key);
  11f160:	8b 45 08             	mov    0x8(%ebp),%eax
  11f163:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11f166:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11f169:	25 00 02 00 00       	and    $0x200,%eax
  11f16e:	83 f8 00             	cmp    $0x0,%eax
  11f171:	0f 84 01 00 00 00    	je     11f178 <z_reschedule_irqlock+0x48>
		__asm__ volatile ("sti" ::: "memory");
  11f177:	fb                   	sti    
  11f178:	e9 00 00 00 00       	jmp    11f17d <z_reschedule_irqlock+0x4d>
}
  11f17d:	83 c4 0c             	add    $0xc,%esp
  11f180:	5d                   	pop    %ebp
  11f181:	c3                   	ret    
  11f182:	66 90                	xchg   %ax,%ax
  11f184:	66 90                	xchg   %ax,%ax
  11f186:	66 90                	xchg   %ax,%ax
  11f188:	66 90                	xchg   %ax,%ax
  11f18a:	66 90                	xchg   %ax,%ax
  11f18c:	66 90                	xchg   %ax,%ax
  11f18e:	66 90                	xchg   %ax,%ax

0011f190 <k_sched_lock>:
{
  11f190:	55                   	push   %ebp
  11f191:	89 e5                	mov    %esp,%ebp
  11f193:	83 e4 f8             	and    $0xfffffff8,%esp
  11f196:	83 ec 38             	sub    $0x38,%esp
  11f199:	31 c0                	xor    %eax,%eax
	LOCKED(&sched_spinlock) {
  11f19b:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  11f19f:	89 0c 24             	mov    %ecx,(%esp)
  11f1a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11f1a9:	00 
  11f1aa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11f1b1:	00 
  11f1b2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11f1b6:	e8 b5 b2 fe ff       	call   10a470 <memset>
  11f1bb:	8d 44 24 10          	lea    0x10(%esp),%eax
  11f1bf:	89 44 24 24          	mov    %eax,0x24(%esp)
  11f1c3:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f1c9:	89 44 24 20          	mov    %eax,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f1cd:	9c                   	pushf  
  11f1ce:	fa                   	cli    
  11f1cf:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  11f1d3:	8b 44 24 28          	mov    0x28(%esp),%eax
	k.key = arch_irq_lock();
  11f1d7:	89 44 24 10          	mov    %eax,0x10(%esp)
  11f1db:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  11f1e0:	0f 95 c0             	setne  %al
  11f1e3:	34 ff                	xor    $0xff,%al
  11f1e5:	a8 01                	test   $0x1,%al
  11f1e7:	0f 85 05 00 00 00    	jne    11f1f2 <k_sched_lock+0x62>
  11f1ed:	e9 3f 00 00 00       	jmp    11f231 <k_sched_lock+0xa1>
		z_sched_lock();
  11f1f2:	e8 49 00 00 00       	call   11f240 <z_sched_lock>
	LOCKED(&sched_spinlock) {
  11f1f7:	8b 44 24 10          	mov    0x10(%esp),%eax
  11f1fb:	89 44 24 30          	mov    %eax,0x30(%esp)
  11f1ff:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f205:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  11f209:	8b 44 24 30          	mov    0x30(%esp),%eax
  11f20d:	89 44 24 34          	mov    %eax,0x34(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11f211:	8b 44 24 34          	mov    0x34(%esp),%eax
  11f215:	25 00 02 00 00       	and    $0x200,%eax
  11f21a:	83 f8 00             	cmp    $0x0,%eax
  11f21d:	0f 84 01 00 00 00    	je     11f224 <k_sched_lock+0x94>
		__asm__ volatile ("sti" ::: "memory");
  11f223:	fb                   	sti    
  11f224:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
  11f22b:	00 
  11f22c:	e9 aa ff ff ff       	jmp    11f1db <k_sched_lock+0x4b>
}
  11f231:	89 ec                	mov    %ebp,%esp
  11f233:	5d                   	pop    %ebp
  11f234:	c3                   	ret    
  11f235:	66 90                	xchg   %ax,%ax
  11f237:	66 90                	xchg   %ax,%ax
  11f239:	66 90                	xchg   %ax,%ax
  11f23b:	66 90                	xchg   %ax,%ax
  11f23d:	66 90                	xchg   %ax,%ax
  11f23f:	90                   	nop

0011f240 <z_sched_lock>:
{
  11f240:	55                   	push   %ebp
  11f241:	89 e5                	mov    %esp,%ebp
	--_current->base.sched_locked;
  11f243:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f248:	8a 48 0f             	mov    0xf(%eax),%cl
  11f24b:	80 c1 ff             	add    $0xff,%cl
  11f24e:	88 48 0f             	mov    %cl,0xf(%eax)
}
  11f251:	5d                   	pop    %ebp
  11f252:	c3                   	ret    
  11f253:	66 90                	xchg   %ax,%ax
  11f255:	66 90                	xchg   %ax,%ax
  11f257:	66 90                	xchg   %ax,%ax
  11f259:	66 90                	xchg   %ax,%ax
  11f25b:	66 90                	xchg   %ax,%ax
  11f25d:	66 90                	xchg   %ax,%ax
  11f25f:	90                   	nop

0011f260 <k_sched_unlock>:
{
  11f260:	55                   	push   %ebp
  11f261:	89 e5                	mov    %esp,%ebp
  11f263:	83 e4 f8             	and    $0xfffffff8,%esp
  11f266:	83 ec 40             	sub    $0x40,%esp
  11f269:	31 c0                	xor    %eax,%eax
	LOCKED(&sched_spinlock) {
  11f26b:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  11f26f:	89 0c 24             	mov    %ecx,(%esp)
  11f272:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11f279:	00 
  11f27a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11f281:	00 
  11f282:	89 44 24 14          	mov    %eax,0x14(%esp)
  11f286:	e8 e5 b1 fe ff       	call   10a470 <memset>
  11f28b:	8d 44 24 18          	lea    0x18(%esp),%eax
  11f28f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11f293:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f299:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f29d:	9c                   	pushf  
  11f29e:	fa                   	cli    
  11f29f:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  11f2a3:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  11f2a7:	89 44 24 18          	mov    %eax,0x18(%esp)
  11f2ab:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  11f2b0:	0f 95 c0             	setne  %al
  11f2b3:	34 ff                	xor    $0xff,%al
  11f2b5:	a8 01                	test   $0x1,%al
  11f2b7:	0f 85 05 00 00 00    	jne    11f2c2 <k_sched_unlock+0x62>
  11f2bd:	e9 5b 00 00 00       	jmp    11f31d <k_sched_unlock+0xbd>
  11f2c2:	31 c0                	xor    %eax,%eax
		++_current->base.sched_locked;
  11f2c4:	8b 0d b0 96 13 00    	mov    0x1396b0,%ecx
  11f2ca:	8a 51 0f             	mov    0xf(%ecx),%dl
  11f2cd:	80 c2 01             	add    $0x1,%dl
  11f2d0:	88 51 0f             	mov    %dl,0xf(%ecx)
		update_cache(0);
  11f2d3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11f2da:	89 44 24 10          	mov    %eax,0x10(%esp)
  11f2de:	e8 fd f1 ff ff       	call   11e4e0 <update_cache>
	LOCKED(&sched_spinlock) {
  11f2e3:	8b 44 24 18          	mov    0x18(%esp),%eax
  11f2e7:	89 44 24 38          	mov    %eax,0x38(%esp)
  11f2eb:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f2f1:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  11f2f5:	8b 44 24 38          	mov    0x38(%esp),%eax
  11f2f9:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11f2fd:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11f301:	25 00 02 00 00       	and    $0x200,%eax
  11f306:	83 f8 00             	cmp    $0x0,%eax
  11f309:	0f 84 01 00 00 00    	je     11f310 <k_sched_unlock+0xb0>
		__asm__ volatile ("sti" ::: "memory");
  11f30f:	fb                   	sti    
  11f310:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  11f317:	00 
  11f318:	e9 8e ff ff ff       	jmp    11f2ab <k_sched_unlock+0x4b>
	z_reschedule_unlocked();
  11f31d:	e8 1e fd ff ff       	call   11f040 <z_reschedule_unlocked>
}
  11f322:	89 ec                	mov    %ebp,%esp
  11f324:	5d                   	pop    %ebp
  11f325:	c3                   	ret    
  11f326:	66 90                	xchg   %ax,%ax
  11f328:	66 90                	xchg   %ax,%ax
  11f32a:	66 90                	xchg   %ax,%ax
  11f32c:	66 90                	xchg   %ax,%ax
  11f32e:	66 90                	xchg   %ax,%ax

0011f330 <z_priq_rb_lessthan>:
{
  11f330:	55                   	push   %ebp
  11f331:	89 e5                	mov    %esp,%ebp
  11f333:	56                   	push   %esi
  11f334:	83 ec 24             	sub    $0x24,%esp
  11f337:	8b 45 0c             	mov    0xc(%ebp),%eax
  11f33a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	ta = CONTAINER_OF(a, struct k_thread, base.qnode_rb);
  11f33d:	8b 55 08             	mov    0x8(%ebp),%edx
  11f340:	89 55 f4             	mov    %edx,-0xc(%ebp)
	tb = CONTAINER_OF(b, struct k_thread, base.qnode_rb);
  11f343:	8b 55 0c             	mov    0xc(%ebp),%edx
  11f346:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if (z_is_t1_higher_prio_than_t2(ta, tb)) {
  11f349:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11f34c:	8b 75 f0             	mov    -0x10(%ebp),%esi
  11f34f:	89 14 24             	mov    %edx,(%esp)
  11f352:	89 74 24 04          	mov    %esi,0x4(%esp)
  11f356:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11f359:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  11f35c:	e8 3f e8 ff ff       	call   11dba0 <z_is_t1_higher_prio_than_t2>
  11f361:	a8 01                	test   $0x1,%al
  11f363:	0f 85 05 00 00 00    	jne    11f36e <z_priq_rb_lessthan+0x3e>
  11f369:	e9 09 00 00 00       	jmp    11f377 <z_priq_rb_lessthan+0x47>
		return true;
  11f36e:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
  11f372:	e9 5e 00 00 00       	jmp    11f3d5 <z_priq_rb_lessthan+0xa5>
	} else if (z_is_t1_higher_prio_than_t2(tb, ta)) {
  11f377:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11f37a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11f37d:	89 04 24             	mov    %eax,(%esp)
  11f380:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11f384:	e8 17 e8 ff ff       	call   11dba0 <z_is_t1_higher_prio_than_t2>
  11f389:	a8 01                	test   $0x1,%al
  11f38b:	0f 85 05 00 00 00    	jne    11f396 <z_priq_rb_lessthan+0x66>
  11f391:	e9 09 00 00 00       	jmp    11f39f <z_priq_rb_lessthan+0x6f>
		return false;
  11f396:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
  11f39a:	e9 36 00 00 00       	jmp    11f3d5 <z_priq_rb_lessthan+0xa5>
  11f39f:	31 c0                	xor    %eax,%eax
		return ta->base.order_key < tb->base.order_key ? 1 : 0;
  11f3a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  11f3a4:	8b 49 10             	mov    0x10(%ecx),%ecx
  11f3a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11f3aa:	8b 52 10             	mov    0x10(%edx),%edx
  11f3ad:	39 d1                	cmp    %edx,%ecx
  11f3af:	b9 01 00 00 00       	mov    $0x1,%ecx
  11f3b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11f3b7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  11f3ba:	0f 82 06 00 00 00    	jb     11f3c6 <z_priq_rb_lessthan+0x96>
  11f3c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11f3c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  11f3c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11f3c9:	83 f8 00             	cmp    $0x0,%eax
  11f3cc:	0f 95 c1             	setne  %cl
  11f3cf:	80 e1 01             	and    $0x1,%cl
  11f3d2:	88 4d fb             	mov    %cl,-0x5(%ebp)
}
  11f3d5:	8a 45 fb             	mov    -0x5(%ebp),%al
  11f3d8:	24 01                	and    $0x1,%al
  11f3da:	0f b6 c0             	movzbl %al,%eax
  11f3dd:	83 c4 24             	add    $0x24,%esp
  11f3e0:	5e                   	pop    %esi
  11f3e1:	5d                   	pop    %ebp
  11f3e2:	c3                   	ret    
  11f3e3:	66 90                	xchg   %ax,%ax
  11f3e5:	66 90                	xchg   %ax,%ax
  11f3e7:	66 90                	xchg   %ax,%ax
  11f3e9:	66 90                	xchg   %ax,%ax
  11f3eb:	66 90                	xchg   %ax,%ax
  11f3ed:	66 90                	xchg   %ax,%ax
  11f3ef:	90                   	nop

0011f3f0 <rb_get_min>:

/**
 * @brief Returns the lowest-sorted member of the tree
 */
static inline struct rbnode *rb_get_min(struct rbtree *tree)
{
  11f3f0:	55                   	push   %ebp
  11f3f1:	89 e5                	mov    %esp,%ebp
  11f3f3:	83 ec 10             	sub    $0x10,%esp
  11f3f6:	8b 45 08             	mov    0x8(%ebp),%eax
  11f3f9:	31 c9                	xor    %ecx,%ecx
	return z_rb_get_minmax(tree, 0);
  11f3fb:	8b 55 08             	mov    0x8(%ebp),%edx
  11f3fe:	89 14 24             	mov    %edx,(%esp)
  11f401:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11f408:	00 
  11f409:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11f40c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11f40f:	e8 4c 1c fe ff       	call   101060 <z_rb_get_minmax>
  11f414:	83 c4 10             	add    $0x10,%esp
  11f417:	5d                   	pop    %ebp
  11f418:	c3                   	ret    
  11f419:	66 90                	xchg   %ax,%ax
  11f41b:	66 90                	xchg   %ax,%ax
  11f41d:	66 90                	xchg   %ax,%ax
  11f41f:	90                   	nop

0011f420 <z_unpend_all>:
	}
	return t;
}

int z_unpend_all(_wait_q_t *wait_q)
{
  11f420:	55                   	push   %ebp
  11f421:	89 e5                	mov    %esp,%ebp
  11f423:	83 ec 10             	sub    $0x10,%esp
  11f426:	8b 45 08             	mov    0x8(%ebp),%eax
	int need_sched = 0;
  11f429:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	struct k_thread *th;

	while ((th = z_waitq_head(wait_q)) != NULL) {
  11f430:	8b 45 08             	mov    0x8(%ebp),%eax
  11f433:	89 04 24             	mov    %eax,(%esp)
  11f436:	e8 55 00 00 00       	call   11f490 <z_waitq_head>
  11f43b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11f43e:	83 f8 00             	cmp    $0x0,%eax
  11f441:	0f 84 40 00 00 00    	je     11f487 <z_unpend_all+0x67>
		z_unpend_thread(th);
  11f447:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11f44a:	89 04 24             	mov    %eax,(%esp)
  11f44d:	e8 ae fa ff ff       	call   11ef00 <z_unpend_thread>
		z_ready_thread(th);
  11f452:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11f455:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (z_is_thread_ready(thread)) {
  11f458:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11f45b:	89 04 24             	mov    %eax,(%esp)
  11f45e:	e8 8d fb ff ff       	call   11eff0 <z_is_thread_ready>
  11f463:	a8 01                	test   $0x1,%al
  11f465:	0f 85 05 00 00 00    	jne    11f470 <z_unpend_all+0x50>
  11f46b:	e9 0b 00 00 00       	jmp    11f47b <z_unpend_all+0x5b>
		z_add_thread_to_ready_q(thread);
  11f470:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11f473:	89 04 24             	mov    %eax,(%esp)
  11f476:	e8 55 ee ff ff       	call   11e2d0 <z_add_thread_to_ready_q>
		need_sched = 1;
  11f47b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
	while ((th = z_waitq_head(wait_q)) != NULL) {
  11f482:	e9 a9 ff ff ff       	jmp    11f430 <z_unpend_all+0x10>
	}

	return need_sched;
  11f487:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11f48a:	83 c4 10             	add    $0x10,%esp
  11f48d:	5d                   	pop    %ebp
  11f48e:	c3                   	ret    
  11f48f:	90                   	nop

0011f490 <z_waitq_head>:

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
  11f490:	55                   	push   %ebp
  11f491:	89 e5                	mov    %esp,%ebp
  11f493:	83 ec 08             	sub    $0x8,%esp
  11f496:	8b 45 08             	mov    0x8(%ebp),%eax
	return (struct k_thread *)rb_get_min(&w->waitq.tree);
  11f499:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11f49c:	89 0c 24             	mov    %ecx,(%esp)
  11f49f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11f4a2:	e8 49 ff ff ff       	call   11f3f0 <rb_get_min>
  11f4a7:	83 c4 08             	add    $0x8,%esp
  11f4aa:	5d                   	pop    %ebp
  11f4ab:	c3                   	ret    
  11f4ac:	66 90                	xchg   %ax,%ax
  11f4ae:	66 90                	xchg   %ax,%ax

0011f4b0 <z_sched_init>:
}

void z_sched_init(void)
{
  11f4b0:	55                   	push   %ebp
  11f4b1:	89 e5                	mov    %esp,%ebp
  11f4b3:	83 e4 f8             	and    $0xfffffff8,%esp
  11f4b6:	83 ec 20             	sub    $0x20,%esp
  11f4b9:	31 c0                	xor    %eax,%eax
	sys_dlist_init(&_kernel.ready_q.runq);
#endif

#ifdef CONFIG_SCHED_SCALABLE
	_kernel.ready_q.runq = (struct _priq_rb) {
		.tree = {
  11f4bb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  11f4c2:	00 
  11f4c3:	8d 0d 30 f3 11 00    	lea    0x11f330,%ecx
  11f4c9:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  11f4cd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  11f4d4:	00 
	_kernel.ready_q.runq = (struct _priq_rb) {
  11f4d5:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  11f4dc:	00 
  11f4dd:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  11f4e1:	89 0d cc 96 13 00    	mov    %ecx,0x1396cc
  11f4e7:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  11f4eb:	89 0d d0 96 13 00    	mov    %ecx,0x1396d0
  11f4f1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  11f4f5:	89 0d d4 96 13 00    	mov    %ecx,0x1396d4
  11f4fb:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11f4ff:	89 0d d8 96 13 00    	mov    %ecx,0x1396d8
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  11f505:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  11f50c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11f513:	00 
  11f514:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11f518:	e8 13 e7 ff ff       	call   11dc30 <k_sched_time_slice_set>
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
  11f51d:	89 ec                	mov    %ebp,%esp
  11f51f:	5d                   	pop    %ebp
  11f520:	c3                   	ret    
  11f521:	66 90                	xchg   %ax,%ax
  11f523:	66 90                	xchg   %ax,%ax
  11f525:	66 90                	xchg   %ax,%ax
  11f527:	66 90                	xchg   %ax,%ax
  11f529:	66 90                	xchg   %ax,%ax
  11f52b:	66 90                	xchg   %ax,%ax
  11f52d:	66 90                	xchg   %ax,%ax
  11f52f:	90                   	nop

0011f530 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
  11f530:	55                   	push   %ebp
  11f531:	89 e5                	mov    %esp,%ebp
  11f533:	83 e4 f8             	and    $0xfffffff8,%esp
  11f536:	83 ec 38             	sub    $0x38,%esp
	__ASSERT(!arch_is_in_isr(), "");

	if (!z_is_idle_thread_object(_current)) {
  11f539:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f53e:	89 04 24             	mov    %eax,(%esp)
  11f541:	e8 fa 00 00 00       	call   11f640 <z_is_idle_thread_object>
  11f546:	a8 01                	test   $0x1,%al
  11f548:	0f 85 e7 00 00 00    	jne    11f635 <z_impl_k_yield+0x105>
  11f54e:	31 c0                	xor    %eax,%eax
		LOCKED(&sched_spinlock) {
  11f550:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  11f554:	89 0c 24             	mov    %ecx,(%esp)
  11f557:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  11f55e:	00 
  11f55f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  11f566:	00 
  11f567:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11f56b:	e8 00 af fe ff       	call   10a470 <memset>
  11f570:	8d 44 24 10          	lea    0x10(%esp),%eax
  11f574:	89 44 24 24          	mov    %eax,0x24(%esp)
  11f578:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f57e:	89 44 24 20          	mov    %eax,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f582:	9c                   	pushf  
  11f583:	fa                   	cli    
  11f584:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  11f588:	8b 44 24 28          	mov    0x28(%esp),%eax
	k.key = arch_irq_lock();
  11f58c:	89 44 24 10          	mov    %eax,0x10(%esp)
  11f590:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  11f595:	0f 95 c0             	setne  %al
  11f598:	34 ff                	xor    $0xff,%al
  11f59a:	a8 01                	test   $0x1,%al
  11f59c:	0f 85 05 00 00 00    	jne    11f5a7 <z_impl_k_yield+0x77>
  11f5a2:	e9 89 00 00 00       	jmp    11f630 <z_impl_k_yield+0x100>
  11f5a7:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11f5ad:	83 c0 24             	add    $0x24,%eax
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
						 _current);
  11f5b0:	8b 0d b0 96 13 00    	mov    0x1396b0,%ecx
				_priq_run_remove(&_kernel.ready_q.runq,
  11f5b6:	89 04 24             	mov    %eax,(%esp)
  11f5b9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11f5bd:	e8 5e f0 ff ff       	call   11e620 <z_priq_rb_remove>
  11f5c2:	8d 05 a8 96 13 00    	lea    0x1396a8,%eax
  11f5c8:	83 c0 24             	add    $0x24,%eax
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
  11f5cb:	8b 0d b0 96 13 00    	mov    0x1396b0,%ecx
  11f5d1:	89 04 24             	mov    %eax,(%esp)
  11f5d4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11f5d8:	e8 d3 ed ff ff       	call   11e3b0 <z_priq_rb_add>
			z_mark_thread_as_queued(_current);
  11f5dd:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f5e2:	89 04 24             	mov    %eax,(%esp)
  11f5e5:	e8 c6 ee ff ff       	call   11e4b0 <z_mark_thread_as_queued>
			update_cache(1);
  11f5ea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  11f5f1:	e8 ea ee ff ff       	call   11e4e0 <update_cache>
		LOCKED(&sched_spinlock) {
  11f5f6:	8b 44 24 10          	mov    0x10(%esp),%eax
  11f5fa:	89 44 24 30          	mov    %eax,0x30(%esp)
  11f5fe:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11f604:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  11f608:	8b 44 24 30          	mov    0x30(%esp),%eax
  11f60c:	89 44 24 34          	mov    %eax,0x34(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11f610:	8b 44 24 34          	mov    0x34(%esp),%eax
  11f614:	25 00 02 00 00       	and    $0x200,%eax
  11f619:	83 f8 00             	cmp    $0x0,%eax
  11f61c:	0f 84 01 00 00 00    	je     11f623 <z_impl_k_yield+0xf3>
		__asm__ volatile ("sti" ::: "memory");
  11f622:	fb                   	sti    
  11f623:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
  11f62a:	00 
  11f62b:	e9 60 ff ff ff       	jmp    11f590 <z_impl_k_yield+0x60>
		}
	}
  11f630:	e9 00 00 00 00       	jmp    11f635 <z_impl_k_yield+0x105>
	z_swap_unlocked();
  11f635:	e8 36 00 00 00       	call   11f670 <z_swap_unlocked>
}
  11f63a:	89 ec                	mov    %ebp,%esp
  11f63c:	5d                   	pop    %ebp
  11f63d:	c3                   	ret    
  11f63e:	66 90                	xchg   %ax,%ax

0011f640 <z_is_idle_thread_object>:
{
  11f640:	55                   	push   %ebp
  11f641:	89 e5                	mov    %esp,%ebp
  11f643:	50                   	push   %eax
  11f644:	8b 45 08             	mov    0x8(%ebp),%eax
	return thread == &z_idle_thread;
  11f647:	8d 0d 00 56 13 00    	lea    0x135600,%ecx
  11f64d:	39 4d 08             	cmp    %ecx,0x8(%ebp)
  11f650:	0f 94 c2             	sete   %dl
  11f653:	80 e2 01             	and    $0x1,%dl
  11f656:	0f b6 ca             	movzbl %dl,%ecx
  11f659:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11f65c:	89 c8                	mov    %ecx,%eax
  11f65e:	83 c4 04             	add    $0x4,%esp
  11f661:	5d                   	pop    %ebp
  11f662:	c3                   	ret    
  11f663:	66 90                	xchg   %ax,%ax
  11f665:	66 90                	xchg   %ax,%ax
  11f667:	66 90                	xchg   %ax,%ax
  11f669:	66 90                	xchg   %ax,%ax
  11f66b:	66 90                	xchg   %ax,%ax
  11f66d:	66 90                	xchg   %ax,%ax
  11f66f:	90                   	nop

0011f670 <z_swap_unlocked>:
{
  11f670:	55                   	push   %ebp
  11f671:	89 e5                	mov    %esp,%ebp
  11f673:	83 ec 08             	sub    $0x8,%esp
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f676:	9c                   	pushf  
  11f677:	fa                   	cli    
  11f678:	8f 45 fc             	popl   -0x4(%ebp)
	return key;
  11f67b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	(void) z_swap_irqlock(arch_irq_lock());
  11f67e:	89 04 24             	mov    %eax,(%esp)
  11f681:	e8 ba f5 ff ff       	call   11ec40 <z_swap_irqlock>
}
  11f686:	83 c4 08             	add    $0x8,%esp
  11f689:	5d                   	pop    %ebp
  11f68a:	c3                   	ret    
  11f68b:	66 90                	xchg   %ax,%ax
  11f68d:	66 90                	xchg   %ax,%ax
  11f68f:	90                   	nop

0011f690 <z_impl_k_sleep>:

	return 0;
}

s32_t z_impl_k_sleep(int ms)
{
  11f690:	55                   	push   %ebp
  11f691:	89 e5                	mov    %esp,%ebp
  11f693:	83 ec 10             	sub    $0x10,%esp
  11f696:	8b 45 08             	mov    0x8(%ebp),%eax
	s32_t ticks;

	if (ms == K_FOREVER) {
  11f699:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
  11f69d:	0f 85 19 00 00 00    	jne    11f6bc <z_impl_k_sleep+0x2c>
		k_thread_suspend(_current);
  11f6a3:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f6a8:	89 04 24             	mov    %eax,(%esp)
  11f6ab:	e8 50 00 00 00       	call   11f700 <k_thread_suspend>
		return K_FOREVER;
  11f6b0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  11f6b7:	e9 35 00 00 00       	jmp    11f6f1 <z_impl_k_sleep+0x61>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
  11f6bc:	8b 45 08             	mov    0x8(%ebp),%eax
  11f6bf:	89 e1                	mov    %esp,%ecx
  11f6c1:	89 01                	mov    %eax,(%ecx)
  11f6c3:	e8 48 e6 ff ff       	call   11dd10 <k_ms_to_ticks_ceil32>
  11f6c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
	ticks = z_tick_sleep(ticks);
  11f6cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11f6ce:	89 e1                	mov    %esp,%ecx
  11f6d0:	89 01                	mov    %eax,(%ecx)
  11f6d2:	e8 49 00 00 00       	call   11f720 <z_tick_sleep>
  11f6d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return k_ticks_to_ms_floor64(ticks);
  11f6da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11f6dd:	89 c1                	mov    %eax,%ecx
  11f6df:	c1 f9 1f             	sar    $0x1f,%ecx
  11f6e2:	89 e2                	mov    %esp,%edx
  11f6e4:	89 4a 04             	mov    %ecx,0x4(%edx)
  11f6e7:	89 02                	mov    %eax,(%edx)
  11f6e9:	e8 32 01 00 00       	call   11f820 <k_ticks_to_ms_floor64>
  11f6ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  11f6f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  11f6f4:	83 c4 10             	add    $0x10,%esp
  11f6f7:	5d                   	pop    %ebp
  11f6f8:	c3                   	ret    
  11f6f9:	66 90                	xchg   %ax,%ax
  11f6fb:	66 90                	xchg   %ax,%ax
  11f6fd:	66 90                	xchg   %ax,%ax
  11f6ff:	90                   	nop

0011f700 <k_thread_suspend>:
{
  11f700:	55                   	push   %ebp
  11f701:	89 e5                	mov    %esp,%ebp
  11f703:	50                   	push   %eax
  11f704:	8b 45 08             	mov    0x8(%ebp),%eax
	z_impl_k_thread_suspend(thread);
  11f707:	8b 45 08             	mov    0x8(%ebp),%eax
  11f70a:	89 04 24             	mov    %eax,(%esp)
  11f70d:	e8 be 10 00 00       	call   1207d0 <z_impl_k_thread_suspend>
}
  11f712:	83 c4 04             	add    $0x4,%esp
  11f715:	5d                   	pop    %ebp
  11f716:	c3                   	ret    
  11f717:	66 90                	xchg   %ax,%ax
  11f719:	66 90                	xchg   %ax,%ax
  11f71b:	66 90                	xchg   %ax,%ax
  11f71d:	66 90                	xchg   %ax,%ax
  11f71f:	90                   	nop

0011f720 <z_tick_sleep>:
{
  11f720:	55                   	push   %ebp
  11f721:	89 e5                	mov    %esp,%ebp
  11f723:	83 e4 f8             	and    $0xfffffff8,%esp
  11f726:	83 ec 48             	sub    $0x48,%esp
  11f729:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ticks == 0) {
  11f72c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11f730:	0f 85 12 00 00 00    	jne    11f748 <z_tick_sleep+0x28>
		k_yield();
  11f736:	e8 25 07 00 00       	call   11fe60 <k_yield>
		return 0;
  11f73b:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11f742:	00 
  11f743:	e9 c7 00 00 00       	jmp    11f80f <z_tick_sleep+0xef>
	ticks += _TICK_ALIGN;
  11f748:	8b 45 08             	mov    0x8(%ebp),%eax
  11f74b:	83 c0 01             	add    $0x1,%eax
  11f74e:	89 45 08             	mov    %eax,0x8(%ebp)
	expected_wakeup_time = ticks + z_tick_get_32();
  11f751:	8b 45 08             	mov    0x8(%ebp),%eax
  11f754:	89 44 24 14          	mov    %eax,0x14(%esp)
  11f758:	e8 e3 22 00 00       	call   121a40 <z_tick_get_32>
  11f75d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  11f761:	01 c1                	add    %eax,%ecx
  11f763:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  11f767:	8d 44 24 18          	lea    0x18(%esp),%eax
  11f76b:	89 44 24 34          	mov    %eax,0x34(%esp)
  11f76f:	8d 44 24 20          	lea    0x20(%esp),%eax
  11f773:	89 44 24 30          	mov    %eax,0x30(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11f777:	9c                   	pushf  
  11f778:	fa                   	cli    
  11f779:	8f 44 24 38          	popl   0x38(%esp)
	return key;
  11f77d:	8b 44 24 38          	mov    0x38(%esp),%eax
	k.key = arch_irq_lock();
  11f781:	89 44 24 18          	mov    %eax,0x18(%esp)
	z_remove_thread_from_ready_q(_current);
  11f785:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f78a:	89 04 24             	mov    %eax,(%esp)
  11f78d:	e8 de ee ff ff       	call   11e670 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, ticks);
  11f792:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f797:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11f79a:	89 04 24             	mov    %eax,(%esp)
  11f79d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  11f7a1:	e8 7a 06 00 00       	call   11fe20 <z_add_thread_timeout>
	z_mark_thread_as_suspended(_current);
  11f7a6:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11f7ab:	89 04 24             	mov    %eax,(%esp)
  11f7ae:	e8 bd 06 00 00       	call   11fe70 <z_mark_thread_as_suspended>
	(void)z_swap(&local_lock, key);
  11f7b3:	8b 44 24 18          	mov    0x18(%esp),%eax
  11f7b7:	89 44 24 40          	mov    %eax,0x40(%esp)
  11f7bb:	8d 44 24 20          	lea    0x20(%esp),%eax
  11f7bf:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	k_spin_release(lock);
  11f7c3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  11f7c7:	89 44 24 44          	mov    %eax,0x44(%esp)
	return z_swap_irqlock(key.key);
  11f7cb:	8b 44 24 40          	mov    0x40(%esp),%eax
  11f7cf:	89 04 24             	mov    %eax,(%esp)
  11f7d2:	e8 69 f4 ff ff       	call   11ec40 <z_swap_irqlock>
	ticks = expected_wakeup_time - z_tick_get_32();
  11f7d7:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  11f7db:	89 44 24 10          	mov    %eax,0x10(%esp)
  11f7df:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  11f7e3:	e8 58 22 00 00       	call   121a40 <z_tick_get_32>
  11f7e8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  11f7ec:	29 c1                	sub    %eax,%ecx
  11f7ee:	89 4d 08             	mov    %ecx,0x8(%ebp)
	if (ticks > 0) {
  11f7f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11f7f5:	0f 8e 0c 00 00 00    	jle    11f807 <z_tick_sleep+0xe7>
		return ticks;
  11f7fb:	8b 45 08             	mov    0x8(%ebp),%eax
  11f7fe:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11f802:	e9 08 00 00 00       	jmp    11f80f <z_tick_sleep+0xef>
	return 0;
  11f807:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  11f80e:	00 
}
  11f80f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  11f813:	89 ec                	mov    %ebp,%esp
  11f815:	5d                   	pop    %ebp
  11f816:	c3                   	ret    
  11f817:	66 90                	xchg   %ax,%ax
  11f819:	66 90                	xchg   %ax,%ax
  11f81b:	66 90                	xchg   %ax,%ax
  11f81d:	66 90                	xchg   %ax,%ax
  11f81f:	90                   	nop

0011f820 <k_ticks_to_ms_floor64>:
 * Truncates to the next lowest output unit.
 *
 * @return The converted time value
 */
static inline u64_t k_ticks_to_ms_floor64(u64_t t)
{
  11f820:	55                   	push   %ebp
  11f821:	89 e5                	mov    %esp,%ebp
  11f823:	57                   	push   %edi
  11f824:	56                   	push   %esi
  11f825:	83 e4 f8             	and    $0xfffffff8,%esp
  11f828:	83 ec 78             	sub    $0x78,%esp
  11f82b:	8b 45 08             	mov    0x8(%ebp),%eax
  11f82e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11f831:	31 d2                	xor    %edx,%edx
  11f833:	89 44 24 40          	mov    %eax,0x40(%esp)
  11f837:	89 4c 24 44          	mov    %ecx,0x44(%esp)
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ms, true, false, false, false);
  11f83b:	8b 44 24 40          	mov    0x40(%esp),%eax
  11f83f:	8b 4c 24 44          	mov    0x44(%esp),%ecx
  11f843:	89 4c 24 6c          	mov    %ecx,0x6c(%esp)
  11f847:	89 44 24 68          	mov    %eax,0x68(%esp)
  11f84b:	c7 44 24 64 64 00 00 	movl   $0x64,0x64(%esp)
  11f852:	00 
  11f853:	c7 44 24 60 e8 03 00 	movl   $0x3e8,0x60(%esp)
  11f85a:	00 
  11f85b:	c6 44 24 5f 01       	movb   $0x1,0x5f(%esp)
  11f860:	c6 44 24 5e 00       	movb   $0x0,0x5e(%esp)
  11f865:	c6 44 24 5d 00       	movb   $0x0,0x5d(%esp)
  11f86a:	c6 44 24 5c 00       	movb   $0x0,0x5c(%esp)
	bool mul_ratio = const_hz &&
  11f86f:	f6 44 24 5f 01       	testb  $0x1,0x5f(%esp)
  11f874:	88 54 24 3f          	mov    %dl,0x3f(%esp)
  11f878:	0f 84 28 00 00 00    	je     11f8a6 <k_ticks_to_ms_floor64+0x86>
  11f87e:	31 c0                	xor    %eax,%eax
		(to_hz > from_hz) && ((to_hz % from_hz) == 0);
  11f880:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  11f884:	3b 4c 24 64          	cmp    0x64(%esp),%ecx
  11f888:	88 44 24 3f          	mov    %al,0x3f(%esp)
  11f88c:	0f 86 14 00 00 00    	jbe    11f8a6 <k_ticks_to_ms_floor64+0x86>
  11f892:	8b 44 24 60          	mov    0x60(%esp),%eax
  11f896:	31 d2                	xor    %edx,%edx
  11f898:	f7 74 24 64          	divl   0x64(%esp)
  11f89c:	83 fa 00             	cmp    $0x0,%edx
  11f89f:	0f 94 c1             	sete   %cl
  11f8a2:	88 4c 24 3f          	mov    %cl,0x3f(%esp)
  11f8a6:	8a 44 24 3f          	mov    0x3f(%esp),%al
  11f8aa:	31 c9                	xor    %ecx,%ecx
	bool mul_ratio = const_hz &&
  11f8ac:	24 01                	and    $0x1,%al
  11f8ae:	88 44 24 5b          	mov    %al,0x5b(%esp)
	bool div_ratio = const_hz &&
  11f8b2:	f6 44 24 5f 01       	testb  $0x1,0x5f(%esp)
  11f8b7:	88 4c 24 3e          	mov    %cl,0x3e(%esp)
  11f8bb:	0f 84 28 00 00 00    	je     11f8e9 <k_ticks_to_ms_floor64+0xc9>
  11f8c1:	31 c0                	xor    %eax,%eax
		(from_hz > to_hz) && ((from_hz % to_hz) == 0);
  11f8c3:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11f8c7:	3b 4c 24 60          	cmp    0x60(%esp),%ecx
  11f8cb:	88 44 24 3e          	mov    %al,0x3e(%esp)
  11f8cf:	0f 86 14 00 00 00    	jbe    11f8e9 <k_ticks_to_ms_floor64+0xc9>
  11f8d5:	8b 44 24 64          	mov    0x64(%esp),%eax
  11f8d9:	31 d2                	xor    %edx,%edx
  11f8db:	f7 74 24 60          	divl   0x60(%esp)
  11f8df:	83 fa 00             	cmp    $0x0,%edx
  11f8e2:	0f 94 c1             	sete   %cl
  11f8e5:	88 4c 24 3e          	mov    %cl,0x3e(%esp)
  11f8e9:	8a 44 24 3e          	mov    0x3e(%esp),%al
	bool div_ratio = const_hz &&
  11f8ed:	24 01                	and    $0x1,%al
  11f8ef:	88 44 24 5a          	mov    %al,0x5a(%esp)
	if (from_hz == to_hz) {
  11f8f3:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11f8f7:	3b 4c 24 60          	cmp    0x60(%esp),%ecx
  11f8fb:	0f 85 48 00 00 00    	jne    11f949 <k_ticks_to_ms_floor64+0x129>
		return result32 ? ((u32_t)t) : t;
  11f901:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  11f906:	0f 84 13 00 00 00    	je     11f91f <k_ticks_to_ms_floor64+0xff>
  11f90c:	8b 44 24 68          	mov    0x68(%esp),%eax
  11f910:	31 c9                	xor    %ecx,%ecx
  11f912:	89 44 24 38          	mov    %eax,0x38(%esp)
  11f916:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  11f91a:	e9 15 00 00 00       	jmp    11f934 <k_ticks_to_ms_floor64+0x114>
  11f91f:	8b 44 24 68          	mov    0x68(%esp),%eax
  11f923:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  11f927:	89 44 24 38          	mov    %eax,0x38(%esp)
  11f92b:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  11f92f:	e9 00 00 00 00       	jmp    11f934 <k_ticks_to_ms_floor64+0x114>
  11f934:	8b 44 24 34          	mov    0x34(%esp),%eax
  11f938:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  11f93c:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  11f940:	89 44 24 74          	mov    %eax,0x74(%esp)
  11f944:	e9 6b 02 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
	u64_t off = 0;
  11f949:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  11f950:	00 
  11f951:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
  11f958:	00 
	if (!mul_ratio) {
  11f959:	f6 44 24 5b 01       	testb  $0x1,0x5b(%esp)
  11f95e:	0f 85 76 00 00 00    	jne    11f9da <k_ticks_to_ms_floor64+0x1ba>
		u32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
  11f964:	f6 44 24 5a 01       	testb  $0x1,0x5a(%esp)
  11f969:	0f 84 13 00 00 00    	je     11f982 <k_ticks_to_ms_floor64+0x162>
  11f96f:	8b 44 24 64          	mov    0x64(%esp),%eax
  11f973:	31 d2                	xor    %edx,%edx
  11f975:	f7 74 24 60          	divl   0x60(%esp)
  11f979:	89 44 24 30          	mov    %eax,0x30(%esp)
  11f97d:	e9 08 00 00 00       	jmp    11f98a <k_ticks_to_ms_floor64+0x16a>
  11f982:	8b 44 24 64          	mov    0x64(%esp),%eax
  11f986:	89 44 24 30          	mov    %eax,0x30(%esp)
  11f98a:	8b 44 24 30          	mov    0x30(%esp),%eax
  11f98e:	89 44 24 4c          	mov    %eax,0x4c(%esp)
		if (round_up) {
  11f992:	f6 44 24 5d 01       	testb  $0x1,0x5d(%esp)
  11f997:	0f 84 16 00 00 00    	je     11f9b3 <k_ticks_to_ms_floor64+0x193>
			off = rdivisor - 1;
  11f99d:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  11f9a1:	48                   	dec    %eax
  11f9a2:	89 44 24 50          	mov    %eax,0x50(%esp)
  11f9a6:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  11f9ad:	00 
		} else if (round_off) {
  11f9ae:	e9 22 00 00 00       	jmp    11f9d5 <k_ticks_to_ms_floor64+0x1b5>
  11f9b3:	f6 44 24 5c 01       	testb  $0x1,0x5c(%esp)
  11f9b8:	0f 84 12 00 00 00    	je     11f9d0 <k_ticks_to_ms_floor64+0x1b0>
			off = rdivisor / 2;
  11f9be:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  11f9c2:	d1 e8                	shr    %eax
  11f9c4:	89 44 24 50          	mov    %eax,0x50(%esp)
  11f9c8:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  11f9cf:	00 
  11f9d0:	e9 00 00 00 00       	jmp    11f9d5 <k_ticks_to_ms_floor64+0x1b5>
	}
  11f9d5:	e9 00 00 00 00       	jmp    11f9da <k_ticks_to_ms_floor64+0x1ba>
	if (div_ratio) {
  11f9da:	f6 44 24 5a 01       	testb  $0x1,0x5a(%esp)
  11f9df:	0f 84 ad 00 00 00    	je     11fa92 <k_ticks_to_ms_floor64+0x272>
		t += off;
  11f9e5:	8b 44 24 50          	mov    0x50(%esp),%eax
  11f9e9:	8b 4c 24 54          	mov    0x54(%esp),%ecx
  11f9ed:	8b 54 24 68          	mov    0x68(%esp),%edx
  11f9f1:	8b 74 24 6c          	mov    0x6c(%esp),%esi
  11f9f5:	01 c2                	add    %eax,%edx
  11f9f7:	11 ce                	adc    %ecx,%esi
  11f9f9:	89 54 24 68          	mov    %edx,0x68(%esp)
  11f9fd:	89 74 24 6c          	mov    %esi,0x6c(%esp)
		if (result32) {
  11fa01:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  11fa06:	0f 84 43 00 00 00    	je     11fa4f <k_ticks_to_ms_floor64+0x22f>
			return ((u32_t)t) / (from_hz / to_hz);
  11fa0c:	8b 44 24 68          	mov    0x68(%esp),%eax
  11fa10:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11fa14:	8b 54 24 60          	mov    0x60(%esp),%edx
  11fa18:	31 f6                	xor    %esi,%esi
  11fa1a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  11fa1e:	89 c8                	mov    %ecx,%eax
  11fa20:	89 54 24 28          	mov    %edx,0x28(%esp)
  11fa24:	89 f2                	mov    %esi,%edx
  11fa26:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  11fa2a:	f7 f1                	div    %ecx
  11fa2c:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  11fa30:	89 44 24 24          	mov    %eax,0x24(%esp)
  11fa34:	89 c8                	mov    %ecx,%eax
  11fa36:	89 f2                	mov    %esi,%edx
  11fa38:	8b 74 24 24          	mov    0x24(%esp),%esi
  11fa3c:	f7 f6                	div    %esi
  11fa3e:	89 44 24 70          	mov    %eax,0x70(%esp)
  11fa42:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  11fa49:	00 
  11fa4a:	e9 65 01 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
			return t / (from_hz / to_hz);
  11fa4f:	8b 44 24 68          	mov    0x68(%esp),%eax
  11fa53:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  11fa57:	8b 54 24 64          	mov    0x64(%esp),%edx
  11fa5b:	8b 74 24 60          	mov    0x60(%esp),%esi
  11fa5f:	31 ff                	xor    %edi,%edi
  11fa61:	89 44 24 20          	mov    %eax,0x20(%esp)
  11fa65:	89 d0                	mov    %edx,%eax
  11fa67:	89 fa                	mov    %edi,%edx
  11fa69:	f7 f6                	div    %esi
  11fa6b:	89 e2                	mov    %esp,%edx
  11fa6d:	89 42 08             	mov    %eax,0x8(%edx)
  11fa70:	89 4a 04             	mov    %ecx,0x4(%edx)
  11fa73:	8b 44 24 20          	mov    0x20(%esp),%eax
  11fa77:	89 02                	mov    %eax,(%edx)
  11fa79:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  11fa80:	e8 4b 06 fe ff       	call   1000d0 <__udivdi3>
  11fa85:	89 54 24 74          	mov    %edx,0x74(%esp)
  11fa89:	89 44 24 70          	mov    %eax,0x70(%esp)
  11fa8d:	e9 22 01 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
	} else if (mul_ratio) {
  11fa92:	f6 44 24 5b 01       	testb  $0x1,0x5b(%esp)
  11fa97:	0f 84 81 00 00 00    	je     11fb1e <k_ticks_to_ms_floor64+0x2fe>
		if (result32) {
  11fa9d:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  11faa2:	0f 84 38 00 00 00    	je     11fae0 <k_ticks_to_ms_floor64+0x2c0>
			return ((u32_t)t) * (to_hz / from_hz);
  11faa8:	8b 44 24 68          	mov    0x68(%esp),%eax
  11faac:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  11fab0:	8b 54 24 64          	mov    0x64(%esp),%edx
  11fab4:	31 f6                	xor    %esi,%esi
  11fab6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  11faba:	89 c8                	mov    %ecx,%eax
  11fabc:	89 54 24 18          	mov    %edx,0x18(%esp)
  11fac0:	89 f2                	mov    %esi,%edx
  11fac2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  11fac6:	f7 f1                	div    %ecx
  11fac8:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11facc:	0f af c8             	imul   %eax,%ecx
  11facf:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  11fad3:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  11fada:	00 
  11fadb:	e9 d4 00 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
			return t * (to_hz / from_hz);
  11fae0:	8b 44 24 68          	mov    0x68(%esp),%eax
  11fae4:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  11fae8:	8b 54 24 60          	mov    0x60(%esp),%edx
  11faec:	8b 74 24 64          	mov    0x64(%esp),%esi
  11faf0:	31 ff                	xor    %edi,%edi
  11faf2:	89 44 24 14          	mov    %eax,0x14(%esp)
  11faf6:	89 d0                	mov    %edx,%eax
  11faf8:	89 fa                	mov    %edi,%edx
  11fafa:	f7 f6                	div    %esi
  11fafc:	0f af c8             	imul   %eax,%ecx
  11faff:	8b 54 24 14          	mov    0x14(%esp),%edx
  11fb03:	89 44 24 10          	mov    %eax,0x10(%esp)
  11fb07:	89 d0                	mov    %edx,%eax
  11fb09:	8b 74 24 10          	mov    0x10(%esp),%esi
  11fb0d:	f7 e6                	mul    %esi
  11fb0f:	01 ca                	add    %ecx,%edx
  11fb11:	89 44 24 70          	mov    %eax,0x70(%esp)
  11fb15:	89 54 24 74          	mov    %edx,0x74(%esp)
  11fb19:	e9 96 00 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
		if (result32) {
  11fb1e:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  11fb23:	0f 84 4a 00 00 00    	je     11fb73 <k_ticks_to_ms_floor64+0x353>
			return (u32_t)((t * to_hz + off) / from_hz);
  11fb29:	8b 44 24 68          	mov    0x68(%esp),%eax
  11fb2d:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  11fb31:	8b 54 24 60          	mov    0x60(%esp),%edx
  11fb35:	0f af ca             	imul   %edx,%ecx
  11fb38:	f7 e2                	mul    %edx
  11fb3a:	01 ca                	add    %ecx,%edx
  11fb3c:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  11fb40:	8b 74 24 54          	mov    0x54(%esp),%esi
  11fb44:	01 c8                	add    %ecx,%eax
  11fb46:	11 f2                	adc    %esi,%edx
  11fb48:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11fb4c:	89 e6                	mov    %esp,%esi
  11fb4e:	89 4e 08             	mov    %ecx,0x8(%esi)
  11fb51:	89 06                	mov    %eax,(%esi)
  11fb53:	89 56 04             	mov    %edx,0x4(%esi)
  11fb56:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  11fb5d:	e8 6e 05 fe ff       	call   1000d0 <__udivdi3>
  11fb62:	89 44 24 70          	mov    %eax,0x70(%esp)
  11fb66:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  11fb6d:	00 
  11fb6e:	e9 41 00 00 00       	jmp    11fbb4 <k_ticks_to_ms_floor64+0x394>
			return (t * to_hz + off) / from_hz;
  11fb73:	8b 44 24 68          	mov    0x68(%esp),%eax
  11fb77:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  11fb7b:	8b 54 24 60          	mov    0x60(%esp),%edx
  11fb7f:	0f af ca             	imul   %edx,%ecx
  11fb82:	f7 e2                	mul    %edx
  11fb84:	01 ca                	add    %ecx,%edx
  11fb86:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  11fb8a:	8b 74 24 54          	mov    0x54(%esp),%esi
  11fb8e:	01 c8                	add    %ecx,%eax
  11fb90:	11 f2                	adc    %esi,%edx
  11fb92:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  11fb96:	89 e6                	mov    %esp,%esi
  11fb98:	89 4e 08             	mov    %ecx,0x8(%esi)
  11fb9b:	89 06                	mov    %eax,(%esi)
  11fb9d:	89 56 04             	mov    %edx,0x4(%esi)
  11fba0:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  11fba7:	e8 24 05 fe ff       	call   1000d0 <__udivdi3>
  11fbac:	89 54 24 74          	mov    %edx,0x74(%esp)
  11fbb0:	89 44 24 70          	mov    %eax,0x70(%esp)
}
  11fbb4:	8b 44 24 70          	mov    0x70(%esp),%eax
  11fbb8:	8b 54 24 74          	mov    0x74(%esp),%edx
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ms, true, false, false, false);
  11fbbc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11fbbf:	5e                   	pop    %esi
  11fbc0:	5f                   	pop    %edi
  11fbc1:	5d                   	pop    %ebp
  11fbc2:	c3                   	ret    
  11fbc3:	66 90                	xchg   %ax,%ax
  11fbc5:	66 90                	xchg   %ax,%ax
  11fbc7:	66 90                	xchg   %ax,%ax
  11fbc9:	66 90                	xchg   %ax,%ax
  11fbcb:	66 90                	xchg   %ax,%ax
  11fbcd:	66 90                	xchg   %ax,%ax
  11fbcf:	90                   	nop

0011fbd0 <arch_is_in_isr>:
#include <ia32/kernel_arch_func.h>
#endif

#ifndef _ASMLANGUAGE
static inline bool arch_is_in_isr(void)
{
  11fbd0:	55                   	push   %ebp
  11fbd1:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_SMP
	return arch_curr_cpu()->nested != 0;
#else
	return _kernel.nested != 0U;
  11fbd3:	83 3d a8 96 13 00 00 	cmpl   $0x0,0x1396a8
  11fbda:	0f 95 c0             	setne  %al
  11fbdd:	24 01                	and    $0x1,%al
  11fbdf:	0f b6 c0             	movzbl %al,%eax
  11fbe2:	5d                   	pop    %ebp
  11fbe3:	c3                   	ret    
  11fbe4:	66 90                	xchg   %ax,%ax
  11fbe6:	66 90                	xchg   %ax,%ax
  11fbe8:	66 90                	xchg   %ax,%ax
  11fbea:	66 90                	xchg   %ax,%ax
  11fbec:	66 90                	xchg   %ax,%ax
  11fbee:	66 90                	xchg   %ax,%ax

0011fbf0 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
  11fbf0:	55                   	push   %ebp
  11fbf1:	89 e5                	mov    %esp,%ebp
	return _current;
  11fbf3:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  11fbf8:	5d                   	pop    %ebp
  11fbf9:	c3                   	ret    
  11fbfa:	66 90                	xchg   %ax,%ax
  11fbfc:	66 90                	xchg   %ax,%ax
  11fbfe:	66 90                	xchg   %ax,%ax

0011fc00 <is_preempt>:
{
  11fc00:	55                   	push   %ebp
  11fc01:	89 e5                	mov    %esp,%ebp
  11fc03:	50                   	push   %eax
  11fc04:	8b 45 08             	mov    0x8(%ebp),%eax
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
  11fc07:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fc0a:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  11fc0e:	83 f9 7f             	cmp    $0x7f,%ecx
  11fc11:	0f 9e c2             	setle  %dl
  11fc14:	80 e2 01             	and    $0x1,%dl
  11fc17:	0f b6 ca             	movzbl %dl,%ecx
  11fc1a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11fc1d:	89 c8                	mov    %ecx,%eax
  11fc1f:	83 c4 04             	add    $0x4,%esp
  11fc22:	5d                   	pop    %ebp
  11fc23:	c3                   	ret    
  11fc24:	66 90                	xchg   %ax,%ax
  11fc26:	66 90                	xchg   %ax,%ax
  11fc28:	66 90                	xchg   %ax,%ax
  11fc2a:	66 90                	xchg   %ax,%ax
  11fc2c:	66 90                	xchg   %ax,%ax
  11fc2e:	66 90                	xchg   %ax,%ax

0011fc30 <z_is_prio_higher>:
{
  11fc30:	55                   	push   %ebp
  11fc31:	89 e5                	mov    %esp,%ebp
  11fc33:	56                   	push   %esi
  11fc34:	83 ec 10             	sub    $0x10,%esp
  11fc37:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fc3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return z_is_prio1_higher_than_prio2(prio, test_prio);
  11fc3d:	8b 55 08             	mov    0x8(%ebp),%edx
  11fc40:	8b 75 0c             	mov    0xc(%ebp),%esi
  11fc43:	89 14 24             	mov    %edx,(%esp)
  11fc46:	89 74 24 04          	mov    %esi,0x4(%esp)
  11fc4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11fc4d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  11fc50:	e8 3b 00 00 00       	call   11fc90 <z_is_prio1_higher_than_prio2>
  11fc55:	24 01                	and    $0x1,%al
  11fc57:	0f b6 c0             	movzbl %al,%eax
  11fc5a:	83 c4 10             	add    $0x10,%esp
  11fc5d:	5e                   	pop    %esi
  11fc5e:	5d                   	pop    %ebp
  11fc5f:	c3                   	ret    

0011fc60 <z_is_thread_timeout_active>:
{
  11fc60:	55                   	push   %ebp
  11fc61:	89 e5                	mov    %esp,%ebp
  11fc63:	83 ec 08             	sub    $0x8,%esp
  11fc66:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  11fc69:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fc6c:	83 c1 18             	add    $0x18,%ecx
  11fc6f:	89 0c 24             	mov    %ecx,(%esp)
  11fc72:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11fc75:	e8 46 00 00 00       	call   11fcc0 <z_is_inactive_timeout>
  11fc7a:	34 ff                	xor    $0xff,%al
  11fc7c:	24 01                	and    $0x1,%al
  11fc7e:	0f b6 c0             	movzbl %al,%eax
  11fc81:	83 c4 08             	add    $0x8,%esp
  11fc84:	5d                   	pop    %ebp
  11fc85:	c3                   	ret    
  11fc86:	66 90                	xchg   %ax,%ax
  11fc88:	66 90                	xchg   %ax,%ax
  11fc8a:	66 90                	xchg   %ax,%ax
  11fc8c:	66 90                	xchg   %ax,%ax
  11fc8e:	66 90                	xchg   %ax,%ax

0011fc90 <z_is_prio1_higher_than_prio2>:
{
  11fc90:	55                   	push   %ebp
  11fc91:	89 e5                	mov    %esp,%ebp
  11fc93:	53                   	push   %ebx
  11fc94:	50                   	push   %eax
  11fc95:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fc98:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return prio1 < prio2;
  11fc9b:	8b 55 08             	mov    0x8(%ebp),%edx
  11fc9e:	3b 55 0c             	cmp    0xc(%ebp),%edx
  11fca1:	0f 9c c3             	setl   %bl
  11fca4:	80 e3 01             	and    $0x1,%bl
  11fca7:	0f b6 d3             	movzbl %bl,%edx
  11fcaa:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11fcad:	89 d0                	mov    %edx,%eax
  11fcaf:	83 c4 04             	add    $0x4,%esp
  11fcb2:	5b                   	pop    %ebx
  11fcb3:	5d                   	pop    %ebp
  11fcb4:	c3                   	ret    
  11fcb5:	66 90                	xchg   %ax,%ax
  11fcb7:	66 90                	xchg   %ax,%ax
  11fcb9:	66 90                	xchg   %ax,%ax
  11fcbb:	66 90                	xchg   %ax,%ax
  11fcbd:	66 90                	xchg   %ax,%ax
  11fcbf:	90                   	nop

0011fcc0 <z_is_inactive_timeout>:
{
  11fcc0:	55                   	push   %ebp
  11fcc1:	89 e5                	mov    %esp,%ebp
  11fcc3:	83 ec 08             	sub    $0x8,%esp
  11fcc6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  11fcc9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fccc:	89 0c 24             	mov    %ecx,(%esp)
  11fccf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11fcd2:	e8 19 00 00 00       	call   11fcf0 <sys_dnode_is_linked>
  11fcd7:	34 ff                	xor    $0xff,%al
  11fcd9:	24 01                	and    $0x1,%al
  11fcdb:	0f b6 c0             	movzbl %al,%eax
  11fcde:	83 c4 08             	add    $0x8,%esp
  11fce1:	5d                   	pop    %ebp
  11fce2:	c3                   	ret    
  11fce3:	66 90                	xchg   %ax,%ax
  11fce5:	66 90                	xchg   %ax,%ax
  11fce7:	66 90                	xchg   %ax,%ax
  11fce9:	66 90                	xchg   %ax,%ax
  11fceb:	66 90                	xchg   %ax,%ax
  11fced:	66 90                	xchg   %ax,%ax
  11fcef:	90                   	nop

0011fcf0 <sys_dnode_is_linked>:
{
  11fcf0:	55                   	push   %ebp
  11fcf1:	89 e5                	mov    %esp,%ebp
  11fcf3:	50                   	push   %eax
  11fcf4:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  11fcf7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fcfa:	83 39 00             	cmpl   $0x0,(%ecx)
  11fcfd:	0f 95 c2             	setne  %dl
  11fd00:	80 e2 01             	and    $0x1,%dl
  11fd03:	0f b6 ca             	movzbl %dl,%ecx
  11fd06:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11fd09:	89 c8                	mov    %ecx,%eax
  11fd0b:	83 c4 04             	add    $0x4,%esp
  11fd0e:	5d                   	pop    %ebp
  11fd0f:	c3                   	ret    

0011fd10 <z_set_thread_states>:
{
  11fd10:	55                   	push   %ebp
  11fd11:	89 e5                	mov    %esp,%ebp
  11fd13:	53                   	push   %ebx
  11fd14:	57                   	push   %edi
  11fd15:	56                   	push   %esi
  11fd16:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fd19:	8b 4d 08             	mov    0x8(%ebp),%ecx
	thread->base.thread_state |= states;
  11fd1c:	8b 55 0c             	mov    0xc(%ebp),%edx
  11fd1f:	8b 75 08             	mov    0x8(%ebp),%esi
  11fd22:	0f b6 7e 0d          	movzbl 0xd(%esi),%edi
  11fd26:	89 fb                	mov    %edi,%ebx
  11fd28:	09 d3                	or     %edx,%ebx
  11fd2a:	88 5e 0d             	mov    %bl,0xd(%esi)
}
  11fd2d:	5e                   	pop    %esi
  11fd2e:	5f                   	pop    %edi
  11fd2f:	5b                   	pop    %ebx
  11fd30:	5d                   	pop    %ebp
  11fd31:	c3                   	ret    
  11fd32:	66 90                	xchg   %ax,%ax
  11fd34:	66 90                	xchg   %ax,%ax
  11fd36:	66 90                	xchg   %ax,%ax
  11fd38:	66 90                	xchg   %ax,%ax
  11fd3a:	66 90                	xchg   %ax,%ax
  11fd3c:	66 90                	xchg   %ax,%ax
  11fd3e:	66 90                	xchg   %ax,%ax

0011fd40 <update_metairq_preempt>:
{
  11fd40:	55                   	push   %ebp
  11fd41:	89 e5                	mov    %esp,%ebp
  11fd43:	8b 45 08             	mov    0x8(%ebp),%eax
}
  11fd46:	5d                   	pop    %ebp
  11fd47:	c3                   	ret    
  11fd48:	66 90                	xchg   %ax,%ax
  11fd4a:	66 90                	xchg   %ax,%ax
  11fd4c:	66 90                	xchg   %ax,%ax
  11fd4e:	66 90                	xchg   %ax,%ax

0011fd50 <z_is_thread_prevented_from_running>:
{
  11fd50:	55                   	push   %ebp
  11fd51:	89 e5                	mov    %esp,%ebp
  11fd53:	83 ec 08             	sub    $0x8,%esp
  11fd56:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  11fd59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fd5c:	8a 51 0d             	mov    0xd(%ecx),%dl
  11fd5f:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11fd62:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  11fd66:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  11fd69:	83 f9 00             	cmp    $0x0,%ecx
  11fd6c:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  11fd6f:	80 e2 01             	and    $0x1,%dl
  11fd72:	0f b6 ca             	movzbl %dl,%ecx
  11fd75:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11fd78:	89 c8                	mov    %ecx,%eax
  11fd7a:	83 c4 08             	add    $0x8,%esp
  11fd7d:	5d                   	pop    %ebp
  11fd7e:	c3                   	ret    
  11fd7f:	90                   	nop

0011fd80 <is_metairq>:
{
  11fd80:	55                   	push   %ebp
  11fd81:	89 e5                	mov    %esp,%ebp
  11fd83:	50                   	push   %eax
  11fd84:	8b 45 08             	mov    0x8(%ebp),%eax
  11fd87:	31 c9                	xor    %ecx,%ecx
  11fd89:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return 0;
  11fd8c:	89 c8                	mov    %ecx,%eax
  11fd8e:	83 c4 04             	add    $0x4,%esp
  11fd91:	5d                   	pop    %ebp
  11fd92:	c3                   	ret    
  11fd93:	66 90                	xchg   %ax,%ax
  11fd95:	66 90                	xchg   %ax,%ax
  11fd97:	66 90                	xchg   %ax,%ax
  11fd99:	66 90                	xchg   %ax,%ax
  11fd9b:	66 90                	xchg   %ax,%ax
  11fd9d:	66 90                	xchg   %ax,%ax
  11fd9f:	90                   	nop

0011fda0 <z_is_thread_state_set>:
{
  11fda0:	55                   	push   %ebp
  11fda1:	89 e5                	mov    %esp,%ebp
  11fda3:	53                   	push   %ebx
  11fda4:	50                   	push   %eax
  11fda5:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fda8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return (thread->base.thread_state & state) != 0U;
  11fdab:	8b 55 08             	mov    0x8(%ebp),%edx
  11fdae:	0f b6 52 0d          	movzbl 0xd(%edx),%edx
  11fdb2:	23 55 0c             	and    0xc(%ebp),%edx
  11fdb5:	83 fa 00             	cmp    $0x0,%edx
  11fdb8:	0f 95 c3             	setne  %bl
  11fdbb:	80 e3 01             	and    $0x1,%bl
  11fdbe:	0f b6 d3             	movzbl %bl,%edx
  11fdc1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11fdc4:	89 d0                	mov    %edx,%eax
  11fdc6:	83 c4 04             	add    $0x4,%esp
  11fdc9:	5b                   	pop    %ebx
  11fdca:	5d                   	pop    %ebp
  11fdcb:	c3                   	ret    
  11fdcc:	66 90                	xchg   %ax,%ax
  11fdce:	66 90                	xchg   %ax,%ax

0011fdd0 <z_reset_thread_states>:
{
  11fdd0:	55                   	push   %ebp
  11fdd1:	89 e5                	mov    %esp,%ebp
  11fdd3:	53                   	push   %ebx
  11fdd4:	57                   	push   %edi
  11fdd5:	56                   	push   %esi
  11fdd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fdd9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	thread->base.thread_state &= ~states;
  11fddc:	8b 55 0c             	mov    0xc(%ebp),%edx
  11fddf:	83 f2 ff             	xor    $0xffffffff,%edx
  11fde2:	8b 75 08             	mov    0x8(%ebp),%esi
  11fde5:	0f b6 7e 0d          	movzbl 0xd(%esi),%edi
  11fde9:	89 fb                	mov    %edi,%ebx
  11fdeb:	21 d3                	and    %edx,%ebx
  11fded:	88 5e 0d             	mov    %bl,0xd(%esi)
}
  11fdf0:	5e                   	pop    %esi
  11fdf1:	5f                   	pop    %edi
  11fdf2:	5b                   	pop    %ebx
  11fdf3:	5d                   	pop    %ebp
  11fdf4:	c3                   	ret    
  11fdf5:	66 90                	xchg   %ax,%ax
  11fdf7:	66 90                	xchg   %ax,%ax
  11fdf9:	66 90                	xchg   %ax,%ax
  11fdfb:	66 90                	xchg   %ax,%ax
  11fdfd:	66 90                	xchg   %ax,%ax
  11fdff:	90                   	nop

0011fe00 <z_mark_thread_as_pending>:
{
  11fe00:	55                   	push   %ebp
  11fe01:	89 e5                	mov    %esp,%ebp
  11fe03:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state |= _THREAD_PENDING;
  11fe06:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fe09:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11fe0d:	83 ca 02             	or     $0x2,%edx
  11fe10:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11fe13:	5d                   	pop    %ebp
  11fe14:	c3                   	ret    
  11fe15:	66 90                	xchg   %ax,%ax
  11fe17:	66 90                	xchg   %ax,%ax
  11fe19:	66 90                	xchg   %ax,%ax
  11fe1b:	66 90                	xchg   %ax,%ax
  11fe1d:	66 90                	xchg   %ax,%ax
  11fe1f:	90                   	nop

0011fe20 <z_add_thread_timeout>:
{
  11fe20:	55                   	push   %ebp
  11fe21:	89 e5                	mov    %esp,%ebp
  11fe23:	56                   	push   %esi
  11fe24:	83 ec 14             	sub    $0x14,%esp
  11fe27:	8b 45 0c             	mov    0xc(%ebp),%eax
  11fe2a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  11fe2d:	8b 55 08             	mov    0x8(%ebp),%edx
  11fe30:	83 c2 18             	add    $0x18,%edx
  11fe33:	8b 75 0c             	mov    0xc(%ebp),%esi
  11fe36:	89 14 24             	mov    %edx,(%esp)
  11fe39:	8d 15 70 ea 11 00    	lea    0x11ea70,%edx
  11fe3f:	89 54 24 04          	mov    %edx,0x4(%esp)
  11fe43:	89 74 24 08          	mov    %esi,0x8(%esp)
  11fe47:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11fe4a:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  11fe4d:	e8 6e 12 00 00       	call   1210c0 <z_add_timeout>
}
  11fe52:	83 c4 14             	add    $0x14,%esp
  11fe55:	5e                   	pop    %esi
  11fe56:	5d                   	pop    %ebp
  11fe57:	c3                   	ret    
  11fe58:	66 90                	xchg   %ax,%ax
  11fe5a:	66 90                	xchg   %ax,%ax
  11fe5c:	66 90                	xchg   %ax,%ax
  11fe5e:	66 90                	xchg   %ax,%ax

0011fe60 <k_yield>:
{
  11fe60:	55                   	push   %ebp
  11fe61:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  11fe63:	e9 00 00 00 00       	jmp    11fe68 <k_yield+0x8>
	z_impl_k_yield();
  11fe68:	e8 c3 f6 ff ff       	call   11f530 <z_impl_k_yield>
}
  11fe6d:	5d                   	pop    %ebp
  11fe6e:	c3                   	ret    
  11fe6f:	90                   	nop

0011fe70 <z_mark_thread_as_suspended>:
{
  11fe70:	55                   	push   %ebp
  11fe71:	89 e5                	mov    %esp,%ebp
  11fe73:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state |= _THREAD_SUSPENDED;
  11fe76:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fe79:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  11fe7d:	83 ca 10             	or     $0x10,%edx
  11fe80:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  11fe83:	5d                   	pop    %ebp
  11fe84:	c3                   	ret    
  11fe85:	66 90                	xchg   %ax,%ax
  11fe87:	66 90                	xchg   %ax,%ax
  11fe89:	66 90                	xchg   %ax,%ax
  11fe8b:	66 90                	xchg   %ax,%ax
  11fe8d:	66 90                	xchg   %ax,%ax
  11fe8f:	90                   	nop

0011fe90 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  11fe90:	55                   	push   %ebp
  11fe91:	89 e5                	mov    %esp,%ebp
  11fe93:	83 e4 f8             	and    $0xfffffff8,%esp
  11fe96:	83 ec 20             	sub    $0x20,%esp
  11fe99:	8b 45 08             	mov    0x8(%ebp),%eax
  11fe9c:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  11fea0:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  11fea4:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  11feaa:	89 4c 24 14          	mov    %ecx,0x14(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11feae:	9c                   	pushf  
  11feaf:	fa                   	cli    
  11feb0:	8f 44 24 1c          	popl   0x1c(%esp)
	return key;
  11feb4:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  11feb8:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
  11febc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11febf:	89 0c 24             	mov    %ecx,(%esp)
  11fec2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  11fec6:	e8 25 00 00 00       	call   11fef0 <do_sem_give>
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
  11fecb:	8b 44 24 10          	mov    0x10(%esp),%eax
  11fecf:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  11fed5:	89 0c 24             	mov    %ecx,(%esp)
  11fed8:	89 44 24 04          	mov    %eax,0x4(%esp)
  11fedc:	e8 7f f1 ff ff       	call   11f060 <z_reschedule>
}
  11fee1:	89 ec                	mov    %ebp,%esp
  11fee3:	5d                   	pop    %ebp
  11fee4:	c3                   	ret    
  11fee5:	66 90                	xchg   %ax,%ax
  11fee7:	66 90                	xchg   %ax,%ax
  11fee9:	66 90                	xchg   %ax,%ax
  11feeb:	66 90                	xchg   %ax,%ax
  11feed:	66 90                	xchg   %ax,%ax
  11feef:	90                   	nop

0011fef0 <do_sem_give>:
{
  11fef0:	55                   	push   %ebp
  11fef1:	89 e5                	mov    %esp,%ebp
  11fef3:	83 ec 18             	sub    $0x18,%esp
  11fef6:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
  11fef9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11fefc:	89 0c 24             	mov    %ecx,(%esp)
  11feff:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11ff02:	e8 d9 ed ff ff       	call   11ece0 <z_unpend_first_thread>
  11ff07:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (thread != NULL) {
  11ff0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  11ff0e:	0f 84 46 00 00 00    	je     11ff5a <do_sem_give+0x6a>
		z_ready_thread(thread);
  11ff14:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ff17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (z_is_thread_ready(thread)) {
  11ff1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11ff1d:	89 04 24             	mov    %eax,(%esp)
  11ff20:	e8 db 01 00 00       	call   120100 <z_is_thread_ready>
  11ff25:	a8 01                	test   $0x1,%al
  11ff27:	0f 85 05 00 00 00    	jne    11ff32 <do_sem_give+0x42>
  11ff2d:	e9 0b 00 00 00       	jmp    11ff3d <do_sem_give+0x4d>
		z_add_thread_to_ready_q(thread);
  11ff32:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11ff35:	89 04 24             	mov    %eax,(%esp)
  11ff38:	e8 93 e3 ff ff       	call   11e2d0 <z_add_thread_to_ready_q>
		arch_thread_return_value_set(thread, 0);
  11ff3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ff40:	89 45 fc             	mov    %eax,-0x4(%ebp)
  11ff43:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11ff4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11ff4d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  11ff50:	8b 49 28             	mov    0x28(%ecx),%ecx
  11ff53:	89 01                	mov    %eax,(%ecx)
	} else {
  11ff55:	e9 16 00 00 00       	jmp    11ff70 <do_sem_give+0x80>
		increment_count_up_to_limit(sem);
  11ff5a:	8b 45 08             	mov    0x8(%ebp),%eax
  11ff5d:	89 04 24             	mov    %eax,(%esp)
  11ff60:	e8 3b 01 00 00       	call   1200a0 <increment_count_up_to_limit>
		handle_poll_events(sem);
  11ff65:	8b 45 08             	mov    0x8(%ebp),%eax
  11ff68:	89 04 24             	mov    %eax,(%esp)
  11ff6b:	e8 80 01 00 00       	call   1200f0 <handle_poll_events>
}
  11ff70:	83 c4 18             	add    $0x18,%esp
  11ff73:	5d                   	pop    %ebp
  11ff74:	c3                   	ret    
  11ff75:	66 90                	xchg   %ax,%ax
  11ff77:	66 90                	xchg   %ax,%ax
  11ff79:	66 90                	xchg   %ax,%ax
  11ff7b:	66 90                	xchg   %ax,%ax
  11ff7d:	66 90                	xchg   %ax,%ax
  11ff7f:	90                   	nop

0011ff80 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
  11ff80:	55                   	push   %ebp
  11ff81:	89 e5                	mov    %esp,%ebp
  11ff83:	53                   	push   %ebx
  11ff84:	56                   	push   %esi
  11ff85:	83 e4 f8             	and    $0xfffffff8,%esp
  11ff88:	83 ec 48             	sub    $0x48,%esp
  11ff8b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11ff8e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  11ff91:	8d 54 24 18          	lea    0x18(%esp),%edx
  11ff95:	89 54 24 24          	mov    %edx,0x24(%esp)
  11ff99:	8d 15 ef 0e 14 00    	lea    0x140eef,%edx
  11ff9f:	89 54 24 20          	mov    %edx,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  11ffa3:	9c                   	pushf  
  11ffa4:	fa                   	cli    
  11ffa5:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  11ffa9:	8b 54 24 28          	mov    0x28(%esp),%edx
  11ffad:	89 54 24 18          	mov    %edx,0x18(%esp)
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
  11ffb1:	8b 55 08             	mov    0x8(%ebp),%edx
  11ffb4:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  11ffb8:	0f 97 c3             	seta   %bl
  11ffbb:	80 f3 ff             	xor    $0xff,%bl
  11ffbe:	80 f3 ff             	xor    $0xff,%bl
  11ffc1:	f6 c3 01             	test   $0x1,%bl
  11ffc4:	0f 85 05 00 00 00    	jne    11ffcf <z_impl_k_sem_take+0x4f>
  11ffca:	e9 46 00 00 00       	jmp    120015 <z_impl_k_sem_take+0x95>
		sem->count--;
  11ffcf:	8b 45 08             	mov    0x8(%ebp),%eax
  11ffd2:	8b 48 10             	mov    0x10(%eax),%ecx
  11ffd5:	83 c1 ff             	add    $0xffffffff,%ecx
  11ffd8:	89 48 10             	mov    %ecx,0x10(%eax)
		k_spin_unlock(&lock, key);
  11ffdb:	8b 44 24 18          	mov    0x18(%esp),%eax
  11ffdf:	89 44 24 30          	mov    %eax,0x30(%esp)
  11ffe3:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  11ffe9:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  11ffed:	8b 44 24 30          	mov    0x30(%esp),%eax
  11fff1:	89 44 24 38          	mov    %eax,0x38(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  11fff5:	8b 44 24 38          	mov    0x38(%esp),%eax
  11fff9:	25 00 02 00 00       	and    $0x200,%eax
  11fffe:	83 f8 00             	cmp    $0x0,%eax
  120001:	0f 84 01 00 00 00    	je     120008 <z_impl_k_sem_take+0x88>
		__asm__ volatile ("sti" ::: "memory");
  120007:	fb                   	sti    
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
  120008:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  12000f:	00 
  120010:	e9 74 00 00 00       	jmp    120089 <z_impl_k_sem_take+0x109>
	}

	if (timeout == K_NO_WAIT) {
  120015:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  120019:	0f 85 3a 00 00 00    	jne    120059 <z_impl_k_sem_take+0xd9>
		k_spin_unlock(&lock, key);
  12001f:	8b 44 24 18          	mov    0x18(%esp),%eax
  120023:	89 44 24 40          	mov    %eax,0x40(%esp)
  120027:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12002d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  120031:	8b 44 24 40          	mov    0x40(%esp),%eax
  120035:	89 44 24 44          	mov    %eax,0x44(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120039:	8b 44 24 44          	mov    0x44(%esp),%eax
  12003d:	25 00 02 00 00       	and    $0x200,%eax
  120042:	83 f8 00             	cmp    $0x0,%eax
  120045:	0f 84 01 00 00 00    	je     12004c <z_impl_k_sem_take+0xcc>
		__asm__ volatile ("sti" ::: "memory");
  12004b:	fb                   	sti    
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return -EBUSY;
  12004c:	c7 44 24 1c f0 ff ff 	movl   $0xfffffff0,0x1c(%esp)
  120053:	ff 
  120054:	e9 30 00 00 00       	jmp    120089 <z_impl_k_sem_take+0x109>
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  120059:	8b 45 08             	mov    0x8(%ebp),%eax
  12005c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  12005f:	8b 54 24 18          	mov    0x18(%esp),%edx
  120063:	8d 35 ef 0e 14 00    	lea    0x140eef,%esi
  120069:	89 34 24             	mov    %esi,(%esp)
  12006c:	89 54 24 04          	mov    %edx,0x4(%esp)
  120070:	89 44 24 08          	mov    %eax,0x8(%esp)
  120074:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  120078:	e8 f3 eb ff ff       	call   11ec70 <z_pend_curr>
  12007d:	89 44 24 14          	mov    %eax,0x14(%esp)
	return ret;
  120081:	8b 44 24 14          	mov    0x14(%esp),%eax
  120085:	89 44 24 1c          	mov    %eax,0x1c(%esp)
}
  120089:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  12008d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  120090:	5e                   	pop    %esi
  120091:	5b                   	pop    %ebx
  120092:	5d                   	pop    %ebp
  120093:	c3                   	ret    
  120094:	66 90                	xchg   %ax,%ax
  120096:	66 90                	xchg   %ax,%ax
  120098:	66 90                	xchg   %ax,%ax
  12009a:	66 90                	xchg   %ax,%ax
  12009c:	66 90                	xchg   %ax,%ax
  12009e:	66 90                	xchg   %ax,%ax

001200a0 <increment_count_up_to_limit>:
{
  1200a0:	55                   	push   %ebp
  1200a1:	89 e5                	mov    %esp,%ebp
  1200a3:	56                   	push   %esi
  1200a4:	83 ec 08             	sub    $0x8,%esp
  1200a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1200aa:	31 c9                	xor    %ecx,%ecx
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
  1200ac:	8b 55 08             	mov    0x8(%ebp),%edx
  1200af:	8b 52 10             	mov    0x10(%edx),%edx
  1200b2:	8b 75 08             	mov    0x8(%ebp),%esi
  1200b5:	8b 76 14             	mov    0x14(%esi),%esi
  1200b8:	39 f2                	cmp    %esi,%edx
  1200ba:	ba 01 00 00 00       	mov    $0x1,%edx
  1200bf:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1200c2:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1200c5:	0f 85 06 00 00 00    	jne    1200d1 <increment_count_up_to_limit+0x31>
  1200cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1200ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1200d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1200d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1200d7:	03 41 10             	add    0x10(%ecx),%eax
  1200da:	89 41 10             	mov    %eax,0x10(%ecx)
}
  1200dd:	83 c4 08             	add    $0x8,%esp
  1200e0:	5e                   	pop    %esi
  1200e1:	5d                   	pop    %ebp
  1200e2:	c3                   	ret    
  1200e3:	66 90                	xchg   %ax,%ax
  1200e5:	66 90                	xchg   %ax,%ax
  1200e7:	66 90                	xchg   %ax,%ax
  1200e9:	66 90                	xchg   %ax,%ax
  1200eb:	66 90                	xchg   %ax,%ax
  1200ed:	66 90                	xchg   %ax,%ax
  1200ef:	90                   	nop

001200f0 <handle_poll_events>:
{
  1200f0:	55                   	push   %ebp
  1200f1:	89 e5                	mov    %esp,%ebp
  1200f3:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1200f6:	5d                   	pop    %ebp
  1200f7:	c3                   	ret    
  1200f8:	66 90                	xchg   %ax,%ax
  1200fa:	66 90                	xchg   %ax,%ax
  1200fc:	66 90                	xchg   %ax,%ax
  1200fe:	66 90                	xchg   %ax,%ax

00120100 <z_is_thread_ready>:
{
  120100:	55                   	push   %ebp
  120101:	89 e5                	mov    %esp,%ebp
  120103:	83 ec 0c             	sub    $0xc,%esp
  120106:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  120109:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12010c:	89 0c 24             	mov    %ecx,(%esp)
  12010f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120112:	e8 39 00 00 00       	call   120150 <z_is_thread_prevented_from_running>
  120117:	24 01                	and    $0x1,%al
  120119:	0f b6 c8             	movzbl %al,%ecx
  12011c:	83 f9 00             	cmp    $0x0,%ecx
  12011f:	b0 01                	mov    $0x1,%al
  120121:	88 45 fb             	mov    %al,-0x5(%ebp)
  120124:	0f 85 0e 00 00 00    	jne    120138 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  12012a:	8b 45 08             	mov    0x8(%ebp),%eax
  12012d:	89 04 24             	mov    %eax,(%esp)
  120130:	e8 4b 00 00 00       	call   120180 <z_is_thread_timeout_active>
  120135:	88 45 fb             	mov    %al,-0x5(%ebp)
  120138:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  12013b:	34 ff                	xor    $0xff,%al
  12013d:	24 01                	and    $0x1,%al
  12013f:	0f b6 c0             	movzbl %al,%eax
  120142:	83 c4 0c             	add    $0xc,%esp
  120145:	5d                   	pop    %ebp
  120146:	c3                   	ret    
  120147:	66 90                	xchg   %ax,%ax
  120149:	66 90                	xchg   %ax,%ax
  12014b:	66 90                	xchg   %ax,%ax
  12014d:	66 90                	xchg   %ax,%ax
  12014f:	90                   	nop

00120150 <z_is_thread_prevented_from_running>:
{
  120150:	55                   	push   %ebp
  120151:	89 e5                	mov    %esp,%ebp
  120153:	83 ec 08             	sub    $0x8,%esp
  120156:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  120159:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12015c:	8a 51 0d             	mov    0xd(%ecx),%dl
  12015f:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  120162:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  120166:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  120169:	83 f9 00             	cmp    $0x0,%ecx
  12016c:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  12016f:	80 e2 01             	and    $0x1,%dl
  120172:	0f b6 ca             	movzbl %dl,%ecx
  120175:	89 45 f8             	mov    %eax,-0x8(%ebp)
  120178:	89 c8                	mov    %ecx,%eax
  12017a:	83 c4 08             	add    $0x8,%esp
  12017d:	5d                   	pop    %ebp
  12017e:	c3                   	ret    
  12017f:	90                   	nop

00120180 <z_is_thread_timeout_active>:
{
  120180:	55                   	push   %ebp
  120181:	89 e5                	mov    %esp,%ebp
  120183:	83 ec 08             	sub    $0x8,%esp
  120186:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  120189:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12018c:	83 c1 18             	add    $0x18,%ecx
  12018f:	89 0c 24             	mov    %ecx,(%esp)
  120192:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120195:	e8 16 00 00 00       	call   1201b0 <z_is_inactive_timeout>
  12019a:	34 ff                	xor    $0xff,%al
  12019c:	24 01                	and    $0x1,%al
  12019e:	0f b6 c0             	movzbl %al,%eax
  1201a1:	83 c4 08             	add    $0x8,%esp
  1201a4:	5d                   	pop    %ebp
  1201a5:	c3                   	ret    
  1201a6:	66 90                	xchg   %ax,%ax
  1201a8:	66 90                	xchg   %ax,%ax
  1201aa:	66 90                	xchg   %ax,%ax
  1201ac:	66 90                	xchg   %ax,%ax
  1201ae:	66 90                	xchg   %ax,%ax

001201b0 <z_is_inactive_timeout>:
{
  1201b0:	55                   	push   %ebp
  1201b1:	89 e5                	mov    %esp,%ebp
  1201b3:	83 ec 08             	sub    $0x8,%esp
  1201b6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  1201b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1201bc:	89 0c 24             	mov    %ecx,(%esp)
  1201bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1201c2:	e8 19 00 00 00       	call   1201e0 <sys_dnode_is_linked>
  1201c7:	34 ff                	xor    $0xff,%al
  1201c9:	24 01                	and    $0x1,%al
  1201cb:	0f b6 c0             	movzbl %al,%eax
  1201ce:	83 c4 08             	add    $0x8,%esp
  1201d1:	5d                   	pop    %ebp
  1201d2:	c3                   	ret    
  1201d3:	66 90                	xchg   %ax,%ax
  1201d5:	66 90                	xchg   %ax,%ax
  1201d7:	66 90                	xchg   %ax,%ax
  1201d9:	66 90                	xchg   %ax,%ax
  1201db:	66 90                	xchg   %ax,%ax
  1201dd:	66 90                	xchg   %ax,%ax
  1201df:	90                   	nop

001201e0 <sys_dnode_is_linked>:
{
  1201e0:	55                   	push   %ebp
  1201e1:	89 e5                	mov    %esp,%ebp
  1201e3:	50                   	push   %eax
  1201e4:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  1201e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1201ea:	83 39 00             	cmpl   $0x0,(%ecx)
  1201ed:	0f 95 c2             	setne  %dl
  1201f0:	80 e2 01             	and    $0x1,%dl
  1201f3:	0f b6 ca             	movzbl %dl,%ecx
  1201f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1201f9:	89 c8                	mov    %ecx,%eax
  1201fb:	83 c4 04             	add    $0x4,%esp
  1201fe:	5d                   	pop    %ebp
  1201ff:	c3                   	ret    

00120200 <z_impl_z_clock_hw_cycles_per_sec_runtime_get>:
{
  120200:	55                   	push   %ebp
  120201:	89 e5                	mov    %esp,%ebp
	return z_clock_hw_cycles_per_sec;
  120203:	a1 a8 33 14 00       	mov    0x1433a8,%eax
  120208:	5d                   	pop    %ebp
  120209:	c3                   	ret    
  12020a:	66 90                	xchg   %ax,%ax
  12020c:	66 90                	xchg   %ax,%ax
  12020e:	66 90                	xchg   %ax,%ax

00120210 <z_impl_k_busy_wait>:
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
}

#ifdef CONFIG_SYS_CLOCK_EXISTS
void z_impl_k_busy_wait(u32_t usec_to_wait)
{
  120210:	55                   	push   %ebp
  120211:	89 e5                	mov    %esp,%ebp
  120213:	57                   	push   %edi
  120214:	56                   	push   %esi
  120215:	83 ec 28             	sub    $0x28,%esp
  120218:	8b 45 08             	mov    0x8(%ebp),%eax
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	/* use 64-bit math to prevent overflow when multiplying */
	u32_t cycles_to_wait = (u32_t)(
		(u64_t)usec_to_wait *
  12021b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12021e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  120221:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		(u64_t)sys_clock_hw_cycles_per_sec() /
  120224:	e8 67 00 00 00       	call   120290 <sys_clock_hw_cycles_per_sec>
  120229:	89 c1                	mov    %eax,%ecx
  12022b:	c1 f9 1f             	sar    $0x1f,%ecx
  12022e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  120231:	89 45 e0             	mov    %eax,-0x20(%ebp)
		(u64_t)usec_to_wait *
  120234:	89 d0                	mov    %edx,%eax
  120236:	8b 75 e0             	mov    -0x20(%ebp),%esi
  120239:	f7 e6                	mul    %esi
  12023b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  12023e:	0f af f9             	imul   %ecx,%edi
  120241:	01 fa                	add    %edi,%edx
		(u64_t)sys_clock_hw_cycles_per_sec() /
  120243:	89 e1                	mov    %esp,%ecx
  120245:	89 01                	mov    %eax,(%ecx)
  120247:	89 51 04             	mov    %edx,0x4(%ecx)
  12024a:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
  120251:	c7 41 08 40 42 0f 00 	movl   $0xf4240,0x8(%ecx)
  120258:	e8 73 fe fd ff       	call   1000d0 <__udivdi3>
	u32_t cycles_to_wait = (u32_t)(
  12025d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		(u64_t)USEC_PER_SEC
	);
	u32_t start_cycles = k_cycle_get_32();
  120260:	e8 3b 00 00 00       	call   1202a0 <k_cycle_get_32>
  120265:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for (;;) {
		u32_t current_cycles = k_cycle_get_32();
  120268:	e8 33 00 00 00       	call   1202a0 <k_cycle_get_32>
  12026d:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
  120270:	8b 45 ec             	mov    -0x14(%ebp),%eax
  120273:	2b 45 f0             	sub    -0x10(%ebp),%eax
  120276:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  120279:	0f 82 05 00 00 00    	jb     120284 <z_impl_k_busy_wait+0x74>
			break;
  12027f:	e9 05 00 00 00       	jmp    120289 <z_impl_k_busy_wait+0x79>
	for (;;) {
  120284:	e9 df ff ff ff       	jmp    120268 <z_impl_k_busy_wait+0x58>
		}
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
}
  120289:	83 c4 28             	add    $0x28,%esp
  12028c:	5e                   	pop    %esi
  12028d:	5f                   	pop    %edi
  12028e:	5d                   	pop    %ebp
  12028f:	c3                   	ret    

00120290 <sys_clock_hw_cycles_per_sec>:
{
  120290:	55                   	push   %ebp
  120291:	89 e5                	mov    %esp,%ebp
	return z_clock_hw_cycles_per_sec_runtime_get();
  120293:	e8 58 08 00 00       	call   120af0 <z_clock_hw_cycles_per_sec_runtime_get>
  120298:	5d                   	pop    %ebp
  120299:	c3                   	ret    
  12029a:	66 90                	xchg   %ax,%ax
  12029c:	66 90                	xchg   %ax,%ax
  12029e:	66 90                	xchg   %ax,%ax

001202a0 <k_cycle_get_32>:
{
  1202a0:	55                   	push   %ebp
  1202a1:	89 e5                	mov    %esp,%ebp
	return arch_k_cycle_get_32();
  1202a3:	e8 58 08 00 00       	call   120b00 <arch_k_cycle_get_32>
  1202a8:	5d                   	pop    %ebp
  1202a9:	c3                   	ret    
  1202aa:	66 90                	xchg   %ax,%ax
  1202ac:	66 90                	xchg   %ax,%ax
  1202ae:	66 90                	xchg   %ax,%ax

001202b0 <z_impl_k_thread_name_set>:
	k_spin_unlock(&lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  1202b0:	55                   	push   %ebp
  1202b1:	89 e5                	mov    %esp,%ebp
  1202b3:	50                   	push   %eax
  1202b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1202b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	sys_trace_thread_name_set(thread);
	return 0;
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
  1202ba:	ba b9 ff ff ff       	mov    $0xffffffb9,%edx
  1202bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1202c2:	89 d0                	mov    %edx,%eax
  1202c4:	83 c4 04             	add    $0x4,%esp
  1202c7:	5d                   	pop    %ebp
  1202c8:	c3                   	ret    
  1202c9:	66 90                	xchg   %ax,%ax
  1202cb:	66 90                	xchg   %ax,%ax
  1202cd:	66 90                	xchg   %ax,%ax
  1202cf:	90                   	nop

001202d0 <k_thread_name_get>:
}
#include <syscalls/k_thread_name_set_mrsh.c>
#endif /* CONFIG_USERSPACE */

const char *k_thread_name_get(struct k_thread *thread)
{
  1202d0:	55                   	push   %ebp
  1202d1:	89 e5                	mov    %esp,%ebp
  1202d3:	50                   	push   %eax
  1202d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1202d7:	31 c9                	xor    %ecx,%ecx
  1202d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
#ifdef CONFIG_THREAD_NAME
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
  1202dc:	89 c8                	mov    %ecx,%eax
  1202de:	83 c4 04             	add    $0x4,%esp
  1202e1:	5d                   	pop    %ebp
  1202e2:	c3                   	ret    
  1202e3:	66 90                	xchg   %ax,%ax
  1202e5:	66 90                	xchg   %ax,%ax
  1202e7:	66 90                	xchg   %ax,%ax
  1202e9:	66 90                	xchg   %ax,%ax
  1202eb:	66 90                	xchg   %ax,%ax
  1202ed:	66 90                	xchg   %ax,%ax
  1202ef:	90                   	nop

001202f0 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
  1202f0:	55                   	push   %ebp
  1202f1:	89 e5                	mov    %esp,%ebp
  1202f3:	83 e4 f8             	and    $0xfffffff8,%esp
  1202f6:	83 ec 38             	sub    $0x38,%esp
  1202f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1202fc:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  120300:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  120304:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  12030a:	89 4c 24 18          	mov    %ecx,0x18(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12030e:	9c                   	pushf  
  12030f:	fa                   	cli    
  120310:	8f 44 24 20          	popl   0x20(%esp)
	return key;
  120314:	8b 4c 24 20          	mov    0x20(%esp),%ecx
	k.key = arch_irq_lock();
  120318:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
  12031c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12031f:	89 0c 24             	mov    %ecx,(%esp)
  120322:	89 44 24 0c          	mov    %eax,0xc(%esp)
  120326:	e8 95 00 00 00       	call   1203c0 <z_has_thread_started>
  12032b:	a8 01                	test   $0x1,%al
  12032d:	0f 85 05 00 00 00    	jne    120338 <z_impl_k_thread_start+0x48>
  120333:	e9 32 00 00 00       	jmp    12036a <z_impl_k_thread_start+0x7a>
		k_spin_unlock(&lock, key);
  120338:	8b 44 24 10          	mov    0x10(%esp),%eax
  12033c:	89 44 24 28          	mov    %eax,0x28(%esp)
  120340:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  120346:	89 44 24 24          	mov    %eax,0x24(%esp)
	arch_irq_unlock(key.key);
  12034a:	8b 44 24 28          	mov    0x28(%esp),%eax
  12034e:	89 44 24 30          	mov    %eax,0x30(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120352:	8b 44 24 30          	mov    0x30(%esp),%eax
  120356:	25 00 02 00 00       	and    $0x200,%eax
  12035b:	83 f8 00             	cmp    $0x0,%eax
  12035e:	0f 84 01 00 00 00    	je     120365 <z_impl_k_thread_start+0x75>
		__asm__ volatile ("sti" ::: "memory");
  120364:	fb                   	sti    
		return;
  120365:	e9 4d 00 00 00       	jmp    1203b7 <z_impl_k_thread_start+0xc7>
	}

	z_mark_thread_as_started(thread);
  12036a:	8b 45 08             	mov    0x8(%ebp),%eax
  12036d:	89 04 24             	mov    %eax,(%esp)
  120370:	e8 7b 00 00 00       	call   1203f0 <z_mark_thread_as_started>
	z_ready_thread(thread);
  120375:	8b 45 08             	mov    0x8(%ebp),%eax
  120378:	89 44 24 34          	mov    %eax,0x34(%esp)
	if (z_is_thread_ready(thread)) {
  12037c:	8b 44 24 34          	mov    0x34(%esp),%eax
  120380:	89 04 24             	mov    %eax,(%esp)
  120383:	e8 d8 03 00 00       	call   120760 <z_is_thread_ready>
  120388:	a8 01                	test   $0x1,%al
  12038a:	0f 85 05 00 00 00    	jne    120395 <z_impl_k_thread_start+0xa5>
  120390:	e9 0c 00 00 00       	jmp    1203a1 <z_impl_k_thread_start+0xb1>
		z_add_thread_to_ready_q(thread);
  120395:	8b 44 24 34          	mov    0x34(%esp),%eax
  120399:	89 04 24             	mov    %eax,(%esp)
  12039c:	e8 2f df ff ff       	call   11e2d0 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
  1203a1:	8b 44 24 10          	mov    0x10(%esp),%eax
  1203a5:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  1203ab:	89 0c 24             	mov    %ecx,(%esp)
  1203ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  1203b2:	e8 a9 ec ff ff       	call   11f060 <z_reschedule>
}
  1203b7:	89 ec                	mov    %ebp,%esp
  1203b9:	5d                   	pop    %ebp
  1203ba:	c3                   	ret    
  1203bb:	66 90                	xchg   %ax,%ax
  1203bd:	66 90                	xchg   %ax,%ax
  1203bf:	90                   	nop

001203c0 <z_has_thread_started>:
{
  1203c0:	55                   	push   %ebp
  1203c1:	89 e5                	mov    %esp,%ebp
  1203c3:	50                   	push   %eax
  1203c4:	8b 45 08             	mov    0x8(%ebp),%eax
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  1203c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1203ca:	0f b6 49 0d          	movzbl 0xd(%ecx),%ecx
  1203ce:	83 e1 04             	and    $0x4,%ecx
  1203d1:	83 f9 00             	cmp    $0x0,%ecx
  1203d4:	0f 94 c2             	sete   %dl
  1203d7:	80 e2 01             	and    $0x1,%dl
  1203da:	0f b6 ca             	movzbl %dl,%ecx
  1203dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1203e0:	89 c8                	mov    %ecx,%eax
  1203e2:	83 c4 04             	add    $0x4,%esp
  1203e5:	5d                   	pop    %ebp
  1203e6:	c3                   	ret    
  1203e7:	66 90                	xchg   %ax,%ax
  1203e9:	66 90                	xchg   %ax,%ax
  1203eb:	66 90                	xchg   %ax,%ax
  1203ed:	66 90                	xchg   %ax,%ax
  1203ef:	90                   	nop

001203f0 <z_mark_thread_as_started>:
{
  1203f0:	55                   	push   %ebp
  1203f1:	89 e5                	mov    %esp,%ebp
  1203f3:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1203f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1203f9:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  1203fd:	83 e2 fb             	and    $0xfffffffb,%edx
  120400:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  120403:	5d                   	pop    %ebp
  120404:	c3                   	ret    
  120405:	66 90                	xchg   %ax,%ax
  120407:	66 90                	xchg   %ax,%ax
  120409:	66 90                	xchg   %ax,%ax
  12040b:	66 90                	xchg   %ax,%ax
  12040d:	66 90                	xchg   %ax,%ax
  12040f:	90                   	nop

00120410 <z_new_thread_init>:
#endif /* CONFIG_STACK_POINTER_RANDOM */

void z_new_thread_init(struct k_thread *thread,
					    char *pStack, size_t stackSize,
					    int prio, unsigned int options)
{
  120410:	55                   	push   %ebp
  120411:	89 e5                	mov    %esp,%ebp
  120413:	53                   	push   %ebx
  120414:	57                   	push   %edi
  120415:	56                   	push   %esi
  120416:	83 ec 28             	sub    $0x28,%esp
  120419:	8b 45 18             	mov    0x18(%ebp),%eax
  12041c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  12041f:	8b 55 10             	mov    0x10(%ebp),%edx
  120422:	8b 75 0c             	mov    0xc(%ebp),%esi
  120425:	8b 7d 08             	mov    0x8(%ebp),%edi
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
  120428:	8b 5d 08             	mov    0x8(%ebp),%ebx
  12042b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  12042e:	8b 45 14             	mov    0x14(%ebp),%eax
  120431:	89 45 ec             	mov    %eax,-0x14(%ebp)
  120434:	8b 45 18             	mov    0x18(%ebp),%eax
  120437:	89 1c 24             	mov    %ebx,(%esp)
  12043a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  12043d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  120441:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  120448:	00 
  120449:	89 44 24 0c          	mov    %eax,0xc(%esp)
  12044d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  120450:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  120453:	89 75 e0             	mov    %esi,-0x20(%ebp)
  120456:	89 7d dc             	mov    %edi,-0x24(%ebp)
  120459:	e8 22 00 00 00       	call   120480 <z_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  12045e:	8b 45 08             	mov    0x8(%ebp),%eax
  120461:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	thread->fn_abort = NULL;
  120468:	8b 45 08             	mov    0x8(%ebp),%eax
  12046b:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)

#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)pStack;
	thread->stack_info.size = (u32_t)stackSize;
#endif /* CONFIG_THREAD_STACK_INFO */
}
  120472:	83 c4 28             	add    $0x28,%esp
  120475:	5e                   	pop    %esi
  120476:	5f                   	pop    %edi
  120477:	5b                   	pop    %ebx
  120478:	5d                   	pop    %ebp
  120479:	c3                   	ret    
  12047a:	66 90                	xchg   %ax,%ax
  12047c:	66 90                	xchg   %ax,%ax
  12047e:	66 90                	xchg   %ax,%ax

00120480 <z_init_thread_base>:
}
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
  120480:	55                   	push   %ebp
  120481:	89 e5                	mov    %esp,%ebp
  120483:	53                   	push   %ebx
  120484:	57                   	push   %edi
  120485:	56                   	push   %esi
  120486:	83 ec 14             	sub    $0x14,%esp
  120489:	8b 45 14             	mov    0x14(%ebp),%eax
  12048c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  12048f:	8b 55 0c             	mov    0xc(%ebp),%edx
  120492:	8b 75 08             	mov    0x8(%ebp),%esi
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
  120495:	8b 5d 14             	mov    0x14(%ebp),%ebx
  120498:	8b 7d 08             	mov    0x8(%ebp),%edi
  12049b:	88 5f 0c             	mov    %bl,0xc(%edi)
	thread_base->thread_state = (u8_t)initial_state;
  12049e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  1204a1:	8b 7d 08             	mov    0x8(%ebp),%edi
  1204a4:	88 5f 0d             	mov    %bl,0xd(%edi)

	thread_base->prio = priority;
  1204a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1204aa:	8b 7d 08             	mov    0x8(%ebp),%edi
  1204ad:	88 5f 0e             	mov    %bl,0xe(%edi)

	thread_base->sched_locked = 0U;
  1204b0:	8b 7d 08             	mov    0x8(%ebp),%edi
  1204b3:	c6 47 0f 00          	movb   $0x0,0xf(%edi)
	thread_base->is_idle = 0;
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
  1204b7:	8b 7d 08             	mov    0x8(%ebp),%edi
  1204ba:	89 3c 24             	mov    %edi,(%esp)
  1204bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1204c0:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1204c3:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1204c6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  1204c9:	e8 02 06 00 00       	call   120ad0 <z_init_thread_timeout>
}
  1204ce:	83 c4 14             	add    $0x14,%esp
  1204d1:	5e                   	pop    %esi
  1204d2:	5f                   	pop    %edi
  1204d3:	5b                   	pop    %ebx
  1204d4:	5d                   	pop    %ebp
  1204d5:	c3                   	ret    
  1204d6:	66 90                	xchg   %ax,%ax
  1204d8:	66 90                	xchg   %ax,%ax
  1204da:	66 90                	xchg   %ax,%ax
  1204dc:	66 90                	xchg   %ax,%ax
  1204de:	66 90                	xchg   %ax,%ax

001204e0 <z_setup_new_thread>:
{
  1204e0:	55                   	push   %ebp
  1204e1:	89 e5                	mov    %esp,%ebp
  1204e3:	53                   	push   %ebx
  1204e4:	57                   	push   %edi
  1204e5:	56                   	push   %esi
  1204e6:	83 ec 5c             	sub    $0x5c,%esp
  1204e9:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1204ec:	8b 4d 28             	mov    0x28(%ebp),%ecx
  1204ef:	8b 55 24             	mov    0x24(%ebp),%edx
  1204f2:	8b 75 20             	mov    0x20(%ebp),%esi
  1204f5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  1204f8:	8b 5d 18             	mov    0x18(%ebp),%ebx
  1204fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1204fe:	8b 45 14             	mov    0x14(%ebp),%eax
  120501:	89 45 ec             	mov    %eax,-0x14(%ebp)
  120504:	8b 45 10             	mov    0x10(%ebp),%eax
  120507:	89 45 e8             	mov    %eax,-0x18(%ebp)
  12050a:	8b 45 0c             	mov    0xc(%ebp),%eax
  12050d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  120510:	8b 45 08             	mov    0x8(%ebp),%eax
  120513:	89 45 e0             	mov    %eax,-0x20(%ebp)
	stack_size = adjust_stack_size(stack_size);
  120516:	8b 45 10             	mov    0x10(%ebp),%eax
  120519:	89 04 24             	mov    %eax,(%esp)
  12051c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  12051f:	89 55 d8             	mov    %edx,-0x28(%ebp)
  120522:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  120525:	89 7d d0             	mov    %edi,-0x30(%ebp)
  120528:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  12052b:	e8 80 00 00 00       	call   1205b0 <adjust_stack_size>
  120530:	89 45 10             	mov    %eax,0x10(%ebp)
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  120533:	8b 45 08             	mov    0x8(%ebp),%eax
  120536:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  120539:	8b 55 10             	mov    0x10(%ebp),%edx
  12053c:	8b 75 14             	mov    0x14(%ebp),%esi
  12053f:	8b 7d 18             	mov    0x18(%ebp),%edi
  120542:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  120545:	89 45 c8             	mov    %eax,-0x38(%ebp)
  120548:	8b 45 20             	mov    0x20(%ebp),%eax
  12054b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			  prio, options);
  12054e:	8b 45 24             	mov    0x24(%ebp),%eax
  120551:	89 45 c0             	mov    %eax,-0x40(%ebp)
  120554:	8b 45 28             	mov    0x28(%ebp),%eax
  120557:	89 45 bc             	mov    %eax,-0x44(%ebp)
  12055a:	8b 45 c8             	mov    -0x38(%ebp),%eax
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  12055d:	89 04 24             	mov    %eax,(%esp)
  120560:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  120564:	89 54 24 08          	mov    %edx,0x8(%esp)
  120568:	89 74 24 0c          	mov    %esi,0xc(%esp)
  12056c:	89 7c 24 10          	mov    %edi,0x10(%esp)
  120570:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  120574:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  120577:	89 44 24 18          	mov    %eax,0x18(%esp)
  12057b:	8b 45 c0             	mov    -0x40(%ebp),%eax
  12057e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  120582:	8b 45 bc             	mov    -0x44(%ebp),%eax
  120585:	89 44 24 20          	mov    %eax,0x20(%esp)
  120589:	e8 62 93 fe ff       	call   1098f0 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
  12058e:	a1 b0 96 13 00       	mov    0x1396b0,%eax
  120593:	8b 40 38             	mov    0x38(%eax),%eax
  120596:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120599:	89 41 38             	mov    %eax,0x38(%ecx)
}
  12059c:	83 c4 5c             	add    $0x5c,%esp
  12059f:	5e                   	pop    %esi
  1205a0:	5f                   	pop    %edi
  1205a1:	5b                   	pop    %ebx
  1205a2:	5d                   	pop    %ebp
  1205a3:	c3                   	ret    
  1205a4:	66 90                	xchg   %ax,%ax
  1205a6:	66 90                	xchg   %ax,%ax
  1205a8:	66 90                	xchg   %ax,%ax
  1205aa:	66 90                	xchg   %ax,%ax
  1205ac:	66 90                	xchg   %ax,%ax
  1205ae:	66 90                	xchg   %ax,%ax

001205b0 <adjust_stack_size>:
{
  1205b0:	55                   	push   %ebp
  1205b1:	89 e5                	mov    %esp,%ebp
  1205b3:	50                   	push   %eax
  1205b4:	8b 45 08             	mov    0x8(%ebp),%eax
	return stack_size;
  1205b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1205ba:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1205bd:	89 c8                	mov    %ecx,%eax
  1205bf:	83 c4 04             	add    $0x4,%esp
  1205c2:	5d                   	pop    %ebp
  1205c3:	c3                   	ret    
  1205c4:	66 90                	xchg   %ax,%ax
  1205c6:	66 90                	xchg   %ax,%ax
  1205c8:	66 90                	xchg   %ax,%ax
  1205ca:	66 90                	xchg   %ax,%ax
  1205cc:	66 90                	xchg   %ax,%ax
  1205ce:	66 90                	xchg   %ax,%ax

001205d0 <z_impl_k_thread_create>:
{
  1205d0:	55                   	push   %ebp
  1205d1:	89 e5                	mov    %esp,%ebp
  1205d3:	53                   	push   %ebx
  1205d4:	57                   	push   %edi
  1205d5:	56                   	push   %esi
  1205d6:	83 ec 78             	sub    $0x78,%esp
  1205d9:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1205dc:	8b 4d 28             	mov    0x28(%ebp),%ecx
  1205df:	8b 55 24             	mov    0x24(%ebp),%edx
  1205e2:	8b 75 20             	mov    0x20(%ebp),%esi
  1205e5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  1205e8:	8b 5d 18             	mov    0x18(%ebp),%ebx
  1205eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1205ee:	8b 45 14             	mov    0x14(%ebp),%eax
  1205f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1205f4:	8b 45 10             	mov    0x10(%ebp),%eax
  1205f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1205fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1205fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  120600:	8b 45 08             	mov    0x8(%ebp),%eax
  120603:	89 45 e0             	mov    %eax,-0x20(%ebp)
  120606:	31 c0                	xor    %eax,%eax
  120608:	89 45 dc             	mov    %eax,-0x24(%ebp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  12060b:	8b 45 08             	mov    0x8(%ebp),%eax
  12060e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  120611:	8b 45 0c             	mov    0xc(%ebp),%eax
  120614:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  120617:	8b 45 10             	mov    0x10(%ebp),%eax
  12061a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  12061d:	8b 45 14             	mov    0x14(%ebp),%eax
  120620:	89 45 cc             	mov    %eax,-0x34(%ebp)
  120623:	8b 45 18             	mov    0x18(%ebp),%eax
  120626:	89 45 c8             	mov    %eax,-0x38(%ebp)
  120629:	8b 45 1c             	mov    0x1c(%ebp),%eax
  12062c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  12062f:	8b 45 20             	mov    0x20(%ebp),%eax
  120632:	89 45 c0             	mov    %eax,-0x40(%ebp)
			  prio, options, NULL);
  120635:	8b 45 24             	mov    0x24(%ebp),%eax
  120638:	89 45 bc             	mov    %eax,-0x44(%ebp)
  12063b:	8b 45 28             	mov    0x28(%ebp),%eax
  12063e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  120641:	8b 45 d8             	mov    -0x28(%ebp),%eax
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  120644:	89 04 24             	mov    %eax,(%esp)
  120647:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  12064a:	89 44 24 04          	mov    %eax,0x4(%esp)
  12064e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  120651:	89 44 24 08          	mov    %eax,0x8(%esp)
  120655:	8b 45 cc             	mov    -0x34(%ebp),%eax
  120658:	89 44 24 0c          	mov    %eax,0xc(%esp)
  12065c:	8b 45 c8             	mov    -0x38(%ebp),%eax
  12065f:	89 44 24 10          	mov    %eax,0x10(%esp)
  120663:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  120666:	89 44 24 14          	mov    %eax,0x14(%esp)
  12066a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  12066d:	89 44 24 18          	mov    %eax,0x18(%esp)
  120671:	8b 45 bc             	mov    -0x44(%ebp),%eax
  120674:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  120678:	8b 45 b8             	mov    -0x48(%ebp),%eax
  12067b:	89 44 24 20          	mov    %eax,0x20(%esp)
  12067f:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  120686:	00 
  120687:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  12068a:	89 55 b0             	mov    %edx,-0x50(%ebp)
  12068d:	89 75 ac             	mov    %esi,-0x54(%ebp)
  120690:	89 7d a8             	mov    %edi,-0x58(%ebp)
  120693:	89 5d a4             	mov    %ebx,-0x5c(%ebp)
  120696:	e8 45 fe ff ff       	call   1204e0 <z_setup_new_thread>
	if (delay != K_FOREVER) {
  12069b:	83 7d 2c ff          	cmpl   $0xffffffff,0x2c(%ebp)
  12069f:	0f 84 12 00 00 00    	je     1206b7 <z_impl_k_thread_create+0xe7>
		schedule_new_thread(new_thread, delay);
  1206a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1206a8:	8b 4d 2c             	mov    0x2c(%ebp),%ecx
  1206ab:	89 04 24             	mov    %eax,(%esp)
  1206ae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1206b2:	e8 19 00 00 00       	call   1206d0 <schedule_new_thread>
	return new_thread;
  1206b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1206ba:	83 c4 78             	add    $0x78,%esp
  1206bd:	5e                   	pop    %esi
  1206be:	5f                   	pop    %edi
  1206bf:	5b                   	pop    %ebx
  1206c0:	5d                   	pop    %ebp
  1206c1:	c3                   	ret    
  1206c2:	66 90                	xchg   %ax,%ax
  1206c4:	66 90                	xchg   %ax,%ax
  1206c6:	66 90                	xchg   %ax,%ax
  1206c8:	66 90                	xchg   %ax,%ax
  1206ca:	66 90                	xchg   %ax,%ax
  1206cc:	66 90                	xchg   %ax,%ax
  1206ce:	66 90                	xchg   %ax,%ax

001206d0 <schedule_new_thread>:
{
  1206d0:	55                   	push   %ebp
  1206d1:	89 e5                	mov    %esp,%ebp
  1206d3:	83 ec 0c             	sub    $0xc,%esp
  1206d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1206d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (delay == 0) {
  1206dc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1206e0:	0f 85 10 00 00 00    	jne    1206f6 <schedule_new_thread+0x26>
		k_thread_start(thread);
  1206e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1206e9:	89 04 24             	mov    %eax,(%esp)
  1206ec:	e8 1f 04 00 00       	call   120b10 <k_thread_start>
	} else {
  1206f1:	e9 23 00 00 00       	jmp    120719 <schedule_new_thread+0x49>
		s32_t ticks = _TICK_ALIGN + k_ms_to_ticks_ceil32(delay);
  1206f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1206f9:	89 04 24             	mov    %eax,(%esp)
  1206fc:	e8 2f 04 00 00       	call   120b30 <k_ms_to_ticks_ceil32>
  120701:	83 c0 01             	add    $0x1,%eax
  120704:	89 45 fc             	mov    %eax,-0x4(%ebp)
		z_add_thread_timeout(thread, ticks);
  120707:	8b 45 08             	mov    0x8(%ebp),%eax
  12070a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  12070d:	89 04 24             	mov    %eax,(%esp)
  120710:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  120714:	e8 b7 07 00 00       	call   120ed0 <z_add_thread_timeout>
}
  120719:	83 c4 0c             	add    $0xc,%esp
  12071c:	5d                   	pop    %ebp
  12071d:	c3                   	ret    
  12071e:	66 90                	xchg   %ax,%ax

00120720 <z_thread_single_suspend>:
{
  120720:	55                   	push   %ebp
  120721:	89 e5                	mov    %esp,%ebp
  120723:	83 ec 08             	sub    $0x8,%esp
  120726:	8b 45 08             	mov    0x8(%ebp),%eax
	if (z_is_thread_ready(thread)) {
  120729:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12072c:	89 0c 24             	mov    %ecx,(%esp)
  12072f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120732:	e8 29 00 00 00       	call   120760 <z_is_thread_ready>
  120737:	a8 01                	test   $0x1,%al
  120739:	0f 85 05 00 00 00    	jne    120744 <z_thread_single_suspend+0x24>
  12073f:	e9 0b 00 00 00       	jmp    12074f <z_thread_single_suspend+0x2f>
		z_remove_thread_from_ready_q(thread);
  120744:	8b 45 08             	mov    0x8(%ebp),%eax
  120747:	89 04 24             	mov    %eax,(%esp)
  12074a:	e8 21 df ff ff       	call   11e670 <z_remove_thread_from_ready_q>
	z_mark_thread_as_suspended(thread);
  12074f:	8b 45 08             	mov    0x8(%ebp),%eax
  120752:	89 04 24             	mov    %eax,(%esp)
  120755:	e8 56 00 00 00       	call   1207b0 <z_mark_thread_as_suspended>
}
  12075a:	83 c4 08             	add    $0x8,%esp
  12075d:	5d                   	pop    %ebp
  12075e:	c3                   	ret    
  12075f:	90                   	nop

00120760 <z_is_thread_ready>:
{
  120760:	55                   	push   %ebp
  120761:	89 e5                	mov    %esp,%ebp
  120763:	83 ec 0c             	sub    $0xc,%esp
  120766:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  120769:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12076c:	89 0c 24             	mov    %ecx,(%esp)
  12076f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120772:	e8 99 07 00 00       	call   120f10 <z_is_thread_prevented_from_running>
  120777:	24 01                	and    $0x1,%al
  120779:	0f b6 c8             	movzbl %al,%ecx
  12077c:	83 f9 00             	cmp    $0x0,%ecx
  12077f:	b0 01                	mov    $0x1,%al
  120781:	88 45 fb             	mov    %al,-0x5(%ebp)
  120784:	0f 85 0e 00 00 00    	jne    120798 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  12078a:	8b 45 08             	mov    0x8(%ebp),%eax
  12078d:	89 04 24             	mov    %eax,(%esp)
  120790:	e8 ab 01 00 00       	call   120940 <z_is_thread_timeout_active>
  120795:	88 45 fb             	mov    %al,-0x5(%ebp)
  120798:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  12079b:	34 ff                	xor    $0xff,%al
  12079d:	24 01                	and    $0x1,%al
  12079f:	0f b6 c0             	movzbl %al,%eax
  1207a2:	83 c4 0c             	add    $0xc,%esp
  1207a5:	5d                   	pop    %ebp
  1207a6:	c3                   	ret    
  1207a7:	66 90                	xchg   %ax,%ax
  1207a9:	66 90                	xchg   %ax,%ax
  1207ab:	66 90                	xchg   %ax,%ax
  1207ad:	66 90                	xchg   %ax,%ax
  1207af:	90                   	nop

001207b0 <z_mark_thread_as_suspended>:
{
  1207b0:	55                   	push   %ebp
  1207b1:	89 e5                	mov    %esp,%ebp
  1207b3:	8b 45 08             	mov    0x8(%ebp),%eax
	thread->base.thread_state |= _THREAD_SUSPENDED;
  1207b6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1207b9:	0f b6 51 0d          	movzbl 0xd(%ecx),%edx
  1207bd:	83 ca 10             	or     $0x10,%edx
  1207c0:	88 51 0d             	mov    %dl,0xd(%ecx)
}
  1207c3:	5d                   	pop    %ebp
  1207c4:	c3                   	ret    
  1207c5:	66 90                	xchg   %ax,%ax
  1207c7:	66 90                	xchg   %ax,%ax
  1207c9:	66 90                	xchg   %ax,%ax
  1207cb:	66 90                	xchg   %ax,%ax
  1207cd:	66 90                	xchg   %ax,%ax
  1207cf:	90                   	nop

001207d0 <z_impl_k_thread_suspend>:
{
  1207d0:	55                   	push   %ebp
  1207d1:	89 e5                	mov    %esp,%ebp
  1207d3:	83 e4 f8             	and    $0xfffffff8,%esp
  1207d6:	83 ec 30             	sub    $0x30,%esp
  1207d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1207dc:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  1207e0:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  1207e4:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  1207ea:	89 4c 24 18          	mov    %ecx,0x18(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1207ee:	9c                   	pushf  
  1207ef:	fa                   	cli    
  1207f0:	8f 44 24 20          	popl   0x20(%esp)
	return key;
  1207f4:	8b 4c 24 20          	mov    0x20(%esp),%ecx
	k.key = arch_irq_lock();
  1207f8:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	z_thread_single_suspend(thread);
  1207fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1207ff:	89 0c 24             	mov    %ecx,(%esp)
  120802:	89 44 24 0c          	mov    %eax,0xc(%esp)
  120806:	e8 15 ff ff ff       	call   120720 <z_thread_single_suspend>
	if (thread == _current) {
  12080b:	8b 45 08             	mov    0x8(%ebp),%eax
  12080e:	3b 05 b0 96 13 00    	cmp    0x1396b0,%eax
  120814:	0f 85 1b 00 00 00    	jne    120835 <z_impl_k_thread_suspend+0x65>
		z_reschedule(&lock, key);
  12081a:	8b 44 24 10          	mov    0x10(%esp),%eax
  12081e:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  120824:	89 0c 24             	mov    %ecx,(%esp)
  120827:	89 44 24 04          	mov    %eax,0x4(%esp)
  12082b:	e8 30 e8 ff ff       	call   11f060 <z_reschedule>
	} else {
  120830:	e9 32 00 00 00       	jmp    120867 <z_impl_k_thread_suspend+0x97>
		k_spin_unlock(&lock, key);
  120835:	8b 44 24 10          	mov    0x10(%esp),%eax
  120839:	89 44 24 28          	mov    %eax,0x28(%esp)
  12083d:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  120843:	89 44 24 24          	mov    %eax,0x24(%esp)
	arch_irq_unlock(key.key);
  120847:	8b 44 24 28          	mov    0x28(%esp),%eax
  12084b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12084f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  120853:	25 00 02 00 00       	and    $0x200,%eax
  120858:	83 f8 00             	cmp    $0x0,%eax
  12085b:	0f 84 01 00 00 00    	je     120862 <z_impl_k_thread_suspend+0x92>
		__asm__ volatile ("sti" ::: "memory");
  120861:	fb                   	sti    
  120862:	e9 00 00 00 00       	jmp    120867 <z_impl_k_thread_suspend+0x97>
}
  120867:	89 ec                	mov    %ebp,%esp
  120869:	5d                   	pop    %ebp
  12086a:	c3                   	ret    
  12086b:	66 90                	xchg   %ax,%ax
  12086d:	66 90                	xchg   %ax,%ax
  12086f:	90                   	nop

00120870 <z_thread_single_abort>:
{
  120870:	55                   	push   %ebp
  120871:	89 e5                	mov    %esp,%ebp
  120873:	50                   	push   %eax
  120874:	8b 45 08             	mov    0x8(%ebp),%eax
	if (thread->fn_abort != NULL) {
  120877:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12087a:	83 79 30 00          	cmpl   $0x0,0x30(%ecx)
  12087e:	0f 84 06 00 00 00    	je     12088a <z_thread_single_abort+0x1a>
		thread->fn_abort();
  120884:	8b 45 08             	mov    0x8(%ebp),%eax
  120887:	ff 50 30             	call   *0x30(%eax)
	if (z_is_thread_ready(thread)) {
  12088a:	8b 45 08             	mov    0x8(%ebp),%eax
  12088d:	89 04 24             	mov    %eax,(%esp)
  120890:	e8 cb fe ff ff       	call   120760 <z_is_thread_ready>
  120895:	a8 01                	test   $0x1,%al
  120897:	0f 85 05 00 00 00    	jne    1208a2 <z_thread_single_abort+0x32>
  12089d:	e9 10 00 00 00       	jmp    1208b2 <z_thread_single_abort+0x42>
		z_remove_thread_from_ready_q(thread);
  1208a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1208a5:	89 04 24             	mov    %eax,(%esp)
  1208a8:	e8 c3 dd ff ff       	call   11e670 <z_remove_thread_from_ready_q>
	} else {
  1208ad:	e9 4b 00 00 00       	jmp    1208fd <z_thread_single_abort+0x8d>
		if (z_is_thread_pending(thread)) {
  1208b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1208b5:	89 04 24             	mov    %eax,(%esp)
  1208b8:	e8 53 00 00 00       	call   120910 <z_is_thread_pending>
  1208bd:	a8 01                	test   $0x1,%al
  1208bf:	0f 85 05 00 00 00    	jne    1208ca <z_thread_single_abort+0x5a>
  1208c5:	e9 0b 00 00 00       	jmp    1208d5 <z_thread_single_abort+0x65>
			z_unpend_thread_no_timeout(thread);
  1208ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1208cd:	89 04 24             	mov    %eax,(%esp)
  1208d0:	e8 7b e0 ff ff       	call   11e950 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
  1208d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1208d8:	89 04 24             	mov    %eax,(%esp)
  1208db:	e8 60 00 00 00       	call   120940 <z_is_thread_timeout_active>
  1208e0:	a8 01                	test   $0x1,%al
  1208e2:	0f 85 05 00 00 00    	jne    1208ed <z_thread_single_abort+0x7d>
  1208e8:	e9 0b 00 00 00       	jmp    1208f8 <z_thread_single_abort+0x88>
			(void)z_abort_thread_timeout(thread);
  1208ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1208f0:	89 04 24             	mov    %eax,(%esp)
  1208f3:	e8 78 00 00 00       	call   120970 <z_abort_thread_timeout>
  1208f8:	e9 00 00 00 00       	jmp    1208fd <z_thread_single_abort+0x8d>
	thread->base.thread_state |= _THREAD_DEAD;
  1208fd:	8b 45 08             	mov    0x8(%ebp),%eax
  120900:	0f b6 48 0d          	movzbl 0xd(%eax),%ecx
  120904:	83 c9 08             	or     $0x8,%ecx
  120907:	88 48 0d             	mov    %cl,0xd(%eax)
}
  12090a:	83 c4 04             	add    $0x4,%esp
  12090d:	5d                   	pop    %ebp
  12090e:	c3                   	ret    
  12090f:	90                   	nop

00120910 <z_is_thread_pending>:
{
  120910:	55                   	push   %ebp
  120911:	89 e5                	mov    %esp,%ebp
  120913:	50                   	push   %eax
  120914:	8b 45 08             	mov    0x8(%ebp),%eax
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  120917:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12091a:	0f b6 49 0d          	movzbl 0xd(%ecx),%ecx
  12091e:	83 e1 02             	and    $0x2,%ecx
  120921:	83 f9 00             	cmp    $0x0,%ecx
  120924:	0f 95 c2             	setne  %dl
  120927:	80 e2 01             	and    $0x1,%dl
  12092a:	0f b6 ca             	movzbl %dl,%ecx
  12092d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120930:	89 c8                	mov    %ecx,%eax
  120932:	83 c4 04             	add    $0x4,%esp
  120935:	5d                   	pop    %ebp
  120936:	c3                   	ret    
  120937:	66 90                	xchg   %ax,%ax
  120939:	66 90                	xchg   %ax,%ax
  12093b:	66 90                	xchg   %ax,%ax
  12093d:	66 90                	xchg   %ax,%ax
  12093f:	90                   	nop

00120940 <z_is_thread_timeout_active>:
{
  120940:	55                   	push   %ebp
  120941:	89 e5                	mov    %esp,%ebp
  120943:	83 ec 08             	sub    $0x8,%esp
  120946:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  120949:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12094c:	83 c1 18             	add    $0x18,%ecx
  12094f:	89 0c 24             	mov    %ecx,(%esp)
  120952:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120955:	e8 e6 05 00 00       	call   120f40 <z_is_inactive_timeout>
  12095a:	34 ff                	xor    $0xff,%al
  12095c:	24 01                	and    $0x1,%al
  12095e:	0f b6 c0             	movzbl %al,%eax
  120961:	83 c4 08             	add    $0x8,%esp
  120964:	5d                   	pop    %ebp
  120965:	c3                   	ret    
  120966:	66 90                	xchg   %ax,%ax
  120968:	66 90                	xchg   %ax,%ax
  12096a:	66 90                	xchg   %ax,%ax
  12096c:	66 90                	xchg   %ax,%ax
  12096e:	66 90                	xchg   %ax,%ax

00120970 <z_abort_thread_timeout>:
{
  120970:	55                   	push   %ebp
  120971:	89 e5                	mov    %esp,%ebp
  120973:	83 ec 08             	sub    $0x8,%esp
  120976:	8b 45 08             	mov    0x8(%ebp),%eax
	return z_abort_timeout(&thread->base.timeout);
  120979:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12097c:	83 c1 18             	add    $0x18,%ecx
  12097f:	89 0c 24             	mov    %ecx,(%esp)
  120982:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120985:	e8 c6 0a 00 00       	call   121450 <z_abort_timeout>
  12098a:	83 c4 08             	add    $0x8,%esp
  12098d:	5d                   	pop    %ebp
  12098e:	c3                   	ret    
  12098f:	90                   	nop

00120990 <z_init_static_threads>:
{
  120990:	55                   	push   %ebp
  120991:	89 e5                	mov    %esp,%ebp
  120993:	53                   	push   %ebx
  120994:	57                   	push   %edi
  120995:	56                   	push   %esi
  120996:	83 ec 4c             	sub    $0x4c,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
  120999:	8d 05 38 34 14 00    	lea    0x143438,%eax
  12099f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1209a2:	8d 05 38 34 14 00    	lea    0x143438,%eax
  1209a8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  1209ab:	0f 92 c1             	setb   %cl
  1209ae:	80 e1 01             	and    $0x1,%cl
  1209b1:	0f b6 c1             	movzbl %cl,%eax
  1209b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1209b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1209bb:	0f 84 9e 00 00 00    	je     120a5f <z_init_static_threads+0xcf>
			thread_data->init_thread,
  1209c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1209c4:	8b 00                	mov    (%eax),%eax
			thread_data->init_stack,
  1209c6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1209c9:	8b 49 04             	mov    0x4(%ecx),%ecx
			thread_data->init_stack_size,
  1209cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1209cf:	8b 52 08             	mov    0x8(%edx),%edx
			thread_data->init_entry,
  1209d2:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1209d5:	8b 76 0c             	mov    0xc(%esi),%esi
			thread_data->init_p1,
  1209d8:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1209db:	8b 7f 10             	mov    0x10(%edi),%edi
			thread_data->init_p2,
  1209de:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  1209e1:	8b 5b 14             	mov    0x14(%ebx),%ebx
  1209e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
			thread_data->init_p3,
  1209e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1209ea:	8b 40 18             	mov    0x18(%eax),%eax
  1209ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
			thread_data->init_prio,
  1209f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1209f3:	8b 40 1c             	mov    0x1c(%eax),%eax
  1209f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
			thread_data->init_options,
  1209f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1209fc:	8b 40 20             	mov    0x20(%eax),%eax
  1209ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			thread_data->init_name);
  120a02:	8b 45 f0             	mov    -0x10(%ebp),%eax
  120a05:	8b 40 2c             	mov    0x2c(%eax),%eax
  120a08:	89 45 d0             	mov    %eax,-0x30(%ebp)
  120a0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		z_setup_new_thread(
  120a0e:	89 04 24             	mov    %eax,(%esp)
  120a11:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  120a15:	89 54 24 08          	mov    %edx,0x8(%esp)
  120a19:	89 74 24 0c          	mov    %esi,0xc(%esp)
  120a1d:	89 7c 24 10          	mov    %edi,0x10(%esp)
  120a21:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  120a25:	8b 45 dc             	mov    -0x24(%ebp),%eax
  120a28:	89 44 24 18          	mov    %eax,0x18(%esp)
  120a2c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  120a2f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  120a33:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  120a36:	89 44 24 20          	mov    %eax,0x20(%esp)
  120a3a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  120a3d:	89 44 24 24          	mov    %eax,0x24(%esp)
  120a41:	e8 9a fa ff ff       	call   1204e0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  120a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
  120a49:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  120a4c:	8b 09                	mov    (%ecx),%ecx
  120a4e:	89 41 2c             	mov    %eax,0x2c(%ecx)
	_FOREACH_STATIC_THREAD(thread_data) {
  120a51:	8b 45 f0             	mov    -0x10(%ebp),%eax
  120a54:	83 c0 30             	add    $0x30,%eax
  120a57:	89 45 f0             	mov    %eax,-0x10(%ebp)
  120a5a:	e9 43 ff ff ff       	jmp    1209a2 <z_init_static_threads+0x12>
	k_sched_lock();
  120a5f:	e8 2c e7 ff ff       	call   11f190 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
  120a64:	8d 05 38 34 14 00    	lea    0x143438,%eax
  120a6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  120a6d:	8d 05 38 34 14 00    	lea    0x143438,%eax
  120a73:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  120a76:	0f 92 c1             	setb   %cl
  120a79:	80 e1 01             	and    $0x1,%cl
  120a7c:	0f b6 c1             	movzbl %cl,%eax
  120a7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  120a82:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  120a86:	0f 84 37 00 00 00    	je     120ac3 <z_init_static_threads+0x133>
		if (thread_data->init_delay != K_FOREVER) {
  120a8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  120a8f:	83 78 24 ff          	cmpl   $0xffffffff,0x24(%eax)
  120a93:	0f 84 17 00 00 00    	je     120ab0 <z_init_static_threads+0x120>
			schedule_new_thread(thread_data->init_thread,
  120a99:	8b 45 e8             	mov    -0x18(%ebp),%eax
  120a9c:	8b 00                	mov    (%eax),%eax
					    thread_data->init_delay);
  120a9e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  120aa1:	8b 49 24             	mov    0x24(%ecx),%ecx
			schedule_new_thread(thread_data->init_thread,
  120aa4:	89 04 24             	mov    %eax,(%esp)
  120aa7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  120aab:	e8 20 fc ff ff       	call   1206d0 <schedule_new_thread>
	}
  120ab0:	e9 00 00 00 00       	jmp    120ab5 <z_init_static_threads+0x125>
	_FOREACH_STATIC_THREAD(thread_data) {
  120ab5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  120ab8:	83 c0 30             	add    $0x30,%eax
  120abb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  120abe:	e9 aa ff ff ff       	jmp    120a6d <z_init_static_threads+0xdd>
	k_sched_unlock();
  120ac3:	e8 98 e7 ff ff       	call   11f260 <k_sched_unlock>
}
  120ac8:	83 c4 4c             	add    $0x4c,%esp
  120acb:	5e                   	pop    %esi
  120acc:	5f                   	pop    %edi
  120acd:	5b                   	pop    %ebx
  120ace:	5d                   	pop    %ebp
  120acf:	c3                   	ret    

00120ad0 <z_init_thread_timeout>:
{
  120ad0:	55                   	push   %ebp
  120ad1:	89 e5                	mov    %esp,%ebp
  120ad3:	83 ec 08             	sub    $0x8,%esp
  120ad6:	8b 45 08             	mov    0x8(%ebp),%eax
	z_init_timeout(&thread_base->timeout);
  120ad9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120adc:	83 c1 18             	add    $0x18,%ecx
  120adf:	89 0c 24             	mov    %ecx,(%esp)
  120ae2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120ae5:	e8 a6 04 00 00       	call   120f90 <z_init_timeout>
}
  120aea:	83 c4 08             	add    $0x8,%esp
  120aed:	5d                   	pop    %ebp
  120aee:	c3                   	ret    
  120aef:	90                   	nop

00120af0 <z_clock_hw_cycles_per_sec_runtime_get>:
{
  120af0:	55                   	push   %ebp
  120af1:	89 e5                	mov    %esp,%ebp
	compiler_barrier();
  120af3:	e9 00 00 00 00       	jmp    120af8 <z_clock_hw_cycles_per_sec_runtime_get+0x8>
	return z_impl_z_clock_hw_cycles_per_sec_runtime_get();
  120af8:	e8 03 f7 ff ff       	call   120200 <z_impl_z_clock_hw_cycles_per_sec_runtime_get>
  120afd:	5d                   	pop    %ebp
  120afe:	c3                   	ret    
  120aff:	90                   	nop

00120b00 <arch_k_cycle_get_32>:
{
  120b00:	55                   	push   %ebp
  120b01:	89 e5                	mov    %esp,%ebp
	return z_timer_cycle_get_32();
  120b03:	e8 b8 71 fe ff       	call   107cc0 <z_timer_cycle_get_32>
  120b08:	5d                   	pop    %ebp
  120b09:	c3                   	ret    
  120b0a:	66 90                	xchg   %ax,%ax
  120b0c:	66 90                	xchg   %ax,%ax
  120b0e:	66 90                	xchg   %ax,%ax

00120b10 <k_thread_start>:
{
  120b10:	55                   	push   %ebp
  120b11:	89 e5                	mov    %esp,%ebp
  120b13:	50                   	push   %eax
  120b14:	8b 45 08             	mov    0x8(%ebp),%eax
	z_impl_k_thread_start(thread);
  120b17:	8b 45 08             	mov    0x8(%ebp),%eax
  120b1a:	89 04 24             	mov    %eax,(%esp)
  120b1d:	e8 ce f7 ff ff       	call   1202f0 <z_impl_k_thread_start>
}
  120b22:	83 c4 04             	add    $0x4,%esp
  120b25:	5d                   	pop    %ebp
  120b26:	c3                   	ret    
  120b27:	66 90                	xchg   %ax,%ax
  120b29:	66 90                	xchg   %ax,%ax
  120b2b:	66 90                	xchg   %ax,%ax
  120b2d:	66 90                	xchg   %ax,%ax
  120b2f:	90                   	nop

00120b30 <k_ms_to_ticks_ceil32>:
{
  120b30:	55                   	push   %ebp
  120b31:	89 e5                	mov    %esp,%ebp
  120b33:	57                   	push   %edi
  120b34:	56                   	push   %esi
  120b35:	83 e4 f8             	and    $0xfffffff8,%esp
  120b38:	83 ec 70             	sub    $0x70,%esp
  120b3b:	8b 45 08             	mov    0x8(%ebp),%eax
  120b3e:	31 c9                	xor    %ecx,%ecx
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  120b40:	8b 55 08             	mov    0x8(%ebp),%edx
  120b43:	89 54 24 60          	mov    %edx,0x60(%esp)
  120b47:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  120b4e:	00 
  120b4f:	c7 44 24 5c e8 03 00 	movl   $0x3e8,0x5c(%esp)
  120b56:	00 
  120b57:	c7 44 24 58 64 00 00 	movl   $0x64,0x58(%esp)
  120b5e:	00 
  120b5f:	c6 44 24 57 01       	movb   $0x1,0x57(%esp)
  120b64:	c6 44 24 56 01       	movb   $0x1,0x56(%esp)
  120b69:	c6 44 24 55 01       	movb   $0x1,0x55(%esp)
  120b6e:	c6 44 24 54 00       	movb   $0x0,0x54(%esp)
	bool mul_ratio = const_hz &&
  120b73:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  120b78:	88 4c 24 43          	mov    %cl,0x43(%esp)
  120b7c:	0f 84 28 00 00 00    	je     120baa <k_ms_to_ticks_ceil32+0x7a>
  120b82:	31 c0                	xor    %eax,%eax
		(to_hz > from_hz) && ((to_hz % from_hz) == 0);
  120b84:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  120b88:	3b 4c 24 5c          	cmp    0x5c(%esp),%ecx
  120b8c:	88 44 24 43          	mov    %al,0x43(%esp)
  120b90:	0f 86 14 00 00 00    	jbe    120baa <k_ms_to_ticks_ceil32+0x7a>
  120b96:	8b 44 24 58          	mov    0x58(%esp),%eax
  120b9a:	31 d2                	xor    %edx,%edx
  120b9c:	f7 74 24 5c          	divl   0x5c(%esp)
  120ba0:	83 fa 00             	cmp    $0x0,%edx
  120ba3:	0f 94 c1             	sete   %cl
  120ba6:	88 4c 24 43          	mov    %cl,0x43(%esp)
  120baa:	8a 44 24 43          	mov    0x43(%esp),%al
  120bae:	31 c9                	xor    %ecx,%ecx
	bool mul_ratio = const_hz &&
  120bb0:	24 01                	and    $0x1,%al
  120bb2:	88 44 24 53          	mov    %al,0x53(%esp)
	bool div_ratio = const_hz &&
  120bb6:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  120bbb:	88 4c 24 42          	mov    %cl,0x42(%esp)
  120bbf:	0f 84 28 00 00 00    	je     120bed <k_ms_to_ticks_ceil32+0xbd>
  120bc5:	31 c0                	xor    %eax,%eax
		(from_hz > to_hz) && ((from_hz % to_hz) == 0);
  120bc7:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  120bcb:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  120bcf:	88 44 24 42          	mov    %al,0x42(%esp)
  120bd3:	0f 86 14 00 00 00    	jbe    120bed <k_ms_to_ticks_ceil32+0xbd>
  120bd9:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  120bdd:	31 d2                	xor    %edx,%edx
  120bdf:	f7 74 24 58          	divl   0x58(%esp)
  120be3:	83 fa 00             	cmp    $0x0,%edx
  120be6:	0f 94 c1             	sete   %cl
  120be9:	88 4c 24 42          	mov    %cl,0x42(%esp)
  120bed:	8a 44 24 42          	mov    0x42(%esp),%al
	bool div_ratio = const_hz &&
  120bf1:	24 01                	and    $0x1,%al
  120bf3:	88 44 24 52          	mov    %al,0x52(%esp)
	if (from_hz == to_hz) {
  120bf7:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  120bfb:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  120bff:	0f 85 48 00 00 00    	jne    120c4d <k_ms_to_ticks_ceil32+0x11d>
		return result32 ? ((u32_t)t) : t;
  120c05:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  120c0a:	0f 84 13 00 00 00    	je     120c23 <k_ms_to_ticks_ceil32+0xf3>
  120c10:	8b 44 24 60          	mov    0x60(%esp),%eax
  120c14:	31 c9                	xor    %ecx,%ecx
  120c16:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  120c1a:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  120c1e:	e9 15 00 00 00       	jmp    120c38 <k_ms_to_ticks_ceil32+0x108>
  120c23:	8b 44 24 60          	mov    0x60(%esp),%eax
  120c27:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  120c2b:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  120c2f:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  120c33:	e9 00 00 00 00       	jmp    120c38 <k_ms_to_ticks_ceil32+0x108>
  120c38:	8b 44 24 38          	mov    0x38(%esp),%eax
  120c3c:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  120c40:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  120c44:	89 44 24 6c          	mov    %eax,0x6c(%esp)
  120c48:	e9 6b 02 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
	u64_t off = 0;
  120c4d:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  120c54:	00 
  120c55:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
  120c5c:	00 
	if (!mul_ratio) {
  120c5d:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  120c62:	0f 85 76 00 00 00    	jne    120cde <k_ms_to_ticks_ceil32+0x1ae>
		u32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
  120c68:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  120c6d:	0f 84 13 00 00 00    	je     120c86 <k_ms_to_ticks_ceil32+0x156>
  120c73:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  120c77:	31 d2                	xor    %edx,%edx
  120c79:	f7 74 24 58          	divl   0x58(%esp)
  120c7d:	89 44 24 34          	mov    %eax,0x34(%esp)
  120c81:	e9 08 00 00 00       	jmp    120c8e <k_ms_to_ticks_ceil32+0x15e>
  120c86:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  120c8a:	89 44 24 34          	mov    %eax,0x34(%esp)
  120c8e:	8b 44 24 34          	mov    0x34(%esp),%eax
  120c92:	89 44 24 44          	mov    %eax,0x44(%esp)
		if (round_up) {
  120c96:	f6 44 24 55 01       	testb  $0x1,0x55(%esp)
  120c9b:	0f 84 16 00 00 00    	je     120cb7 <k_ms_to_ticks_ceil32+0x187>
			off = rdivisor - 1;
  120ca1:	8b 44 24 44          	mov    0x44(%esp),%eax
  120ca5:	48                   	dec    %eax
  120ca6:	89 44 24 48          	mov    %eax,0x48(%esp)
  120caa:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  120cb1:	00 
		} else if (round_off) {
  120cb2:	e9 22 00 00 00       	jmp    120cd9 <k_ms_to_ticks_ceil32+0x1a9>
  120cb7:	f6 44 24 54 01       	testb  $0x1,0x54(%esp)
  120cbc:	0f 84 12 00 00 00    	je     120cd4 <k_ms_to_ticks_ceil32+0x1a4>
			off = rdivisor / 2;
  120cc2:	8b 44 24 44          	mov    0x44(%esp),%eax
  120cc6:	d1 e8                	shr    %eax
  120cc8:	89 44 24 48          	mov    %eax,0x48(%esp)
  120ccc:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  120cd3:	00 
  120cd4:	e9 00 00 00 00       	jmp    120cd9 <k_ms_to_ticks_ceil32+0x1a9>
	}
  120cd9:	e9 00 00 00 00       	jmp    120cde <k_ms_to_ticks_ceil32+0x1ae>
	if (div_ratio) {
  120cde:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  120ce3:	0f 84 ad 00 00 00    	je     120d96 <k_ms_to_ticks_ceil32+0x266>
		t += off;
  120ce9:	8b 44 24 48          	mov    0x48(%esp),%eax
  120ced:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  120cf1:	8b 54 24 60          	mov    0x60(%esp),%edx
  120cf5:	8b 74 24 64          	mov    0x64(%esp),%esi
  120cf9:	01 c2                	add    %eax,%edx
  120cfb:	11 ce                	adc    %ecx,%esi
  120cfd:	89 54 24 60          	mov    %edx,0x60(%esp)
  120d01:	89 74 24 64          	mov    %esi,0x64(%esp)
		if (result32) {
  120d05:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  120d0a:	0f 84 43 00 00 00    	je     120d53 <k_ms_to_ticks_ceil32+0x223>
			return ((u32_t)t) / (from_hz / to_hz);
  120d10:	8b 44 24 60          	mov    0x60(%esp),%eax
  120d14:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  120d18:	8b 54 24 58          	mov    0x58(%esp),%edx
  120d1c:	31 f6                	xor    %esi,%esi
  120d1e:	89 44 24 30          	mov    %eax,0x30(%esp)
  120d22:	89 c8                	mov    %ecx,%eax
  120d24:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  120d28:	89 f2                	mov    %esi,%edx
  120d2a:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  120d2e:	f7 f1                	div    %ecx
  120d30:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  120d34:	89 44 24 28          	mov    %eax,0x28(%esp)
  120d38:	89 c8                	mov    %ecx,%eax
  120d3a:	89 f2                	mov    %esi,%edx
  120d3c:	8b 74 24 28          	mov    0x28(%esp),%esi
  120d40:	f7 f6                	div    %esi
  120d42:	89 44 24 68          	mov    %eax,0x68(%esp)
  120d46:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  120d4d:	00 
  120d4e:	e9 65 01 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
			return t / (from_hz / to_hz);
  120d53:	8b 44 24 60          	mov    0x60(%esp),%eax
  120d57:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  120d5b:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  120d5f:	8b 74 24 58          	mov    0x58(%esp),%esi
  120d63:	31 ff                	xor    %edi,%edi
  120d65:	89 44 24 24          	mov    %eax,0x24(%esp)
  120d69:	89 d0                	mov    %edx,%eax
  120d6b:	89 fa                	mov    %edi,%edx
  120d6d:	f7 f6                	div    %esi
  120d6f:	89 e2                	mov    %esp,%edx
  120d71:	89 42 08             	mov    %eax,0x8(%edx)
  120d74:	89 4a 04             	mov    %ecx,0x4(%edx)
  120d77:	8b 44 24 24          	mov    0x24(%esp),%eax
  120d7b:	89 02                	mov    %eax,(%edx)
  120d7d:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  120d84:	e8 47 f3 fd ff       	call   1000d0 <__udivdi3>
  120d89:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  120d8d:	89 44 24 68          	mov    %eax,0x68(%esp)
  120d91:	e9 22 01 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
	} else if (mul_ratio) {
  120d96:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  120d9b:	0f 84 81 00 00 00    	je     120e22 <k_ms_to_ticks_ceil32+0x2f2>
		if (result32) {
  120da1:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  120da6:	0f 84 38 00 00 00    	je     120de4 <k_ms_to_ticks_ceil32+0x2b4>
			return ((u32_t)t) * (to_hz / from_hz);
  120dac:	8b 44 24 60          	mov    0x60(%esp),%eax
  120db0:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  120db4:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  120db8:	31 f6                	xor    %esi,%esi
  120dba:	89 44 24 20          	mov    %eax,0x20(%esp)
  120dbe:	89 c8                	mov    %ecx,%eax
  120dc0:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  120dc4:	89 f2                	mov    %esi,%edx
  120dc6:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  120dca:	f7 f1                	div    %ecx
  120dcc:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  120dd0:	0f af c8             	imul   %eax,%ecx
  120dd3:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  120dd7:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  120dde:	00 
  120ddf:	e9 d4 00 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
			return t * (to_hz / from_hz);
  120de4:	8b 44 24 60          	mov    0x60(%esp),%eax
  120de8:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  120dec:	8b 54 24 58          	mov    0x58(%esp),%edx
  120df0:	8b 74 24 5c          	mov    0x5c(%esp),%esi
  120df4:	31 ff                	xor    %edi,%edi
  120df6:	89 44 24 18          	mov    %eax,0x18(%esp)
  120dfa:	89 d0                	mov    %edx,%eax
  120dfc:	89 fa                	mov    %edi,%edx
  120dfe:	f7 f6                	div    %esi
  120e00:	0f af c8             	imul   %eax,%ecx
  120e03:	8b 54 24 18          	mov    0x18(%esp),%edx
  120e07:	89 44 24 14          	mov    %eax,0x14(%esp)
  120e0b:	89 d0                	mov    %edx,%eax
  120e0d:	8b 74 24 14          	mov    0x14(%esp),%esi
  120e11:	f7 e6                	mul    %esi
  120e13:	01 ca                	add    %ecx,%edx
  120e15:	89 44 24 68          	mov    %eax,0x68(%esp)
  120e19:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  120e1d:	e9 96 00 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
		if (result32) {
  120e22:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  120e27:	0f 84 4a 00 00 00    	je     120e77 <k_ms_to_ticks_ceil32+0x347>
			return (u32_t)((t * to_hz + off) / from_hz);
  120e2d:	8b 44 24 60          	mov    0x60(%esp),%eax
  120e31:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  120e35:	8b 54 24 58          	mov    0x58(%esp),%edx
  120e39:	0f af ca             	imul   %edx,%ecx
  120e3c:	f7 e2                	mul    %edx
  120e3e:	01 ca                	add    %ecx,%edx
  120e40:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  120e44:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  120e48:	01 c8                	add    %ecx,%eax
  120e4a:	11 f2                	adc    %esi,%edx
  120e4c:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  120e50:	89 e6                	mov    %esp,%esi
  120e52:	89 4e 08             	mov    %ecx,0x8(%esi)
  120e55:	89 06                	mov    %eax,(%esi)
  120e57:	89 56 04             	mov    %edx,0x4(%esi)
  120e5a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  120e61:	e8 6a f2 fd ff       	call   1000d0 <__udivdi3>
  120e66:	89 44 24 68          	mov    %eax,0x68(%esp)
  120e6a:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  120e71:	00 
  120e72:	e9 41 00 00 00       	jmp    120eb8 <k_ms_to_ticks_ceil32+0x388>
			return (t * to_hz + off) / from_hz;
  120e77:	8b 44 24 60          	mov    0x60(%esp),%eax
  120e7b:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  120e7f:	8b 54 24 58          	mov    0x58(%esp),%edx
  120e83:	0f af ca             	imul   %edx,%ecx
  120e86:	f7 e2                	mul    %edx
  120e88:	01 ca                	add    %ecx,%edx
  120e8a:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  120e8e:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  120e92:	01 c8                	add    %ecx,%eax
  120e94:	11 f2                	adc    %esi,%edx
  120e96:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  120e9a:	89 e6                	mov    %esp,%esi
  120e9c:	89 4e 08             	mov    %ecx,0x8(%esi)
  120e9f:	89 06                	mov    %eax,(%esi)
  120ea1:	89 56 04             	mov    %edx,0x4(%esi)
  120ea4:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  120eab:	e8 20 f2 fd ff       	call   1000d0 <__udivdi3>
  120eb0:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  120eb4:	89 44 24 68          	mov    %eax,0x68(%esp)
}
  120eb8:	8b 44 24 68          	mov    0x68(%esp),%eax
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  120ebc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  120ebf:	5e                   	pop    %esi
  120ec0:	5f                   	pop    %edi
  120ec1:	5d                   	pop    %ebp
  120ec2:	c3                   	ret    
  120ec3:	66 90                	xchg   %ax,%ax
  120ec5:	66 90                	xchg   %ax,%ax
  120ec7:	66 90                	xchg   %ax,%ax
  120ec9:	66 90                	xchg   %ax,%ax
  120ecb:	66 90                	xchg   %ax,%ax
  120ecd:	66 90                	xchg   %ax,%ax
  120ecf:	90                   	nop

00120ed0 <z_add_thread_timeout>:
{
  120ed0:	55                   	push   %ebp
  120ed1:	89 e5                	mov    %esp,%ebp
  120ed3:	56                   	push   %esi
  120ed4:	83 ec 14             	sub    $0x14,%esp
  120ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
  120eda:	8b 4d 08             	mov    0x8(%ebp),%ecx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  120edd:	8b 55 08             	mov    0x8(%ebp),%edx
  120ee0:	83 c2 18             	add    $0x18,%edx
  120ee3:	8b 75 0c             	mov    0xc(%ebp),%esi
  120ee6:	89 14 24             	mov    %edx,(%esp)
  120ee9:	8d 15 70 ea 11 00    	lea    0x11ea70,%edx
  120eef:	89 54 24 04          	mov    %edx,0x4(%esp)
  120ef3:	89 74 24 08          	mov    %esi,0x8(%esp)
  120ef7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  120efa:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  120efd:	e8 be 01 00 00       	call   1210c0 <z_add_timeout>
}
  120f02:	83 c4 14             	add    $0x14,%esp
  120f05:	5e                   	pop    %esi
  120f06:	5d                   	pop    %ebp
  120f07:	c3                   	ret    
  120f08:	66 90                	xchg   %ax,%ax
  120f0a:	66 90                	xchg   %ax,%ax
  120f0c:	66 90                	xchg   %ax,%ax
  120f0e:	66 90                	xchg   %ax,%ax

00120f10 <z_is_thread_prevented_from_running>:
{
  120f10:	55                   	push   %ebp
  120f11:	89 e5                	mov    %esp,%ebp
  120f13:	83 ec 08             	sub    $0x8,%esp
  120f16:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  120f19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120f1c:	8a 51 0d             	mov    0xd(%ecx),%dl
  120f1f:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  120f22:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  120f26:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  120f29:	83 f9 00             	cmp    $0x0,%ecx
  120f2c:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  120f2f:	80 e2 01             	and    $0x1,%dl
  120f32:	0f b6 ca             	movzbl %dl,%ecx
  120f35:	89 45 f8             	mov    %eax,-0x8(%ebp)
  120f38:	89 c8                	mov    %ecx,%eax
  120f3a:	83 c4 08             	add    $0x8,%esp
  120f3d:	5d                   	pop    %ebp
  120f3e:	c3                   	ret    
  120f3f:	90                   	nop

00120f40 <z_is_inactive_timeout>:
{
  120f40:	55                   	push   %ebp
  120f41:	89 e5                	mov    %esp,%ebp
  120f43:	83 ec 08             	sub    $0x8,%esp
  120f46:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  120f49:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120f4c:	89 0c 24             	mov    %ecx,(%esp)
  120f4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120f52:	e8 19 00 00 00       	call   120f70 <sys_dnode_is_linked>
  120f57:	34 ff                	xor    $0xff,%al
  120f59:	24 01                	and    $0x1,%al
  120f5b:	0f b6 c0             	movzbl %al,%eax
  120f5e:	83 c4 08             	add    $0x8,%esp
  120f61:	5d                   	pop    %ebp
  120f62:	c3                   	ret    
  120f63:	66 90                	xchg   %ax,%ax
  120f65:	66 90                	xchg   %ax,%ax
  120f67:	66 90                	xchg   %ax,%ax
  120f69:	66 90                	xchg   %ax,%ax
  120f6b:	66 90                	xchg   %ax,%ax
  120f6d:	66 90                	xchg   %ax,%ax
  120f6f:	90                   	nop

00120f70 <sys_dnode_is_linked>:
{
  120f70:	55                   	push   %ebp
  120f71:	89 e5                	mov    %esp,%ebp
  120f73:	50                   	push   %eax
  120f74:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  120f77:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120f7a:	83 39 00             	cmpl   $0x0,(%ecx)
  120f7d:	0f 95 c2             	setne  %dl
  120f80:	80 e2 01             	and    $0x1,%dl
  120f83:	0f b6 ca             	movzbl %dl,%ecx
  120f86:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120f89:	89 c8                	mov    %ecx,%eax
  120f8b:	83 c4 04             	add    $0x4,%esp
  120f8e:	5d                   	pop    %ebp
  120f8f:	c3                   	ret    

00120f90 <z_init_timeout>:
{
  120f90:	55                   	push   %ebp
  120f91:	89 e5                	mov    %esp,%ebp
  120f93:	83 ec 08             	sub    $0x8,%esp
  120f96:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dnode_init(&t->node);
  120f99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120f9c:	89 0c 24             	mov    %ecx,(%esp)
  120f9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  120fa2:	e8 09 00 00 00       	call   120fb0 <sys_dnode_init>
}
  120fa7:	83 c4 08             	add    $0x8,%esp
  120faa:	5d                   	pop    %ebp
  120fab:	c3                   	ret    
  120fac:	66 90                	xchg   %ax,%ax
  120fae:	66 90                	xchg   %ax,%ax

00120fb0 <sys_dnode_init>:
{
  120fb0:	55                   	push   %ebp
  120fb1:	89 e5                	mov    %esp,%ebp
  120fb3:	8b 45 08             	mov    0x8(%ebp),%eax
	node->next = NULL;
  120fb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120fb9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	node->prev = NULL;
  120fbf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120fc2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
}
  120fc9:	5d                   	pop    %ebp
  120fca:	c3                   	ret    
  120fcb:	66 90                	xchg   %ax,%ax
  120fcd:	66 90                	xchg   %ax,%ax
  120fcf:	90                   	nop

00120fd0 <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  120fd0:	55                   	push   %ebp
  120fd1:	89 e5                	mov    %esp,%ebp
  120fd3:	83 e4 f8             	and    $0xfffffff8,%esp
  120fd6:	83 ec 38             	sub    $0x38,%esp
  120fd9:	8b 45 08             	mov    0x8(%ebp),%eax
  120fdc:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  120fe0:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  120fe4:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  120fe8:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  120fec:	9c                   	pushf  
  120fed:	fa                   	cli    
  120fee:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  120ff2:	8b 4c 24 28          	mov    0x28(%esp),%ecx
	k.key = arch_irq_lock();
  120ff6:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0U,
		 "essential thread aborted");

	z_thread_single_abort(thread);
  120ffa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120ffd:	89 0c 24             	mov    %ecx,(%esp)
  121000:	89 44 24 0c          	mov    %eax,0xc(%esp)
  121004:	e8 67 f8 ff ff       	call   120870 <z_thread_single_abort>
	z_thread_monitor_exit(thread);
  121009:	e9 00 00 00 00       	jmp    12100e <z_impl_k_thread_abort+0x3e>

	if (thread == _current && !arch_is_in_isr()) {
  12100e:	8b 45 08             	mov    0x8(%ebp),%eax
  121011:	3b 05 b0 96 13 00    	cmp    0x1396b0,%eax
  121017:	0f 85 36 00 00 00    	jne    121053 <z_impl_k_thread_abort+0x83>
  12101d:	e8 4e 00 00 00       	call   121070 <arch_is_in_isr>
  121022:	a8 01                	test   $0x1,%al
  121024:	0f 85 29 00 00 00    	jne    121053 <z_impl_k_thread_abort+0x83>
		z_swap(&lock, key);
  12102a:	8b 44 24 10          	mov    0x10(%esp),%eax
  12102e:	89 44 24 30          	mov    %eax,0x30(%esp)
  121032:	8d 44 24 18          	lea    0x18(%esp),%eax
  121036:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	k_spin_release(lock);
  12103a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  12103e:	89 44 24 34          	mov    %eax,0x34(%esp)
	return z_swap_irqlock(key.key);
  121042:	8b 44 24 30          	mov    0x30(%esp),%eax
  121046:	89 04 24             	mov    %eax,(%esp)
  121049:	e8 42 00 00 00       	call   121090 <z_swap_irqlock>
	} else {
  12104e:	e9 14 00 00 00       	jmp    121067 <z_impl_k_thread_abort+0x97>
		 * because we're running!).  But it always has been
		 * and is thus part of our API, and we have tests that
		 * rely on k_thread_abort() scheduling out of
		 * cooperative threads.
		 */
		z_reschedule(&lock, key);
  121053:	8b 44 24 10          	mov    0x10(%esp),%eax
  121057:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  12105b:	89 0c 24             	mov    %ecx,(%esp)
  12105e:	89 44 24 04          	mov    %eax,0x4(%esp)
  121062:	e8 f9 df ff ff       	call   11f060 <z_reschedule>
	}
}
  121067:	89 ec                	mov    %ebp,%esp
  121069:	5d                   	pop    %ebp
  12106a:	c3                   	ret    
  12106b:	66 90                	xchg   %ax,%ax
  12106d:	66 90                	xchg   %ax,%ax
  12106f:	90                   	nop

00121070 <arch_is_in_isr>:
{
  121070:	55                   	push   %ebp
  121071:	89 e5                	mov    %esp,%ebp
	return _kernel.nested != 0U;
  121073:	83 3d a8 96 13 00 00 	cmpl   $0x0,0x1396a8
  12107a:	0f 95 c0             	setne  %al
  12107d:	24 01                	and    $0x1,%al
  12107f:	0f b6 c0             	movzbl %al,%eax
  121082:	5d                   	pop    %ebp
  121083:	c3                   	ret    
  121084:	66 90                	xchg   %ax,%ax
  121086:	66 90                	xchg   %ax,%ax
  121088:	66 90                	xchg   %ax,%ax
  12108a:	66 90                	xchg   %ax,%ax
  12108c:	66 90                	xchg   %ax,%ax
  12108e:	66 90                	xchg   %ax,%ax

00121090 <z_swap_irqlock>:
{
  121090:	55                   	push   %ebp
  121091:	89 e5                	mov    %esp,%ebp
  121093:	83 ec 0c             	sub    $0xc,%esp
  121096:	8b 45 08             	mov    0x8(%ebp),%eax
	ret = arch_swap(key);
  121099:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12109c:	89 0c 24             	mov    %ecx,(%esp)
  12109f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1210a2:	e8 09 88 fe ff       	call   1098b0 <arch_swap>
  1210a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return ret;
  1210aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1210ad:	83 c4 0c             	add    $0xc,%esp
  1210b0:	5d                   	pop    %ebp
  1210b1:	c3                   	ret    
  1210b2:	66 90                	xchg   %ax,%ax
  1210b4:	66 90                	xchg   %ax,%ax
  1210b6:	66 90                	xchg   %ax,%ax
  1210b8:	66 90                	xchg   %ax,%ax
  1210ba:	66 90                	xchg   %ax,%ax
  1210bc:	66 90                	xchg   %ax,%ax
  1210be:	66 90                	xchg   %ax,%ax

001210c0 <z_add_timeout>:
#endif
	return ret;
}

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
  1210c0:	55                   	push   %ebp
  1210c1:	89 e5                	mov    %esp,%ebp
  1210c3:	57                   	push   %edi
  1210c4:	56                   	push   %esi
  1210c5:	83 e4 f8             	and    $0xfffffff8,%esp
  1210c8:	83 ec 50             	sub    $0x50,%esp
  1210cb:	8b 45 10             	mov    0x10(%ebp),%eax
  1210ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1210d1:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
  1210d4:	8b 75 0c             	mov    0xc(%ebp),%esi
  1210d7:	8b 7d 08             	mov    0x8(%ebp),%edi
  1210da:	89 77 0c             	mov    %esi,0xc(%edi)
	ticks = MAX(1, ticks);
  1210dd:	be 01 00 00 00       	mov    $0x1,%esi
  1210e2:	3b 75 10             	cmp    0x10(%ebp),%esi
  1210e5:	0f 8e 0e 00 00 00    	jle    1210f9 <z_add_timeout+0x39>
  1210eb:	b8 01 00 00 00       	mov    $0x1,%eax
  1210f0:	89 44 24 20          	mov    %eax,0x20(%esp)
  1210f4:	e9 07 00 00 00       	jmp    121100 <z_add_timeout+0x40>
  1210f9:	8b 45 10             	mov    0x10(%ebp),%eax
  1210fc:	89 44 24 20          	mov    %eax,0x20(%esp)
  121100:	8b 44 24 20          	mov    0x20(%esp),%eax
  121104:	31 c9                	xor    %ecx,%ecx
  121106:	89 45 10             	mov    %eax,0x10(%ebp)

	LOCKED(&timeout_lock) {
  121109:	8d 44 24 30          	lea    0x30(%esp),%eax
  12110d:	89 04 24             	mov    %eax,(%esp)
  121110:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  121117:	00 
  121118:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  12111f:	00 
  121120:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  121124:	e8 47 93 fe ff       	call   10a470 <memset>
  121129:	8d 44 24 28          	lea    0x28(%esp),%eax
  12112d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  121131:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  121137:	89 44 24 38          	mov    %eax,0x38(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12113b:	9c                   	pushf  
  12113c:	fa                   	cli    
  12113d:	8f 44 24 40          	popl   0x40(%esp)
	return key;
  121141:	8b 44 24 40          	mov    0x40(%esp),%eax
  121145:	89 44 24 28          	mov    %eax,0x28(%esp)
  121149:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
  12114e:	0f 85 22 01 00 00    	jne    121276 <z_add_timeout+0x1b6>
		struct _timeout *t;

		to->dticks = ticks + elapsed();
  121154:	8b 45 10             	mov    0x10(%ebp),%eax
  121157:	89 44 24 18          	mov    %eax,0x18(%esp)
  12115b:	e8 20 01 00 00       	call   121280 <elapsed>
  121160:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  121164:	01 c1                	add    %eax,%ecx
  121166:	8b 45 08             	mov    0x8(%ebp),%eax
  121169:	89 48 08             	mov    %ecx,0x8(%eax)
		for (t = first(); t != NULL; t = next(t)) {
  12116c:	e8 3f 01 00 00       	call   1212b0 <first>
  121171:	89 44 24 24          	mov    %eax,0x24(%esp)
  121175:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  12117a:	0f 84 64 00 00 00    	je     1211e4 <z_add_timeout+0x124>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
  121180:	8b 44 24 24          	mov    0x24(%esp),%eax
  121184:	8b 40 08             	mov    0x8(%eax),%eax
  121187:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12118a:	3b 41 08             	cmp    0x8(%ecx),%eax
  12118d:	0f 8e 2a 00 00 00    	jle    1211bd <z_add_timeout+0xfd>
				t->dticks -= to->dticks;
  121193:	8b 45 08             	mov    0x8(%ebp),%eax
  121196:	8b 40 08             	mov    0x8(%eax),%eax
  121199:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  12119d:	8b 51 08             	mov    0x8(%ecx),%edx
  1211a0:	29 c2                	sub    %eax,%edx
  1211a2:	89 51 08             	mov    %edx,0x8(%ecx)
				sys_dlist_insert(&t->node, &to->node);
  1211a5:	8b 44 24 24          	mov    0x24(%esp),%eax
  1211a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1211ac:	89 04 24             	mov    %eax,(%esp)
  1211af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1211b3:	e8 38 01 00 00       	call   1212f0 <sys_dlist_insert>
				break;
  1211b8:	e9 27 00 00 00       	jmp    1211e4 <z_add_timeout+0x124>
			}
			to->dticks -= t->dticks;
  1211bd:	8b 44 24 24          	mov    0x24(%esp),%eax
  1211c1:	8b 40 08             	mov    0x8(%eax),%eax
  1211c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1211c7:	8b 51 08             	mov    0x8(%ecx),%edx
  1211ca:	29 c2                	sub    %eax,%edx
  1211cc:	89 51 08             	mov    %edx,0x8(%ecx)
		for (t = first(); t != NULL; t = next(t)) {
  1211cf:	8b 44 24 24          	mov    0x24(%esp),%eax
  1211d3:	89 04 24             	mov    %eax,(%esp)
  1211d6:	e8 55 01 00 00       	call   121330 <next>
  1211db:	89 44 24 24          	mov    %eax,0x24(%esp)
  1211df:	e9 91 ff ff ff       	jmp    121175 <z_add_timeout+0xb5>
		}

		if (t == NULL) {
  1211e4:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  1211e9:	0f 85 15 00 00 00    	jne    121204 <z_add_timeout+0x144>
			sys_dlist_append(&timeout_list, &to->node);
  1211ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1211f2:	8d 0d ac 33 14 00    	lea    0x1433ac,%ecx
  1211f8:	89 0c 24             	mov    %ecx,(%esp)
  1211fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1211ff:	e8 7c 01 00 00       	call   121380 <sys_dlist_append>
		}

		if (to == first()) {
  121204:	8b 45 08             	mov    0x8(%ebp),%eax
  121207:	89 44 24 14          	mov    %eax,0x14(%esp)
  12120b:	e8 a0 00 00 00       	call   1212b0 <first>
  121210:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  121214:	39 c1                	cmp    %eax,%ecx
  121216:	0f 85 1b 00 00 00    	jne    121237 <z_add_timeout+0x177>
			z_clock_set_timeout(next_timeout(), false);
  12121c:	e8 9f 01 00 00       	call   1213c0 <next_timeout>
  121221:	31 c9                	xor    %ecx,%ecx
  121223:	89 04 24             	mov    %eax,(%esp)
  121226:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  12122d:	00 
  12122e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  121232:	e8 49 68 fe ff       	call   107a80 <z_clock_set_timeout>
		}
	}
  121237:	e9 00 00 00 00       	jmp    12123c <z_add_timeout+0x17c>
	LOCKED(&timeout_lock) {
  12123c:	8b 44 24 28          	mov    0x28(%esp),%eax
  121240:	89 44 24 48          	mov    %eax,0x48(%esp)
  121244:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12124a:	89 44 24 44          	mov    %eax,0x44(%esp)
	arch_irq_unlock(key.key);
  12124e:	8b 44 24 48          	mov    0x48(%esp),%eax
  121252:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121256:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  12125a:	25 00 02 00 00       	and    $0x200,%eax
  12125f:	83 f8 00             	cmp    $0x0,%eax
  121262:	0f 84 01 00 00 00    	je     121269 <z_add_timeout+0x1a9>
		__asm__ volatile ("sti" ::: "memory");
  121268:	fb                   	sti    
  121269:	c7 44 24 30 01 00 00 	movl   $0x1,0x30(%esp)
  121270:	00 
  121271:	e9 d3 fe ff ff       	jmp    121149 <z_add_timeout+0x89>
}
  121276:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121279:	5e                   	pop    %esi
  12127a:	5f                   	pop    %edi
  12127b:	5d                   	pop    %ebp
  12127c:	c3                   	ret    
  12127d:	66 90                	xchg   %ax,%ax
  12127f:	90                   	nop

00121280 <elapsed>:
{
  121280:	55                   	push   %ebp
  121281:	89 e5                	mov    %esp,%ebp
  121283:	50                   	push   %eax
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
  121284:	83 3d e0 96 13 00 00 	cmpl   $0x0,0x1396e0
  12128b:	0f 85 0d 00 00 00    	jne    12129e <elapsed+0x1e>
  121291:	e8 aa 69 fe ff       	call   107c40 <z_clock_elapsed>
  121296:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121299:	e9 0a 00 00 00       	jmp    1212a8 <elapsed+0x28>
  12129e:	31 c0                	xor    %eax,%eax
  1212a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1212a3:	e9 00 00 00 00       	jmp    1212a8 <elapsed+0x28>
  1212a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1212ab:	83 c4 04             	add    $0x4,%esp
  1212ae:	5d                   	pop    %ebp
  1212af:	c3                   	ret    

001212b0 <first>:
{
  1212b0:	55                   	push   %ebp
  1212b1:	89 e5                	mov    %esp,%ebp
  1212b3:	83 ec 0c             	sub    $0xc,%esp
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
  1212b6:	8d 05 ac 33 14 00    	lea    0x1433ac,%eax
  1212bc:	89 04 24             	mov    %eax,(%esp)
  1212bf:	e8 5c 0b 00 00       	call   121e20 <sys_dlist_peek_head>
  1212c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
  1212c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1212cb:	0f 85 0a 00 00 00    	jne    1212db <first+0x2b>
  1212d1:	31 c0                	xor    %eax,%eax
  1212d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1212d6:	e9 06 00 00 00       	jmp    1212e1 <first+0x31>
  1212db:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1212de:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1212e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1212e4:	83 c4 0c             	add    $0xc,%esp
  1212e7:	5d                   	pop    %ebp
  1212e8:	c3                   	ret    
  1212e9:	66 90                	xchg   %ax,%ax
  1212eb:	66 90                	xchg   %ax,%ax
  1212ed:	66 90                	xchg   %ax,%ax
  1212ef:	90                   	nop

001212f0 <sys_dlist_insert>:
{
  1212f0:	55                   	push   %ebp
  1212f1:	89 e5                	mov    %esp,%ebp
  1212f3:	56                   	push   %esi
  1212f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1212f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	node->prev = successor->prev;
  1212fa:	8b 55 08             	mov    0x8(%ebp),%edx
  1212fd:	8b 52 04             	mov    0x4(%edx),%edx
  121300:	8b 75 0c             	mov    0xc(%ebp),%esi
  121303:	89 56 04             	mov    %edx,0x4(%esi)
	node->next = successor;
  121306:	8b 55 08             	mov    0x8(%ebp),%edx
  121309:	8b 75 0c             	mov    0xc(%ebp),%esi
  12130c:	89 16                	mov    %edx,(%esi)
	successor->prev->next = node;
  12130e:	8b 55 0c             	mov    0xc(%ebp),%edx
  121311:	8b 75 08             	mov    0x8(%ebp),%esi
  121314:	8b 76 04             	mov    0x4(%esi),%esi
  121317:	89 16                	mov    %edx,(%esi)
	successor->prev = node;
  121319:	8b 55 0c             	mov    0xc(%ebp),%edx
  12131c:	8b 75 08             	mov    0x8(%ebp),%esi
  12131f:	89 56 04             	mov    %edx,0x4(%esi)
}
  121322:	5e                   	pop    %esi
  121323:	5d                   	pop    %ebp
  121324:	c3                   	ret    
  121325:	66 90                	xchg   %ax,%ax
  121327:	66 90                	xchg   %ax,%ax
  121329:	66 90                	xchg   %ax,%ax
  12132b:	66 90                	xchg   %ax,%ax
  12132d:	66 90                	xchg   %ax,%ax
  12132f:	90                   	nop

00121330 <next>:
{
  121330:	55                   	push   %ebp
  121331:	89 e5                	mov    %esp,%ebp
  121333:	83 ec 14             	sub    $0x14,%esp
  121336:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
  121339:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12133c:	8d 15 ac 33 14 00    	lea    0x1433ac,%edx
  121342:	89 14 24             	mov    %edx,(%esp)
  121345:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  121349:	89 45 f8             	mov    %eax,-0x8(%ebp)
  12134c:	e8 3f 0b 00 00       	call   121e90 <sys_dlist_peek_next>
  121351:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
  121354:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  121358:	0f 85 0a 00 00 00    	jne    121368 <next+0x38>
  12135e:	31 c0                	xor    %eax,%eax
  121360:	89 45 f4             	mov    %eax,-0xc(%ebp)
  121363:	e9 06 00 00 00       	jmp    12136e <next+0x3e>
  121368:	8b 45 fc             	mov    -0x4(%ebp),%eax
  12136b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  12136e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  121371:	83 c4 14             	add    $0x14,%esp
  121374:	5d                   	pop    %ebp
  121375:	c3                   	ret    
  121376:	66 90                	xchg   %ax,%ax
  121378:	66 90                	xchg   %ax,%ax
  12137a:	66 90                	xchg   %ax,%ax
  12137c:	66 90                	xchg   %ax,%ax
  12137e:	66 90                	xchg   %ax,%ax

00121380 <sys_dlist_append>:
{
  121380:	55                   	push   %ebp
  121381:	89 e5                	mov    %esp,%ebp
  121383:	56                   	push   %esi
  121384:	8b 45 0c             	mov    0xc(%ebp),%eax
  121387:	8b 4d 08             	mov    0x8(%ebp),%ecx
	node->next = list;
  12138a:	8b 55 08             	mov    0x8(%ebp),%edx
  12138d:	8b 75 0c             	mov    0xc(%ebp),%esi
  121390:	89 16                	mov    %edx,(%esi)
	node->prev = list->tail;
  121392:	8b 55 08             	mov    0x8(%ebp),%edx
  121395:	8b 52 04             	mov    0x4(%edx),%edx
  121398:	8b 75 0c             	mov    0xc(%ebp),%esi
  12139b:	89 56 04             	mov    %edx,0x4(%esi)
	list->tail->next = node;
  12139e:	8b 55 0c             	mov    0xc(%ebp),%edx
  1213a1:	8b 75 08             	mov    0x8(%ebp),%esi
  1213a4:	8b 76 04             	mov    0x4(%esi),%esi
  1213a7:	89 16                	mov    %edx,(%esi)
	list->tail = node;
  1213a9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1213ac:	8b 75 08             	mov    0x8(%ebp),%esi
  1213af:	89 56 04             	mov    %edx,0x4(%esi)
}
  1213b2:	5e                   	pop    %esi
  1213b3:	5d                   	pop    %ebp
  1213b4:	c3                   	ret    
  1213b5:	66 90                	xchg   %ax,%ax
  1213b7:	66 90                	xchg   %ax,%ax
  1213b9:	66 90                	xchg   %ax,%ax
  1213bb:	66 90                	xchg   %ax,%ax
  1213bd:	66 90                	xchg   %ax,%ax
  1213bf:	90                   	nop

001213c0 <next_timeout>:
{
  1213c0:	55                   	push   %ebp
  1213c1:	89 e5                	mov    %esp,%ebp
  1213c3:	83 ec 14             	sub    $0x14,%esp
	struct _timeout *to = first();
  1213c6:	e8 e5 fe ff ff       	call   1212b0 <first>
  1213cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	s32_t ticks_elapsed = elapsed();
  1213ce:	e8 ad fe ff ff       	call   121280 <elapsed>
  1213d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
  1213d6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1213da:	0f 85 0d 00 00 00    	jne    1213ed <next_timeout+0x2d>
  1213e0:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  1213e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1213e8:	e9 2f 00 00 00       	jmp    12141c <next_timeout+0x5c>
  1213ed:	31 c0                	xor    %eax,%eax
  1213ef:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1213f2:	8b 49 08             	mov    0x8(%ecx),%ecx
  1213f5:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  1213f8:	39 c8                	cmp    %ecx,%eax
  1213fa:	0f 8e 0a 00 00 00    	jle    12140a <next_timeout+0x4a>
  121400:	31 c0                	xor    %eax,%eax
  121402:	89 45 ec             	mov    %eax,-0x14(%ebp)
  121405:	e9 0c 00 00 00       	jmp    121416 <next_timeout+0x56>
  12140a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  12140d:	8b 40 08             	mov    0x8(%eax),%eax
  121410:	2b 45 f8             	sub    -0x8(%ebp),%eax
  121413:	89 45 ec             	mov    %eax,-0x14(%ebp)
  121416:	8b 45 ec             	mov    -0x14(%ebp),%eax
  121419:	89 45 f0             	mov    %eax,-0x10(%ebp)
  12141c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  12141f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
  121422:	83 3d b8 96 13 00 00 	cmpl   $0x0,0x1396b8
  121429:	0f 84 16 00 00 00    	je     121445 <next_timeout+0x85>
  12142f:	a1 b8 96 13 00       	mov    0x1396b8,%eax
  121434:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  121437:	0f 8d 08 00 00 00    	jge    121445 <next_timeout+0x85>
		ret = _current_cpu->slice_ticks;
  12143d:	a1 b8 96 13 00       	mov    0x1396b8,%eax
  121442:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
  121445:	8b 45 f4             	mov    -0xc(%ebp),%eax
  121448:	83 c4 14             	add    $0x14,%esp
  12144b:	5d                   	pop    %ebp
  12144c:	c3                   	ret    
  12144d:	66 90                	xchg   %ax,%ax
  12144f:	90                   	nop

00121450 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  121450:	55                   	push   %ebp
  121451:	89 e5                	mov    %esp,%ebp
  121453:	83 e4 f8             	and    $0xfffffff8,%esp
  121456:	83 ec 40             	sub    $0x40,%esp
  121459:	8b 45 08             	mov    0x8(%ebp),%eax
  12145c:	31 c9                	xor    %ecx,%ecx
	int ret = -EINVAL;
  12145e:	c7 44 24 24 ea ff ff 	movl   $0xffffffea,0x24(%esp)
  121465:	ff 

	LOCKED(&timeout_lock) {
  121466:	8d 54 24 20          	lea    0x20(%esp),%edx
  12146a:	89 14 24             	mov    %edx,(%esp)
  12146d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  121474:	00 
  121475:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  12147c:	00 
  12147d:	89 44 24 14          	mov    %eax,0x14(%esp)
  121481:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  121485:	e8 e6 8f fe ff       	call   10a470 <memset>
  12148a:	8d 44 24 18          	lea    0x18(%esp),%eax
  12148e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  121492:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  121498:	89 44 24 28          	mov    %eax,0x28(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12149c:	9c                   	pushf  
  12149d:	fa                   	cli    
  12149e:	8f 44 24 30          	popl   0x30(%esp)
	return key;
  1214a2:	8b 44 24 30          	mov    0x30(%esp),%eax
	k.key = arch_irq_lock();
  1214a6:	89 44 24 18          	mov    %eax,0x18(%esp)
  1214aa:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  1214af:	0f 85 6a 00 00 00    	jne    12151f <z_abort_timeout+0xcf>
		if (sys_dnode_is_linked(&to->node)) {
  1214b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1214b8:	89 04 24             	mov    %eax,(%esp)
  1214bb:	e8 70 00 00 00       	call   121530 <sys_dnode_is_linked>
  1214c0:	a8 01                	test   $0x1,%al
  1214c2:	0f 85 05 00 00 00    	jne    1214cd <z_abort_timeout+0x7d>
  1214c8:	e9 13 00 00 00       	jmp    1214e0 <z_abort_timeout+0x90>
			remove_timeout(to);
  1214cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1214d0:	89 04 24             	mov    %eax,(%esp)
  1214d3:	e8 78 00 00 00       	call   121550 <remove_timeout>
			ret = 0;
  1214d8:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  1214df:	00 
		}
	}
  1214e0:	e9 00 00 00 00       	jmp    1214e5 <z_abort_timeout+0x95>
	LOCKED(&timeout_lock) {
  1214e5:	8b 44 24 18          	mov    0x18(%esp),%eax
  1214e9:	89 44 24 38          	mov    %eax,0x38(%esp)
  1214ed:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  1214f3:	89 44 24 34          	mov    %eax,0x34(%esp)
	arch_irq_unlock(key.key);
  1214f7:	8b 44 24 38          	mov    0x38(%esp),%eax
  1214fb:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1214ff:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  121503:	25 00 02 00 00       	and    $0x200,%eax
  121508:	83 f8 00             	cmp    $0x0,%eax
  12150b:	0f 84 01 00 00 00    	je     121512 <z_abort_timeout+0xc2>
		__asm__ volatile ("sti" ::: "memory");
  121511:	fb                   	sti    
  121512:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  121519:	00 
  12151a:	e9 8b ff ff ff       	jmp    1214aa <z_abort_timeout+0x5a>

	return ret;
  12151f:	8b 44 24 24          	mov    0x24(%esp),%eax
  121523:	89 ec                	mov    %ebp,%esp
  121525:	5d                   	pop    %ebp
  121526:	c3                   	ret    
  121527:	66 90                	xchg   %ax,%ax
  121529:	66 90                	xchg   %ax,%ax
  12152b:	66 90                	xchg   %ax,%ax
  12152d:	66 90                	xchg   %ax,%ax
  12152f:	90                   	nop

00121530 <sys_dnode_is_linked>:
{
  121530:	55                   	push   %ebp
  121531:	89 e5                	mov    %esp,%ebp
  121533:	50                   	push   %eax
  121534:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  121537:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12153a:	83 39 00             	cmpl   $0x0,(%ecx)
  12153d:	0f 95 c2             	setne  %dl
  121540:	80 e2 01             	and    $0x1,%dl
  121543:	0f b6 ca             	movzbl %dl,%ecx
  121546:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121549:	89 c8                	mov    %ecx,%eax
  12154b:	83 c4 04             	add    $0x4,%esp
  12154e:	5d                   	pop    %ebp
  12154f:	c3                   	ret    

00121550 <remove_timeout>:
{
  121550:	55                   	push   %ebp
  121551:	89 e5                	mov    %esp,%ebp
  121553:	83 ec 0c             	sub    $0xc,%esp
  121556:	8b 45 08             	mov    0x8(%ebp),%eax
	if (next(t) != NULL) {
  121559:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12155c:	89 0c 24             	mov    %ecx,(%esp)
  12155f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121562:	e8 c9 fd ff ff       	call   121330 <next>
  121567:	83 f8 00             	cmp    $0x0,%eax
  12156a:	0f 84 1d 00 00 00    	je     12158d <remove_timeout+0x3d>
		next(t)->dticks += t->dticks;
  121570:	8b 45 08             	mov    0x8(%ebp),%eax
  121573:	8b 40 08             	mov    0x8(%eax),%eax
  121576:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121579:	89 0c 24             	mov    %ecx,(%esp)
  12157c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  12157f:	e8 ac fd ff ff       	call   121330 <next>
  121584:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  121587:	03 48 08             	add    0x8(%eax),%ecx
  12158a:	89 48 08             	mov    %ecx,0x8(%eax)
	sys_dlist_remove(&t->node);
  12158d:	8b 45 08             	mov    0x8(%ebp),%eax
  121590:	89 04 24             	mov    %eax,(%esp)
  121593:	e8 88 09 00 00       	call   121f20 <sys_dlist_remove>
}
  121598:	83 c4 0c             	add    $0xc,%esp
  12159b:	5d                   	pop    %ebp
  12159c:	c3                   	ret    
  12159d:	66 90                	xchg   %ax,%ax
  12159f:	90                   	nop

001215a0 <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
  1215a0:	55                   	push   %ebp
  1215a1:	89 e5                	mov    %esp,%ebp
  1215a3:	83 e4 f8             	and    $0xfffffff8,%esp
  1215a6:	83 ec 38             	sub    $0x38,%esp
  1215a9:	31 c0                	xor    %eax,%eax
	s32_t ret = K_FOREVER;
  1215ab:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp)
  1215b2:	ff 

	LOCKED(&timeout_lock) {
  1215b3:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  1215b7:	89 0c 24             	mov    %ecx,(%esp)
  1215ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1215c1:	00 
  1215c2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1215c9:	00 
  1215ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1215ce:	e8 9d 8e fe ff       	call   10a470 <memset>
  1215d3:	8d 44 24 10          	lea    0x10(%esp),%eax
  1215d7:	89 44 24 24          	mov    %eax,0x24(%esp)
  1215db:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  1215e1:	89 44 24 20          	mov    %eax,0x20(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1215e5:	9c                   	pushf  
  1215e6:	fa                   	cli    
  1215e7:	8f 44 24 28          	popl   0x28(%esp)
	return key;
  1215eb:	8b 44 24 28          	mov    0x28(%esp),%eax
	k.key = arch_irq_lock();
  1215ef:	89 44 24 10          	mov    %eax,0x10(%esp)
  1215f3:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  1215f8:	0f 85 43 00 00 00    	jne    121641 <z_get_next_timeout_expiry+0xa1>
		ret = next_timeout();
  1215fe:	e8 bd fd ff ff       	call   1213c0 <next_timeout>
  121603:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	LOCKED(&timeout_lock) {
  121607:	8b 44 24 10          	mov    0x10(%esp),%eax
  12160b:	89 44 24 30          	mov    %eax,0x30(%esp)
  12160f:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  121615:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	arch_irq_unlock(key.key);
  121619:	8b 44 24 30          	mov    0x30(%esp),%eax
  12161d:	89 44 24 34          	mov    %eax,0x34(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121621:	8b 44 24 34          	mov    0x34(%esp),%eax
  121625:	25 00 02 00 00       	and    $0x200,%eax
  12162a:	83 f8 00             	cmp    $0x0,%eax
  12162d:	0f 84 01 00 00 00    	je     121634 <z_get_next_timeout_expiry+0x94>
		__asm__ volatile ("sti" ::: "memory");
  121633:	fb                   	sti    
  121634:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
  12163b:	00 
  12163c:	e9 b2 ff ff ff       	jmp    1215f3 <z_get_next_timeout_expiry+0x53>
	}
	return ret;
  121641:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  121645:	89 ec                	mov    %ebp,%esp
  121647:	5d                   	pop    %ebp
  121648:	c3                   	ret    
  121649:	66 90                	xchg   %ax,%ax
  12164b:	66 90                	xchg   %ax,%ax
  12164d:	66 90                	xchg   %ax,%ax
  12164f:	90                   	nop

00121650 <z_set_timeout_expiry>:
}

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
  121650:	55                   	push   %ebp
  121651:	89 e5                	mov    %esp,%ebp
  121653:	56                   	push   %esi
  121654:	83 e4 f8             	and    $0xfffffff8,%esp
  121657:	83 ec 50             	sub    $0x50,%esp
  12165a:	8a 45 0c             	mov    0xc(%ebp),%al
  12165d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121660:	31 d2                	xor    %edx,%edx
  121662:	24 01                	and    $0x1,%al
  121664:	88 44 24 2f          	mov    %al,0x2f(%esp)
	LOCKED(&timeout_lock) {
  121668:	8d 74 24 28          	lea    0x28(%esp),%esi
  12166c:	89 34 24             	mov    %esi,(%esp)
  12166f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  121676:	00 
  121677:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  12167e:	00 
  12167f:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  121683:	89 54 24 10          	mov    %edx,0x10(%esp)
  121687:	e8 e4 8d fe ff       	call   10a470 <memset>
  12168c:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  121690:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  121694:	8d 0d ef 0e 14 00    	lea    0x140eef,%ecx
  12169a:	89 4c 24 30          	mov    %ecx,0x30(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12169e:	9c                   	pushf  
  12169f:	fa                   	cli    
  1216a0:	8f 44 24 38          	popl   0x38(%esp)
	return key;
  1216a4:	8b 4c 24 38          	mov    0x38(%esp),%ecx
	k.key = arch_irq_lock();
  1216a8:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  1216ac:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  1216b1:	0f 85 ae 00 00 00    	jne    121765 <z_set_timeout_expiry+0x115>
		int next = next_timeout();
  1216b7:	e8 04 fd ff ff       	call   1213c0 <next_timeout>
  1216bc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		bool sooner = (next == K_FOREVER) || (ticks < next);
  1216c0:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1216c5:	b1 01                	mov    $0x1,%cl
  1216c7:	88 4c 24 0f          	mov    %cl,0xf(%esp)
  1216cb:	0f 84 0e 00 00 00    	je     1216df <z_set_timeout_expiry+0x8f>
  1216d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1216d4:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
  1216d8:	0f 9c c1             	setl   %cl
  1216db:	88 4c 24 0f          	mov    %cl,0xf(%esp)
  1216df:	8a 44 24 0f          	mov    0xf(%esp),%al
  1216e3:	24 01                	and    $0x1,%al
  1216e5:	88 44 24 1b          	mov    %al,0x1b(%esp)
		bool imminent = next <= 1;
  1216e9:	83 7c 24 1c 01       	cmpl   $0x1,0x1c(%esp)
  1216ee:	0f 9e c0             	setle  %al
  1216f1:	24 01                	and    $0x1,%al
  1216f3:	88 44 24 1a          	mov    %al,0x1a(%esp)
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
  1216f7:	f6 44 24 1a 01       	testb  $0x1,0x1a(%esp)
  1216fc:	0f 85 24 00 00 00    	jne    121726 <z_set_timeout_expiry+0xd6>
  121702:	f6 44 24 1b 01       	testb  $0x1,0x1b(%esp)
  121707:	0f 84 19 00 00 00    	je     121726 <z_set_timeout_expiry+0xd6>
			z_clock_set_timeout(ticks, idle);
  12170d:	8b 45 08             	mov    0x8(%ebp),%eax
  121710:	8a 4c 24 2f          	mov    0x2f(%esp),%cl
  121714:	80 e1 01             	and    $0x1,%cl
  121717:	89 04 24             	mov    %eax,(%esp)
  12171a:	0f b6 c1             	movzbl %cl,%eax
  12171d:	89 44 24 04          	mov    %eax,0x4(%esp)
  121721:	e8 5a 63 fe ff       	call   107a80 <z_clock_set_timeout>
		}
	}
  121726:	e9 00 00 00 00       	jmp    12172b <z_set_timeout_expiry+0xdb>
	LOCKED(&timeout_lock) {
  12172b:	8b 44 24 20          	mov    0x20(%esp),%eax
  12172f:	89 44 24 40          	mov    %eax,0x40(%esp)
  121733:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  121739:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	arch_irq_unlock(key.key);
  12173d:	8b 44 24 40          	mov    0x40(%esp),%eax
  121741:	89 44 24 48          	mov    %eax,0x48(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121745:	8b 44 24 48          	mov    0x48(%esp),%eax
  121749:	25 00 02 00 00       	and    $0x200,%eax
  12174e:	83 f8 00             	cmp    $0x0,%eax
  121751:	0f 84 01 00 00 00    	je     121758 <z_set_timeout_expiry+0x108>
		__asm__ volatile ("sti" ::: "memory");
  121757:	fb                   	sti    
  121758:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
  12175f:	00 
  121760:	e9 47 ff ff ff       	jmp    1216ac <z_set_timeout_expiry+0x5c>
}
  121765:	8d 65 fc             	lea    -0x4(%ebp),%esp
  121768:	5e                   	pop    %esi
  121769:	5d                   	pop    %ebp
  12176a:	c3                   	ret    
  12176b:	66 90                	xchg   %ax,%ax
  12176d:	66 90                	xchg   %ax,%ax
  12176f:	90                   	nop

00121770 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
  121770:	55                   	push   %ebp
  121771:	89 e5                	mov    %esp,%ebp
  121773:	56                   	push   %esi
  121774:	83 e4 f8             	and    $0xfffffff8,%esp
  121777:	83 ec 68             	sub    $0x68,%esp
  12177a:	8b 45 08             	mov    0x8(%ebp),%eax
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
  12177d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121780:	89 0c 24             	mov    %ecx,(%esp)
  121783:	89 44 24 14          	mov    %eax,0x14(%esp)
  121787:	e8 24 c9 ff ff       	call   11e0b0 <z_time_slice>
  12178c:	8d 44 24 28          	lea    0x28(%esp),%eax
  121790:	89 44 24 34          	mov    %eax,0x34(%esp)
  121794:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12179a:	89 44 24 30          	mov    %eax,0x30(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12179e:	9c                   	pushf  
  12179f:	fa                   	cli    
  1217a0:	8f 44 24 38          	popl   0x38(%esp)
	return key;
  1217a4:	8b 44 24 38          	mov    0x38(%esp),%eax
	k.key = arch_irq_lock();
  1217a8:	89 44 24 28          	mov    %eax,0x28(%esp)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
  1217ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1217af:	a3 e0 96 13 00       	mov    %eax,0x1396e0

	while (first() != NULL && first()->dticks <= announce_remaining) {
  1217b4:	e8 f7 fa ff ff       	call   1212b0 <first>
  1217b9:	31 c9                	xor    %ecx,%ecx
  1217bb:	83 f8 00             	cmp    $0x0,%eax
  1217be:	88 4c 24 13          	mov    %cl,0x13(%esp)
  1217c2:	0f 84 15 00 00 00    	je     1217dd <z_clock_announce+0x6d>
  1217c8:	e8 e3 fa ff ff       	call   1212b0 <first>
  1217cd:	8b 40 08             	mov    0x8(%eax),%eax
  1217d0:	3b 05 e0 96 13 00    	cmp    0x1396e0,%eax
  1217d6:	0f 9e c1             	setle  %cl
  1217d9:	88 4c 24 13          	mov    %cl,0x13(%esp)
  1217dd:	8a 44 24 13          	mov    0x13(%esp),%al
  1217e1:	a8 01                	test   $0x1,%al
  1217e3:	0f 85 05 00 00 00    	jne    1217ee <z_clock_announce+0x7e>
  1217e9:	e9 cc 00 00 00       	jmp    1218ba <z_clock_announce+0x14a>
		struct _timeout *t = first();
  1217ee:	e8 bd fa ff ff       	call   1212b0 <first>
  1217f3:	89 44 24 24          	mov    %eax,0x24(%esp)
		int dt = t->dticks;
  1217f7:	8b 44 24 24          	mov    0x24(%esp),%eax
  1217fb:	8b 40 08             	mov    0x8(%eax),%eax
  1217fe:	89 44 24 20          	mov    %eax,0x20(%esp)

		curr_tick += dt;
  121802:	8b 44 24 20          	mov    0x20(%esp),%eax
  121806:	89 c1                	mov    %eax,%ecx
  121808:	c1 f9 1f             	sar    $0x1f,%ecx
  12180b:	8b 15 24 50 13 00    	mov    0x135024,%edx
  121811:	8b 35 20 50 13 00    	mov    0x135020,%esi
  121817:	01 c6                	add    %eax,%esi
  121819:	11 ca                	adc    %ecx,%edx
  12181b:	89 35 20 50 13 00    	mov    %esi,0x135020
  121821:	89 15 24 50 13 00    	mov    %edx,0x135024
		announce_remaining -= dt;
  121827:	8b 44 24 20          	mov    0x20(%esp),%eax
  12182b:	8b 0d e0 96 13 00    	mov    0x1396e0,%ecx
  121831:	29 c1                	sub    %eax,%ecx
  121833:	89 0d e0 96 13 00    	mov    %ecx,0x1396e0
		t->dticks = 0;
  121839:	8b 44 24 24          	mov    0x24(%esp),%eax
  12183d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		remove_timeout(t);
  121844:	8b 44 24 24          	mov    0x24(%esp),%eax
  121848:	89 04 24             	mov    %eax,(%esp)
  12184b:	e8 00 fd ff ff       	call   121550 <remove_timeout>

		k_spin_unlock(&timeout_lock, key);
  121850:	8b 44 24 28          	mov    0x28(%esp),%eax
  121854:	89 44 24 40          	mov    %eax,0x40(%esp)
  121858:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12185e:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	arch_irq_unlock(key.key);
  121862:	8b 44 24 40          	mov    0x40(%esp),%eax
  121866:	89 44 24 44          	mov    %eax,0x44(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12186a:	8b 44 24 44          	mov    0x44(%esp),%eax
  12186e:	25 00 02 00 00       	and    $0x200,%eax
  121873:	83 f8 00             	cmp    $0x0,%eax
  121876:	0f 84 01 00 00 00    	je     12187d <z_clock_announce+0x10d>
		__asm__ volatile ("sti" ::: "memory");
  12187c:	fb                   	sti    
		t->fn(t);
  12187d:	8b 44 24 24          	mov    0x24(%esp),%eax
  121881:	8b 40 0c             	mov    0xc(%eax),%eax
  121884:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  121888:	89 0c 24             	mov    %ecx,(%esp)
  12188b:	ff d0                	call   *%eax
  12188d:	8d 44 24 18          	lea    0x18(%esp),%eax
  121891:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  121895:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12189b:	89 44 24 48          	mov    %eax,0x48(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  12189f:	9c                   	pushf  
  1218a0:	fa                   	cli    
  1218a1:	8f 44 24 50          	popl   0x50(%esp)
	return key;
  1218a5:	8b 44 24 50          	mov    0x50(%esp),%eax
	k.key = arch_irq_lock();
  1218a9:	89 44 24 18          	mov    %eax,0x18(%esp)
		key = k_spin_lock(&timeout_lock);
  1218ad:	8b 44 24 18          	mov    0x18(%esp),%eax
  1218b1:	89 44 24 28          	mov    %eax,0x28(%esp)
	while (first() != NULL && first()->dticks <= announce_remaining) {
  1218b5:	e9 fa fe ff ff       	jmp    1217b4 <z_clock_announce+0x44>
	}

	if (first() != NULL) {
  1218ba:	e8 f1 f9 ff ff       	call   1212b0 <first>
  1218bf:	83 f8 00             	cmp    $0x0,%eax
  1218c2:	0f 84 1a 00 00 00    	je     1218e2 <z_clock_announce+0x172>
		first()->dticks -= announce_remaining;
  1218c8:	a1 e0 96 13 00       	mov    0x1396e0,%eax
  1218cd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1218d1:	e8 da f9 ff ff       	call   1212b0 <first>
  1218d6:	8b 48 08             	mov    0x8(%eax),%ecx
  1218d9:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1218dd:	29 d1                	sub    %edx,%ecx
  1218df:	89 48 08             	mov    %ecx,0x8(%eax)
	}

	curr_tick += announce_remaining;
  1218e2:	a1 e0 96 13 00       	mov    0x1396e0,%eax
  1218e7:	89 c1                	mov    %eax,%ecx
  1218e9:	c1 f9 1f             	sar    $0x1f,%ecx
  1218ec:	8b 15 24 50 13 00    	mov    0x135024,%edx
  1218f2:	8b 35 20 50 13 00    	mov    0x135020,%esi
  1218f8:	01 c6                	add    %eax,%esi
  1218fa:	11 ca                	adc    %ecx,%edx
  1218fc:	89 35 20 50 13 00    	mov    %esi,0x135020
  121902:	89 15 24 50 13 00    	mov    %edx,0x135024
	announce_remaining = 0;
  121908:	c7 05 e0 96 13 00 00 	movl   $0x0,0x1396e0
  12190f:	00 00 00 

	z_clock_set_timeout(next_timeout(), false);
  121912:	e8 a9 fa ff ff       	call   1213c0 <next_timeout>
  121917:	31 c9                	xor    %ecx,%ecx
  121919:	89 04 24             	mov    %eax,(%esp)
  12191c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  121923:	00 
  121924:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  121928:	e8 53 61 fe ff       	call   107a80 <z_clock_set_timeout>

	k_spin_unlock(&timeout_lock, key);
  12192d:	8b 44 24 28          	mov    0x28(%esp),%eax
  121931:	89 44 24 58          	mov    %eax,0x58(%esp)
  121935:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  12193b:	89 44 24 54          	mov    %eax,0x54(%esp)
	arch_irq_unlock(key.key);
  12193f:	8b 44 24 58          	mov    0x58(%esp),%eax
  121943:	89 44 24 60          	mov    %eax,0x60(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121947:	8b 44 24 60          	mov    0x60(%esp),%eax
  12194b:	25 00 02 00 00       	and    $0x200,%eax
  121950:	83 f8 00             	cmp    $0x0,%eax
  121953:	0f 84 01 00 00 00    	je     12195a <z_clock_announce+0x1ea>
		__asm__ volatile ("sti" ::: "memory");
  121959:	fb                   	sti    
}
  12195a:	8d 65 fc             	lea    -0x4(%ebp),%esp
  12195d:	5e                   	pop    %esi
  12195e:	5d                   	pop    %ebp
  12195f:	c3                   	ret    

00121960 <z_tick_get>:

s64_t z_tick_get(void)
{
  121960:	55                   	push   %ebp
  121961:	89 e5                	mov    %esp,%ebp
  121963:	83 e4 f8             	and    $0xfffffff8,%esp
  121966:	83 ec 48             	sub    $0x48,%esp
  121969:	31 c0                	xor    %eax,%eax
	u64_t t = 0U;
  12196b:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  121972:	00 
  121973:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
  12197a:	00 

	LOCKED(&timeout_lock) {
  12197b:	8d 4c 24 20          	lea    0x20(%esp),%ecx
  12197f:	89 0c 24             	mov    %ecx,(%esp)
  121982:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  121989:	00 
  12198a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  121991:	00 
  121992:	89 44 24 14          	mov    %eax,0x14(%esp)
  121996:	e8 d5 8a fe ff       	call   10a470 <memset>
  12199b:	8d 44 24 18          	lea    0x18(%esp),%eax
  12199f:	89 44 24 34          	mov    %eax,0x34(%esp)
  1219a3:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  1219a9:	89 44 24 30          	mov    %eax,0x30(%esp)
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1219ad:	9c                   	pushf  
  1219ae:	fa                   	cli    
  1219af:	8f 44 24 38          	popl   0x38(%esp)
	return key;
  1219b3:	8b 44 24 38          	mov    0x38(%esp),%eax
	k.key = arch_irq_lock();
  1219b7:	89 44 24 18          	mov    %eax,0x18(%esp)
  1219bb:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  1219c0:	0f 85 67 00 00 00    	jne    121a2d <z_tick_get+0xcd>
		t = curr_tick + z_clock_elapsed();
  1219c6:	a1 24 50 13 00       	mov    0x135024,%eax
  1219cb:	8b 0d 20 50 13 00    	mov    0x135020,%ecx
  1219d1:	89 44 24 10          	mov    %eax,0x10(%esp)
  1219d5:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1219d9:	e8 62 62 fe ff       	call   107c40 <z_clock_elapsed>
  1219de:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1219e2:	01 c1                	add    %eax,%ecx
  1219e4:	8b 44 24 10          	mov    0x10(%esp),%eax
  1219e8:	83 d0 00             	adc    $0x0,%eax
  1219eb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
  1219ef:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	LOCKED(&timeout_lock) {
  1219f3:	8b 44 24 18          	mov    0x18(%esp),%eax
  1219f7:	89 44 24 40          	mov    %eax,0x40(%esp)
  1219fb:	8d 05 ef 0e 14 00    	lea    0x140eef,%eax
  121a01:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	arch_irq_unlock(key.key);
  121a05:	8b 44 24 40          	mov    0x40(%esp),%eax
  121a09:	89 44 24 44          	mov    %eax,0x44(%esp)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121a0d:	8b 44 24 44          	mov    0x44(%esp),%eax
  121a11:	25 00 02 00 00       	and    $0x200,%eax
  121a16:	83 f8 00             	cmp    $0x0,%eax
  121a19:	0f 84 01 00 00 00    	je     121a20 <z_tick_get+0xc0>
		__asm__ volatile ("sti" ::: "memory");
  121a1f:	fb                   	sti    
  121a20:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  121a27:	00 
  121a28:	e9 8e ff ff ff       	jmp    1219bb <z_tick_get+0x5b>
	}
	return t;
  121a2d:	8b 44 24 28          	mov    0x28(%esp),%eax
  121a31:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  121a35:	89 ec                	mov    %ebp,%esp
  121a37:	5d                   	pop    %ebp
  121a38:	c3                   	ret    
  121a39:	66 90                	xchg   %ax,%ax
  121a3b:	66 90                	xchg   %ax,%ax
  121a3d:	66 90                	xchg   %ax,%ax
  121a3f:	90                   	nop

00121a40 <z_tick_get_32>:
}

u32_t z_tick_get_32(void)
{
  121a40:	55                   	push   %ebp
  121a41:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
  121a43:	e8 18 ff ff ff       	call   121960 <z_tick_get>
  121a48:	5d                   	pop    %ebp
  121a49:	c3                   	ret    
  121a4a:	66 90                	xchg   %ax,%ax
  121a4c:	66 90                	xchg   %ax,%ax
  121a4e:	66 90                	xchg   %ax,%ax

00121a50 <z_impl_k_uptime_get>:
	return (u32_t)curr_tick;
#endif
}

s64_t z_impl_k_uptime_get(void)
{
  121a50:	55                   	push   %ebp
  121a51:	89 e5                	mov    %esp,%ebp
  121a53:	83 ec 08             	sub    $0x8,%esp
	return k_ticks_to_ms_floor64(z_tick_get());
  121a56:	e8 05 ff ff ff       	call   121960 <z_tick_get>
  121a5b:	89 e1                	mov    %esp,%ecx
  121a5d:	89 51 04             	mov    %edx,0x4(%ecx)
  121a60:	89 01                	mov    %eax,(%ecx)
  121a62:	e8 09 00 00 00       	call   121a70 <k_ticks_to_ms_floor64>
  121a67:	83 c4 08             	add    $0x8,%esp
  121a6a:	5d                   	pop    %ebp
  121a6b:	c3                   	ret    
  121a6c:	66 90                	xchg   %ax,%ax
  121a6e:	66 90                	xchg   %ax,%ax

00121a70 <k_ticks_to_ms_floor64>:
{
  121a70:	55                   	push   %ebp
  121a71:	89 e5                	mov    %esp,%ebp
  121a73:	57                   	push   %edi
  121a74:	56                   	push   %esi
  121a75:	83 e4 f8             	and    $0xfffffff8,%esp
  121a78:	83 ec 78             	sub    $0x78,%esp
  121a7b:	8b 45 08             	mov    0x8(%ebp),%eax
  121a7e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  121a81:	31 d2                	xor    %edx,%edx
  121a83:	89 44 24 40          	mov    %eax,0x40(%esp)
  121a87:	89 4c 24 44          	mov    %ecx,0x44(%esp)
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ms, true, false, false, false);
  121a8b:	8b 44 24 40          	mov    0x40(%esp),%eax
  121a8f:	8b 4c 24 44          	mov    0x44(%esp),%ecx
  121a93:	89 4c 24 6c          	mov    %ecx,0x6c(%esp)
  121a97:	89 44 24 68          	mov    %eax,0x68(%esp)
  121a9b:	c7 44 24 64 64 00 00 	movl   $0x64,0x64(%esp)
  121aa2:	00 
  121aa3:	c7 44 24 60 e8 03 00 	movl   $0x3e8,0x60(%esp)
  121aaa:	00 
  121aab:	c6 44 24 5f 01       	movb   $0x1,0x5f(%esp)
  121ab0:	c6 44 24 5e 00       	movb   $0x0,0x5e(%esp)
  121ab5:	c6 44 24 5d 00       	movb   $0x0,0x5d(%esp)
  121aba:	c6 44 24 5c 00       	movb   $0x0,0x5c(%esp)
	bool mul_ratio = const_hz &&
  121abf:	f6 44 24 5f 01       	testb  $0x1,0x5f(%esp)
  121ac4:	88 54 24 3f          	mov    %dl,0x3f(%esp)
  121ac8:	0f 84 28 00 00 00    	je     121af6 <k_ticks_to_ms_floor64+0x86>
  121ace:	31 c0                	xor    %eax,%eax
		(to_hz > from_hz) && ((to_hz % from_hz) == 0);
  121ad0:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  121ad4:	3b 4c 24 64          	cmp    0x64(%esp),%ecx
  121ad8:	88 44 24 3f          	mov    %al,0x3f(%esp)
  121adc:	0f 86 14 00 00 00    	jbe    121af6 <k_ticks_to_ms_floor64+0x86>
  121ae2:	8b 44 24 60          	mov    0x60(%esp),%eax
  121ae6:	31 d2                	xor    %edx,%edx
  121ae8:	f7 74 24 64          	divl   0x64(%esp)
  121aec:	83 fa 00             	cmp    $0x0,%edx
  121aef:	0f 94 c1             	sete   %cl
  121af2:	88 4c 24 3f          	mov    %cl,0x3f(%esp)
  121af6:	8a 44 24 3f          	mov    0x3f(%esp),%al
  121afa:	31 c9                	xor    %ecx,%ecx
	bool mul_ratio = const_hz &&
  121afc:	24 01                	and    $0x1,%al
  121afe:	88 44 24 5b          	mov    %al,0x5b(%esp)
	bool div_ratio = const_hz &&
  121b02:	f6 44 24 5f 01       	testb  $0x1,0x5f(%esp)
  121b07:	88 4c 24 3e          	mov    %cl,0x3e(%esp)
  121b0b:	0f 84 28 00 00 00    	je     121b39 <k_ticks_to_ms_floor64+0xc9>
  121b11:	31 c0                	xor    %eax,%eax
		(from_hz > to_hz) && ((from_hz % to_hz) == 0);
  121b13:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  121b17:	3b 4c 24 60          	cmp    0x60(%esp),%ecx
  121b1b:	88 44 24 3e          	mov    %al,0x3e(%esp)
  121b1f:	0f 86 14 00 00 00    	jbe    121b39 <k_ticks_to_ms_floor64+0xc9>
  121b25:	8b 44 24 64          	mov    0x64(%esp),%eax
  121b29:	31 d2                	xor    %edx,%edx
  121b2b:	f7 74 24 60          	divl   0x60(%esp)
  121b2f:	83 fa 00             	cmp    $0x0,%edx
  121b32:	0f 94 c1             	sete   %cl
  121b35:	88 4c 24 3e          	mov    %cl,0x3e(%esp)
  121b39:	8a 44 24 3e          	mov    0x3e(%esp),%al
	bool div_ratio = const_hz &&
  121b3d:	24 01                	and    $0x1,%al
  121b3f:	88 44 24 5a          	mov    %al,0x5a(%esp)
	if (from_hz == to_hz) {
  121b43:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  121b47:	3b 4c 24 60          	cmp    0x60(%esp),%ecx
  121b4b:	0f 85 48 00 00 00    	jne    121b99 <k_ticks_to_ms_floor64+0x129>
		return result32 ? ((u32_t)t) : t;
  121b51:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  121b56:	0f 84 13 00 00 00    	je     121b6f <k_ticks_to_ms_floor64+0xff>
  121b5c:	8b 44 24 68          	mov    0x68(%esp),%eax
  121b60:	31 c9                	xor    %ecx,%ecx
  121b62:	89 44 24 38          	mov    %eax,0x38(%esp)
  121b66:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  121b6a:	e9 15 00 00 00       	jmp    121b84 <k_ticks_to_ms_floor64+0x114>
  121b6f:	8b 44 24 68          	mov    0x68(%esp),%eax
  121b73:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  121b77:	89 44 24 38          	mov    %eax,0x38(%esp)
  121b7b:	89 4c 24 34          	mov    %ecx,0x34(%esp)
  121b7f:	e9 00 00 00 00       	jmp    121b84 <k_ticks_to_ms_floor64+0x114>
  121b84:	8b 44 24 34          	mov    0x34(%esp),%eax
  121b88:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  121b8c:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  121b90:	89 44 24 74          	mov    %eax,0x74(%esp)
  121b94:	e9 6b 02 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
	u64_t off = 0;
  121b99:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  121ba0:	00 
  121ba1:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
  121ba8:	00 
	if (!mul_ratio) {
  121ba9:	f6 44 24 5b 01       	testb  $0x1,0x5b(%esp)
  121bae:	0f 85 76 00 00 00    	jne    121c2a <k_ticks_to_ms_floor64+0x1ba>
		u32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
  121bb4:	f6 44 24 5a 01       	testb  $0x1,0x5a(%esp)
  121bb9:	0f 84 13 00 00 00    	je     121bd2 <k_ticks_to_ms_floor64+0x162>
  121bbf:	8b 44 24 64          	mov    0x64(%esp),%eax
  121bc3:	31 d2                	xor    %edx,%edx
  121bc5:	f7 74 24 60          	divl   0x60(%esp)
  121bc9:	89 44 24 30          	mov    %eax,0x30(%esp)
  121bcd:	e9 08 00 00 00       	jmp    121bda <k_ticks_to_ms_floor64+0x16a>
  121bd2:	8b 44 24 64          	mov    0x64(%esp),%eax
  121bd6:	89 44 24 30          	mov    %eax,0x30(%esp)
  121bda:	8b 44 24 30          	mov    0x30(%esp),%eax
  121bde:	89 44 24 4c          	mov    %eax,0x4c(%esp)
		if (round_up) {
  121be2:	f6 44 24 5d 01       	testb  $0x1,0x5d(%esp)
  121be7:	0f 84 16 00 00 00    	je     121c03 <k_ticks_to_ms_floor64+0x193>
			off = rdivisor - 1;
  121bed:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  121bf1:	48                   	dec    %eax
  121bf2:	89 44 24 50          	mov    %eax,0x50(%esp)
  121bf6:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  121bfd:	00 
		} else if (round_off) {
  121bfe:	e9 22 00 00 00       	jmp    121c25 <k_ticks_to_ms_floor64+0x1b5>
  121c03:	f6 44 24 5c 01       	testb  $0x1,0x5c(%esp)
  121c08:	0f 84 12 00 00 00    	je     121c20 <k_ticks_to_ms_floor64+0x1b0>
			off = rdivisor / 2;
  121c0e:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  121c12:	d1 e8                	shr    %eax
  121c14:	89 44 24 50          	mov    %eax,0x50(%esp)
  121c18:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
  121c1f:	00 
  121c20:	e9 00 00 00 00       	jmp    121c25 <k_ticks_to_ms_floor64+0x1b5>
	}
  121c25:	e9 00 00 00 00       	jmp    121c2a <k_ticks_to_ms_floor64+0x1ba>
	if (div_ratio) {
  121c2a:	f6 44 24 5a 01       	testb  $0x1,0x5a(%esp)
  121c2f:	0f 84 ad 00 00 00    	je     121ce2 <k_ticks_to_ms_floor64+0x272>
		t += off;
  121c35:	8b 44 24 50          	mov    0x50(%esp),%eax
  121c39:	8b 4c 24 54          	mov    0x54(%esp),%ecx
  121c3d:	8b 54 24 68          	mov    0x68(%esp),%edx
  121c41:	8b 74 24 6c          	mov    0x6c(%esp),%esi
  121c45:	01 c2                	add    %eax,%edx
  121c47:	11 ce                	adc    %ecx,%esi
  121c49:	89 54 24 68          	mov    %edx,0x68(%esp)
  121c4d:	89 74 24 6c          	mov    %esi,0x6c(%esp)
		if (result32) {
  121c51:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  121c56:	0f 84 43 00 00 00    	je     121c9f <k_ticks_to_ms_floor64+0x22f>
			return ((u32_t)t) / (from_hz / to_hz);
  121c5c:	8b 44 24 68          	mov    0x68(%esp),%eax
  121c60:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  121c64:	8b 54 24 60          	mov    0x60(%esp),%edx
  121c68:	31 f6                	xor    %esi,%esi
  121c6a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  121c6e:	89 c8                	mov    %ecx,%eax
  121c70:	89 54 24 28          	mov    %edx,0x28(%esp)
  121c74:	89 f2                	mov    %esi,%edx
  121c76:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  121c7a:	f7 f1                	div    %ecx
  121c7c:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  121c80:	89 44 24 24          	mov    %eax,0x24(%esp)
  121c84:	89 c8                	mov    %ecx,%eax
  121c86:	89 f2                	mov    %esi,%edx
  121c88:	8b 74 24 24          	mov    0x24(%esp),%esi
  121c8c:	f7 f6                	div    %esi
  121c8e:	89 44 24 70          	mov    %eax,0x70(%esp)
  121c92:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  121c99:	00 
  121c9a:	e9 65 01 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
			return t / (from_hz / to_hz);
  121c9f:	8b 44 24 68          	mov    0x68(%esp),%eax
  121ca3:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  121ca7:	8b 54 24 64          	mov    0x64(%esp),%edx
  121cab:	8b 74 24 60          	mov    0x60(%esp),%esi
  121caf:	31 ff                	xor    %edi,%edi
  121cb1:	89 44 24 20          	mov    %eax,0x20(%esp)
  121cb5:	89 d0                	mov    %edx,%eax
  121cb7:	89 fa                	mov    %edi,%edx
  121cb9:	f7 f6                	div    %esi
  121cbb:	89 e2                	mov    %esp,%edx
  121cbd:	89 42 08             	mov    %eax,0x8(%edx)
  121cc0:	89 4a 04             	mov    %ecx,0x4(%edx)
  121cc3:	8b 44 24 20          	mov    0x20(%esp),%eax
  121cc7:	89 02                	mov    %eax,(%edx)
  121cc9:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  121cd0:	e8 fb e3 fd ff       	call   1000d0 <__udivdi3>
  121cd5:	89 54 24 74          	mov    %edx,0x74(%esp)
  121cd9:	89 44 24 70          	mov    %eax,0x70(%esp)
  121cdd:	e9 22 01 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
	} else if (mul_ratio) {
  121ce2:	f6 44 24 5b 01       	testb  $0x1,0x5b(%esp)
  121ce7:	0f 84 81 00 00 00    	je     121d6e <k_ticks_to_ms_floor64+0x2fe>
		if (result32) {
  121ced:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  121cf2:	0f 84 38 00 00 00    	je     121d30 <k_ticks_to_ms_floor64+0x2c0>
			return ((u32_t)t) * (to_hz / from_hz);
  121cf8:	8b 44 24 68          	mov    0x68(%esp),%eax
  121cfc:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  121d00:	8b 54 24 64          	mov    0x64(%esp),%edx
  121d04:	31 f6                	xor    %esi,%esi
  121d06:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  121d0a:	89 c8                	mov    %ecx,%eax
  121d0c:	89 54 24 18          	mov    %edx,0x18(%esp)
  121d10:	89 f2                	mov    %esi,%edx
  121d12:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  121d16:	f7 f1                	div    %ecx
  121d18:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  121d1c:	0f af c8             	imul   %eax,%ecx
  121d1f:	89 4c 24 70          	mov    %ecx,0x70(%esp)
  121d23:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  121d2a:	00 
  121d2b:	e9 d4 00 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
			return t * (to_hz / from_hz);
  121d30:	8b 44 24 68          	mov    0x68(%esp),%eax
  121d34:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  121d38:	8b 54 24 60          	mov    0x60(%esp),%edx
  121d3c:	8b 74 24 64          	mov    0x64(%esp),%esi
  121d40:	31 ff                	xor    %edi,%edi
  121d42:	89 44 24 14          	mov    %eax,0x14(%esp)
  121d46:	89 d0                	mov    %edx,%eax
  121d48:	89 fa                	mov    %edi,%edx
  121d4a:	f7 f6                	div    %esi
  121d4c:	0f af c8             	imul   %eax,%ecx
  121d4f:	8b 54 24 14          	mov    0x14(%esp),%edx
  121d53:	89 44 24 10          	mov    %eax,0x10(%esp)
  121d57:	89 d0                	mov    %edx,%eax
  121d59:	8b 74 24 10          	mov    0x10(%esp),%esi
  121d5d:	f7 e6                	mul    %esi
  121d5f:	01 ca                	add    %ecx,%edx
  121d61:	89 44 24 70          	mov    %eax,0x70(%esp)
  121d65:	89 54 24 74          	mov    %edx,0x74(%esp)
  121d69:	e9 96 00 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
		if (result32) {
  121d6e:	f6 44 24 5e 01       	testb  $0x1,0x5e(%esp)
  121d73:	0f 84 4a 00 00 00    	je     121dc3 <k_ticks_to_ms_floor64+0x353>
			return (u32_t)((t * to_hz + off) / from_hz);
  121d79:	8b 44 24 68          	mov    0x68(%esp),%eax
  121d7d:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  121d81:	8b 54 24 60          	mov    0x60(%esp),%edx
  121d85:	0f af ca             	imul   %edx,%ecx
  121d88:	f7 e2                	mul    %edx
  121d8a:	01 ca                	add    %ecx,%edx
  121d8c:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  121d90:	8b 74 24 54          	mov    0x54(%esp),%esi
  121d94:	01 c8                	add    %ecx,%eax
  121d96:	11 f2                	adc    %esi,%edx
  121d98:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  121d9c:	89 e6                	mov    %esp,%esi
  121d9e:	89 4e 08             	mov    %ecx,0x8(%esi)
  121da1:	89 06                	mov    %eax,(%esi)
  121da3:	89 56 04             	mov    %edx,0x4(%esi)
  121da6:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  121dad:	e8 1e e3 fd ff       	call   1000d0 <__udivdi3>
  121db2:	89 44 24 70          	mov    %eax,0x70(%esp)
  121db6:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
  121dbd:	00 
  121dbe:	e9 41 00 00 00       	jmp    121e04 <k_ticks_to_ms_floor64+0x394>
			return (t * to_hz + off) / from_hz;
  121dc3:	8b 44 24 68          	mov    0x68(%esp),%eax
  121dc7:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
  121dcb:	8b 54 24 60          	mov    0x60(%esp),%edx
  121dcf:	0f af ca             	imul   %edx,%ecx
  121dd2:	f7 e2                	mul    %edx
  121dd4:	01 ca                	add    %ecx,%edx
  121dd6:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  121dda:	8b 74 24 54          	mov    0x54(%esp),%esi
  121dde:	01 c8                	add    %ecx,%eax
  121de0:	11 f2                	adc    %esi,%edx
  121de2:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  121de6:	89 e6                	mov    %esp,%esi
  121de8:	89 4e 08             	mov    %ecx,0x8(%esi)
  121deb:	89 06                	mov    %eax,(%esi)
  121ded:	89 56 04             	mov    %edx,0x4(%esi)
  121df0:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  121df7:	e8 d4 e2 fd ff       	call   1000d0 <__udivdi3>
  121dfc:	89 54 24 74          	mov    %edx,0x74(%esp)
  121e00:	89 44 24 70          	mov    %eax,0x70(%esp)
}
  121e04:	8b 44 24 70          	mov    0x70(%esp),%eax
  121e08:	8b 54 24 74          	mov    0x74(%esp),%edx
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ms, true, false, false, false);
  121e0c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121e0f:	5e                   	pop    %esi
  121e10:	5f                   	pop    %edi
  121e11:	5d                   	pop    %ebp
  121e12:	c3                   	ret    
  121e13:	66 90                	xchg   %ax,%ax
  121e15:	66 90                	xchg   %ax,%ax
  121e17:	66 90                	xchg   %ax,%ax
  121e19:	66 90                	xchg   %ax,%ax
  121e1b:	66 90                	xchg   %ax,%ax
  121e1d:	66 90                	xchg   %ax,%ax
  121e1f:	90                   	nop

00121e20 <sys_dlist_peek_head>:
{
  121e20:	55                   	push   %ebp
  121e21:	89 e5                	mov    %esp,%ebp
  121e23:	83 ec 0c             	sub    $0xc,%esp
  121e26:	8b 45 08             	mov    0x8(%ebp),%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  121e29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121e2c:	89 0c 24             	mov    %ecx,(%esp)
  121e2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121e32:	e8 29 00 00 00       	call   121e60 <sys_dlist_is_empty>
  121e37:	a8 01                	test   $0x1,%al
  121e39:	0f 85 05 00 00 00    	jne    121e44 <sys_dlist_peek_head+0x24>
  121e3f:	e9 0a 00 00 00       	jmp    121e4e <sys_dlist_peek_head+0x2e>
  121e44:	31 c0                	xor    %eax,%eax
  121e46:	89 45 f8             	mov    %eax,-0x8(%ebp)
  121e49:	e9 08 00 00 00       	jmp    121e56 <sys_dlist_peek_head+0x36>
  121e4e:	8b 45 08             	mov    0x8(%ebp),%eax
  121e51:	8b 00                	mov    (%eax),%eax
  121e53:	89 45 f8             	mov    %eax,-0x8(%ebp)
  121e56:	8b 45 f8             	mov    -0x8(%ebp),%eax
  121e59:	83 c4 0c             	add    $0xc,%esp
  121e5c:	5d                   	pop    %ebp
  121e5d:	c3                   	ret    
  121e5e:	66 90                	xchg   %ax,%ax

00121e60 <sys_dlist_is_empty>:
{
  121e60:	55                   	push   %ebp
  121e61:	89 e5                	mov    %esp,%ebp
  121e63:	50                   	push   %eax
  121e64:	8b 45 08             	mov    0x8(%ebp),%eax
	return list->head == list;
  121e67:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121e6a:	8b 09                	mov    (%ecx),%ecx
  121e6c:	3b 4d 08             	cmp    0x8(%ebp),%ecx
  121e6f:	0f 94 c2             	sete   %dl
  121e72:	80 e2 01             	and    $0x1,%dl
  121e75:	0f b6 ca             	movzbl %dl,%ecx
  121e78:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121e7b:	89 c8                	mov    %ecx,%eax
  121e7d:	83 c4 04             	add    $0x4,%esp
  121e80:	5d                   	pop    %ebp
  121e81:	c3                   	ret    
  121e82:	66 90                	xchg   %ax,%ax
  121e84:	66 90                	xchg   %ax,%ax
  121e86:	66 90                	xchg   %ax,%ax
  121e88:	66 90                	xchg   %ax,%ax
  121e8a:	66 90                	xchg   %ax,%ax
  121e8c:	66 90                	xchg   %ax,%ax
  121e8e:	66 90                	xchg   %ax,%ax

00121e90 <sys_dlist_peek_next>:
{
  121e90:	55                   	push   %ebp
  121e91:	89 e5                	mov    %esp,%ebp
  121e93:	83 ec 0c             	sub    $0xc,%esp
  121e96:	8b 45 0c             	mov    0xc(%ebp),%eax
  121e99:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  121e9c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  121ea0:	0f 84 1a 00 00 00    	je     121ec0 <sys_dlist_peek_next+0x30>
  121ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  121ea9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  121eac:	89 04 24             	mov    %eax,(%esp)
  121eaf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  121eb3:	e8 28 00 00 00       	call   121ee0 <sys_dlist_peek_next_no_check>
  121eb8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121ebb:	e9 0a 00 00 00       	jmp    121eca <sys_dlist_peek_next+0x3a>
  121ec0:	31 c0                	xor    %eax,%eax
  121ec2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121ec5:	e9 00 00 00 00       	jmp    121eca <sys_dlist_peek_next+0x3a>
  121eca:	8b 45 fc             	mov    -0x4(%ebp),%eax
  121ecd:	83 c4 0c             	add    $0xc,%esp
  121ed0:	5d                   	pop    %ebp
  121ed1:	c3                   	ret    
  121ed2:	66 90                	xchg   %ax,%ax
  121ed4:	66 90                	xchg   %ax,%ax
  121ed6:	66 90                	xchg   %ax,%ax
  121ed8:	66 90                	xchg   %ax,%ax
  121eda:	66 90                	xchg   %ax,%ax
  121edc:	66 90                	xchg   %ax,%ax
  121ede:	66 90                	xchg   %ax,%ax

00121ee0 <sys_dlist_peek_next_no_check>:
{
  121ee0:	55                   	push   %ebp
  121ee1:	89 e5                	mov    %esp,%ebp
  121ee3:	56                   	push   %esi
  121ee4:	50                   	push   %eax
  121ee5:	8b 45 0c             	mov    0xc(%ebp),%eax
  121ee8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return (node == list->tail) ? NULL : node->next;
  121eeb:	8b 55 0c             	mov    0xc(%ebp),%edx
  121eee:	8b 75 08             	mov    0x8(%ebp),%esi
  121ef1:	3b 56 04             	cmp    0x4(%esi),%edx
  121ef4:	0f 85 0a 00 00 00    	jne    121f04 <sys_dlist_peek_next_no_check+0x24>
  121efa:	31 c0                	xor    %eax,%eax
  121efc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  121eff:	e9 08 00 00 00       	jmp    121f0c <sys_dlist_peek_next_no_check+0x2c>
  121f04:	8b 45 0c             	mov    0xc(%ebp),%eax
  121f07:	8b 00                	mov    (%eax),%eax
  121f09:	89 45 f8             	mov    %eax,-0x8(%ebp)
  121f0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  121f0f:	83 c4 04             	add    $0x4,%esp
  121f12:	5e                   	pop    %esi
  121f13:	5d                   	pop    %ebp
  121f14:	c3                   	ret    
  121f15:	66 90                	xchg   %ax,%ax
  121f17:	66 90                	xchg   %ax,%ax
  121f19:	66 90                	xchg   %ax,%ax
  121f1b:	66 90                	xchg   %ax,%ax
  121f1d:	66 90                	xchg   %ax,%ax
  121f1f:	90                   	nop

00121f20 <sys_dlist_remove>:
{
  121f20:	55                   	push   %ebp
  121f21:	89 e5                	mov    %esp,%ebp
  121f23:	83 ec 08             	sub    $0x8,%esp
  121f26:	8b 45 08             	mov    0x8(%ebp),%eax
	node->prev->next = node->next;
  121f29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f2c:	8b 09                	mov    (%ecx),%ecx
  121f2e:	8b 55 08             	mov    0x8(%ebp),%edx
  121f31:	8b 52 04             	mov    0x4(%edx),%edx
  121f34:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  121f36:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f39:	8b 49 04             	mov    0x4(%ecx),%ecx
  121f3c:	8b 55 08             	mov    0x8(%ebp),%edx
  121f3f:	8b 12                	mov    (%edx),%edx
  121f41:	89 4a 04             	mov    %ecx,0x4(%edx)
	sys_dnode_init(node);
  121f44:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f47:	89 0c 24             	mov    %ecx,(%esp)
  121f4a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  121f4d:	e8 0e 00 00 00       	call   121f60 <sys_dnode_init>
}
  121f52:	83 c4 08             	add    $0x8,%esp
  121f55:	5d                   	pop    %ebp
  121f56:	c3                   	ret    
  121f57:	66 90                	xchg   %ax,%ax
  121f59:	66 90                	xchg   %ax,%ax
  121f5b:	66 90                	xchg   %ax,%ax
  121f5d:	66 90                	xchg   %ax,%ax
  121f5f:	90                   	nop

00121f60 <sys_dnode_init>:
{
  121f60:	55                   	push   %ebp
  121f61:	89 e5                	mov    %esp,%ebp
  121f63:	8b 45 08             	mov    0x8(%ebp),%eax
	node->next = NULL;
  121f66:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f69:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	node->prev = NULL;
  121f6f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f72:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
}
  121f79:	5d                   	pop    %ebp
  121f7a:	c3                   	ret    
  121f7b:	66 90                	xchg   %ax,%ax
  121f7d:	66 90                	xchg   %ax,%ax
  121f7f:	90                   	nop

00121f80 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  121f80:	55                   	push   %ebp
  121f81:	89 e5                	mov    %esp,%ebp
  121f83:	83 ec 20             	sub    $0x20,%esp
  121f86:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);
  121f89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  121f8c:	89 4d f0             	mov    %ecx,-0x10(%ebp)

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  121f8f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  121f92:	83 79 28 00          	cmpl   $0x0,0x28(%ecx)
  121f96:	0f 8e 1f 00 00 00    	jle    121fbb <z_timer_expiration_handler+0x3b>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  121f9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
			     timer->period);
  121f9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  121fa2:	8b 49 28             	mov    0x28(%ecx),%ecx
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  121fa5:	89 04 24             	mov    %eax,(%esp)
  121fa8:	8d 05 80 1f 12 00    	lea    0x121f80,%eax
  121fae:	89 44 24 04          	mov    %eax,0x4(%esp)
  121fb2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  121fb6:	e8 05 f1 ff ff       	call   1210c0 <z_add_timeout>
	}

	/* update timer's status */
	timer->status += 1U;
  121fbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  121fbe:	8b 48 2c             	mov    0x2c(%eax),%ecx
  121fc1:	83 c1 01             	add    $0x1,%ecx
  121fc4:	89 48 2c             	mov    %ecx,0x2c(%eax)

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  121fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  121fca:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
  121fce:	0f 84 0e 00 00 00    	je     121fe2 <z_timer_expiration_handler+0x62>
		timer->expiry_fn(timer);
  121fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  121fd7:	8b 40 20             	mov    0x20(%eax),%eax
  121fda:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  121fdd:	89 0c 24             	mov    %ecx,(%esp)
  121fe0:	ff d0                	call   *%eax
	}

	thread = z_waitq_head(&timer->wait_q);
  121fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  121fe5:	83 c0 10             	add    $0x10,%eax
  121fe8:	89 04 24             	mov    %eax,(%esp)
  121feb:	e8 70 00 00 00       	call   122060 <z_waitq_head>
  121ff0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (thread == NULL) {
  121ff3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  121ff7:	0f 85 05 00 00 00    	jne    122002 <z_timer_expiration_handler+0x82>
		return;
  121ffd:	e9 4c 00 00 00       	jmp    12204e <z_timer_expiration_handler+0xce>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
  122002:	8b 45 ec             	mov    -0x14(%ebp),%eax
  122005:	89 04 24             	mov    %eax,(%esp)
  122008:	e8 43 c9 ff ff       	call   11e950 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
  12200d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  122010:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (z_is_thread_ready(thread)) {
  122013:	8b 45 f4             	mov    -0xc(%ebp),%eax
  122016:	89 04 24             	mov    %eax,(%esp)
  122019:	e8 e2 06 00 00       	call   122700 <z_is_thread_ready>
  12201e:	a8 01                	test   $0x1,%al
  122020:	0f 85 05 00 00 00    	jne    12202b <z_timer_expiration_handler+0xab>
  122026:	e9 0b 00 00 00       	jmp    122036 <z_timer_expiration_handler+0xb6>
		z_add_thread_to_ready_q(thread);
  12202b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  12202e:	89 04 24             	mov    %eax,(%esp)
  122031:	e8 9a c2 ff ff       	call   11e2d0 <z_add_thread_to_ready_q>

	arch_thread_return_value_set(thread, 0);
  122036:	8b 45 ec             	mov    -0x14(%ebp),%eax
  122039:	89 45 fc             	mov    %eax,-0x4(%ebp)
  12203c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  122043:	8b 45 f8             	mov    -0x8(%ebp),%eax
  122046:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  122049:	8b 49 28             	mov    0x28(%ecx),%ecx
  12204c:	89 01                	mov    %eax,(%ecx)
}
  12204e:	83 c4 20             	add    $0x20,%esp
  122051:	5d                   	pop    %ebp
  122052:	c3                   	ret    
  122053:	66 90                	xchg   %ax,%ax
  122055:	66 90                	xchg   %ax,%ax
  122057:	66 90                	xchg   %ax,%ax
  122059:	66 90                	xchg   %ax,%ax
  12205b:	66 90                	xchg   %ax,%ax
  12205d:	66 90                	xchg   %ax,%ax
  12205f:	90                   	nop

00122060 <z_waitq_head>:
{
  122060:	55                   	push   %ebp
  122061:	89 e5                	mov    %esp,%ebp
  122063:	83 ec 08             	sub    $0x8,%esp
  122066:	8b 45 08             	mov    0x8(%ebp),%eax
	return (struct k_thread *)rb_get_min(&w->waitq.tree);
  122069:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12206c:	89 0c 24             	mov    %ecx,(%esp)
  12206f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  122072:	e8 59 06 00 00       	call   1226d0 <rb_get_min>
  122077:	83 c4 08             	add    $0x8,%esp
  12207a:	5d                   	pop    %ebp
  12207b:	c3                   	ret    
  12207c:	66 90                	xchg   %ax,%ax
  12207e:	66 90                	xchg   %ax,%ax

00122080 <k_timer_init>:


void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
  122080:	55                   	push   %ebp
  122081:	89 e5                	mov    %esp,%ebp
  122083:	57                   	push   %edi
  122084:	56                   	push   %esi
  122085:	83 ec 10             	sub    $0x10,%esp
  122088:	8b 45 10             	mov    0x10(%ebp),%eax
  12208b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  12208e:	8b 55 08             	mov    0x8(%ebp),%edx
	timer->expiry_fn = expiry_fn;
  122091:	8b 75 0c             	mov    0xc(%ebp),%esi
  122094:	8b 7d 08             	mov    0x8(%ebp),%edi
  122097:	89 77 20             	mov    %esi,0x20(%edi)
	timer->stop_fn = stop_fn;
  12209a:	8b 75 10             	mov    0x10(%ebp),%esi
  12209d:	8b 7d 08             	mov    0x8(%ebp),%edi
  1220a0:	89 77 24             	mov    %esi,0x24(%edi)
	timer->status = 0U;
  1220a3:	8b 75 08             	mov    0x8(%ebp),%esi
  1220a6:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)

	z_waitq_init(&timer->wait_q);
  1220ad:	8b 75 08             	mov    0x8(%ebp),%esi
  1220b0:	83 c6 10             	add    $0x10,%esi
  1220b3:	89 34 24             	mov    %esi,(%esp)
  1220b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1220b9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1220bc:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1220bf:	e8 2c 00 00 00       	call   1220f0 <z_waitq_init>
	z_init_timeout(&timer->timeout);
  1220c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1220c7:	89 04 24             	mov    %eax,(%esp)
  1220ca:	e8 71 00 00 00       	call   122140 <z_init_timeout>
	SYS_TRACING_OBJ_INIT(k_timer, timer);
  1220cf:	e9 00 00 00 00       	jmp    1220d4 <k_timer_init+0x54>

	timer->user_data = NULL;
  1220d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1220d7:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)

	z_object_init(timer);
  1220de:	8b 45 08             	mov    0x8(%ebp),%eax
  1220e1:	89 04 24             	mov    %eax,(%esp)
  1220e4:	e8 77 00 00 00       	call   122160 <z_object_init>
}
  1220e9:	83 c4 10             	add    $0x10,%esp
  1220ec:	5e                   	pop    %esi
  1220ed:	5f                   	pop    %edi
  1220ee:	5d                   	pop    %ebp
  1220ef:	c3                   	ret    

001220f0 <z_waitq_init>:
{
  1220f0:	55                   	push   %ebp
  1220f1:	89 e5                	mov    %esp,%ebp
  1220f3:	83 e4 f8             	and    $0xfffffff8,%esp
  1220f6:	83 ec 10             	sub    $0x10,%esp
  1220f9:	8b 45 08             	mov    0x8(%ebp),%eax
	w->waitq = (struct _priq_rb) {
  1220fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
		.tree = {
  1220ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  122106:	8d 15 30 f3 11 00    	lea    0x11f330,%edx
  12210c:	89 54 24 04          	mov    %edx,0x4(%esp)
  122110:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  122117:	00 
	w->waitq = (struct _priq_rb) {
  122118:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  12211f:	00 
  122120:	8b 14 24             	mov    (%esp),%edx
  122123:	89 11                	mov    %edx,(%ecx)
  122125:	8b 54 24 04          	mov    0x4(%esp),%edx
  122129:	89 51 04             	mov    %edx,0x4(%ecx)
  12212c:	8b 54 24 08          	mov    0x8(%esp),%edx
  122130:	89 51 08             	mov    %edx,0x8(%ecx)
  122133:	8b 54 24 0c          	mov    0xc(%esp),%edx
  122137:	89 51 0c             	mov    %edx,0xc(%ecx)
}
  12213a:	89 ec                	mov    %ebp,%esp
  12213c:	5d                   	pop    %ebp
  12213d:	c3                   	ret    
  12213e:	66 90                	xchg   %ax,%ax

00122140 <z_init_timeout>:
{
  122140:	55                   	push   %ebp
  122141:	89 e5                	mov    %esp,%ebp
  122143:	83 ec 08             	sub    $0x8,%esp
  122146:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dnode_init(&t->node);
  122149:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12214c:	89 0c 24             	mov    %ecx,(%esp)
  12214f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  122152:	e8 59 06 00 00       	call   1227b0 <sys_dnode_init>
}
  122157:	83 c4 08             	add    $0x8,%esp
  12215a:	5d                   	pop    %ebp
  12215b:	c3                   	ret    
  12215c:	66 90                	xchg   %ax,%ax
  12215e:	66 90                	xchg   %ax,%ax

00122160 <z_object_init>:
{
  122160:	55                   	push   %ebp
  122161:	89 e5                	mov    %esp,%ebp
  122163:	8b 45 08             	mov    0x8(%ebp),%eax
}
  122166:	5d                   	pop    %ebp
  122167:	c3                   	ret    
  122168:	66 90                	xchg   %ax,%ax
  12216a:	66 90                	xchg   %ax,%ax
  12216c:	66 90                	xchg   %ax,%ax
  12216e:	66 90                	xchg   %ax,%ax

00122170 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
  122170:	55                   	push   %ebp
  122171:	89 e5                	mov    %esp,%ebp
  122173:	56                   	push   %esi
  122174:	83 ec 24             	sub    $0x24,%esp
  122177:	8b 45 10             	mov    0x10(%ebp),%eax
  12217a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  12217d:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
  122180:	8b 75 10             	mov    0x10(%ebp),%esi
  122183:	89 34 24             	mov    %esi,(%esp)
  122186:	89 45 f0             	mov    %eax,-0x10(%ebp)
  122189:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  12218c:	89 55 e8             	mov    %edx,-0x18(%ebp)
  12218f:	e8 5c 00 00 00       	call   1221f0 <k_ms_to_ticks_ceil32>
  122194:	89 45 f8             	mov    %eax,-0x8(%ebp)
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
  122197:	8b 45 0c             	mov    0xc(%ebp),%eax
  12219a:	89 04 24             	mov    %eax,(%esp)
  12219d:	e8 4e 00 00 00       	call   1221f0 <k_ms_to_ticks_ceil32>
  1221a2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	(void)z_abort_timeout(&timer->timeout);
  1221a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1221a8:	89 04 24             	mov    %eax,(%esp)
  1221ab:	e8 a0 f2 ff ff       	call   121450 <z_abort_timeout>
	timer->period = period_in_ticks;
  1221b0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1221b3:	8b 55 08             	mov    0x8(%ebp),%edx
  1221b6:	89 4a 28             	mov    %ecx,0x28(%edx)
	timer->status = 0U;
  1221b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1221bc:	c7 41 2c 00 00 00 00 	movl   $0x0,0x2c(%ecx)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  1221c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
		     duration_in_ticks);
  1221c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  1221c9:	89 0c 24             	mov    %ecx,(%esp)
  1221cc:	8d 0d 80 1f 12 00    	lea    0x121f80,%ecx
  1221d2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1221d6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1221da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1221dd:	e8 de ee ff ff       	call   1210c0 <z_add_timeout>
}
  1221e2:	83 c4 24             	add    $0x24,%esp
  1221e5:	5e                   	pop    %esi
  1221e6:	5d                   	pop    %ebp
  1221e7:	c3                   	ret    
  1221e8:	66 90                	xchg   %ax,%ax
  1221ea:	66 90                	xchg   %ax,%ax
  1221ec:	66 90                	xchg   %ax,%ax
  1221ee:	66 90                	xchg   %ax,%ax

001221f0 <k_ms_to_ticks_ceil32>:
{
  1221f0:	55                   	push   %ebp
  1221f1:	89 e5                	mov    %esp,%ebp
  1221f3:	57                   	push   %edi
  1221f4:	56                   	push   %esi
  1221f5:	83 e4 f8             	and    $0xfffffff8,%esp
  1221f8:	83 ec 70             	sub    $0x70,%esp
  1221fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1221fe:	31 c9                	xor    %ecx,%ecx
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  122200:	8b 55 08             	mov    0x8(%ebp),%edx
  122203:	89 54 24 60          	mov    %edx,0x60(%esp)
  122207:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  12220e:	00 
  12220f:	c7 44 24 5c e8 03 00 	movl   $0x3e8,0x5c(%esp)
  122216:	00 
  122217:	c7 44 24 58 64 00 00 	movl   $0x64,0x58(%esp)
  12221e:	00 
  12221f:	c6 44 24 57 01       	movb   $0x1,0x57(%esp)
  122224:	c6 44 24 56 01       	movb   $0x1,0x56(%esp)
  122229:	c6 44 24 55 01       	movb   $0x1,0x55(%esp)
  12222e:	c6 44 24 54 00       	movb   $0x0,0x54(%esp)
	bool mul_ratio = const_hz &&
  122233:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  122238:	88 4c 24 43          	mov    %cl,0x43(%esp)
  12223c:	0f 84 28 00 00 00    	je     12226a <k_ms_to_ticks_ceil32+0x7a>
  122242:	31 c0                	xor    %eax,%eax
		(to_hz > from_hz) && ((to_hz % from_hz) == 0);
  122244:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  122248:	3b 4c 24 5c          	cmp    0x5c(%esp),%ecx
  12224c:	88 44 24 43          	mov    %al,0x43(%esp)
  122250:	0f 86 14 00 00 00    	jbe    12226a <k_ms_to_ticks_ceil32+0x7a>
  122256:	8b 44 24 58          	mov    0x58(%esp),%eax
  12225a:	31 d2                	xor    %edx,%edx
  12225c:	f7 74 24 5c          	divl   0x5c(%esp)
  122260:	83 fa 00             	cmp    $0x0,%edx
  122263:	0f 94 c1             	sete   %cl
  122266:	88 4c 24 43          	mov    %cl,0x43(%esp)
  12226a:	8a 44 24 43          	mov    0x43(%esp),%al
  12226e:	31 c9                	xor    %ecx,%ecx
	bool mul_ratio = const_hz &&
  122270:	24 01                	and    $0x1,%al
  122272:	88 44 24 53          	mov    %al,0x53(%esp)
	bool div_ratio = const_hz &&
  122276:	f6 44 24 57 01       	testb  $0x1,0x57(%esp)
  12227b:	88 4c 24 42          	mov    %cl,0x42(%esp)
  12227f:	0f 84 28 00 00 00    	je     1222ad <k_ms_to_ticks_ceil32+0xbd>
  122285:	31 c0                	xor    %eax,%eax
		(from_hz > to_hz) && ((from_hz % to_hz) == 0);
  122287:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  12228b:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  12228f:	88 44 24 42          	mov    %al,0x42(%esp)
  122293:	0f 86 14 00 00 00    	jbe    1222ad <k_ms_to_ticks_ceil32+0xbd>
  122299:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  12229d:	31 d2                	xor    %edx,%edx
  12229f:	f7 74 24 58          	divl   0x58(%esp)
  1222a3:	83 fa 00             	cmp    $0x0,%edx
  1222a6:	0f 94 c1             	sete   %cl
  1222a9:	88 4c 24 42          	mov    %cl,0x42(%esp)
  1222ad:	8a 44 24 42          	mov    0x42(%esp),%al
	bool div_ratio = const_hz &&
  1222b1:	24 01                	and    $0x1,%al
  1222b3:	88 44 24 52          	mov    %al,0x52(%esp)
	if (from_hz == to_hz) {
  1222b7:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  1222bb:	3b 4c 24 58          	cmp    0x58(%esp),%ecx
  1222bf:	0f 85 48 00 00 00    	jne    12230d <k_ms_to_ticks_ceil32+0x11d>
		return result32 ? ((u32_t)t) : t;
  1222c5:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  1222ca:	0f 84 13 00 00 00    	je     1222e3 <k_ms_to_ticks_ceil32+0xf3>
  1222d0:	8b 44 24 60          	mov    0x60(%esp),%eax
  1222d4:	31 c9                	xor    %ecx,%ecx
  1222d6:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1222da:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  1222de:	e9 15 00 00 00       	jmp    1222f8 <k_ms_to_ticks_ceil32+0x108>
  1222e3:	8b 44 24 60          	mov    0x60(%esp),%eax
  1222e7:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  1222eb:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  1222ef:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  1222f3:	e9 00 00 00 00       	jmp    1222f8 <k_ms_to_ticks_ceil32+0x108>
  1222f8:	8b 44 24 38          	mov    0x38(%esp),%eax
  1222fc:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  122300:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  122304:	89 44 24 6c          	mov    %eax,0x6c(%esp)
  122308:	e9 6b 02 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
	u64_t off = 0;
  12230d:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  122314:	00 
  122315:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
  12231c:	00 
	if (!mul_ratio) {
  12231d:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  122322:	0f 85 76 00 00 00    	jne    12239e <k_ms_to_ticks_ceil32+0x1ae>
		u32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
  122328:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  12232d:	0f 84 13 00 00 00    	je     122346 <k_ms_to_ticks_ceil32+0x156>
  122333:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  122337:	31 d2                	xor    %edx,%edx
  122339:	f7 74 24 58          	divl   0x58(%esp)
  12233d:	89 44 24 34          	mov    %eax,0x34(%esp)
  122341:	e9 08 00 00 00       	jmp    12234e <k_ms_to_ticks_ceil32+0x15e>
  122346:	8b 44 24 5c          	mov    0x5c(%esp),%eax
  12234a:	89 44 24 34          	mov    %eax,0x34(%esp)
  12234e:	8b 44 24 34          	mov    0x34(%esp),%eax
  122352:	89 44 24 44          	mov    %eax,0x44(%esp)
		if (round_up) {
  122356:	f6 44 24 55 01       	testb  $0x1,0x55(%esp)
  12235b:	0f 84 16 00 00 00    	je     122377 <k_ms_to_ticks_ceil32+0x187>
			off = rdivisor - 1;
  122361:	8b 44 24 44          	mov    0x44(%esp),%eax
  122365:	48                   	dec    %eax
  122366:	89 44 24 48          	mov    %eax,0x48(%esp)
  12236a:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  122371:	00 
		} else if (round_off) {
  122372:	e9 22 00 00 00       	jmp    122399 <k_ms_to_ticks_ceil32+0x1a9>
  122377:	f6 44 24 54 01       	testb  $0x1,0x54(%esp)
  12237c:	0f 84 12 00 00 00    	je     122394 <k_ms_to_ticks_ceil32+0x1a4>
			off = rdivisor / 2;
  122382:	8b 44 24 44          	mov    0x44(%esp),%eax
  122386:	d1 e8                	shr    %eax
  122388:	89 44 24 48          	mov    %eax,0x48(%esp)
  12238c:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
  122393:	00 
  122394:	e9 00 00 00 00       	jmp    122399 <k_ms_to_ticks_ceil32+0x1a9>
	}
  122399:	e9 00 00 00 00       	jmp    12239e <k_ms_to_ticks_ceil32+0x1ae>
	if (div_ratio) {
  12239e:	f6 44 24 52 01       	testb  $0x1,0x52(%esp)
  1223a3:	0f 84 ad 00 00 00    	je     122456 <k_ms_to_ticks_ceil32+0x266>
		t += off;
  1223a9:	8b 44 24 48          	mov    0x48(%esp),%eax
  1223ad:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
  1223b1:	8b 54 24 60          	mov    0x60(%esp),%edx
  1223b5:	8b 74 24 64          	mov    0x64(%esp),%esi
  1223b9:	01 c2                	add    %eax,%edx
  1223bb:	11 ce                	adc    %ecx,%esi
  1223bd:	89 54 24 60          	mov    %edx,0x60(%esp)
  1223c1:	89 74 24 64          	mov    %esi,0x64(%esp)
		if (result32) {
  1223c5:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  1223ca:	0f 84 43 00 00 00    	je     122413 <k_ms_to_ticks_ceil32+0x223>
			return ((u32_t)t) / (from_hz / to_hz);
  1223d0:	8b 44 24 60          	mov    0x60(%esp),%eax
  1223d4:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  1223d8:	8b 54 24 58          	mov    0x58(%esp),%edx
  1223dc:	31 f6                	xor    %esi,%esi
  1223de:	89 44 24 30          	mov    %eax,0x30(%esp)
  1223e2:	89 c8                	mov    %ecx,%eax
  1223e4:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  1223e8:	89 f2                	mov    %esi,%edx
  1223ea:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  1223ee:	f7 f1                	div    %ecx
  1223f0:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  1223f4:	89 44 24 28          	mov    %eax,0x28(%esp)
  1223f8:	89 c8                	mov    %ecx,%eax
  1223fa:	89 f2                	mov    %esi,%edx
  1223fc:	8b 74 24 28          	mov    0x28(%esp),%esi
  122400:	f7 f6                	div    %esi
  122402:	89 44 24 68          	mov    %eax,0x68(%esp)
  122406:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  12240d:	00 
  12240e:	e9 65 01 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
			return t / (from_hz / to_hz);
  122413:	8b 44 24 60          	mov    0x60(%esp),%eax
  122417:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  12241b:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  12241f:	8b 74 24 58          	mov    0x58(%esp),%esi
  122423:	31 ff                	xor    %edi,%edi
  122425:	89 44 24 24          	mov    %eax,0x24(%esp)
  122429:	89 d0                	mov    %edx,%eax
  12242b:	89 fa                	mov    %edi,%edx
  12242d:	f7 f6                	div    %esi
  12242f:	89 e2                	mov    %esp,%edx
  122431:	89 42 08             	mov    %eax,0x8(%edx)
  122434:	89 4a 04             	mov    %ecx,0x4(%edx)
  122437:	8b 44 24 24          	mov    0x24(%esp),%eax
  12243b:	89 02                	mov    %eax,(%edx)
  12243d:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  122444:	e8 87 dc fd ff       	call   1000d0 <__udivdi3>
  122449:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  12244d:	89 44 24 68          	mov    %eax,0x68(%esp)
  122451:	e9 22 01 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
	} else if (mul_ratio) {
  122456:	f6 44 24 53 01       	testb  $0x1,0x53(%esp)
  12245b:	0f 84 81 00 00 00    	je     1224e2 <k_ms_to_ticks_ceil32+0x2f2>
		if (result32) {
  122461:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  122466:	0f 84 38 00 00 00    	je     1224a4 <k_ms_to_ticks_ceil32+0x2b4>
			return ((u32_t)t) * (to_hz / from_hz);
  12246c:	8b 44 24 60          	mov    0x60(%esp),%eax
  122470:	8b 4c 24 58          	mov    0x58(%esp),%ecx
  122474:	8b 54 24 5c          	mov    0x5c(%esp),%edx
  122478:	31 f6                	xor    %esi,%esi
  12247a:	89 44 24 20          	mov    %eax,0x20(%esp)
  12247e:	89 c8                	mov    %ecx,%eax
  122480:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  122484:	89 f2                	mov    %esi,%edx
  122486:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  12248a:	f7 f1                	div    %ecx
  12248c:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  122490:	0f af c8             	imul   %eax,%ecx
  122493:	89 4c 24 68          	mov    %ecx,0x68(%esp)
  122497:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  12249e:	00 
  12249f:	e9 d4 00 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
			return t * (to_hz / from_hz);
  1224a4:	8b 44 24 60          	mov    0x60(%esp),%eax
  1224a8:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  1224ac:	8b 54 24 58          	mov    0x58(%esp),%edx
  1224b0:	8b 74 24 5c          	mov    0x5c(%esp),%esi
  1224b4:	31 ff                	xor    %edi,%edi
  1224b6:	89 44 24 18          	mov    %eax,0x18(%esp)
  1224ba:	89 d0                	mov    %edx,%eax
  1224bc:	89 fa                	mov    %edi,%edx
  1224be:	f7 f6                	div    %esi
  1224c0:	0f af c8             	imul   %eax,%ecx
  1224c3:	8b 54 24 18          	mov    0x18(%esp),%edx
  1224c7:	89 44 24 14          	mov    %eax,0x14(%esp)
  1224cb:	89 d0                	mov    %edx,%eax
  1224cd:	8b 74 24 14          	mov    0x14(%esp),%esi
  1224d1:	f7 e6                	mul    %esi
  1224d3:	01 ca                	add    %ecx,%edx
  1224d5:	89 44 24 68          	mov    %eax,0x68(%esp)
  1224d9:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  1224dd:	e9 96 00 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
		if (result32) {
  1224e2:	f6 44 24 56 01       	testb  $0x1,0x56(%esp)
  1224e7:	0f 84 4a 00 00 00    	je     122537 <k_ms_to_ticks_ceil32+0x347>
			return (u32_t)((t * to_hz + off) / from_hz);
  1224ed:	8b 44 24 60          	mov    0x60(%esp),%eax
  1224f1:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  1224f5:	8b 54 24 58          	mov    0x58(%esp),%edx
  1224f9:	0f af ca             	imul   %edx,%ecx
  1224fc:	f7 e2                	mul    %edx
  1224fe:	01 ca                	add    %ecx,%edx
  122500:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  122504:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  122508:	01 c8                	add    %ecx,%eax
  12250a:	11 f2                	adc    %esi,%edx
  12250c:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  122510:	89 e6                	mov    %esp,%esi
  122512:	89 4e 08             	mov    %ecx,0x8(%esi)
  122515:	89 06                	mov    %eax,(%esi)
  122517:	89 56 04             	mov    %edx,0x4(%esi)
  12251a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  122521:	e8 aa db fd ff       	call   1000d0 <__udivdi3>
  122526:	89 44 24 68          	mov    %eax,0x68(%esp)
  12252a:	c7 44 24 6c 00 00 00 	movl   $0x0,0x6c(%esp)
  122531:	00 
  122532:	e9 41 00 00 00       	jmp    122578 <k_ms_to_ticks_ceil32+0x388>
			return (t * to_hz + off) / from_hz;
  122537:	8b 44 24 60          	mov    0x60(%esp),%eax
  12253b:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  12253f:	8b 54 24 58          	mov    0x58(%esp),%edx
  122543:	0f af ca             	imul   %edx,%ecx
  122546:	f7 e2                	mul    %edx
  122548:	01 ca                	add    %ecx,%edx
  12254a:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  12254e:	8b 74 24 4c          	mov    0x4c(%esp),%esi
  122552:	01 c8                	add    %ecx,%eax
  122554:	11 f2                	adc    %esi,%edx
  122556:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
  12255a:	89 e6                	mov    %esp,%esi
  12255c:	89 4e 08             	mov    %ecx,0x8(%esi)
  12255f:	89 06                	mov    %eax,(%esi)
  122561:	89 56 04             	mov    %edx,0x4(%esi)
  122564:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  12256b:	e8 60 db fd ff       	call   1000d0 <__udivdi3>
  122570:	89 54 24 6c          	mov    %edx,0x6c(%esp)
  122574:	89 44 24 68          	mov    %eax,0x68(%esp)
}
  122578:	8b 44 24 68          	mov    0x68(%esp),%eax
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  12257c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12257f:	5e                   	pop    %esi
  122580:	5f                   	pop    %edi
  122581:	5d                   	pop    %ebp
  122582:	c3                   	ret    
  122583:	66 90                	xchg   %ax,%ax
  122585:	66 90                	xchg   %ax,%ax
  122587:	66 90                	xchg   %ax,%ax
  122589:	66 90                	xchg   %ax,%ax
  12258b:	66 90                	xchg   %ax,%ax
  12258d:	66 90                	xchg   %ax,%ax
  12258f:	90                   	nop

00122590 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  122590:	55                   	push   %ebp
  122591:	89 e5                	mov    %esp,%ebp
  122593:	83 ec 14             	sub    $0x14,%esp
  122596:	8b 45 08             	mov    0x8(%ebp),%eax
	int inactive = z_abort_timeout(&timer->timeout) != 0;
  122599:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12259c:	89 0c 24             	mov    %ecx,(%esp)
  12259f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1225a2:	e8 a9 ee ff ff       	call   121450 <z_abort_timeout>
  1225a7:	83 f8 00             	cmp    $0x0,%eax
  1225aa:	0f 95 c2             	setne  %dl
  1225ad:	80 e2 01             	and    $0x1,%dl
  1225b0:	0f b6 c2             	movzbl %dl,%eax
  1225b3:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (inactive) {
  1225b6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1225ba:	0f 84 05 00 00 00    	je     1225c5 <z_impl_k_timer_stop+0x35>
		return;
  1225c0:	e9 64 00 00 00       	jmp    122629 <z_impl_k_timer_stop+0x99>
	}

	if (timer->stop_fn != NULL) {
  1225c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1225c8:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
  1225cc:	0f 84 0e 00 00 00    	je     1225e0 <z_impl_k_timer_stop+0x50>
		timer->stop_fn(timer);
  1225d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1225d5:	8b 40 24             	mov    0x24(%eax),%eax
  1225d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1225db:	89 0c 24             	mov    %ecx,(%esp)
  1225de:	ff d0                	call   *%eax
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  1225e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1225e3:	83 c0 10             	add    $0x10,%eax
  1225e6:	89 04 24             	mov    %eax,(%esp)
  1225e9:	e8 42 00 00 00       	call   122630 <z_unpend1_no_timeout>
  1225ee:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (pending_thread != NULL) {
  1225f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1225f5:	0f 84 2e 00 00 00    	je     122629 <z_impl_k_timer_stop+0x99>
		z_ready_thread(pending_thread);
  1225fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1225fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (z_is_thread_ready(thread)) {
  122601:	8b 45 fc             	mov    -0x4(%ebp),%eax
  122604:	89 04 24             	mov    %eax,(%esp)
  122607:	e8 f4 00 00 00       	call   122700 <z_is_thread_ready>
  12260c:	a8 01                	test   $0x1,%al
  12260e:	0f 85 05 00 00 00    	jne    122619 <z_impl_k_timer_stop+0x89>
  122614:	e9 0b 00 00 00       	jmp    122624 <z_impl_k_timer_stop+0x94>
		z_add_thread_to_ready_q(thread);
  122619:	8b 45 fc             	mov    -0x4(%ebp),%eax
  12261c:	89 04 24             	mov    %eax,(%esp)
  12261f:	e8 ac bc ff ff       	call   11e2d0 <z_add_thread_to_ready_q>
		z_reschedule_unlocked();
  122624:	e8 57 00 00 00       	call   122680 <z_reschedule_unlocked>
	}
}
  122629:	83 c4 14             	add    $0x14,%esp
  12262c:	5d                   	pop    %ebp
  12262d:	c3                   	ret    
  12262e:	66 90                	xchg   %ax,%ax

00122630 <z_unpend1_no_timeout>:
{
  122630:	55                   	push   %ebp
  122631:	89 e5                	mov    %esp,%ebp
  122633:	83 ec 14             	sub    $0x14,%esp
  122636:	8b 45 08             	mov    0x8(%ebp),%eax
  122639:	31 c9                	xor    %ecx,%ecx
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
  12263b:	8b 55 08             	mov    0x8(%ebp),%edx
  12263e:	89 14 24             	mov    %edx,(%esp)
  122641:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  122648:	00 
  122649:	89 45 f8             	mov    %eax,-0x8(%ebp)
  12264c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  12264f:	e8 ec c1 ff ff       	call   11e840 <z_find_first_thread_to_unpend>
  122654:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (thread != NULL) {
  122657:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  12265b:	0f 84 0b 00 00 00    	je     12266c <z_unpend1_no_timeout+0x3c>
		z_unpend_thread_no_timeout(thread);
  122661:	8b 45 fc             	mov    -0x4(%ebp),%eax
  122664:	89 04 24             	mov    %eax,(%esp)
  122667:	e8 e4 c2 ff ff       	call   11e950 <z_unpend_thread_no_timeout>
	return thread;
  12266c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  12266f:	83 c4 14             	add    $0x14,%esp
  122672:	5d                   	pop    %ebp
  122673:	c3                   	ret    
  122674:	66 90                	xchg   %ax,%ax
  122676:	66 90                	xchg   %ax,%ax
  122678:	66 90                	xchg   %ax,%ax
  12267a:	66 90                	xchg   %ax,%ax
  12267c:	66 90                	xchg   %ax,%ax
  12267e:	66 90                	xchg   %ax,%ax

00122680 <z_reschedule_unlocked>:
{
  122680:	55                   	push   %ebp
  122681:	89 e5                	mov    %esp,%ebp
  122683:	83 ec 08             	sub    $0x8,%esp
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  122686:	9c                   	pushf  
  122687:	fa                   	cli    
  122688:	8f 45 fc             	popl   -0x4(%ebp)
	return key;
  12268b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	(void) z_reschedule_irqlock(arch_irq_lock());
  12268e:	89 04 24             	mov    %eax,(%esp)
  122691:	e8 9a ca ff ff       	call   11f130 <z_reschedule_irqlock>
}
  122696:	83 c4 08             	add    $0x8,%esp
  122699:	5d                   	pop    %ebp
  12269a:	c3                   	ret    
  12269b:	66 90                	xchg   %ax,%ax
  12269d:	66 90                	xchg   %ax,%ax
  12269f:	90                   	nop

001226a0 <z_is_inactive_timeout>:
{
  1226a0:	55                   	push   %ebp
  1226a1:	89 e5                	mov    %esp,%ebp
  1226a3:	83 ec 08             	sub    $0x8,%esp
  1226a6:	8b 45 08             	mov    0x8(%ebp),%eax
	return !sys_dnode_is_linked(&t->node);
  1226a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1226ac:	89 0c 24             	mov    %ecx,(%esp)
  1226af:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1226b2:	e8 19 01 00 00       	call   1227d0 <sys_dnode_is_linked>
  1226b7:	34 ff                	xor    $0xff,%al
  1226b9:	24 01                	and    $0x1,%al
  1226bb:	0f b6 c0             	movzbl %al,%eax
  1226be:	83 c4 08             	add    $0x8,%esp
  1226c1:	5d                   	pop    %ebp
  1226c2:	c3                   	ret    
  1226c3:	66 90                	xchg   %ax,%ax
  1226c5:	66 90                	xchg   %ax,%ax
  1226c7:	66 90                	xchg   %ax,%ax
  1226c9:	66 90                	xchg   %ax,%ax
  1226cb:	66 90                	xchg   %ax,%ax
  1226cd:	66 90                	xchg   %ax,%ax
  1226cf:	90                   	nop

001226d0 <rb_get_min>:
{
  1226d0:	55                   	push   %ebp
  1226d1:	89 e5                	mov    %esp,%ebp
  1226d3:	83 ec 10             	sub    $0x10,%esp
  1226d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1226d9:	31 c9                	xor    %ecx,%ecx
	return z_rb_get_minmax(tree, 0);
  1226db:	8b 55 08             	mov    0x8(%ebp),%edx
  1226de:	89 14 24             	mov    %edx,(%esp)
  1226e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1226e8:	00 
  1226e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1226ec:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1226ef:	e8 6c e9 fd ff       	call   101060 <z_rb_get_minmax>
  1226f4:	83 c4 10             	add    $0x10,%esp
  1226f7:	5d                   	pop    %ebp
  1226f8:	c3                   	ret    
  1226f9:	66 90                	xchg   %ax,%ax
  1226fb:	66 90                	xchg   %ax,%ax
  1226fd:	66 90                	xchg   %ax,%ax
  1226ff:	90                   	nop

00122700 <z_is_thread_ready>:
{
  122700:	55                   	push   %ebp
  122701:	89 e5                	mov    %esp,%ebp
  122703:	83 ec 0c             	sub    $0xc,%esp
  122706:	8b 45 08             	mov    0x8(%ebp),%eax
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  122709:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12270c:	89 0c 24             	mov    %ecx,(%esp)
  12270f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  122712:	e8 39 00 00 00       	call   122750 <z_is_thread_prevented_from_running>
  122717:	24 01                	and    $0x1,%al
  122719:	0f b6 c8             	movzbl %al,%ecx
  12271c:	83 f9 00             	cmp    $0x0,%ecx
  12271f:	b0 01                	mov    $0x1,%al
  122721:	88 45 fb             	mov    %al,-0x5(%ebp)
  122724:	0f 85 0e 00 00 00    	jne    122738 <z_is_thread_ready+0x38>
		 z_is_thread_timeout_active(thread));
  12272a:	8b 45 08             	mov    0x8(%ebp),%eax
  12272d:	89 04 24             	mov    %eax,(%esp)
  122730:	e8 4b 00 00 00       	call   122780 <z_is_thread_timeout_active>
  122735:	88 45 fb             	mov    %al,-0x5(%ebp)
  122738:	8a 45 fb             	mov    -0x5(%ebp),%al
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
  12273b:	34 ff                	xor    $0xff,%al
  12273d:	24 01                	and    $0x1,%al
  12273f:	0f b6 c0             	movzbl %al,%eax
  122742:	83 c4 0c             	add    $0xc,%esp
  122745:	5d                   	pop    %ebp
  122746:	c3                   	ret    
  122747:	66 90                	xchg   %ax,%ax
  122749:	66 90                	xchg   %ax,%ax
  12274b:	66 90                	xchg   %ax,%ax
  12274d:	66 90                	xchg   %ax,%ax
  12274f:	90                   	nop

00122750 <z_is_thread_prevented_from_running>:
{
  122750:	55                   	push   %ebp
  122751:	89 e5                	mov    %esp,%ebp
  122753:	83 ec 08             	sub    $0x8,%esp
  122756:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t state = thread->base.thread_state;
  122759:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12275c:	8a 51 0d             	mov    0xd(%ecx),%dl
  12275f:	88 55 ff             	mov    %dl,-0x1(%ebp)
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  122762:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  122766:	83 e1 1f             	and    $0x1f,%ecx
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
  122769:	83 f9 00             	cmp    $0x0,%ecx
  12276c:	0f 95 c2             	setne  %dl
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
  12276f:	80 e2 01             	and    $0x1,%dl
  122772:	0f b6 ca             	movzbl %dl,%ecx
  122775:	89 45 f8             	mov    %eax,-0x8(%ebp)
  122778:	89 c8                	mov    %ecx,%eax
  12277a:	83 c4 08             	add    $0x8,%esp
  12277d:	5d                   	pop    %ebp
  12277e:	c3                   	ret    
  12277f:	90                   	nop

00122780 <z_is_thread_timeout_active>:
{
  122780:	55                   	push   %ebp
  122781:	89 e5                	mov    %esp,%ebp
  122783:	83 ec 08             	sub    $0x8,%esp
  122786:	8b 45 08             	mov    0x8(%ebp),%eax
	return !z_is_inactive_timeout(&thread->base.timeout);
  122789:	8b 4d 08             	mov    0x8(%ebp),%ecx
  12278c:	83 c1 18             	add    $0x18,%ecx
  12278f:	89 0c 24             	mov    %ecx,(%esp)
  122792:	89 45 fc             	mov    %eax,-0x4(%ebp)
  122795:	e8 06 ff ff ff       	call   1226a0 <z_is_inactive_timeout>
  12279a:	34 ff                	xor    $0xff,%al
  12279c:	24 01                	and    $0x1,%al
  12279e:	0f b6 c0             	movzbl %al,%eax
  1227a1:	83 c4 08             	add    $0x8,%esp
  1227a4:	5d                   	pop    %ebp
  1227a5:	c3                   	ret    
  1227a6:	66 90                	xchg   %ax,%ax
  1227a8:	66 90                	xchg   %ax,%ax
  1227aa:	66 90                	xchg   %ax,%ax
  1227ac:	66 90                	xchg   %ax,%ax
  1227ae:	66 90                	xchg   %ax,%ax

001227b0 <sys_dnode_init>:
{
  1227b0:	55                   	push   %ebp
  1227b1:	89 e5                	mov    %esp,%ebp
  1227b3:	8b 45 08             	mov    0x8(%ebp),%eax
	node->next = NULL;
  1227b6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1227b9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	node->prev = NULL;
  1227bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1227c2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
}
  1227c9:	5d                   	pop    %ebp
  1227ca:	c3                   	ret    
  1227cb:	66 90                	xchg   %ax,%ax
  1227cd:	66 90                	xchg   %ax,%ax
  1227cf:	90                   	nop

001227d0 <sys_dnode_is_linked>:
{
  1227d0:	55                   	push   %ebp
  1227d1:	89 e5                	mov    %esp,%ebp
  1227d3:	50                   	push   %eax
  1227d4:	8b 45 08             	mov    0x8(%ebp),%eax
	return node->next != NULL;
  1227d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1227da:	83 39 00             	cmpl   $0x0,(%ecx)
  1227dd:	0f 95 c2             	setne  %dl
  1227e0:	80 e2 01             	and    $0x1,%dl
  1227e3:	0f b6 ca             	movzbl %dl,%ecx
  1227e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1227e9:	89 c8                	mov    %ecx,%eax
  1227eb:	83 c4 04             	add    $0x4,%esp
  1227ee:	5d                   	pop    %ebp
  1227ef:	c3                   	ret    

001227f0 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
  1227f0:	55                   	push   %ebp
  1227f1:	89 e5                	mov    %esp,%ebp
  1227f3:	50                   	push   %eax
  1227f4:	8b 45 10             	mov    0x10(%ebp),%eax
  1227f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1227fa:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1227fd:	9c                   	pushf  
  1227fe:	fa                   	cli    
  1227ff:	8f 45 fc             	popl   -0x4(%ebp)
#if SMP_FALLBACK
		k_busy_wait(100);
		k_yield();
#else
		(void)arch_irq_lock();
		sys_power_save_idle();
  122802:	e8 19 00 00 00       	call   122820 <sys_power_save_idle>
		IDLE_YIELD_IF_COOP();
  122807:	e9 00 00 00 00       	jmp    12280c <idle+0x1c>
	while (true) {
  12280c:	e9 ec ff ff ff       	jmp    1227fd <idle+0xd>
  122811:	66 90                	xchg   %ax,%ax
  122813:	66 90                	xchg   %ax,%ax
  122815:	66 90                	xchg   %ax,%ax
  122817:	66 90                	xchg   %ax,%ax
  122819:	66 90                	xchg   %ax,%ax
  12281b:	66 90                	xchg   %ax,%ax
  12281d:	66 90                	xchg   %ax,%ax
  12281f:	90                   	nop

00122820 <sys_power_save_idle>:
{
  122820:	55                   	push   %ebp
  122821:	89 e5                	mov    %esp,%ebp
  122823:	83 ec 10             	sub    $0x10,%esp
	s32_t ticks = z_get_next_timeout_expiry();
  122826:	e8 75 ed ff ff       	call   1215a0 <z_get_next_timeout_expiry>
  12282b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
  12282e:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
  122832:	0f 8d 0d 00 00 00    	jge    122845 <sys_power_save_idle+0x25>
  122838:	b8 01 00 00 00       	mov    $0x1,%eax
  12283d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  122840:	e9 06 00 00 00       	jmp    12284b <sys_power_save_idle+0x2b>
  122845:	8b 45 fc             	mov    -0x4(%ebp),%eax
  122848:	89 45 f8             	mov    %eax,-0x8(%ebp)
  12284b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  12284e:	89 04 24             	mov    %eax,(%esp)
  122851:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  122858:	00 
  122859:	e8 f2 ed ff ff       	call   121650 <z_set_timeout_expiry>
	set_kernel_idle_time_in_ticks(ticks);
  12285e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  122861:	89 04 24             	mov    %eax,(%esp)
  122864:	e8 17 00 00 00       	call   122880 <set_kernel_idle_time_in_ticks>
	k_cpu_idle();
  122869:	e8 22 00 00 00       	call   122890 <k_cpu_idle>
}
  12286e:	83 c4 10             	add    $0x10,%esp
  122871:	5d                   	pop    %ebp
  122872:	c3                   	ret    
  122873:	66 90                	xchg   %ax,%ax
  122875:	66 90                	xchg   %ax,%ax
  122877:	66 90                	xchg   %ax,%ax
  122879:	66 90                	xchg   %ax,%ax
  12287b:	66 90                	xchg   %ax,%ax
  12287d:	66 90                	xchg   %ax,%ax
  12287f:	90                   	nop

00122880 <set_kernel_idle_time_in_ticks>:
{
  122880:	55                   	push   %ebp
  122881:	89 e5                	mov    %esp,%ebp
  122883:	8b 45 08             	mov    0x8(%ebp),%eax
}
  122886:	5d                   	pop    %ebp
  122887:	c3                   	ret    
  122888:	66 90                	xchg   %ax,%ax
  12288a:	66 90                	xchg   %ax,%ax
  12288c:	66 90                	xchg   %ax,%ax
  12288e:	66 90                	xchg   %ax,%ax

00122890 <k_cpu_idle>:
{
  122890:	55                   	push   %ebp
  122891:	89 e5                	mov    %esp,%ebp
	arch_cpu_idle();
  122893:	e8 38 54 fe ff       	call   107cd0 <arch_cpu_idle>
}
  122898:	5d                   	pop    %ebp
  122899:	c3                   	ret    
  12289a:	66 90                	xchg   %ax,%ax
  12289c:	66 90                	xchg   %ax,%ax
  12289e:	66 90                	xchg   %ax,%ax

001228a0 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
  1228a0:	55                   	push   %ebp
  1228a1:	89 e5                	mov    %esp,%ebp
#include "ia32_offsets.c"
#endif

GEN_OFFSET_SYM(_thread_arch_t, flags);

GEN_ABS_SYM_END
  1228a3:	5d                   	pop    %ebp
  1228a4:	c3                   	ret    

001228a5 <hpet_isr_irq2_stub>:
  1228a5:	6a 00                	push   $0x0
  1228a7:	68 a0 79 10 00       	push   $0x1079a0
  1228ac:	e9 6f 6f fe ff       	jmp    109820 <_interrupt_enter>

001228b1 <_handle_exc_0_vector_0_stub>:
  1228b1:	6a 00                	push   $0x0
  1228b3:	68 90 9b 10 00       	push   $0x109b90
  1228b8:	e9 23 6f fe ff       	jmp    1097e0 <_exception_enter>

001228bd <_handle_exc_2_vector_2_stub>:
  1228bd:	6a 00                	push   $0x0
  1228bf:	68 70 9f 10 00       	push   $0x109f70
  1228c4:	e9 17 6f fe ff       	jmp    1097e0 <_exception_enter>

001228c9 <_handle_exc_4_vector_4_stub>:
  1228c9:	6a 00                	push   $0x0
  1228cb:	68 90 9f 10 00       	push   $0x109f90
  1228d0:	e9 0b 6f fe ff       	jmp    1097e0 <_exception_enter>

001228d5 <_handle_exc_5_vector_5_stub>:
  1228d5:	6a 00                	push   $0x0
  1228d7:	68 b0 9f 10 00       	push   $0x109fb0
  1228dc:	e9 ff 6e fe ff       	jmp    1097e0 <_exception_enter>

001228e1 <_handle_exc_6_vector_6_stub>:
  1228e1:	6a 00                	push   $0x0
  1228e3:	68 d0 9f 10 00       	push   $0x109fd0
  1228e8:	e9 f3 6e fe ff       	jmp    1097e0 <_exception_enter>

001228ed <_handle_exc_7_vector_7_stub>:
  1228ed:	6a 00                	push   $0x0
  1228ef:	68 f0 9f 10 00       	push   $0x109ff0
  1228f4:	e9 e7 6e fe ff       	jmp    1097e0 <_exception_enter>

001228f9 <_handle_exc_8_vector_8_stub>:
  1228f9:	6a 00                	push   $0x0
  1228fb:	68 10 a0 10 00       	push   $0x10a010
  122900:	e9 db 6e fe ff       	jmp    1097e0 <_exception_enter>

00122905 <_handle_exc_10_vector_10_stub>:
  122905:	68 30 a0 10 00       	push   $0x10a030
  12290a:	e9 d1 6e fe ff       	jmp    1097e0 <_exception_enter>

0012290f <_handle_exc_11_vector_11_stub>:
  12290f:	68 50 a0 10 00       	push   $0x10a050
  122914:	e9 c7 6e fe ff       	jmp    1097e0 <_exception_enter>

00122919 <_handle_exc_12_vector_12_stub>:
  122919:	68 70 a0 10 00       	push   $0x10a070
  12291e:	e9 bd 6e fe ff       	jmp    1097e0 <_exception_enter>

00122923 <_handle_exc_13_vector_13_stub>:
  122923:	68 90 a0 10 00       	push   $0x10a090
  122928:	e9 b3 6e fe ff       	jmp    1097e0 <_exception_enter>

0012292d <_handle_exc_16_vector_16_stub>:
  12292d:	6a 00                	push   $0x0
  12292f:	68 b0 a0 10 00       	push   $0x10a0b0
  122934:	e9 a7 6e fe ff       	jmp    1097e0 <_exception_enter>

00122939 <_handle_exc_17_vector_17_stub>:
  122939:	68 d0 a0 10 00       	push   $0x10a0d0
  12293e:	e9 9d 6e fe ff       	jmp    1097e0 <_exception_enter>

00122943 <_handle_exc_18_vector_18_stub>:
  122943:	6a 00                	push   $0x0
  122945:	68 f0 a0 10 00       	push   $0x10a0f0
  12294a:	e9 91 6e fe ff       	jmp    1097e0 <_exception_enter>

0012294f <_z_x86_page_fault_handler_vector_14_stub>:
  12294f:	68 e0 82 10 00       	push   $0x1082e0
  122954:	e9 87 6e fe ff       	jmp    1097e0 <_exception_enter>
  122959:	66 90                	xchg   %ax,%ax
  12295b:	66 90                	xchg   %ax,%ax
  12295d:	66 90                	xchg   %ax,%ax
  12295f:	66 90                	xchg   %ax,%ax
  122961:	66 90                	xchg   %ax,%ax
  122963:	66 90                	xchg   %ax,%ax
  122965:	66 90                	xchg   %ax,%ax
  122967:	66 90                	xchg   %ax,%ax
  122969:	66 90                	xchg   %ax,%ax
  12296b:	66 90                	xchg   %ax,%ax
  12296d:	66 90                	xchg   %ax,%ax
  12296f:	66 90                	xchg   %ax,%ax
  122971:	66 90                	xchg   %ax,%ax
  122973:	66 90                	xchg   %ax,%ax
  122975:	66 90                	xchg   %ax,%ax
  122977:	66 90                	xchg   %ax,%ax
  122979:	66 90                	xchg   %ax,%ax
  12297b:	66 90                	xchg   %ax,%ax
  12297d:	66 90                	xchg   %ax,%ax
  12297f:	66 90                	xchg   %ax,%ax
  122981:	66 90                	xchg   %ax,%ax
  122983:	66 90                	xchg   %ax,%ax
  122985:	66 90                	xchg   %ax,%ax
  122987:	66 90                	xchg   %ax,%ax
  122989:	66 90                	xchg   %ax,%ax
  12298b:	66 90                	xchg   %ax,%ax
  12298d:	66 90                	xchg   %ax,%ax
  12298f:	66 90                	xchg   %ax,%ax
  122991:	66 90                	xchg   %ax,%ax
  122993:	66 90                	xchg   %ax,%ax
  122995:	66 90                	xchg   %ax,%ax
  122997:	66 90                	xchg   %ax,%ax
  122999:	66 90                	xchg   %ax,%ax
  12299b:	66 90                	xchg   %ax,%ax
  12299d:	66 90                	xchg   %ax,%ax
  12299f:	66 90                	xchg   %ax,%ax
  1229a1:	66 90                	xchg   %ax,%ax
  1229a3:	66 90                	xchg   %ax,%ax
  1229a5:	66 90                	xchg   %ax,%ax
  1229a7:	66 90                	xchg   %ax,%ax
  1229a9:	66 90                	xchg   %ax,%ax
  1229ab:	66 90                	xchg   %ax,%ax
  1229ad:	66 90                	xchg   %ax,%ax
  1229af:	66 90                	xchg   %ax,%ax
  1229b1:	66 90                	xchg   %ax,%ax
  1229b3:	66 90                	xchg   %ax,%ax
  1229b5:	66 90                	xchg   %ax,%ax
  1229b7:	66 90                	xchg   %ax,%ax
  1229b9:	66 90                	xchg   %ax,%ax
  1229bb:	66 90                	xchg   %ax,%ax
  1229bd:	66 90                	xchg   %ax,%ax
  1229bf:	66 90                	xchg   %ax,%ax
  1229c1:	66 90                	xchg   %ax,%ax
  1229c3:	66 90                	xchg   %ax,%ax
  1229c5:	66 90                	xchg   %ax,%ax
  1229c7:	66 90                	xchg   %ax,%ax
  1229c9:	66 90                	xchg   %ax,%ax
  1229cb:	66 90                	xchg   %ax,%ax
  1229cd:	66 90                	xchg   %ax,%ax
  1229cf:	66 90                	xchg   %ax,%ax
  1229d1:	66 90                	xchg   %ax,%ax
  1229d3:	66 90                	xchg   %ax,%ax
  1229d5:	66 90                	xchg   %ax,%ax
  1229d7:	66 90                	xchg   %ax,%ax
  1229d9:	66 90                	xchg   %ax,%ax
  1229db:	66 90                	xchg   %ax,%ax
  1229dd:	66 90                	xchg   %ax,%ax
  1229df:	66 90                	xchg   %ax,%ax
  1229e1:	66 90                	xchg   %ax,%ax
  1229e3:	66 90                	xchg   %ax,%ax
  1229e5:	66 90                	xchg   %ax,%ax
  1229e7:	66 90                	xchg   %ax,%ax
  1229e9:	66 90                	xchg   %ax,%ax
  1229eb:	66 90                	xchg   %ax,%ax
  1229ed:	66 90                	xchg   %ax,%ax
  1229ef:	66 90                	xchg   %ax,%ax
  1229f1:	66 90                	xchg   %ax,%ax
  1229f3:	66 90                	xchg   %ax,%ax
  1229f5:	66 90                	xchg   %ax,%ax
  1229f7:	66 90                	xchg   %ax,%ax
  1229f9:	66 90                	xchg   %ax,%ax
  1229fb:	66 90                	xchg   %ax,%ax
  1229fd:	66 90                	xchg   %ax,%ax
  1229ff:	66 90                	xchg   %ax,%ax
  122a01:	66 90                	xchg   %ax,%ax
  122a03:	66 90                	xchg   %ax,%ax
  122a05:	66 90                	xchg   %ax,%ax
  122a07:	66 90                	xchg   %ax,%ax
  122a09:	66 90                	xchg   %ax,%ax
  122a0b:	66 90                	xchg   %ax,%ax
  122a0d:	66 90                	xchg   %ax,%ax
  122a0f:	66 90                	xchg   %ax,%ax
  122a11:	66 90                	xchg   %ax,%ax
  122a13:	66 90                	xchg   %ax,%ax
  122a15:	66 90                	xchg   %ax,%ax
  122a17:	66 90                	xchg   %ax,%ax
  122a19:	66 90                	xchg   %ax,%ax
  122a1b:	66 90                	xchg   %ax,%ax
  122a1d:	66 90                	xchg   %ax,%ax
  122a1f:	66 90                	xchg   %ax,%ax
  122a21:	66 90                	xchg   %ax,%ax
  122a23:	66 90                	xchg   %ax,%ax
  122a25:	66 90                	xchg   %ax,%ax
  122a27:	66 90                	xchg   %ax,%ax
  122a29:	66 90                	xchg   %ax,%ax
  122a2b:	66 90                	xchg   %ax,%ax
  122a2d:	66 90                	xchg   %ax,%ax
  122a2f:	66 90                	xchg   %ax,%ax
  122a31:	66 90                	xchg   %ax,%ax
  122a33:	66 90                	xchg   %ax,%ax
  122a35:	66 90                	xchg   %ax,%ax
  122a37:	66 90                	xchg   %ax,%ax
  122a39:	66 90                	xchg   %ax,%ax
  122a3b:	66 90                	xchg   %ax,%ax
  122a3d:	66 90                	xchg   %ax,%ax
  122a3f:	66 90                	xchg   %ax,%ax
  122a41:	66 90                	xchg   %ax,%ax
  122a43:	66 90                	xchg   %ax,%ax
  122a45:	66 90                	xchg   %ax,%ax
  122a47:	66 90                	xchg   %ax,%ax
  122a49:	66 90                	xchg   %ax,%ax
  122a4b:	66 90                	xchg   %ax,%ax
  122a4d:	66 90                	xchg   %ax,%ax
  122a4f:	66 90                	xchg   %ax,%ax
  122a51:	66 90                	xchg   %ax,%ax
  122a53:	66 90                	xchg   %ax,%ax
  122a55:	66 90                	xchg   %ax,%ax
  122a57:	66 90                	xchg   %ax,%ax
  122a59:	66 90                	xchg   %ax,%ax
  122a5b:	66 90                	xchg   %ax,%ax
  122a5d:	66 90                	xchg   %ax,%ax
  122a5f:	66 90                	xchg   %ax,%ax
  122a61:	66 90                	xchg   %ax,%ax
  122a63:	66 90                	xchg   %ax,%ax
  122a65:	66 90                	xchg   %ax,%ax
  122a67:	66 90                	xchg   %ax,%ax
  122a69:	66 90                	xchg   %ax,%ax
  122a6b:	66 90                	xchg   %ax,%ax
  122a6d:	66 90                	xchg   %ax,%ax
  122a6f:	66 90                	xchg   %ax,%ax
  122a71:	66 90                	xchg   %ax,%ax
  122a73:	66 90                	xchg   %ax,%ax
  122a75:	66 90                	xchg   %ax,%ax
  122a77:	66 90                	xchg   %ax,%ax
  122a79:	66 90                	xchg   %ax,%ax
  122a7b:	66 90                	xchg   %ax,%ax
  122a7d:	66 90                	xchg   %ax,%ax
  122a7f:	66 90                	xchg   %ax,%ax
  122a81:	66 90                	xchg   %ax,%ax
  122a83:	66 90                	xchg   %ax,%ax
  122a85:	66 90                	xchg   %ax,%ax
  122a87:	66 90                	xchg   %ax,%ax
  122a89:	66 90                	xchg   %ax,%ax
  122a8b:	66 90                	xchg   %ax,%ax
  122a8d:	66 90                	xchg   %ax,%ax
  122a8f:	66 90                	xchg   %ax,%ax
  122a91:	66 90                	xchg   %ax,%ax
  122a93:	66 90                	xchg   %ax,%ax
  122a95:	66 90                	xchg   %ax,%ax
  122a97:	66 90                	xchg   %ax,%ax
  122a99:	66 90                	xchg   %ax,%ax
  122a9b:	66 90                	xchg   %ax,%ax
  122a9d:	66 90                	xchg   %ax,%ax
  122a9f:	66 90                	xchg   %ax,%ax
  122aa1:	66 90                	xchg   %ax,%ax
  122aa3:	66 90                	xchg   %ax,%ax
  122aa5:	66 90                	xchg   %ax,%ax
  122aa7:	66 90                	xchg   %ax,%ax
  122aa9:	66 90                	xchg   %ax,%ax
  122aab:	66 90                	xchg   %ax,%ax
  122aad:	66 90                	xchg   %ax,%ax
  122aaf:	66 90                	xchg   %ax,%ax
  122ab1:	66 90                	xchg   %ax,%ax
  122ab3:	66 90                	xchg   %ax,%ax
  122ab5:	66 90                	xchg   %ax,%ax
  122ab7:	66 90                	xchg   %ax,%ax
  122ab9:	66 90                	xchg   %ax,%ax
  122abb:	66 90                	xchg   %ax,%ax
  122abd:	66 90                	xchg   %ax,%ax
  122abf:	66 90                	xchg   %ax,%ax
  122ac1:	66 90                	xchg   %ax,%ax
  122ac3:	66 90                	xchg   %ax,%ax
  122ac5:	66 90                	xchg   %ax,%ax
  122ac7:	66 90                	xchg   %ax,%ax
  122ac9:	66 90                	xchg   %ax,%ax
  122acb:	66 90                	xchg   %ax,%ax
  122acd:	66 90                	xchg   %ax,%ax
  122acf:	66 90                	xchg   %ax,%ax
  122ad1:	66 90                	xchg   %ax,%ax
  122ad3:	66 90                	xchg   %ax,%ax
  122ad5:	66 90                	xchg   %ax,%ax
  122ad7:	66 90                	xchg   %ax,%ax
  122ad9:	66 90                	xchg   %ax,%ax
  122adb:	66 90                	xchg   %ax,%ax
  122add:	66 90                	xchg   %ax,%ax
  122adf:	66 90                	xchg   %ax,%ax
  122ae1:	66 90                	xchg   %ax,%ax
  122ae3:	66 90                	xchg   %ax,%ax
  122ae5:	66 90                	xchg   %ax,%ax
  122ae7:	66 90                	xchg   %ax,%ax
  122ae9:	66 90                	xchg   %ax,%ax
  122aeb:	66 90                	xchg   %ax,%ax
  122aed:	66 90                	xchg   %ax,%ax
  122aef:	66 90                	xchg   %ax,%ax
  122af1:	66 90                	xchg   %ax,%ax
  122af3:	66 90                	xchg   %ax,%ax
  122af5:	66 90                	xchg   %ax,%ax
  122af7:	66 90                	xchg   %ax,%ax
  122af9:	66 90                	xchg   %ax,%ax
  122afb:	66 90                	xchg   %ax,%ax
  122afd:	66 90                	xchg   %ax,%ax
  122aff:	66 90                	xchg   %ax,%ax
  122b01:	66 90                	xchg   %ax,%ax
  122b03:	66 90                	xchg   %ax,%ax
  122b05:	66 90                	xchg   %ax,%ax
  122b07:	66 90                	xchg   %ax,%ax
  122b09:	66 90                	xchg   %ax,%ax
  122b0b:	66 90                	xchg   %ax,%ax
  122b0d:	66 90                	xchg   %ax,%ax
  122b0f:	66 90                	xchg   %ax,%ax
  122b11:	66 90                	xchg   %ax,%ax
  122b13:	66 90                	xchg   %ax,%ax
  122b15:	66 90                	xchg   %ax,%ax
  122b17:	66 90                	xchg   %ax,%ax
  122b19:	66 90                	xchg   %ax,%ax
  122b1b:	66 90                	xchg   %ax,%ax
  122b1d:	66 90                	xchg   %ax,%ax
  122b1f:	66 90                	xchg   %ax,%ax
  122b21:	66 90                	xchg   %ax,%ax
  122b23:	66 90                	xchg   %ax,%ax
  122b25:	66 90                	xchg   %ax,%ax
  122b27:	66 90                	xchg   %ax,%ax
  122b29:	66 90                	xchg   %ax,%ax
  122b2b:	66 90                	xchg   %ax,%ax
  122b2d:	66 90                	xchg   %ax,%ax
  122b2f:	66 90                	xchg   %ax,%ax
  122b31:	66 90                	xchg   %ax,%ax
  122b33:	66 90                	xchg   %ax,%ax
  122b35:	66 90                	xchg   %ax,%ax
  122b37:	66 90                	xchg   %ax,%ax
  122b39:	66 90                	xchg   %ax,%ax
  122b3b:	66 90                	xchg   %ax,%ax
  122b3d:	66 90                	xchg   %ax,%ax
  122b3f:	66 90                	xchg   %ax,%ax
  122b41:	66 90                	xchg   %ax,%ax
  122b43:	66 90                	xchg   %ax,%ax
  122b45:	66 90                	xchg   %ax,%ax
  122b47:	66 90                	xchg   %ax,%ax
  122b49:	66 90                	xchg   %ax,%ax
  122b4b:	66 90                	xchg   %ax,%ax
  122b4d:	66 90                	xchg   %ax,%ax
  122b4f:	66 90                	xchg   %ax,%ax
  122b51:	66 90                	xchg   %ax,%ax
  122b53:	66 90                	xchg   %ax,%ax
  122b55:	66 90                	xchg   %ax,%ax
  122b57:	66 90                	xchg   %ax,%ax
  122b59:	66 90                	xchg   %ax,%ax
  122b5b:	66 90                	xchg   %ax,%ax
  122b5d:	66 90                	xchg   %ax,%ax
  122b5f:	66 90                	xchg   %ax,%ax
  122b61:	66 90                	xchg   %ax,%ax
  122b63:	66 90                	xchg   %ax,%ax
  122b65:	66 90                	xchg   %ax,%ax
  122b67:	66 90                	xchg   %ax,%ax
  122b69:	66 90                	xchg   %ax,%ax
  122b6b:	66 90                	xchg   %ax,%ax
  122b6d:	66 90                	xchg   %ax,%ax
  122b6f:	66 90                	xchg   %ax,%ax
  122b71:	66 90                	xchg   %ax,%ax
  122b73:	66 90                	xchg   %ax,%ax
  122b75:	66 90                	xchg   %ax,%ax
  122b77:	66 90                	xchg   %ax,%ax
  122b79:	66 90                	xchg   %ax,%ax
  122b7b:	66 90                	xchg   %ax,%ax
  122b7d:	66 90                	xchg   %ax,%ax
  122b7f:	66 90                	xchg   %ax,%ax
  122b81:	66 90                	xchg   %ax,%ax
  122b83:	66 90                	xchg   %ax,%ax
  122b85:	66 90                	xchg   %ax,%ax
  122b87:	66 90                	xchg   %ax,%ax
  122b89:	66 90                	xchg   %ax,%ax
  122b8b:	66 90                	xchg   %ax,%ax
  122b8d:	66 90                	xchg   %ax,%ax
  122b8f:	66 90                	xchg   %ax,%ax
  122b91:	66 90                	xchg   %ax,%ax
  122b93:	66 90                	xchg   %ax,%ax
  122b95:	66 90                	xchg   %ax,%ax
  122b97:	66 90                	xchg   %ax,%ax
  122b99:	66 90                	xchg   %ax,%ax
  122b9b:	66 90                	xchg   %ax,%ax
  122b9d:	66 90                	xchg   %ax,%ax
  122b9f:	66 90                	xchg   %ax,%ax
  122ba1:	66 90                	xchg   %ax,%ax
  122ba3:	66 90                	xchg   %ax,%ax
  122ba5:	66 90                	xchg   %ax,%ax
  122ba7:	66 90                	xchg   %ax,%ax
  122ba9:	66 90                	xchg   %ax,%ax
  122bab:	66 90                	xchg   %ax,%ax
  122bad:	66 90                	xchg   %ax,%ax
  122baf:	66 90                	xchg   %ax,%ax
  122bb1:	66 90                	xchg   %ax,%ax
  122bb3:	66 90                	xchg   %ax,%ax
  122bb5:	66 90                	xchg   %ax,%ax
  122bb7:	66 90                	xchg   %ax,%ax
  122bb9:	66 90                	xchg   %ax,%ax
  122bbb:	66 90                	xchg   %ax,%ax
  122bbd:	66 90                	xchg   %ax,%ax
  122bbf:	66 90                	xchg   %ax,%ax
  122bc1:	66 90                	xchg   %ax,%ax
  122bc3:	66 90                	xchg   %ax,%ax
  122bc5:	66 90                	xchg   %ax,%ax
  122bc7:	66 90                	xchg   %ax,%ax
  122bc9:	66 90                	xchg   %ax,%ax
  122bcb:	66 90                	xchg   %ax,%ax
  122bcd:	66 90                	xchg   %ax,%ax
  122bcf:	66 90                	xchg   %ax,%ax
  122bd1:	66 90                	xchg   %ax,%ax
  122bd3:	66 90                	xchg   %ax,%ax
  122bd5:	66 90                	xchg   %ax,%ax
  122bd7:	66 90                	xchg   %ax,%ax
  122bd9:	66 90                	xchg   %ax,%ax
  122bdb:	66 90                	xchg   %ax,%ax
  122bdd:	66 90                	xchg   %ax,%ax
  122bdf:	66 90                	xchg   %ax,%ax
  122be1:	66 90                	xchg   %ax,%ax
  122be3:	66 90                	xchg   %ax,%ax
  122be5:	66 90                	xchg   %ax,%ax
  122be7:	66 90                	xchg   %ax,%ax
  122be9:	66 90                	xchg   %ax,%ax
  122beb:	66 90                	xchg   %ax,%ax
  122bed:	66 90                	xchg   %ax,%ax
  122bef:	66 90                	xchg   %ax,%ax
  122bf1:	66 90                	xchg   %ax,%ax
  122bf3:	66 90                	xchg   %ax,%ax
  122bf5:	66 90                	xchg   %ax,%ax
  122bf7:	66 90                	xchg   %ax,%ax
  122bf9:	66 90                	xchg   %ax,%ax
  122bfb:	66 90                	xchg   %ax,%ax
  122bfd:	66 90                	xchg   %ax,%ax
  122bff:	66 90                	xchg   %ax,%ax
  122c01:	66 90                	xchg   %ax,%ax
  122c03:	66 90                	xchg   %ax,%ax
  122c05:	66 90                	xchg   %ax,%ax
  122c07:	66 90                	xchg   %ax,%ax
  122c09:	66 90                	xchg   %ax,%ax
  122c0b:	66 90                	xchg   %ax,%ax
  122c0d:	66 90                	xchg   %ax,%ax
  122c0f:	66 90                	xchg   %ax,%ax
  122c11:	66 90                	xchg   %ax,%ax
  122c13:	66 90                	xchg   %ax,%ax
  122c15:	66 90                	xchg   %ax,%ax
  122c17:	66 90                	xchg   %ax,%ax
  122c19:	66 90                	xchg   %ax,%ax
  122c1b:	66 90                	xchg   %ax,%ax
  122c1d:	66 90                	xchg   %ax,%ax
  122c1f:	66 90                	xchg   %ax,%ax
  122c21:	66 90                	xchg   %ax,%ax
  122c23:	66 90                	xchg   %ax,%ax
  122c25:	66 90                	xchg   %ax,%ax
  122c27:	66 90                	xchg   %ax,%ax
  122c29:	66 90                	xchg   %ax,%ax
  122c2b:	66 90                	xchg   %ax,%ax
  122c2d:	66 90                	xchg   %ax,%ax
  122c2f:	66 90                	xchg   %ax,%ax
  122c31:	66 90                	xchg   %ax,%ax
  122c33:	66 90                	xchg   %ax,%ax
  122c35:	66 90                	xchg   %ax,%ax
  122c37:	66 90                	xchg   %ax,%ax
  122c39:	66 90                	xchg   %ax,%ax
  122c3b:	66 90                	xchg   %ax,%ax
  122c3d:	66 90                	xchg   %ax,%ax
  122c3f:	66 90                	xchg   %ax,%ax
  122c41:	66 90                	xchg   %ax,%ax
  122c43:	66 90                	xchg   %ax,%ax
  122c45:	66 90                	xchg   %ax,%ax
  122c47:	66 90                	xchg   %ax,%ax
  122c49:	66 90                	xchg   %ax,%ax
  122c4b:	66 90                	xchg   %ax,%ax
  122c4d:	66 90                	xchg   %ax,%ax
  122c4f:	66 90                	xchg   %ax,%ax
  122c51:	66 90                	xchg   %ax,%ax
  122c53:	66 90                	xchg   %ax,%ax
  122c55:	66 90                	xchg   %ax,%ax
  122c57:	66 90                	xchg   %ax,%ax
  122c59:	66 90                	xchg   %ax,%ax
  122c5b:	66 90                	xchg   %ax,%ax
  122c5d:	66 90                	xchg   %ax,%ax
  122c5f:	66 90                	xchg   %ax,%ax
  122c61:	66 90                	xchg   %ax,%ax
  122c63:	66 90                	xchg   %ax,%ax
  122c65:	66 90                	xchg   %ax,%ax
  122c67:	66 90                	xchg   %ax,%ax
  122c69:	66 90                	xchg   %ax,%ax
  122c6b:	66 90                	xchg   %ax,%ax
  122c6d:	66 90                	xchg   %ax,%ax
  122c6f:	66 90                	xchg   %ax,%ax
  122c71:	66 90                	xchg   %ax,%ax
  122c73:	66 90                	xchg   %ax,%ax
  122c75:	66 90                	xchg   %ax,%ax
  122c77:	66 90                	xchg   %ax,%ax
  122c79:	66 90                	xchg   %ax,%ax
  122c7b:	66 90                	xchg   %ax,%ax
  122c7d:	66 90                	xchg   %ax,%ax
  122c7f:	66 90                	xchg   %ax,%ax
  122c81:	66 90                	xchg   %ax,%ax
  122c83:	66 90                	xchg   %ax,%ax
  122c85:	66 90                	xchg   %ax,%ax
  122c87:	66 90                	xchg   %ax,%ax
  122c89:	66 90                	xchg   %ax,%ax
  122c8b:	66 90                	xchg   %ax,%ax
  122c8d:	66 90                	xchg   %ax,%ax
  122c8f:	66 90                	xchg   %ax,%ax
  122c91:	66 90                	xchg   %ax,%ax
  122c93:	66 90                	xchg   %ax,%ax
  122c95:	66 90                	xchg   %ax,%ax
  122c97:	66 90                	xchg   %ax,%ax
  122c99:	66 90                	xchg   %ax,%ax
  122c9b:	66 90                	xchg   %ax,%ax
  122c9d:	66 90                	xchg   %ax,%ax
  122c9f:	66 90                	xchg   %ax,%ax
  122ca1:	66 90                	xchg   %ax,%ax
  122ca3:	66 90                	xchg   %ax,%ax
  122ca5:	66 90                	xchg   %ax,%ax
  122ca7:	66 90                	xchg   %ax,%ax
  122ca9:	66 90                	xchg   %ax,%ax
  122cab:	66 90                	xchg   %ax,%ax
  122cad:	66 90                	xchg   %ax,%ax
  122caf:	66 90                	xchg   %ax,%ax
  122cb1:	66 90                	xchg   %ax,%ax
  122cb3:	66 90                	xchg   %ax,%ax
  122cb5:	66 90                	xchg   %ax,%ax
  122cb7:	66 90                	xchg   %ax,%ax
  122cb9:	66 90                	xchg   %ax,%ax
  122cbb:	66 90                	xchg   %ax,%ax
  122cbd:	66 90                	xchg   %ax,%ax
  122cbf:	66 90                	xchg   %ax,%ax
  122cc1:	66 90                	xchg   %ax,%ax
  122cc3:	66 90                	xchg   %ax,%ax
  122cc5:	66 90                	xchg   %ax,%ax
  122cc7:	66 90                	xchg   %ax,%ax
  122cc9:	66 90                	xchg   %ax,%ax
  122ccb:	66 90                	xchg   %ax,%ax
  122ccd:	66 90                	xchg   %ax,%ax
  122ccf:	66 90                	xchg   %ax,%ax
  122cd1:	66 90                	xchg   %ax,%ax
  122cd3:	66 90                	xchg   %ax,%ax
  122cd5:	66 90                	xchg   %ax,%ax
  122cd7:	66 90                	xchg   %ax,%ax
  122cd9:	66 90                	xchg   %ax,%ax
  122cdb:	66 90                	xchg   %ax,%ax
  122cdd:	66 90                	xchg   %ax,%ax
  122cdf:	66 90                	xchg   %ax,%ax
  122ce1:	66 90                	xchg   %ax,%ax
  122ce3:	66 90                	xchg   %ax,%ax
  122ce5:	66 90                	xchg   %ax,%ax
  122ce7:	66 90                	xchg   %ax,%ax
  122ce9:	66 90                	xchg   %ax,%ax
  122ceb:	66 90                	xchg   %ax,%ax
  122ced:	66 90                	xchg   %ax,%ax
  122cef:	66 90                	xchg   %ax,%ax
  122cf1:	66 90                	xchg   %ax,%ax
  122cf3:	66 90                	xchg   %ax,%ax
  122cf5:	66 90                	xchg   %ax,%ax
  122cf7:	66 90                	xchg   %ax,%ax
  122cf9:	66 90                	xchg   %ax,%ax
  122cfb:	66 90                	xchg   %ax,%ax
  122cfd:	66 90                	xchg   %ax,%ax
  122cff:	66 90                	xchg   %ax,%ax
  122d01:	66 90                	xchg   %ax,%ax
  122d03:	66 90                	xchg   %ax,%ax
  122d05:	66 90                	xchg   %ax,%ax
  122d07:	66 90                	xchg   %ax,%ax
  122d09:	66 90                	xchg   %ax,%ax
  122d0b:	66 90                	xchg   %ax,%ax
  122d0d:	66 90                	xchg   %ax,%ax
  122d0f:	66 90                	xchg   %ax,%ax
  122d11:	66 90                	xchg   %ax,%ax
  122d13:	66 90                	xchg   %ax,%ax
  122d15:	66 90                	xchg   %ax,%ax
  122d17:	66 90                	xchg   %ax,%ax
  122d19:	66 90                	xchg   %ax,%ax
  122d1b:	66 90                	xchg   %ax,%ax
  122d1d:	66 90                	xchg   %ax,%ax
  122d1f:	66 90                	xchg   %ax,%ax
  122d21:	66 90                	xchg   %ax,%ax
  122d23:	66 90                	xchg   %ax,%ax
  122d25:	66 90                	xchg   %ax,%ax
  122d27:	66 90                	xchg   %ax,%ax
  122d29:	66 90                	xchg   %ax,%ax
  122d2b:	66 90                	xchg   %ax,%ax
  122d2d:	66 90                	xchg   %ax,%ax
  122d2f:	66 90                	xchg   %ax,%ax
  122d31:	66 90                	xchg   %ax,%ax
  122d33:	66 90                	xchg   %ax,%ax
  122d35:	66 90                	xchg   %ax,%ax
  122d37:	66 90                	xchg   %ax,%ax
  122d39:	66 90                	xchg   %ax,%ax
  122d3b:	66 90                	xchg   %ax,%ax
  122d3d:	66 90                	xchg   %ax,%ax
  122d3f:	66 90                	xchg   %ax,%ax
  122d41:	66 90                	xchg   %ax,%ax
  122d43:	66 90                	xchg   %ax,%ax
  122d45:	66 90                	xchg   %ax,%ax
  122d47:	66 90                	xchg   %ax,%ax
  122d49:	66 90                	xchg   %ax,%ax
  122d4b:	66 90                	xchg   %ax,%ax
  122d4d:	66 90                	xchg   %ax,%ax
  122d4f:	66 90                	xchg   %ax,%ax
  122d51:	66 90                	xchg   %ax,%ax
  122d53:	66 90                	xchg   %ax,%ax
  122d55:	66 90                	xchg   %ax,%ax
  122d57:	66 90                	xchg   %ax,%ax
  122d59:	66 90                	xchg   %ax,%ax
  122d5b:	66 90                	xchg   %ax,%ax
  122d5d:	66 90                	xchg   %ax,%ax
  122d5f:	66 90                	xchg   %ax,%ax
  122d61:	66 90                	xchg   %ax,%ax
  122d63:	66 90                	xchg   %ax,%ax
  122d65:	66 90                	xchg   %ax,%ax
  122d67:	66 90                	xchg   %ax,%ax
  122d69:	66 90                	xchg   %ax,%ax
  122d6b:	66 90                	xchg   %ax,%ax
  122d6d:	66 90                	xchg   %ax,%ax
  122d6f:	66 90                	xchg   %ax,%ax
  122d71:	66 90                	xchg   %ax,%ax
  122d73:	66 90                	xchg   %ax,%ax
  122d75:	66 90                	xchg   %ax,%ax
  122d77:	66 90                	xchg   %ax,%ax
  122d79:	66 90                	xchg   %ax,%ax
  122d7b:	66 90                	xchg   %ax,%ax
  122d7d:	66 90                	xchg   %ax,%ax
  122d7f:	66 90                	xchg   %ax,%ax
  122d81:	66 90                	xchg   %ax,%ax
  122d83:	66 90                	xchg   %ax,%ax
  122d85:	66 90                	xchg   %ax,%ax
  122d87:	66 90                	xchg   %ax,%ax
  122d89:	66 90                	xchg   %ax,%ax
  122d8b:	66 90                	xchg   %ax,%ax
  122d8d:	66 90                	xchg   %ax,%ax
  122d8f:	66 90                	xchg   %ax,%ax
  122d91:	66 90                	xchg   %ax,%ax
  122d93:	66 90                	xchg   %ax,%ax
  122d95:	66 90                	xchg   %ax,%ax
  122d97:	66 90                	xchg   %ax,%ax
  122d99:	66 90                	xchg   %ax,%ax
  122d9b:	66 90                	xchg   %ax,%ax
  122d9d:	66 90                	xchg   %ax,%ax
  122d9f:	66 90                	xchg   %ax,%ax
  122da1:	66 90                	xchg   %ax,%ax
  122da3:	66 90                	xchg   %ax,%ax
  122da5:	66 90                	xchg   %ax,%ax
  122da7:	66 90                	xchg   %ax,%ax
  122da9:	66 90                	xchg   %ax,%ax
  122dab:	66 90                	xchg   %ax,%ax
  122dad:	66 90                	xchg   %ax,%ax
  122daf:	66 90                	xchg   %ax,%ax
  122db1:	66 90                	xchg   %ax,%ax
  122db3:	66 90                	xchg   %ax,%ax
  122db5:	66 90                	xchg   %ax,%ax
  122db7:	66 90                	xchg   %ax,%ax
  122db9:	66 90                	xchg   %ax,%ax
  122dbb:	66 90                	xchg   %ax,%ax
  122dbd:	66 90                	xchg   %ax,%ax
  122dbf:	66 90                	xchg   %ax,%ax
  122dc1:	66 90                	xchg   %ax,%ax
  122dc3:	66 90                	xchg   %ax,%ax
  122dc5:	66 90                	xchg   %ax,%ax
  122dc7:	66 90                	xchg   %ax,%ax
  122dc9:	66 90                	xchg   %ax,%ax
  122dcb:	66 90                	xchg   %ax,%ax
  122dcd:	66 90                	xchg   %ax,%ax
  122dcf:	66 90                	xchg   %ax,%ax
  122dd1:	66 90                	xchg   %ax,%ax
  122dd3:	66 90                	xchg   %ax,%ax
  122dd5:	66 90                	xchg   %ax,%ax
  122dd7:	66 90                	xchg   %ax,%ax
  122dd9:	66 90                	xchg   %ax,%ax
  122ddb:	66 90                	xchg   %ax,%ax
  122ddd:	66 90                	xchg   %ax,%ax
  122ddf:	66 90                	xchg   %ax,%ax
  122de1:	66 90                	xchg   %ax,%ax
  122de3:	66 90                	xchg   %ax,%ax
  122de5:	66 90                	xchg   %ax,%ax
  122de7:	66 90                	xchg   %ax,%ax
  122de9:	66 90                	xchg   %ax,%ax
  122deb:	66 90                	xchg   %ax,%ax
  122ded:	66 90                	xchg   %ax,%ax
  122def:	66 90                	xchg   %ax,%ax
  122df1:	66 90                	xchg   %ax,%ax
  122df3:	66 90                	xchg   %ax,%ax
  122df5:	66 90                	xchg   %ax,%ax
  122df7:	66 90                	xchg   %ax,%ax
  122df9:	66 90                	xchg   %ax,%ax
  122dfb:	66 90                	xchg   %ax,%ax
  122dfd:	66 90                	xchg   %ax,%ax
  122dff:	66 90                	xchg   %ax,%ax
  122e01:	66 90                	xchg   %ax,%ax
  122e03:	66 90                	xchg   %ax,%ax
  122e05:	66 90                	xchg   %ax,%ax
  122e07:	66 90                	xchg   %ax,%ax
  122e09:	66 90                	xchg   %ax,%ax
  122e0b:	66 90                	xchg   %ax,%ax
  122e0d:	66 90                	xchg   %ax,%ax
  122e0f:	66 90                	xchg   %ax,%ax
  122e11:	66 90                	xchg   %ax,%ax
  122e13:	66 90                	xchg   %ax,%ax
  122e15:	66 90                	xchg   %ax,%ax
  122e17:	66 90                	xchg   %ax,%ax
  122e19:	66 90                	xchg   %ax,%ax
  122e1b:	66 90                	xchg   %ax,%ax
  122e1d:	66 90                	xchg   %ax,%ax
  122e1f:	66 90                	xchg   %ax,%ax
  122e21:	66 90                	xchg   %ax,%ax
  122e23:	66 90                	xchg   %ax,%ax
  122e25:	66 90                	xchg   %ax,%ax
  122e27:	66 90                	xchg   %ax,%ax
  122e29:	66 90                	xchg   %ax,%ax
  122e2b:	66 90                	xchg   %ax,%ax
  122e2d:	66 90                	xchg   %ax,%ax
  122e2f:	66 90                	xchg   %ax,%ax
  122e31:	66 90                	xchg   %ax,%ax
  122e33:	66 90                	xchg   %ax,%ax
  122e35:	66 90                	xchg   %ax,%ax
  122e37:	66 90                	xchg   %ax,%ax
  122e39:	66 90                	xchg   %ax,%ax
  122e3b:	66 90                	xchg   %ax,%ax
  122e3d:	66 90                	xchg   %ax,%ax
  122e3f:	66 90                	xchg   %ax,%ax
  122e41:	66 90                	xchg   %ax,%ax
  122e43:	66 90                	xchg   %ax,%ax
  122e45:	66 90                	xchg   %ax,%ax
  122e47:	66 90                	xchg   %ax,%ax
  122e49:	66 90                	xchg   %ax,%ax
  122e4b:	66 90                	xchg   %ax,%ax
  122e4d:	66 90                	xchg   %ax,%ax
  122e4f:	66 90                	xchg   %ax,%ax
  122e51:	66 90                	xchg   %ax,%ax
  122e53:	66 90                	xchg   %ax,%ax
  122e55:	66 90                	xchg   %ax,%ax
  122e57:	66 90                	xchg   %ax,%ax
  122e59:	66 90                	xchg   %ax,%ax
  122e5b:	66 90                	xchg   %ax,%ax
  122e5d:	66 90                	xchg   %ax,%ax
  122e5f:	66 90                	xchg   %ax,%ax
  122e61:	66 90                	xchg   %ax,%ax
  122e63:	66 90                	xchg   %ax,%ax
  122e65:	66 90                	xchg   %ax,%ax
  122e67:	66 90                	xchg   %ax,%ax
  122e69:	66 90                	xchg   %ax,%ax
  122e6b:	66 90                	xchg   %ax,%ax
  122e6d:	66 90                	xchg   %ax,%ax
  122e6f:	66 90                	xchg   %ax,%ax
  122e71:	66 90                	xchg   %ax,%ax
  122e73:	66 90                	xchg   %ax,%ax
  122e75:	66 90                	xchg   %ax,%ax
  122e77:	66 90                	xchg   %ax,%ax
  122e79:	66 90                	xchg   %ax,%ax
  122e7b:	66 90                	xchg   %ax,%ax
  122e7d:	66 90                	xchg   %ax,%ax
  122e7f:	66 90                	xchg   %ax,%ax
  122e81:	66 90                	xchg   %ax,%ax
  122e83:	66 90                	xchg   %ax,%ax
  122e85:	66 90                	xchg   %ax,%ax
  122e87:	66 90                	xchg   %ax,%ax
  122e89:	66 90                	xchg   %ax,%ax
  122e8b:	66 90                	xchg   %ax,%ax
  122e8d:	66 90                	xchg   %ax,%ax
  122e8f:	66 90                	xchg   %ax,%ax
  122e91:	66 90                	xchg   %ax,%ax
  122e93:	66 90                	xchg   %ax,%ax
  122e95:	66 90                	xchg   %ax,%ax
  122e97:	66 90                	xchg   %ax,%ax
  122e99:	66 90                	xchg   %ax,%ax
  122e9b:	66 90                	xchg   %ax,%ax
  122e9d:	66 90                	xchg   %ax,%ax
  122e9f:	66 90                	xchg   %ax,%ax
  122ea1:	66 90                	xchg   %ax,%ax
  122ea3:	66 90                	xchg   %ax,%ax
  122ea5:	66 90                	xchg   %ax,%ax
  122ea7:	66 90                	xchg   %ax,%ax
  122ea9:	66 90                	xchg   %ax,%ax
  122eab:	66 90                	xchg   %ax,%ax
  122ead:	66 90                	xchg   %ax,%ax
  122eaf:	66 90                	xchg   %ax,%ax
  122eb1:	66 90                	xchg   %ax,%ax
  122eb3:	66 90                	xchg   %ax,%ax
  122eb5:	66 90                	xchg   %ax,%ax
  122eb7:	66 90                	xchg   %ax,%ax
  122eb9:	66 90                	xchg   %ax,%ax
  122ebb:	66 90                	xchg   %ax,%ax
  122ebd:	66 90                	xchg   %ax,%ax
  122ebf:	66 90                	xchg   %ax,%ax
  122ec1:	66 90                	xchg   %ax,%ax
  122ec3:	66 90                	xchg   %ax,%ax
  122ec5:	66 90                	xchg   %ax,%ax
  122ec7:	66 90                	xchg   %ax,%ax
  122ec9:	66 90                	xchg   %ax,%ax
  122ecb:	66 90                	xchg   %ax,%ax
  122ecd:	66 90                	xchg   %ax,%ax
  122ecf:	66 90                	xchg   %ax,%ax
  122ed1:	66 90                	xchg   %ax,%ax
  122ed3:	66 90                	xchg   %ax,%ax
  122ed5:	66 90                	xchg   %ax,%ax
  122ed7:	66 90                	xchg   %ax,%ax
  122ed9:	66 90                	xchg   %ax,%ax
  122edb:	66 90                	xchg   %ax,%ax
  122edd:	66 90                	xchg   %ax,%ax
  122edf:	66 90                	xchg   %ax,%ax
  122ee1:	66 90                	xchg   %ax,%ax
  122ee3:	66 90                	xchg   %ax,%ax
  122ee5:	66 90                	xchg   %ax,%ax
  122ee7:	66 90                	xchg   %ax,%ax
  122ee9:	66 90                	xchg   %ax,%ax
  122eeb:	66 90                	xchg   %ax,%ax
  122eed:	66 90                	xchg   %ax,%ax
  122eef:	66 90                	xchg   %ax,%ax
  122ef1:	66 90                	xchg   %ax,%ax
  122ef3:	66 90                	xchg   %ax,%ax
  122ef5:	66 90                	xchg   %ax,%ax
  122ef7:	66 90                	xchg   %ax,%ax
  122ef9:	66 90                	xchg   %ax,%ax
  122efb:	66 90                	xchg   %ax,%ax
  122efd:	66 90                	xchg   %ax,%ax
  122eff:	66 90                	xchg   %ax,%ax
  122f01:	66 90                	xchg   %ax,%ax
  122f03:	66 90                	xchg   %ax,%ax
  122f05:	66 90                	xchg   %ax,%ax
  122f07:	66 90                	xchg   %ax,%ax
  122f09:	66 90                	xchg   %ax,%ax
  122f0b:	66 90                	xchg   %ax,%ax
  122f0d:	66 90                	xchg   %ax,%ax
  122f0f:	66 90                	xchg   %ax,%ax
  122f11:	66 90                	xchg   %ax,%ax
  122f13:	66 90                	xchg   %ax,%ax
  122f15:	66 90                	xchg   %ax,%ax
  122f17:	66 90                	xchg   %ax,%ax
  122f19:	66 90                	xchg   %ax,%ax
  122f1b:	66 90                	xchg   %ax,%ax
  122f1d:	66 90                	xchg   %ax,%ax
  122f1f:	66 90                	xchg   %ax,%ax
  122f21:	66 90                	xchg   %ax,%ax
  122f23:	66 90                	xchg   %ax,%ax
  122f25:	66 90                	xchg   %ax,%ax
  122f27:	66 90                	xchg   %ax,%ax
  122f29:	66 90                	xchg   %ax,%ax
  122f2b:	66 90                	xchg   %ax,%ax
  122f2d:	66 90                	xchg   %ax,%ax
  122f2f:	66 90                	xchg   %ax,%ax
  122f31:	66 90                	xchg   %ax,%ax
  122f33:	66 90                	xchg   %ax,%ax
  122f35:	66 90                	xchg   %ax,%ax
  122f37:	66 90                	xchg   %ax,%ax
  122f39:	66 90                	xchg   %ax,%ax
  122f3b:	66 90                	xchg   %ax,%ax
  122f3d:	66 90                	xchg   %ax,%ax
  122f3f:	66 90                	xchg   %ax,%ax
  122f41:	66 90                	xchg   %ax,%ax
  122f43:	66 90                	xchg   %ax,%ax
  122f45:	66 90                	xchg   %ax,%ax
  122f47:	66 90                	xchg   %ax,%ax
  122f49:	66 90                	xchg   %ax,%ax
  122f4b:	66 90                	xchg   %ax,%ax
  122f4d:	66 90                	xchg   %ax,%ax
  122f4f:	66 90                	xchg   %ax,%ax
  122f51:	66 90                	xchg   %ax,%ax
  122f53:	66 90                	xchg   %ax,%ax
  122f55:	66 90                	xchg   %ax,%ax
  122f57:	66 90                	xchg   %ax,%ax
  122f59:	66 90                	xchg   %ax,%ax
  122f5b:	66 90                	xchg   %ax,%ax
  122f5d:	66 90                	xchg   %ax,%ax
  122f5f:	66 90                	xchg   %ax,%ax
  122f61:	66 90                	xchg   %ax,%ax
  122f63:	66 90                	xchg   %ax,%ax
  122f65:	66 90                	xchg   %ax,%ax
  122f67:	66 90                	xchg   %ax,%ax
  122f69:	66 90                	xchg   %ax,%ax
  122f6b:	66 90                	xchg   %ax,%ax
  122f6d:	66 90                	xchg   %ax,%ax
  122f6f:	66 90                	xchg   %ax,%ax
  122f71:	66 90                	xchg   %ax,%ax
  122f73:	66 90                	xchg   %ax,%ax
  122f75:	66 90                	xchg   %ax,%ax
  122f77:	66 90                	xchg   %ax,%ax
  122f79:	66 90                	xchg   %ax,%ax
  122f7b:	66 90                	xchg   %ax,%ax
  122f7d:	66 90                	xchg   %ax,%ax
  122f7f:	66 90                	xchg   %ax,%ax
  122f81:	66 90                	xchg   %ax,%ax
  122f83:	66 90                	xchg   %ax,%ax
  122f85:	66 90                	xchg   %ax,%ax
  122f87:	66 90                	xchg   %ax,%ax
  122f89:	66 90                	xchg   %ax,%ax
  122f8b:	66 90                	xchg   %ax,%ax
  122f8d:	66 90                	xchg   %ax,%ax
  122f8f:	66 90                	xchg   %ax,%ax
  122f91:	66 90                	xchg   %ax,%ax
  122f93:	66 90                	xchg   %ax,%ax
  122f95:	66 90                	xchg   %ax,%ax
  122f97:	66 90                	xchg   %ax,%ax
  122f99:	66 90                	xchg   %ax,%ax
  122f9b:	66 90                	xchg   %ax,%ax
  122f9d:	66 90                	xchg   %ax,%ax
  122f9f:	66 90                	xchg   %ax,%ax
  122fa1:	66 90                	xchg   %ax,%ax
  122fa3:	66 90                	xchg   %ax,%ax
  122fa5:	66 90                	xchg   %ax,%ax
  122fa7:	66 90                	xchg   %ax,%ax
  122fa9:	66 90                	xchg   %ax,%ax
  122fab:	66 90                	xchg   %ax,%ax
  122fad:	66 90                	xchg   %ax,%ax
  122faf:	66 90                	xchg   %ax,%ax
  122fb1:	66 90                	xchg   %ax,%ax
  122fb3:	66 90                	xchg   %ax,%ax
  122fb5:	66 90                	xchg   %ax,%ax
  122fb7:	66 90                	xchg   %ax,%ax
  122fb9:	66 90                	xchg   %ax,%ax
  122fbb:	66 90                	xchg   %ax,%ax
  122fbd:	66 90                	xchg   %ax,%ax
  122fbf:	66 90                	xchg   %ax,%ax
  122fc1:	66 90                	xchg   %ax,%ax
  122fc3:	66 90                	xchg   %ax,%ax
  122fc5:	66 90                	xchg   %ax,%ax
  122fc7:	66 90                	xchg   %ax,%ax
  122fc9:	66 90                	xchg   %ax,%ax
  122fcb:	66 90                	xchg   %ax,%ax
  122fcd:	66 90                	xchg   %ax,%ax
  122fcf:	66 90                	xchg   %ax,%ax
  122fd1:	66 90                	xchg   %ax,%ax
  122fd3:	66 90                	xchg   %ax,%ax
  122fd5:	66 90                	xchg   %ax,%ax
  122fd7:	66 90                	xchg   %ax,%ax
  122fd9:	66 90                	xchg   %ax,%ax
  122fdb:	66 90                	xchg   %ax,%ax
  122fdd:	66 90                	xchg   %ax,%ax
  122fdf:	66 90                	xchg   %ax,%ax
  122fe1:	66 90                	xchg   %ax,%ax
  122fe3:	66 90                	xchg   %ax,%ax
  122fe5:	66 90                	xchg   %ax,%ax
  122fe7:	66 90                	xchg   %ax,%ax
  122fe9:	66 90                	xchg   %ax,%ax
  122feb:	66 90                	xchg   %ax,%ax
  122fed:	66 90                	xchg   %ax,%ax
  122fef:	66 90                	xchg   %ax,%ax
  122ff1:	66 90                	xchg   %ax,%ax
  122ff3:	66 90                	xchg   %ax,%ax
  122ff5:	66 90                	xchg   %ax,%ax
  122ff7:	66 90                	xchg   %ax,%ax
  122ff9:	66 90                	xchg   %ax,%ax
  122ffb:	66 90                	xchg   %ax,%ax
  122ffd:	66 90                	xchg   %ax,%ax
  122fff:	90                   	nop
